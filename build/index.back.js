/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@chemzqm/neovim/lib/api/Base.js":
/*!******************************************************!*\
  !*** ./node_modules/@chemzqm/neovim/lib/api/Base.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseApi = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst isVim = process.env.VIM_NODE_RPC == '1';\n// i.e. a plugin that detaches will affect all plugins registered on host\n// const EXCLUDED = ['nvim_buf_attach', 'nvim_buf_detach']\n// Instead of dealing with multiple inheritance (or lackof), just extend EE\n// Only the Neovim API class should use EE though\nclass BaseApi extends events_1.EventEmitter {\n    constructor({ transport, data, client, }) {\n        super();\n        this.setTransport(transport);\n        this.data = data;\n        this.client = client;\n    }\n    setTransport(transport) {\n        this.transport = transport;\n    }\n    equals(other) {\n        try {\n            return String(this.data) === String(other.data);\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    async request(name, args = []) {\n        let stack = Error().stack;\n        return new Promise((resolve, reject) => {\n            this.transport.request(name, this.getArgsByPrefix(args), (err, res) => {\n                if (err) {\n                    let e = new Error(`request error ${name} - ${err[1]}`);\n                    e.stack = stack;\n                    if (!name.endsWith('get_var')) {\n                        this.client.logError(`request error on \"${name}\"`, args, err[1], stack);\n                    }\n                    reject(e);\n                }\n                else {\n                    resolve(res);\n                }\n            });\n        });\n    }\n    getArgsByPrefix(args) {\n        // Check if class is Neovim and if so, should not send `this` as first arg\n        if (this.prefix !== 'nvim_' && args[0] != this) {\n            let id = isVim ? this.data : this;\n            return [id, ...args];\n        }\n        return args;\n    }\n    /** Retrieves a scoped variable depending on type (using `this.prefix`) */\n    getVar(name) {\n        return this.request(`${this.prefix}get_var`, [name]).then(res => res, _err => {\n            return null;\n        });\n    }\n    setVar(name, value, isNotify = false) {\n        if (isNotify) {\n            this.notify(`${this.prefix}set_var`, [name, value]);\n            return;\n        }\n        return this.request(`${this.prefix}set_var`, [name, value]);\n    }\n    /** Delete a scoped variable */\n    deleteVar(name) {\n        this.notify(`${this.prefix}del_var`, [name]);\n    }\n    /** Retrieves a scoped option depending on type of `this` */\n    getOption(name) {\n        return this.request(`${this.prefix}get_option`, [name]);\n    }\n    setOption(name, value, isNotify) {\n        if (isNotify) {\n            this.notify(`${this.prefix}set_option`, [name, value]);\n            return;\n        }\n        return this.request(`${this.prefix}set_option`, [name, value]);\n    }\n    /** `request` is basically the same except you can choose to wait forpromise to be resolved */\n    notify(name, args = []) {\n        this.transport.notify(name, this.getArgsByPrefix(args));\n    }\n}\nexports.BaseApi = BaseApi;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/@chemzqm/neovim/lib/api/Base.js?");

/***/ }),

/***/ "./node_modules/@chemzqm/neovim/lib/api/Buffer.js":
/*!********************************************************!*\
  !*** ./node_modules/@chemzqm/neovim/lib/api/Buffer.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Buffer = void 0;\nconst Base_1 = __webpack_require__(/*! ./Base */ \"./node_modules/@chemzqm/neovim/lib/api/Base.js\");\nclass Buffer extends Base_1.BaseApi {\n    constructor() {\n        super(...arguments);\n        this.prefix = 'nvim_buf_';\n    }\n    /**\n     * Attach to buffer to listen to buffer events\n     * @param sendBuffer Set to true if the initial notification should contain\n     *        the whole buffer. If so, the first notification will be a\n     *        `nvim_buf_lines_event`. Otherwise, the first notification will be\n     *        a `nvim_buf_changedtick_event`\n     */\n    async attach(sendBuffer = false, options = {}) {\n        return await this.request(`${this.prefix}attach`, [sendBuffer, options]);\n    }\n    /**\n     * Detach from buffer to stop listening to buffer events\n     */\n    async detach() {\n        return await this.request(`${this.prefix}detach`, []);\n    }\n    /**\n     * Get the bufnr of Buffer\n     */\n    get id() {\n        return this.data;\n    }\n    /** Total number of lines in buffer */\n    get length() {\n        return this.request(`${this.prefix}line_count`, []);\n    }\n    /** Get lines in buffer */\n    get lines() {\n        return this.getLines();\n    }\n    /** Gets a changed tick of a buffer */\n    get changedtick() {\n        return this.request(`${this.prefix}get_changedtick`, []);\n    }\n    get commands() {\n        return this.getCommands();\n    }\n    getCommands(options = {}) {\n        return this.request(`${this.prefix}get_commands`, [options]);\n    }\n    /** Get specific lines of buffer */\n    getLines({ start, end, strictIndexing } = { start: 0, end: -1, strictIndexing: true }) {\n        const indexing = typeof strictIndexing === 'undefined' ? true : strictIndexing;\n        return this.request(`${this.prefix}get_lines`, [\n            start,\n            end,\n            indexing,\n        ]);\n    }\n    /** Set lines of buffer given indeces */\n    setLines(_lines, { start: _start, end: _end, strictIndexing } = {\n        strictIndexing: true,\n    }, notify = false) {\n        // TODO: Error checking\n        // if (typeof start === 'undefined' || typeof end === 'undefined') {\n        // }\n        const indexing = typeof strictIndexing === 'undefined' ? true : strictIndexing;\n        const lines = typeof _lines === 'string' ? [_lines] : _lines;\n        const end = typeof _end !== 'undefined' ? _end : _start + 1;\n        const method = notify ? 'notify' : 'request';\n        return this[method](`${this.prefix}set_lines`, [\n            _start,\n            end,\n            indexing,\n            lines,\n        ]);\n    }\n    /**\n     * Set virtual text for a line\n     *\n     * @public\n     * @param {number} src_id - Source group to use or 0 to use a new group, or -1\n     * @param {number} line - Line to annotate with virtual text (zero-indexed)\n     * @param {Chunk[]} chunks - List with [text, hl_group]\n     * @param {{[index} opts\n     * @returns {Promise<number>}\n     */\n    setVirtualText(src_id, line, chunks, opts = {}) {\n        this.notify(`${this.prefix}set_virtual_text`, [\n            src_id,\n            line,\n            chunks,\n            opts,\n        ]);\n        return Promise.resolve(src_id);\n    }\n    /** Insert lines at `start` index */\n    insert(lines, start) {\n        return this.setLines(lines, {\n            start,\n            end: start,\n            strictIndexing: true,\n        });\n    }\n    /** Replace lines starting at `start` index */\n    replace(_lines, start) {\n        const lines = typeof _lines === 'string' ? [_lines] : _lines;\n        return this.setLines(lines, {\n            start,\n            end: start + lines.length,\n            strictIndexing: false,\n        });\n    }\n    /** Remove lines at index */\n    remove(start, end, strictIndexing = false) {\n        return this.setLines([], { start, end, strictIndexing });\n    }\n    /** Append a string or list of lines to end of buffer */\n    append(lines) {\n        return this.setLines(lines, {\n            start: -1,\n            end: -1,\n            strictIndexing: false,\n        });\n    }\n    /** Get buffer name */\n    get name() {\n        return this.request(`${this.prefix}get_name`, []);\n    }\n    /** Set current buffer name */\n    setName(value) {\n        return this.request(`${this.prefix}set_name`, [value]);\n    }\n    /** Is current buffer valid */\n    get valid() {\n        return this.request(`${this.prefix}is_valid`, []);\n    }\n    /** Get mark position given mark name */\n    mark(name) {\n        return this.request(`${this.prefix}get_mark`, [name]);\n    }\n    // range(start, end) {\n    // \"\"\"Return a `Range` object, which represents part of the Buffer.\"\"\"\n    // return Range(this, start, end)\n    // }\n    /** Gets keymap */\n    getKeymap(mode) {\n        return this.request(`${this.prefix}get_keymap`, [mode]);\n    }\n    /**\n   * Checks if a buffer is valid and loaded. See |api-buffer| for\n   * more info about unloaded buffers.\n   */\n    get loaded() {\n        return this.request(`${this.prefix}is_loaded`, []);\n    }\n    /**\n     * Returns the byte offset for a line.\n     *\n     * Line 1 (index=0) has offset 0. UTF-8 bytes are counted. EOL is\n     * one byte. 'fileformat' and 'fileencoding' are ignored. The\n     * line index just after the last line gives the total byte-count\n     * of the buffer. A final EOL byte is counted if it would be\n     * written, see 'eol'.\n     *\n     * Unlike |line2byte()|, throws error for out-of-bounds indexing.\n     * Returns -1 for unloaded buffer.\n     *\n     * @return {Number} Integer byte offset, or -1 for unloaded buffer.\n     */\n    getOffset(index) {\n        return this.request(`${this.prefix}get_offset`, [index]);\n    }\n    /**\n      Adds a highlight to buffer.\n  \n      This can be used for plugins which dynamically generate\n      highlights to a buffer (like a semantic highlighter or\n      linter). The function adds a single highlight to a buffer.\n      Unlike matchaddpos() highlights follow changes to line\n      numbering (as lines are inserted/removed above the highlighted\n      line), like signs and marks do.\n  \n      \"src_id\" is useful for batch deletion/updating of a set of\n      highlights. When called with src_id = 0, an unique source id\n      is generated and returned. Succesive calls can pass in it as\n      \"src_id\" to add new highlights to the same source group. All\n      highlights in the same group can then be cleared with\n      nvim_buf_clear_highlight. If the highlight never will be\n      manually deleted pass in -1 for \"src_id\".\n  \n      If \"hl_group\" is the empty string no highlight is added, but a\n      new src_id is still returned. This is useful for an external\n      plugin to synchrounously request an unique src_id at\n      initialization, and later asynchronously add and clear\n      highlights in response to buffer changes. */\n    addHighlight({ hlGroup, line, colStart: _start, colEnd: _end, srcId: _srcId, }) {\n        if (!hlGroup)\n            throw new Error('hlGroup should not empty');\n        const colEnd = typeof _end !== 'undefined' ? _end : -1;\n        const colStart = typeof _start !== 'undefined' ? _start : -0;\n        const srcId = typeof _srcId !== 'undefined' ? _srcId : -1;\n        const method = srcId == 0 ? 'request' : 'notify';\n        let res = this[method](`${this.prefix}add_highlight`, [\n            srcId,\n            hlGroup,\n            line,\n            colStart,\n            colEnd,\n        ]);\n        return method === 'request' ? res : Promise.resolve(null);\n    }\n    /**\n     * Clear highlights of specified lins.\n     *\n     * @deprecated use clearNamespace instead.\n     */\n    clearHighlight(args = {}) {\n        const defaults = {\n            srcId: -1,\n            lineStart: 0,\n            lineEnd: -1,\n        };\n        const { srcId, lineStart, lineEnd } = Object.assign({}, defaults, args);\n        return this.notify(`${this.prefix}clear_highlight`, [\n            srcId,\n            lineStart,\n            lineEnd,\n        ]);\n    }\n    /**\n     * Add highlight to ranges.\n     *\n     * @param {string | number} srcId Unique key or namespace number.\n     * @param {string} hlGroup Highlight group.\n     * @param {Range[]} ranges List of highlight ranges\n     */\n    highlightRanges(srcId, hlGroup, ranges) {\n        this.client.call('coc#highlight#ranges', [this.id, srcId, hlGroup, ranges], true);\n    }\n    /**\n     * Clear namespace by id or name.\n     *\n     * @param key Unique key or namespace number, use -1 for all namespaces\n     * @param lineStart Start of line, 0 based, default to 0.\n     * @param lineEnd End of line, 0 based, default to -1.\n     */\n    clearNamespace(key, lineStart = 0, lineEnd = -1) {\n        this.client.call('coc#highlight#clear_highlight', [this.id, key, lineStart, lineEnd]);\n    }\n    /**\n     * Listens to buffer for events\n     */\n    listen(eventName, cb, disposables) {\n        this.client.attachBufferEvent(this, eventName, cb);\n        if (disposables) {\n            disposables.push({\n                dispose: () => {\n                    this.client.detachBufferEvent(this, eventName, cb);\n                }\n            });\n        }\n    }\n}\nexports.Buffer = Buffer;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/@chemzqm/neovim/lib/api/Buffer.js?");

/***/ }),

/***/ "./node_modules/@chemzqm/neovim/lib/api/Neovim.js":
/*!********************************************************!*\
  !*** ./node_modules/@chemzqm/neovim/lib/api/Neovim.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Neovim = void 0;\nconst Base_1 = __webpack_require__(/*! ./Base */ \"./node_modules/@chemzqm/neovim/lib/api/Base.js\");\nconst Buffer_1 = __webpack_require__(/*! ./Buffer */ \"./node_modules/@chemzqm/neovim/lib/api/Buffer.js\");\nconst Tabpage_1 = __webpack_require__(/*! ./Tabpage */ \"./node_modules/@chemzqm/neovim/lib/api/Tabpage.js\");\nconst Window_1 = __webpack_require__(/*! ./Window */ \"./node_modules/@chemzqm/neovim/lib/api/Window.js\");\nconst isVim = process.env.VIM_NODE_RPC == '1';\n/**\n * Neovim API\n */\nclass Neovim extends Base_1.BaseApi {\n    constructor() {\n        super(...arguments);\n        this.prefix = 'nvim_';\n        this.Buffer = Buffer_1.Buffer;\n        this.Window = Window_1.Window;\n        this.Tabpage = Tabpage_1.Tabpage;\n    }\n    getArgs(args) {\n        if (!args)\n            return [];\n        if (Array.isArray(args))\n            return args;\n        return [args];\n    }\n    get apiInfo() {\n        return this.request(`${this.prefix}get_api_info`);\n    }\n    /** Get list of all buffers */\n    get buffers() {\n        return this.request(`${this.prefix}list_bufs`);\n    }\n    /** Get current buffer */\n    get buffer() {\n        return this.request(`${this.prefix}get_current_buf`);\n    }\n    /** Set current buffer */\n    async setBuffer(buffer) {\n        await this.request(`${this.prefix}set_current_buf`, [buffer]);\n    }\n    get chans() {\n        return this.request(`${this.prefix}list_chans`);\n    }\n    getChanInfo(chan) {\n        return this.request(`${this.prefix}get_chan_info`, [chan]);\n    }\n    createNamespace(name = \"\") {\n        return this.request(`${this.prefix}create_namespace`, [name]);\n    }\n    get namespaces() {\n        return this.request(`${this.prefix}get_namespaces`, []);\n    }\n    get commands() {\n        return this.getCommands();\n    }\n    getCommands(options = {}) {\n        return this.request(`${this.prefix}get_commands`, [options]);\n    }\n    /** Get list of all tabpages */\n    get tabpages() {\n        return this.request(`${this.prefix}list_tabpages`);\n    }\n    /** Get current tabpage */\n    get tabpage() {\n        return this.request(`${this.prefix}get_current_tabpage`);\n    }\n    /** Set current tabpage */\n    async setTabpage(tabpage) {\n        await this.request(`${this.prefix}set_current_tabpage`, [tabpage]);\n    }\n    /** Get list of all windows */\n    get windows() {\n        return this.getWindows();\n    }\n    /** Get current window */\n    get window() {\n        return this.request(`${this.prefix}get_current_win`);\n    }\n    /** Get list of all windows */\n    getWindows() {\n        return this.request(`${this.prefix}list_wins`);\n    }\n    async setWindow(win) {\n        // Throw error if win is not instance of Window?\n        await this.request(`${this.prefix}set_current_win`, [win]);\n    }\n    /** Get list of all runtime paths */\n    get runtimePaths() {\n        return this.request(`${this.prefix}list_runtime_paths`);\n    }\n    /** Set current directory */\n    setDirectory(dir) {\n        return this.request(`${this.prefix}set_current_dir`, [dir]);\n    }\n    /** Get current line. Always returns a Promise. */\n    get line() {\n        return this.getLine();\n    }\n    createNewBuffer(listed = false, scratch = false) {\n        return this.request(`${this.prefix}create_buf`, [listed, scratch]);\n    }\n    openFloatWindow(buffer, enter, options) {\n        return this.request(`${this.prefix}open_win`, [buffer, enter, options]);\n    }\n    getLine() {\n        return this.request(`${this.prefix}get_current_line`);\n    }\n    /** Set current line */\n    setLine(line) {\n        return this.request(`${this.prefix}set_current_line`, [line]);\n    }\n    /** Gets keymap */\n    getKeymap(mode) {\n        return this.request(`${this.prefix}get_keymap`, [mode]);\n    }\n    /** Gets current mode */\n    get mode() {\n        return this.request(`${this.prefix}get_mode`);\n    }\n    /** Gets map of defined colors */\n    get colorMap() {\n        return this.request(`${this.prefix}get_color_map`);\n    }\n    /** Get color by name */\n    getColorByName(name) {\n        return this.request(`${this.prefix}get_color_by_name`, [name]);\n    }\n    /** Get highlight by name or id */\n    getHighlight(nameOrId, isRgb = true) {\n        const functionName = typeof nameOrId === 'string' ? 'by_name' : 'by_id';\n        return this.request(`${this.prefix}get_hl_${functionName}`, [\n            nameOrId,\n            isRgb,\n        ]);\n    }\n    getHighlightByName(name, isRgb = true) {\n        return this.request(`${this.prefix}get_hl_by_name`, [name, isRgb]);\n    }\n    getHighlightById(id, isRgb = true) {\n        return this.request(`${this.prefix}get_hl_by_id`, [id, isRgb]);\n    }\n    /** Delete current line in buffer */\n    deleteCurrentLine() {\n        return this.request(`${this.prefix}del_current_line`);\n    }\n    /**\n     * Evaluates a VimL expression (:help expression). Dictionaries\n     * and Lists are recursively expanded. On VimL error: Returns a\n     * generic error; v:errmsg is not updated.\n     *\n     */\n    eval(expr) {\n        return this.request(`${this.prefix}eval`, [expr]);\n    }\n    /**\n     * Executes lua, it's possible neovim client does not support this\n     */\n    lua(code, args = []) {\n        const _args = this.getArgs(args);\n        return this.request(`${this.prefix}execute_lua`, [code, _args]);\n    }\n    // Alias for `lua()` to be consistent with neovim API\n    executeLua(code, args = []) {\n        return this.lua(code, args);\n    }\n    callDictFunction(dict, fname, args = []) {\n        const _args = this.getArgs(args);\n        return this.request(`${this.prefix}call_dict_function`, [\n            dict,\n            fname,\n            _args,\n        ]);\n    }\n    call(fname, args = [], isNotify) {\n        const _args = this.getArgs(args);\n        if (isNotify) {\n            this.notify(`${this.prefix}call_function`, [fname, _args]);\n            return null;\n        }\n        return this.request(`${this.prefix}call_function`, [fname, _args]);\n    }\n    callTimer(fname, args = [], isNotify) {\n        const _args = this.getArgs(args);\n        if (isNotify) {\n            this.notify(`${this.prefix}call_function`, ['coc#util#timer', [fname, _args]]);\n            return null;\n        }\n        if (isVim) {\n            this.notify(`${this.prefix}call_function`, ['coc#util#timer', [fname, _args]]);\n            return new Promise(resolve => {\n                setTimeout(() => {\n                    resolve(null);\n                }, 20);\n            });\n        }\n        return this.request(`${this.prefix}call_function`, ['coc#util#timer', [fname, _args]]);\n    }\n    callAsync(fname, args = []) {\n        const _args = this.getArgs(args);\n        return this.client.sendAsyncRequest(fname, _args);\n    }\n    /** Alias for `call` */\n    callFunction(fname, args = []) {\n        return this.call(fname, args);\n    }\n    /** Call Atomic calls */\n    callAtomic(calls) {\n        return this.request(`${this.prefix}call_atomic`, [calls]);\n    }\n    command(arg, isNotify) {\n        if (isNotify) {\n            this.notify(`${this.prefix}command`, [arg]);\n            return null;\n        }\n        return this.request(`${this.prefix}command`, [arg]);\n    }\n    /** Runs a command and returns output (synchronous?) */\n    commandOutput(arg) {\n        return this.request(`${this.prefix}command_output`, [arg]);\n    }\n    /** Gets a v: variable */\n    getVvar(name) {\n        return this.request(`${this.prefix}get_vvar`, [name]);\n    }\n    /** feedKeys */\n    feedKeys(keys, mode, escapeCsi) {\n        return this.request(`${this.prefix}feedkeys`, [keys, mode, escapeCsi]);\n    }\n    /** Sends input keys */\n    input(keys) {\n        return this.request(`${this.prefix}input`, [keys]);\n    }\n    /**\n     * Parse a VimL Expression\n     *\n     * TODO: return type, see :help\n     */\n    parseExpression(expr, flags, highlight) {\n        return this.request(`${this.prefix}parse_expression`, [\n            expr,\n            flags,\n            highlight,\n        ]);\n    }\n    getProc(pid) {\n        return this.request(`${this.prefix}get_proc`, [pid]);\n    }\n    getProcChildren(pid) {\n        return this.request(`${this.prefix}get_proc_children`, [pid]);\n    }\n    /** Replace term codes */\n    replaceTermcodes(str, fromPart, doIt, special) {\n        return this.request(`${this.prefix}replace_termcodes`, [\n            str,\n            fromPart,\n            doIt,\n            special,\n        ]);\n    }\n    /** Gets width of string */\n    strWidth(str) {\n        return this.request(`${this.prefix}strwidth`, [str]);\n    }\n    /** Write to output buffer */\n    outWrite(str) {\n        this.notify(`${this.prefix}out_write`, [str]);\n    }\n    outWriteLine(str) {\n        this.outWrite(`${str}\\n`);\n    }\n    /** Write to error buffer */\n    errWrite(str) {\n        this.notify(`${this.prefix}err_write`, [str]);\n    }\n    /** Write to error buffer */\n    errWriteLine(str) {\n        this.notify(`${this.prefix}err_writeln`, [str]);\n    }\n    // TODO: add type\n    get uis() {\n        return this.request(`${this.prefix}list_uis`);\n    }\n    uiAttach(width, height, options) {\n        return this.request(`${this.prefix}ui_attach`, [width, height, options]);\n    }\n    uiDetach() {\n        return this.request(`${this.prefix}ui_detach`, []);\n    }\n    uiTryResize(width, height) {\n        return this.request(`${this.prefix}ui_try_resize`, [width, height]);\n    }\n    /** Set UI Option */\n    uiSetOption(name, value) {\n        return this.request(`${this.prefix}ui_set_option`, [name, value]);\n    }\n    /** Subscribe to nvim event broadcasts */\n    subscribe(event) {\n        return this.request(`${this.prefix}subscribe`, [event]);\n    }\n    /** Unsubscribe to nvim event broadcasts */\n    unsubscribe(event) {\n        return this.request(`${this.prefix}unsubscribe`, [event]);\n    }\n    setClientInfo(name, version, type, methods, attributes) {\n        this.notify(`${this.prefix}set_client_info`, [\n            name,\n            version,\n            type,\n            methods,\n            attributes,\n        ]);\n    }\n    /** Quit nvim */\n    async quit() {\n        this.command('qa!', true);\n        if (this.transport) {\n            this.transport.detach();\n        }\n    }\n}\nexports.Neovim = Neovim;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/@chemzqm/neovim/lib/api/Neovim.js?");

/***/ }),

/***/ "./node_modules/@chemzqm/neovim/lib/api/Tabpage.js":
/*!*********************************************************!*\
  !*** ./node_modules/@chemzqm/neovim/lib/api/Tabpage.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Tabpage = void 0;\nconst Base_1 = __webpack_require__(/*! ./Base */ \"./node_modules/@chemzqm/neovim/lib/api/Base.js\");\nclass Tabpage extends Base_1.BaseApi {\n    constructor() {\n        super(...arguments);\n        this.prefix = 'nvim_tabpage_';\n    }\n    /** Returns all windows of tabpage */\n    get windows() {\n        return this.request(`${this.prefix}list_wins`, []);\n    }\n    /** Gets the current window of tabpage */\n    get window() {\n        return this.request(`${this.prefix}get_win`, []);\n    }\n    /** Is current tabpage valid */\n    get valid() {\n        return this.request(`${this.prefix}is_valid`, []);\n    }\n    /** Tabpage number */\n    get number() {\n        return this.request(`${this.prefix}get_number`, []);\n    }\n    /** Invalid */\n    getOption() {\n        throw new Error('Tabpage does not have `getOption`');\n    }\n    /** Invalid */\n    setOption() {\n        throw new Error('Tabpage does not have `setOption`');\n    }\n}\nexports.Tabpage = Tabpage;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/@chemzqm/neovim/lib/api/Tabpage.js?");

/***/ }),

/***/ "./node_modules/@chemzqm/neovim/lib/api/Window.js":
/*!********************************************************!*\
  !*** ./node_modules/@chemzqm/neovim/lib/api/Window.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Window = void 0;\nconst Base_1 = __webpack_require__(/*! ./Base */ \"./node_modules/@chemzqm/neovim/lib/api/Base.js\");\nconst timers_1 = __webpack_require__(/*! timers */ \"timers\");\nclass Window extends Base_1.BaseApi {\n    constructor() {\n        super(...arguments);\n        this.prefix = 'nvim_win_';\n    }\n    /**\n     * The windowid that not change within a Vim session\n     */\n    get id() {\n        return this.data;\n    }\n    /** Get current buffer of window */\n    get buffer() {\n        return this.request(`${this.prefix}get_buf`, []);\n    }\n    /** Get the Tabpage that contains the window */\n    get tabpage() {\n        return this.request(`${this.prefix}get_tabpage`, []);\n    }\n    /** Get cursor position */\n    get cursor() {\n        return this.request(`${this.prefix}get_cursor`, []);\n    }\n    setCursor(pos, isNotify = false) {\n        let method = isNotify ? 'notify' : 'request';\n        return this[method](`${this.prefix}set_cursor`, [pos]);\n    }\n    /** Get window height by number of rows */\n    get height() {\n        return this.request(`${this.prefix}get_height`, []);\n    }\n    setHeight(height, isNotify = false) {\n        let method = isNotify ? 'notify' : 'request';\n        return this[method](`${this.prefix}set_height`, [height]);\n    }\n    /** Get window width by number of columns */\n    get width() {\n        return this.request(`${this.prefix}get_width`, []);\n    }\n    setWidth(width, isNotify = false) {\n        let method = isNotify ? 'notify' : 'request';\n        return this[method](`${this.prefix}set_height`, [width]);\n    }\n    /** Get window position */\n    get position() {\n        return this.request(`${this.prefix}get_position`, []);\n    }\n    /** 0-indexed, on-screen window position(row) in display cells. */\n    get row() {\n        return this.request(`${this.prefix}get_position`, []).then(position => position[0]);\n    }\n    /** 0-indexed, on-screen window position(col) in display cells. */\n    get col() {\n        return this.request(`${this.prefix}get_position`, []).then(position => position[1]);\n    }\n    /** Is window valid */\n    get valid() {\n        return this.request(`${this.prefix}is_valid`, []);\n    }\n    /** Get window number */\n    get number() {\n        return this.request(`${this.prefix}get_number`, []);\n    }\n    setConfig(options, isNotify) {\n        let method = isNotify ? 'notify' : 'request';\n        return this[method](`${this.prefix}set_config`, [options]);\n    }\n    getConfig() {\n        return this.request(`${this.prefix}get_config`, []);\n    }\n    close(force, isNotify) {\n        if (isNotify) {\n            this.notify(`${this.prefix}close`, [force]);\n            let count = 0;\n            let interval = setInterval(() => {\n                if (count == 5)\n                    return timers_1.clearInterval(interval);\n                this.request(`${this.prefix}is_valid`, []).then(valid => {\n                    if (!valid) {\n                        timers_1.clearInterval(interval);\n                    }\n                    else {\n                        this.notify(`${this.prefix}close`, [force]);\n                    }\n                }, () => {\n                    timers_1.clearInterval(interval);\n                });\n                count++;\n            }, 50);\n            return null;\n        }\n        return this.request(`${this.prefix}close`, [force]);\n    }\n    highlightRanges(hlGroup, ranges, priority = 10, isNotify) {\n        if (isNotify) {\n            this.client.call('coc#highlight#match_ranges', [this.id, 0, ranges, hlGroup, priority], true);\n            return undefined;\n        }\n        return this.client.call('coc#highlight#match_ranges', [this.id, 0, ranges, hlGroup, priority]);\n    }\n    /**\n     * Clear match by highlight group.\n     */\n    clearMatchGroup(hlGroup) {\n        this.client.call('coc#highlight#clear_match_group', [this.id, hlGroup], true);\n    }\n    /**\n     * Clear match by match ids.\n     */\n    clearMatches(ids) {\n        this.client.call('coc#highlight#clear_matches', [this.id, ids], true);\n    }\n}\nexports.Window = Window;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/@chemzqm/neovim/lib/api/Window.js?");

/***/ }),

/***/ "./node_modules/@chemzqm/neovim/lib/api/client.js":
/*!********************************************************!*\
  !*** ./node_modules/@chemzqm/neovim/lib/api/client.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NeovimClient = exports.AsyncResponse = void 0;\n/**\n * Handles attaching transport\n */\nconst nvim_1 = __webpack_require__(/*! ../transport/nvim */ \"./node_modules/@chemzqm/neovim/lib/transport/nvim.js\");\nconst vim_1 = __webpack_require__(/*! ../transport/vim */ \"./node_modules/@chemzqm/neovim/lib/transport/vim.js\");\nconst Neovim_1 = __webpack_require__(/*! ./Neovim */ \"./node_modules/@chemzqm/neovim/lib/api/Neovim.js\");\nconst Buffer_1 = __webpack_require__(/*! ./Buffer */ \"./node_modules/@chemzqm/neovim/lib/api/Buffer.js\");\nconst Window_1 = __webpack_require__(/*! ./Window */ \"./node_modules/@chemzqm/neovim/lib/api/Window.js\");\nconst Tabpage_1 = __webpack_require__(/*! ./Tabpage */ \"./node_modules/@chemzqm/neovim/lib/api/Tabpage.js\");\nconst logger_1 = __webpack_require__(/*! ../utils/logger */ \"./node_modules/@chemzqm/neovim/lib/utils/logger.js\");\nconst logger = logger_1.createLogger('client');\nconst isVim = process.env.VIM_NODE_RPC == '1';\nclass AsyncResponse {\n    constructor(requestId, cb) {\n        this.requestId = requestId;\n        this.cb = cb;\n        this.finished = false;\n    }\n    finish(err, res) {\n        if (this.finished)\n            return;\n        this.finished = true;\n        if (err) {\n            this.cb(new Error(err));\n            return;\n        }\n        this.cb(null, res);\n    }\n}\nexports.AsyncResponse = AsyncResponse;\nclass NeovimClient extends Neovim_1.Neovim {\n    constructor(logger) {\n        // Neovim has no `data` or `metadata`\n        super({});\n        this.logger = logger;\n        this.requestId = 1;\n        this.responses = new Map();\n        this.attachedBuffers = new Map();\n        Object.defineProperty(this, 'client', {\n            value: this\n        });\n        let transport = isVim ? new vim_1.VimTransport(logger) : new nvim_1.NvimTransport(logger);\n        this.setTransport(transport);\n        this.transportAttached = false;\n        this.handleRequest = this.handleRequest.bind(this);\n        this.handleNotification = this.handleNotification.bind(this);\n    }\n    logError(msg, ...args) {\n        if (!this.logger)\n            return;\n        this.logger.error(msg, ...args);\n    }\n    createBuffer(id) {\n        return new Buffer_1.Buffer({\n            transport: this.transport,\n            data: id,\n            client: this\n        });\n    }\n    createWindow(id) {\n        return new Window_1.Window({\n            transport: this.transport,\n            data: id,\n            client: this\n        });\n    }\n    createTabpage(id) {\n        return new Tabpage_1.Tabpage({\n            transport: this.transport,\n            data: id,\n            client: this\n        });\n    }\n    send(arr) {\n        this.transport.send(arr);\n    }\n    /** Attaches msgpack to read/write streams * */\n    attach({ reader, writer, }, requestApi = true) {\n        this.transport.attach(writer, reader, this);\n        this.transportAttached = true;\n        this.setupTransport(requestApi);\n    }\n    /* called when attach process disconnected*/\n    detach() {\n        this.transport.detach();\n        this.transportAttached = false;\n    }\n    get isApiReady() {\n        return this.transportAttached && typeof this._channelId !== 'undefined';\n    }\n    get channelId() {\n        return this._isReady.then(() => {\n            return this._channelId;\n        });\n    }\n    isAttached(bufnr) {\n        return this.attachedBuffers.has(bufnr);\n    }\n    handleRequest(method, args, resp) {\n        this.emit('request', method, args, resp);\n    }\n    sendAsyncRequest(method, args) {\n        let id = this.requestId;\n        this.requestId = id + 1;\n        this.notify('nvim_call_function', ['coc#rpc#async_request', [id, method, args || []]]);\n        return new Promise((resolve, reject) => {\n            let response = new AsyncResponse(id, (err, res) => {\n                if (err)\n                    return reject(err);\n                resolve(res);\n            });\n            this.responses.set(id, response);\n        });\n    }\n    emitNotification(method, args) {\n        if (method.endsWith('_event')) {\n            if (method.startsWith('nvim_buf_')) {\n                const shortName = method.replace(/nvim_buf_(.*)_event/, '$1');\n                const { id } = args[0];\n                if (!this.attachedBuffers.has(id))\n                    return;\n                const bufferMap = this.attachedBuffers.get(id);\n                const cbs = bufferMap.get(shortName) || [];\n                cbs.forEach(cb => cb(...args));\n                // Handle `nvim_buf_detach_event`\n                // clean `attachedBuffers` since it will no longer be attached\n                if (shortName === 'detach') {\n                    this.attachedBuffers.delete(id);\n                }\n                return;\n            }\n            // async_request_event from vim\n            if (method.startsWith('nvim_async_request')) {\n                const [id, method, arr] = args;\n                this.handleRequest(method, arr, {\n                    send: (resp, isError) => {\n                        this.notify('nvim_call_function', ['coc#rpc#async_response', [id, resp, isError]]);\n                    }\n                });\n            }\n            // nvim_async_response_event\n            if (method.startsWith('nvim_async_response')) {\n                const [id, err, res] = args;\n                const response = this.responses.get(id);\n                if (!response) {\n                    // tslint:disable-next-line: no-console\n                    console.error(`Response not found for request ${id}`);\n                    return;\n                }\n                this.responses.delete(id);\n                response.finish(err, res);\n                return;\n            }\n            // tslint:disable-next-line: no-console\n            // console.error(`Unhandled event: ${method}`)\n        }\n        else {\n            this.emit('notification', method, args);\n        }\n    }\n    handleNotification(method, args) {\n        this.emitNotification(method, args);\n    }\n    // Listen and setup handlers for transport\n    setupTransport(requestApi = true) {\n        if (!this.transportAttached) {\n            throw new Error('Not attached to input/output');\n        }\n        this.transport.on('request', this.handleRequest);\n        this.transport.on('notification', this.handleNotification);\n        this.transport.on('detach', () => {\n            this.emit('disconnect');\n            this.transport.removeAllListeners('request');\n            this.transport.removeAllListeners('notification');\n            this.transport.removeAllListeners('detach');\n        });\n        if (requestApi) {\n            this._isReady = this.generateApi();\n        }\n        else {\n            this._channelId = 0;\n            this._isReady = Promise.resolve(true);\n        }\n    }\n    requestApi() {\n        return new Promise((resolve, reject) => {\n            this.transport.request('nvim_get_api_info', [], (err, res) => {\n                if (err) {\n                    reject(new Error(Array.isArray(err) ? err[1] : err.message || err.toString()));\n                }\n                else {\n                    resolve(res);\n                }\n            });\n        });\n    }\n    async generateApi() {\n        let results;\n        try {\n            results = await this.requestApi();\n        }\n        catch (err) {\n            // tslint:disable-next-line: no-console\n            console.error('Could not get vim api results');\n            logger.error(err);\n        }\n        if (results) {\n            try {\n                const [channelId, metadata] = results;\n                this.functions = metadata.functions.map(f => f.name);\n                this._channelId = channelId;\n                return true;\n            }\n            catch (err) {\n                logger.error(err.stack);\n                return null;\n            }\n        }\n        return null;\n    }\n    attachBufferEvent(buffer, eventName, cb) {\n        const bufferMap = this.attachedBuffers.get(buffer.id) || new Map();\n        const cbs = bufferMap.get(eventName) || [];\n        if (cbs.includes(cb))\n            return;\n        cbs.push(cb);\n        bufferMap.set(eventName, cbs);\n        this.attachedBuffers.set(buffer.id, bufferMap);\n        return;\n    }\n    /**\n     * Returns `true` if buffer should be detached\n     */\n    detachBufferEvent(buffer, eventName, cb) {\n        const bufferMap = this.attachedBuffers.get(buffer.id);\n        if (!bufferMap || !bufferMap.has(eventName))\n            return;\n        const handlers = bufferMap.get(eventName).filter(handler => handler !== cb);\n        bufferMap.set(eventName, handlers);\n    }\n    pauseNotification() {\n        this.transport.pauseNotification();\n        let stack = Error().stack;\n        process.nextTick(() => {\n            if (this.transport.pauseLevel > 0) {\n                this.logError(`resumeNotification not called within same tick:`, stack);\n            }\n        });\n    }\n    resumeNotification(cancel, notify) {\n        if (cancel)\n            return Promise.resolve(this.transport.cancelNotification());\n        if (notify) {\n            return Promise.resolve(this.transport.resumeNotification(true));\n        }\n        return Promise.resolve(this.transport.resumeNotification());\n    }\n    hasFunction(name) {\n        if (!this.functions)\n            return true;\n        return this.functions.indexOf(name) !== -1;\n    }\n}\nexports.NeovimClient = NeovimClient;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/@chemzqm/neovim/lib/api/client.js?");

/***/ }),

/***/ "./node_modules/@chemzqm/neovim/lib/api/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@chemzqm/neovim/lib/api/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Tabpage = exports.Window = exports.Buffer = exports.NeovimClient = exports.Neovim = void 0;\nvar client_1 = __webpack_require__(/*! ./client */ \"./node_modules/@chemzqm/neovim/lib/api/client.js\");\nObject.defineProperty(exports, \"Neovim\", ({ enumerable: true, get: function () { return client_1.NeovimClient; } }));\nvar client_2 = __webpack_require__(/*! ./client */ \"./node_modules/@chemzqm/neovim/lib/api/client.js\");\nObject.defineProperty(exports, \"NeovimClient\", ({ enumerable: true, get: function () { return client_2.NeovimClient; } }));\nvar Buffer_1 = __webpack_require__(/*! ./Buffer */ \"./node_modules/@chemzqm/neovim/lib/api/Buffer.js\");\nObject.defineProperty(exports, \"Buffer\", ({ enumerable: true, get: function () { return Buffer_1.Buffer; } }));\nvar Window_1 = __webpack_require__(/*! ./Window */ \"./node_modules/@chemzqm/neovim/lib/api/Window.js\");\nObject.defineProperty(exports, \"Window\", ({ enumerable: true, get: function () { return Window_1.Window; } }));\nvar Tabpage_1 = __webpack_require__(/*! ./Tabpage */ \"./node_modules/@chemzqm/neovim/lib/api/Tabpage.js\");\nObject.defineProperty(exports, \"Tabpage\", ({ enumerable: true, get: function () { return Tabpage_1.Tabpage; } }));\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/@chemzqm/neovim/lib/api/index.js?");

/***/ }),

/***/ "./node_modules/@chemzqm/neovim/lib/api/types.js":
/*!*******************************************************!*\
  !*** ./node_modules/@chemzqm/neovim/lib/api/types.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Metadata = exports.ExtType = void 0;\nconst Buffer_1 = __webpack_require__(/*! ./Buffer */ \"./node_modules/@chemzqm/neovim/lib/api/Buffer.js\");\nconst Window_1 = __webpack_require__(/*! ./Window */ \"./node_modules/@chemzqm/neovim/lib/api/Window.js\");\nconst Tabpage_1 = __webpack_require__(/*! ./Tabpage */ \"./node_modules/@chemzqm/neovim/lib/api/Tabpage.js\");\nvar ExtType;\n(function (ExtType) {\n    ExtType[ExtType[\"Buffer\"] = 0] = \"Buffer\";\n    ExtType[ExtType[\"Window\"] = 1] = \"Window\";\n    ExtType[ExtType[\"Tabpage\"] = 2] = \"Tabpage\";\n})(ExtType = exports.ExtType || (exports.ExtType = {}));\nexports.Metadata = [\n    {\n        constructor: Buffer_1.Buffer,\n        name: 'Buffer',\n        prefix: 'nvim_buf_',\n    },\n    {\n        constructor: Window_1.Window,\n        name: 'Window',\n        prefix: 'nvim_win_',\n    },\n    {\n        constructor: Tabpage_1.Tabpage,\n        name: 'Tabpage',\n        prefix: 'nvim_tabpage_',\n    },\n];\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/@chemzqm/neovim/lib/api/types.js?");

/***/ }),

/***/ "./node_modules/@chemzqm/neovim/lib/attach/attach.js":
/*!***********************************************************!*\
  !*** ./node_modules/@chemzqm/neovim/lib/attach/attach.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.attach = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst client_1 = __webpack_require__(/*! ./../api/client */ \"./node_modules/@chemzqm/neovim/lib/api/client.js\");\nfunction attach({ reader: _reader, writer: _writer, proc, socket, }, logger = null, requestApi = true) {\n    let writer;\n    let reader;\n    let neovim;\n    if (socket) {\n        const client = net_1.createConnection(socket);\n        writer = client;\n        reader = client;\n        client.once('close', () => {\n            neovim.detach();\n        });\n    }\n    else if (_reader && _writer) {\n        writer = _writer;\n        reader = _reader;\n    }\n    else if (proc) {\n        writer = proc.stdin;\n        reader = proc.stdout;\n        proc.once('disconnect', () => {\n            neovim.detach();\n        });\n    }\n    writer.on('error', err => {\n        if (err.code == 'EPIPE') {\n            neovim.detach();\n        }\n    });\n    if (writer && reader) {\n        neovim = new client_1.NeovimClient(logger);\n        neovim.attach({\n            writer,\n            reader,\n        }, requestApi);\n        return neovim;\n    }\n    throw new Error('Invalid arguments, could not attach');\n}\nexports.attach = attach;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/@chemzqm/neovim/lib/attach/attach.js?");

/***/ }),

/***/ "./node_modules/@chemzqm/neovim/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@chemzqm/neovim/lib/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Window = exports.Tabpage = exports.Buffer = exports.NeovimClient = exports.Neovim = exports.attach = void 0;\nvar attach_1 = __webpack_require__(/*! ./attach/attach */ \"./node_modules/@chemzqm/neovim/lib/attach/attach.js\");\nObject.defineProperty(exports, \"attach\", ({ enumerable: true, get: function () { return attach_1.attach; } }));\nvar index_1 = __webpack_require__(/*! ./api/index */ \"./node_modules/@chemzqm/neovim/lib/api/index.js\");\nObject.defineProperty(exports, \"Neovim\", ({ enumerable: true, get: function () { return index_1.Neovim; } }));\nObject.defineProperty(exports, \"NeovimClient\", ({ enumerable: true, get: function () { return index_1.NeovimClient; } }));\nObject.defineProperty(exports, \"Buffer\", ({ enumerable: true, get: function () { return index_1.Buffer; } }));\nObject.defineProperty(exports, \"Tabpage\", ({ enumerable: true, get: function () { return index_1.Tabpage; } }));\nObject.defineProperty(exports, \"Window\", ({ enumerable: true, get: function () { return index_1.Window; } }));\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/@chemzqm/neovim/lib/index.js?");

/***/ }),

/***/ "./node_modules/@chemzqm/neovim/lib/transport/base.js":
/*!************************************************************!*\
  !*** ./node_modules/@chemzqm/neovim/lib/transport/base.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst logger_1 = __webpack_require__(/*! ../utils/logger */ \"./node_modules/@chemzqm/neovim/lib/utils/logger.js\");\nconst debug = process.env.NODE_CLIENT_LOG_LEVEL == 'debug';\nconst logger = logger_1.createLogger('transport');\nclass Transport extends events_1.EventEmitter {\n    constructor(logger) {\n        super();\n        this.logger = logger;\n        this.pauseLevel = 0;\n        this.paused = new Map();\n    }\n    debug(key, ...meta) {\n        if (!debug)\n            return;\n        logger.debug(key, ...meta);\n    }\n    info(key, ...meta) {\n        logger.info(key, ...meta);\n    }\n    debugMessage(msg) {\n        if (!debug)\n            return;\n        const msgType = msg[0];\n        if (msgType == 0) {\n            logger.debug('receive request:', msg.slice(1));\n        }\n        else if (msgType == 1) {\n            // logger.debug('receive response:', msg.slice(1))\n        }\n        else if (msgType == 2) {\n            logger.debug('receive notification:', msg.slice(1));\n        }\n        else {\n            logger.debug('unknown message:', msg);\n        }\n    }\n    pauseNotification() {\n        this.pauseLevel = this.pauseLevel + 1;\n        this.paused.set(this.pauseLevel, []);\n    }\n    cancelNotification() {\n        let { pauseLevel } = this;\n        if (pauseLevel > 0) {\n            this.paused.delete(pauseLevel);\n            this.pauseLevel = pauseLevel - 1;\n        }\n    }\n    resumeNotification(isNotify = false) {\n        let { pauseLevel } = this;\n        if (pauseLevel == 0)\n            return isNotify ? null : Promise.resolve([null, null]);\n        let stack = Error().stack;\n        this.pauseLevel = pauseLevel - 1;\n        let list = this.paused.get(pauseLevel);\n        this.paused.delete(pauseLevel);\n        if (list && list.length) {\n            return new Promise((resolve, reject) => {\n                if (!isNotify) {\n                    return this.request('nvim_call_atomic', [list], (err, res) => {\n                        if (err) {\n                            let e = new Error(`call_atomic error: ${err[1]}`);\n                            e.stack = stack;\n                            return reject(e);\n                        }\n                        if (Array.isArray(res) && res[1] != null) {\n                            let [index, errType, message] = res[1];\n                            let [fname, args] = list[index];\n                            this.logger.error(`request error ${errType} on \"${fname}\"`, args, message, stack);\n                        }\n                        resolve(res);\n                    });\n                }\n                this.notify('nvim_call_atomic', [list]);\n                resolve();\n            });\n        }\n        return isNotify ? null : Promise.resolve([[], undefined]);\n    }\n}\nexports.default = Transport;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/@chemzqm/neovim/lib/transport/base.js?");

/***/ }),

/***/ "./node_modules/@chemzqm/neovim/lib/transport/connection.js":
/*!******************************************************************!*\
  !*** ./node_modules/@chemzqm/neovim/lib/transport/connection.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst events_1 = __importDefault(__webpack_require__(/*! events */ \"events\"));\nconst readline_1 = __importDefault(__webpack_require__(/*! readline */ \"readline\"));\nconst logger_1 = __webpack_require__(/*! ../utils/logger */ \"./node_modules/@chemzqm/neovim/lib/utils/logger.js\");\nconst logger = logger_1.createLogger('connection');\nconst debug = process.env.NODE_CLIENT_LOG_LEVEL == 'debug';\nclass Connection extends events_1.default {\n    constructor(readable, writeable) {\n        super();\n        this.readable = readable;\n        this.writeable = writeable;\n        const rl = readline_1.default.createInterface(this.readable);\n        rl.on('line', (line) => {\n            this.parseData(line);\n        });\n        rl.on('close', () => {\n            logger.error('connection closed');\n            process.exit(0);\n        });\n    }\n    parseData(str) {\n        if (str.length == 0)\n            return;\n        let arr;\n        try {\n            arr = JSON.parse(str);\n        }\n        catch (e) {\n            // tslint:disable-next-line: no-console\n            console.error(`Invalid data from vim: ${str}`);\n            return;\n        }\n        // request, notification, response\n        let [id, obj] = arr;\n        if (id > 0) {\n            logger.debug('received request:', id, obj);\n            this.emit('request', id, obj);\n        }\n        else if (id == 0) {\n            logger.debug('received notification:', obj);\n            this.emit('notification', obj);\n        }\n        else {\n            logger.debug('received response:', id, obj);\n            // response for previous request\n            this.emit('response', id, obj);\n        }\n    }\n    response(requestId, data) {\n        this.send([requestId, data || null]);\n    }\n    notify(event, data) {\n        this.send([0, [event, data || null]]);\n    }\n    send(arr) {\n        logger.debug('send to vim:', arr);\n        try {\n            this.writeable.write(JSON.stringify(arr) + '\\n');\n        }\n        catch (e) {\n            logger.error('Send error:', arr);\n        }\n    }\n    redraw(force = false) {\n        this.send(['redraw', force ? 'force' : '']);\n    }\n    commmand(cmd) {\n        this.send(['ex', cmd]);\n    }\n    expr(expr) {\n        this.send(['expr', expr]);\n    }\n    call(func, args, requestId) {\n        if (!requestId) {\n            this.send(['call', func, args]);\n            return;\n        }\n        this.send(['call', func, args, requestId]);\n    }\n    dispose() {\n        this.removeAllListeners();\n    }\n}\nexports.default = Connection;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/@chemzqm/neovim/lib/transport/connection.js?");

/***/ }),

/***/ "./node_modules/@chemzqm/neovim/lib/transport/nvim.js":
/*!************************************************************!*\
  !*** ./node_modules/@chemzqm/neovim/lib/transport/nvim.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NvimTransport = void 0;\nconst msgpack = __importStar(__webpack_require__(/*! msgpack-lite */ \"./node_modules/msgpack-lite/index.js\"));\nconst buffered_1 = __importDefault(__webpack_require__(/*! ../utils/buffered */ \"./node_modules/@chemzqm/neovim/lib/utils/buffered.js\"));\nconst types_1 = __webpack_require__(/*! ../api/types */ \"./node_modules/@chemzqm/neovim/lib/api/types.js\");\nconst base_1 = __importDefault(__webpack_require__(/*! ./base */ \"./node_modules/@chemzqm/neovim/lib/transport/base.js\"));\nclass NvimTransport extends base_1.default {\n    constructor(logger) {\n        super(logger);\n        this.pending = new Map();\n        this.nextRequestId = 1;\n        this.attached = false;\n        const codec = this.setupCodec();\n        this.encodeStream = msgpack.createEncodeStream({ codec });\n        this.decodeStream = msgpack.createDecodeStream({ codec });\n        this.decodeStream.on('data', (msg) => {\n            this.parseMessage(msg);\n        });\n        this.decodeStream.on('end', () => {\n            this.detach();\n            this.emit('detach');\n        });\n    }\n    parseMessage(msg) {\n        const msgType = msg[0];\n        this.debugMessage(msg);\n        if (msgType === 0) {\n            // request\n            //   - msg[1]: id\n            //   - msg[2]: method name\n            //   - msg[3]: arguments\n            this.emit('request', msg[2].toString(), msg[3], this.createResponse(msg[1]));\n        }\n        else if (msgType === 1) {\n            // response to a previous request:\n            //   - msg[1]: the id\n            //   - msg[2]: error(if any)\n            //   - msg[3]: result(if not errored)\n            const id = msg[1];\n            const handler = this.pending.get(id);\n            if (handler) {\n                this.pending.delete(id);\n                let err = msg[2];\n                if (err && err.length != 2) {\n                    err = [0, err instanceof Error ? err.message : err];\n                }\n                handler(err, msg[3]);\n            }\n        }\n        else if (msgType === 2) {\n            // notification/event\n            //   - msg[1]: event name\n            //   - msg[2]: arguments\n            this.emit('notification', msg[1].toString(), msg[2]);\n        }\n        else {\n            // tslint:disable-next-line: no-console\n            console.error(`Invalid message type ${msgType}`);\n        }\n    }\n    setupCodec() {\n        const codec = msgpack.createCodec();\n        types_1.Metadata.forEach(({ constructor }, id) => {\n            codec.addExtPacker(id, constructor, (obj) => msgpack.encode(obj.data));\n            codec.addExtUnpacker(id, data => new constructor({\n                transport: this,\n                client: this.client,\n                data: msgpack.decode(data),\n            }));\n        });\n        this.codec = codec;\n        return this.codec;\n    }\n    attach(writer, reader, client) {\n        this.encodeStream = this.encodeStream.pipe(writer);\n        const buffered = new buffered_1.default();\n        reader.pipe(buffered).pipe(this.decodeStream);\n        this.writer = writer;\n        this.reader = reader;\n        this.client = client;\n        this.attached = true;\n    }\n    detach() {\n        if (!this.attached)\n            return;\n        this.attached = false;\n        this.encodeStream.unpipe(this.writer);\n        this.reader.unpipe(this.decodeStream);\n    }\n    request(method, args, cb) {\n        if (!this.attached)\n            return;\n        let id = this.nextRequestId;\n        this.nextRequestId = this.nextRequestId + 1;\n        let startTs = Date.now();\n        this.debug('request to nvim:', id, method, args);\n        this.encodeStream.write(msgpack.encode([0, id, method, args], {\n            codec: this.codec,\n        }));\n        let stack = Error().stack;\n        let timer = setTimeout(() => {\n            this.debug(`request to vim blocked more than 1s: ${method}`, args, stack);\n        }, 1000);\n        this.pending.set(id, (err, res) => {\n            clearTimeout(timer);\n            this.debug('response of nvim:', id, `${Date.now() - startTs}ms`, res, err);\n            cb(err, res);\n        });\n    }\n    notify(method, args) {\n        if (!this.attached)\n            return;\n        if (this.pauseLevel != 0) {\n            let arr = this.paused.get(this.pauseLevel);\n            if (arr) {\n                arr.push([method, args]);\n                return;\n            }\n        }\n        this.debug('nvim notification:', method, args);\n        this.encodeStream.write(msgpack.encode([2, method, args], {\n            codec: this.codec,\n        }));\n    }\n    send(arr) {\n        this.encodeStream.write(msgpack.encode(arr, {\n            codec: this.codec,\n        }));\n    }\n    createResponse(requestId) {\n        let { encodeStream } = this;\n        let startTs = Date.now();\n        let called = false;\n        let timer = setTimeout(() => {\n            this.debug(`request to client cost more than 1s`, requestId);\n        }, 1000);\n        return {\n            send: (resp, isError) => {\n                clearTimeout(timer);\n                if (called || !this.attached)\n                    return;\n                this.debug('response of client:', requestId, `${Date.now() - startTs}ms`, resp, isError == true);\n                called = true;\n                encodeStream.write(msgpack.encode([\n                    1,\n                    requestId,\n                    isError ? resp : null,\n                    !isError ? resp : null,\n                ]));\n            }\n        };\n    }\n}\nexports.NvimTransport = NvimTransport;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/@chemzqm/neovim/lib/transport/nvim.js?");

/***/ }),

/***/ "./node_modules/@chemzqm/neovim/lib/transport/request.js":
/*!***************************************************************!*\
  !*** ./node_modules/@chemzqm/neovim/lib/transport/request.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst logger_1 = __webpack_require__(/*! ../utils/logger */ \"./node_modules/@chemzqm/neovim/lib/utils/logger.js\");\nconst logger = logger_1.createLogger('request');\nconst debug = process.env.NODE_CLIENT_LOG_LEVEL == 'debug';\nconst func = process.env.COC_NVIM == '1' ? 'coc#api#call' : 'nvim#api#call';\nclass Request {\n    constructor(connection, cb, id) {\n        this.connection = connection;\n        this.cb = cb;\n        this.id = id;\n    }\n    request(method, args = []) {\n        this.method = method;\n        this.args = args;\n        this.connection.call(func, [method.slice(5), args], this.id);\n    }\n    callback(client, err, result) {\n        let { method, cb } = this;\n        if (debug && err) {\n            logger.debug(`request ${this.method} error:`, err, this.args);\n        }\n        if (err)\n            return cb([0, err.toString()]);\n        switch (method) {\n            case 'nvim_list_wins':\n            case 'nvim_tabpage_list_wins':\n                return cb(null, result.map(o => client.createWindow(o)));\n            case 'nvim_tabpage_get_win':\n            case 'nvim_get_current_win':\n            case 'nvim_open_win':\n                return cb(null, client.createWindow(result));\n            case 'nvim_list_bufs':\n                return cb(null, result.map(o => client.createBuffer(o)));\n            case 'nvim_win_get_buf':\n            case 'nvim_create_buf':\n            case 'nvim_get_current_buf':\n                return cb(null, client.createBuffer(result));\n            case 'nvim_list_tabpages':\n                return cb(null, result.map(o => client.createTabpage(o)));\n            case 'nvim_get_current_tabpage':\n                return cb(null, client.createTabpage(result));\n            default:\n                return cb(null, result);\n        }\n    }\n}\nexports.default = Request;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/@chemzqm/neovim/lib/transport/request.js?");

/***/ }),

/***/ "./node_modules/@chemzqm/neovim/lib/transport/vim.js":
/*!***********************************************************!*\
  !*** ./node_modules/@chemzqm/neovim/lib/transport/vim.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VimTransport = void 0;\nconst base_1 = __importDefault(__webpack_require__(/*! ./base */ \"./node_modules/@chemzqm/neovim/lib/transport/base.js\"));\nconst connection_1 = __importDefault(__webpack_require__(/*! ./connection */ \"./node_modules/@chemzqm/neovim/lib/transport/connection.js\"));\nconst request_1 = __importDefault(__webpack_require__(/*! ./request */ \"./node_modules/@chemzqm/neovim/lib/transport/request.js\"));\nclass VimTransport extends base_1.default {\n    constructor(logger) {\n        super(logger);\n        this.pending = new Map();\n        this.nextRequestId = -1;\n        this.attached = false;\n        this.notifyMethod = process.env.COC_NVIM == '1' ? 'coc#api#notify' : 'nvim#api#notify';\n    }\n    attach(writer, reader, client) {\n        let connection = this.connection = new connection_1.default(reader, writer);\n        this.attached = true;\n        this.client = client;\n        connection.on('request', (id, obj) => {\n            let [method, args] = obj;\n            this.emit('request', method, args, this.createResponse(id));\n        });\n        connection.on('notification', (obj) => {\n            let [event, args] = obj;\n            this.emit('notification', event.toString(), args);\n        });\n        connection.on('response', (id, obj) => {\n            let req = this.pending.get(id);\n            if (req) {\n                this.pending.delete(id);\n                let err = null;\n                let result = null;\n                if (!Array.isArray(obj)) {\n                    err = obj;\n                }\n                else {\n                    err = obj[0];\n                    result = obj[1];\n                }\n                req.callback(this.client, err, result);\n            }\n        });\n    }\n    send(arr) {\n        this.connection.send(arr);\n    }\n    detach() {\n        if (!this.attached)\n            return;\n        this.attached = false;\n        this.connection.dispose();\n    }\n    /**\n     * Send request to vim\n     */\n    request(method, args, cb) {\n        if (!this.attached)\n            return cb([0, 'transport disconnected']);\n        let id = this.nextRequestId;\n        this.nextRequestId = this.nextRequestId - 1;\n        let startTs = Date.now();\n        this.debug('request to vim:', id, method, args);\n        let timer = setTimeout(() => {\n            this.debug(`request to vim cost more than 1s`, method, args);\n        }, 1000);\n        let req = new request_1.default(this.connection, (err, res) => {\n            clearTimeout(timer);\n            this.debug(`response from vim cost:`, id, `${Date.now() - startTs}ms`);\n            cb(err, res);\n        }, id);\n        this.pending.set(id, req);\n        req.request(method, args);\n    }\n    notify(method, args) {\n        if (!this.attached)\n            return;\n        if (this.pauseLevel != 0) {\n            let arr = this.paused.get(this.pauseLevel);\n            if (arr) {\n                arr.push([method, args]);\n                return;\n            }\n        }\n        this.connection.call(this.notifyMethod, [method.slice(5), args]);\n    }\n    createResponse(requestId) {\n        let called = false;\n        let { connection } = this;\n        let startTs = Date.now();\n        let timer = setTimeout(() => {\n            this.debug(`request to client cost more than 1s`, requestId);\n        }, 1000);\n        return {\n            send: (resp, isError) => {\n                clearTimeout(timer);\n                if (called || !this.attached)\n                    return;\n                called = true;\n                let err = null;\n                if (isError)\n                    err = typeof resp === 'string' ? resp : resp.toString();\n                this.debug('response of client cost:', requestId, `${Date.now() - startTs}ms`);\n                connection.response(requestId, [err, isError ? null : resp]);\n            }\n        };\n    }\n}\nexports.VimTransport = VimTransport;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/@chemzqm/neovim/lib/transport/vim.js?");

/***/ }),

/***/ "./node_modules/@chemzqm/neovim/lib/utils/buffered.js":
/*!************************************************************!*\
  !*** ./node_modules/@chemzqm/neovim/lib/utils/buffered.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nclass Buffered extends stream_1.Transform {\n    constructor() {\n        super({\n            readableHighWaterMark: 10 * 1024 * 1024,\n            writableHighWaterMark: 10 * 1024 * 1024,\n        });\n        this.chunks = null;\n        this.timer = null;\n    }\n    sendData() {\n        const { chunks } = this;\n        if (chunks) {\n            this.chunks = null;\n            const buf = Buffer.concat(chunks);\n            this.push(buf);\n        }\n    }\n    // eslint-disable-next-line consistent-return\n    _transform(chunk, _encoding, callback) {\n        const { chunks, timer } = this;\n        const MIN_SIZE = Buffer.poolSize;\n        if (timer)\n            clearTimeout(timer);\n        if (chunk.length < MIN_SIZE) {\n            if (!chunks)\n                return callback(null, chunk);\n            chunks.push(chunk);\n            this.sendData();\n            callback();\n        }\n        else {\n            if (!chunks) {\n                this.chunks = [chunk];\n            }\n            else {\n                chunks.push(chunk);\n            }\n            this.timer = setTimeout(this.sendData.bind(this), 20);\n            callback();\n        }\n    }\n    _flush(callback) {\n        const { chunks } = this;\n        if (chunks) {\n            this.chunks = null;\n            const buf = Buffer.concat(chunks);\n            callback(null, buf);\n        }\n        else {\n            callback();\n        }\n    }\n}\nexports.default = Buffered;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/@chemzqm/neovim/lib/utils/buffered.js?");

/***/ }),

/***/ "./node_modules/@chemzqm/neovim/lib/utils/logger.js":
/*!**********************************************************!*\
  !*** ./node_modules/@chemzqm/neovim/lib/utils/logger.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createLogger = void 0;\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst os_1 = __importDefault(__webpack_require__(/*! os */ \"os\"));\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nfunction getLogFile() {\n    let file = process.env.NODE_CLIENT_LOG_FILE;\n    if (file)\n        return file;\n    let dir = process.env.XDG_RUNTIME_DIR;\n    if (dir)\n        return path_1.default.join(dir, 'node-client.log');\n    return path_1.default.join(os_1.default.tmpdir(), `node-client-${process.pid}.log`);\n}\nconst LOG_FILE_PATH = getLogFile();\nconst level = process.env.NODE_CLIENT_LOG_LEVEL || 'info';\nlet invalid = process.getuid && process.getuid() == 0;\nif (!invalid) {\n    try {\n        fs_1.default.mkdirSync(path_1.default.dirname(LOG_FILE_PATH), { recursive: true });\n        fs_1.default.writeFileSync(LOG_FILE_PATH, '', { encoding: 'utf8', mode: 0o666 });\n    }\n    catch (_e) {\n        invalid = true;\n    }\n}\nfunction toObject(arg) {\n    if (arg == null) {\n        return arg;\n    }\n    if (Array.isArray(arg)) {\n        return arg.map(o => toObject(o));\n    }\n    if (typeof arg == 'object' && typeof arg.prefix == 'string' && typeof arg.data == 'number') {\n        return '[' + arg.prefix + arg.data + ']';\n    }\n    return arg;\n}\nfunction toString(arg) {\n    if (arg == null)\n        return String(arg);\n    if (typeof arg == 'object')\n        return JSON.stringify(arg, null, 2);\n    return String(arg);\n}\nclass Logger {\n    constructor(name) {\n        this.name = name;\n    }\n    get stream() {\n        if (invalid)\n            return null;\n        if (this._stream)\n            return this._stream;\n        this._stream = fs_1.default.createWriteStream(LOG_FILE_PATH, { encoding: 'utf8' });\n        return this._stream;\n    }\n    getText(level, data, meta) {\n        let more = '';\n        if (meta.length) {\n            let arr = toObject(meta);\n            more = ' ' + arr.map(o => toString(o));\n        }\n        return `${new Date().toLocaleTimeString()} ${level.toUpperCase()} [${this.name}] - ${data}${more}\\n`;\n    }\n    debug(data, ...meta) {\n        if (level != 'debug' || this.stream == null)\n            return;\n        this.stream.write(this.getText('debug', data, meta));\n    }\n    info(data, ...meta) {\n        if (this.stream == null)\n            return;\n        this.stream.write(this.getText('info', data, meta));\n    }\n    error(data, ...meta) {\n        if (this.stream == null)\n            return;\n        this.stream.write(this.getText('error', data, meta));\n    }\n    trace(data, ...meta) {\n        if (level != 'trace' || this.stream == null)\n            return;\n        this.stream.write(this.getText('trace', data, meta));\n    }\n}\nfunction createLogger(name) {\n    return new Logger(name);\n}\nexports.createLogger = createLogger;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/@chemzqm/neovim/lib/utils/logger.js?");

/***/ }),

/***/ "./node_modules/@tootallnate/once/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@tootallnate/once/dist/index.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\nfunction noop() { }\nfunction once(emitter, name) {\n    const o = once.spread(emitter, name);\n    const r = o.then((args) => args[0]);\n    r.cancel = o.cancel;\n    return r;\n}\n(function (once) {\n    function spread(emitter, name) {\n        let c = null;\n        const p = new Promise((resolve, reject) => {\n            function cancel() {\n                emitter.removeListener(name, onEvent);\n                emitter.removeListener('error', onError);\n                p.cancel = noop;\n            }\n            function onEvent(...args) {\n                cancel();\n                resolve(args);\n            }\n            function onError(err) {\n                cancel();\n                reject(err);\n            }\n            c = cancel;\n            emitter.on(name, onEvent);\n            emitter.on('error', onError);\n        });\n        if (!c) {\n            throw new TypeError('Could not get `cancel()` function');\n        }\n        p.cancel = c;\n        return p;\n    }\n    once.spread = spread;\n})(once || (once = {}));\nmodule.exports = once;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://coc.nvim/./node_modules/@tootallnate/once/dist/index.js?");

/***/ }),

/***/ "./node_modules/agent-base/dist/src/index.js":
/*!***************************************************!*\
  !*** ./node_modules/agent-base/dist/src/index.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\"));\nconst promisify_1 = __importDefault(__webpack_require__(/*! ./promisify */ \"./node_modules/agent-base/dist/src/promisify.js\"));\nconst debug = debug_1.default('agent-base');\nfunction isAgent(v) {\n    return Boolean(v) && typeof v.addRequest === 'function';\n}\nfunction isSecureEndpoint() {\n    const { stack } = new Error();\n    if (typeof stack !== 'string')\n        return false;\n    return stack.split('\\n').some(l => l.indexOf('(https.js:') !== -1 || l.indexOf('node:https:') !== -1);\n}\nfunction createAgent(callback, opts) {\n    return new createAgent.Agent(callback, opts);\n}\n(function (createAgent) {\n    /**\n     * Base `http.Agent` implementation.\n     * No pooling/keep-alive is implemented by default.\n     *\n     * @param {Function} callback\n     * @api public\n     */\n    class Agent extends events_1.EventEmitter {\n        constructor(callback, _opts) {\n            super();\n            let opts = _opts;\n            if (typeof callback === 'function') {\n                this.callback = callback;\n            }\n            else if (callback) {\n                opts = callback;\n            }\n            // Timeout for the socket to be returned from the callback\n            this.timeout = null;\n            if (opts && typeof opts.timeout === 'number') {\n                this.timeout = opts.timeout;\n            }\n            // These aren't actually used by `agent-base`, but are required\n            // for the TypeScript definition files in `@types/node` :/\n            this.maxFreeSockets = 1;\n            this.maxSockets = 1;\n            this.maxTotalSockets = Infinity;\n            this.sockets = {};\n            this.freeSockets = {};\n            this.requests = {};\n            this.options = {};\n        }\n        get defaultPort() {\n            if (typeof this.explicitDefaultPort === 'number') {\n                return this.explicitDefaultPort;\n            }\n            return isSecureEndpoint() ? 443 : 80;\n        }\n        set defaultPort(v) {\n            this.explicitDefaultPort = v;\n        }\n        get protocol() {\n            if (typeof this.explicitProtocol === 'string') {\n                return this.explicitProtocol;\n            }\n            return isSecureEndpoint() ? 'https:' : 'http:';\n        }\n        set protocol(v) {\n            this.explicitProtocol = v;\n        }\n        callback(req, opts, fn) {\n            throw new Error('\"agent-base\" has no default implementation, you must subclass and override `callback()`');\n        }\n        /**\n         * Called by node-core's \"_http_client.js\" module when creating\n         * a new HTTP request with this Agent instance.\n         *\n         * @api public\n         */\n        addRequest(req, _opts) {\n            const opts = Object.assign({}, _opts);\n            if (typeof opts.secureEndpoint !== 'boolean') {\n                opts.secureEndpoint = isSecureEndpoint();\n            }\n            if (opts.host == null) {\n                opts.host = 'localhost';\n            }\n            if (opts.port == null) {\n                opts.port = opts.secureEndpoint ? 443 : 80;\n            }\n            if (opts.protocol == null) {\n                opts.protocol = opts.secureEndpoint ? 'https:' : 'http:';\n            }\n            if (opts.host && opts.path) {\n                // If both a `host` and `path` are specified then it's most\n                // likely the result of a `url.parse()` call... we need to\n                // remove the `path` portion so that `net.connect()` doesn't\n                // attempt to open that as a unix socket file.\n                delete opts.path;\n            }\n            delete opts.agent;\n            delete opts.hostname;\n            delete opts._defaultAgent;\n            delete opts.defaultPort;\n            delete opts.createConnection;\n            // Hint to use \"Connection: close\"\n            // XXX: non-documented `http` module API :(\n            req._last = true;\n            req.shouldKeepAlive = false;\n            let timedOut = false;\n            let timeoutId = null;\n            const timeoutMs = opts.timeout || this.timeout;\n            const onerror = (err) => {\n                if (req._hadError)\n                    return;\n                req.emit('error', err);\n                // For Safety. Some additional errors might fire later on\n                // and we need to make sure we don't double-fire the error event.\n                req._hadError = true;\n            };\n            const ontimeout = () => {\n                timeoutId = null;\n                timedOut = true;\n                const err = new Error(`A \"socket\" was not created for HTTP request before ${timeoutMs}ms`);\n                err.code = 'ETIMEOUT';\n                onerror(err);\n            };\n            const callbackError = (err) => {\n                if (timedOut)\n                    return;\n                if (timeoutId !== null) {\n                    clearTimeout(timeoutId);\n                    timeoutId = null;\n                }\n                onerror(err);\n            };\n            const onsocket = (socket) => {\n                if (timedOut)\n                    return;\n                if (timeoutId != null) {\n                    clearTimeout(timeoutId);\n                    timeoutId = null;\n                }\n                if (isAgent(socket)) {\n                    // `socket` is actually an `http.Agent` instance, so\n                    // relinquish responsibility for this `req` to the Agent\n                    // from here on\n                    debug('Callback returned another Agent instance %o', socket.constructor.name);\n                    socket.addRequest(req, opts);\n                    return;\n                }\n                if (socket) {\n                    socket.once('free', () => {\n                        this.freeSocket(socket, opts);\n                    });\n                    req.onSocket(socket);\n                    return;\n                }\n                const err = new Error(`no Duplex stream was returned to agent-base for \\`${req.method} ${req.path}\\``);\n                onerror(err);\n            };\n            if (typeof this.callback !== 'function') {\n                onerror(new Error('`callback` is not defined'));\n                return;\n            }\n            if (!this.promisifiedCallback) {\n                if (this.callback.length >= 3) {\n                    debug('Converting legacy callback function to promise');\n                    this.promisifiedCallback = promisify_1.default(this.callback);\n                }\n                else {\n                    this.promisifiedCallback = this.callback;\n                }\n            }\n            if (typeof timeoutMs === 'number' && timeoutMs > 0) {\n                timeoutId = setTimeout(ontimeout, timeoutMs);\n            }\n            if ('port' in opts && typeof opts.port !== 'number') {\n                opts.port = Number(opts.port);\n            }\n            try {\n                debug('Resolving socket for %o request: %o', opts.protocol, `${req.method} ${req.path}`);\n                Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);\n            }\n            catch (err) {\n                Promise.reject(err).catch(callbackError);\n            }\n        }\n        freeSocket(socket, opts) {\n            debug('Freeing socket %o %o', socket.constructor.name, opts);\n            socket.destroy();\n        }\n        destroy() {\n            debug('Destroying agent %o', this.constructor.name);\n        }\n    }\n    createAgent.Agent = Agent;\n    // So that `instanceof` works correctly\n    createAgent.prototype = createAgent.Agent.prototype;\n})(createAgent || (createAgent = {}));\nmodule.exports = createAgent;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://coc.nvim/./node_modules/agent-base/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/agent-base/dist/src/promisify.js":
/*!*******************************************************!*\
  !*** ./node_modules/agent-base/dist/src/promisify.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction promisify(fn) {\n    return function (req, opts) {\n        return new Promise((resolve, reject) => {\n            fn.call(this, req, opts, (err, rtn) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(rtn);\n                }\n            });\n        });\n    };\n}\nexports.default = promisify;\n//# sourceMappingURL=promisify.js.map\n\n//# sourceURL=webpack://coc.nvim/./node_modules/agent-base/dist/src/promisify.js?");

/***/ }),

/***/ "./node_modules/ansi-regex/index.js":
/*!******************************************!*\
  !*** ./node_modules/ansi-regex/index.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = ({onlyFirst = false} = {}) => {\n\tconst pattern = [\n\t\t'[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n\t\t'(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))'\n\t].join('|');\n\n\treturn new RegExp(pattern, onlyFirst ? undefined : 'g');\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/ansi-regex/index.js?");

/***/ }),

/***/ "./node_modules/ansi-styles/index.js":
/*!*******************************************!*\
  !*** ./node_modules/ansi-styles/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nconst ANSI_BACKGROUND_OFFSET = 10;\n\nconst wrapAnsi256 = (offset = 0) => code => `\\u001B[${38 + offset};5;${code}m`;\n\nconst wrapAnsi16m = (offset = 0) => (red, green, blue) => `\\u001B[${38 + offset};2;${red};${green};${blue}m`;\n\nfunction assembleStyles() {\n\tconst codes = new Map();\n\tconst styles = {\n\t\tmodifier: {\n\t\t\treset: [0, 0],\n\t\t\t// 21 isn't widely supported and 22 does the same thing\n\t\t\tbold: [1, 22],\n\t\t\tdim: [2, 22],\n\t\t\titalic: [3, 23],\n\t\t\tunderline: [4, 24],\n\t\t\tinverse: [7, 27],\n\t\t\thidden: [8, 28],\n\t\t\tstrikethrough: [9, 29]\n\t\t},\n\t\tcolor: {\n\t\t\tblack: [30, 39],\n\t\t\tred: [31, 39],\n\t\t\tgreen: [32, 39],\n\t\t\tyellow: [33, 39],\n\t\t\tblue: [34, 39],\n\t\t\tmagenta: [35, 39],\n\t\t\tcyan: [36, 39],\n\t\t\twhite: [37, 39],\n\n\t\t\t// Bright color\n\t\t\tblackBright: [90, 39],\n\t\t\tredBright: [91, 39],\n\t\t\tgreenBright: [92, 39],\n\t\t\tyellowBright: [93, 39],\n\t\t\tblueBright: [94, 39],\n\t\t\tmagentaBright: [95, 39],\n\t\t\tcyanBright: [96, 39],\n\t\t\twhiteBright: [97, 39]\n\t\t},\n\t\tbgColor: {\n\t\t\tbgBlack: [40, 49],\n\t\t\tbgRed: [41, 49],\n\t\t\tbgGreen: [42, 49],\n\t\t\tbgYellow: [43, 49],\n\t\t\tbgBlue: [44, 49],\n\t\t\tbgMagenta: [45, 49],\n\t\t\tbgCyan: [46, 49],\n\t\t\tbgWhite: [47, 49],\n\n\t\t\t// Bright color\n\t\t\tbgBlackBright: [100, 49],\n\t\t\tbgRedBright: [101, 49],\n\t\t\tbgGreenBright: [102, 49],\n\t\t\tbgYellowBright: [103, 49],\n\t\t\tbgBlueBright: [104, 49],\n\t\t\tbgMagentaBright: [105, 49],\n\t\t\tbgCyanBright: [106, 49],\n\t\t\tbgWhiteBright: [107, 49]\n\t\t}\n\t};\n\n\t// Alias bright black as gray (and grey)\n\tstyles.color.gray = styles.color.blackBright;\n\tstyles.bgColor.bgGray = styles.bgColor.bgBlackBright;\n\tstyles.color.grey = styles.color.blackBright;\n\tstyles.bgColor.bgGrey = styles.bgColor.bgBlackBright;\n\n\tfor (const [groupName, group] of Object.entries(styles)) {\n\t\tfor (const [styleName, style] of Object.entries(group)) {\n\t\t\tstyles[styleName] = {\n\t\t\t\topen: `\\u001B[${style[0]}m`,\n\t\t\t\tclose: `\\u001B[${style[1]}m`\n\t\t\t};\n\n\t\t\tgroup[styleName] = styles[styleName];\n\n\t\t\tcodes.set(style[0], style[1]);\n\t\t}\n\n\t\tObject.defineProperty(styles, groupName, {\n\t\t\tvalue: group,\n\t\t\tenumerable: false\n\t\t});\n\t}\n\n\tObject.defineProperty(styles, 'codes', {\n\t\tvalue: codes,\n\t\tenumerable: false\n\t});\n\n\tstyles.color.close = '\\u001B[39m';\n\tstyles.bgColor.close = '\\u001B[49m';\n\n\tstyles.color.ansi256 = wrapAnsi256();\n\tstyles.color.ansi16m = wrapAnsi16m();\n\tstyles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);\n\tstyles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);\n\n\t// From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js\n\tstyles.rgbToAnsi256 = (red, green, blue) => {\n\t\t// We use the extended greyscale palette here, with the exception of\n\t\t// black and white. normal palette only has 4 greyscale shades.\n\t\tif (red === green && green === blue) {\n\t\t\tif (red < 8) {\n\t\t\t\treturn 16;\n\t\t\t}\n\n\t\t\tif (red > 248) {\n\t\t\t\treturn 231;\n\t\t\t}\n\n\t\t\treturn Math.round(((red - 8) / 247) * 24) + 232;\n\t\t}\n\n\t\treturn 16 +\n\t\t\t(36 * Math.round(red / 255 * 5)) +\n\t\t\t(6 * Math.round(green / 255 * 5)) +\n\t\t\tMath.round(blue / 255 * 5);\n\t};\n\n\tstyles.hexToRgb = hex => {\n\t\tconst matches = /(?<colorString>[a-f\\d]{6}|[a-f\\d]{3})/i.exec(hex.toString(16));\n\t\tif (!matches) {\n\t\t\treturn [0, 0, 0];\n\t\t}\n\n\t\tlet {colorString} = matches.groups;\n\n\t\tif (colorString.length === 3) {\n\t\t\tcolorString = colorString.split('').map(character => character + character).join('');\n\t\t}\n\n\t\tconst integer = Number.parseInt(colorString, 16);\n\n\t\treturn [\n\t\t\t(integer >> 16) & 0xFF,\n\t\t\t(integer >> 8) & 0xFF,\n\t\t\tinteger & 0xFF\n\t\t];\n\t};\n\n\tstyles.hexToAnsi256 = hex => styles.rgbToAnsi256(...styles.hexToRgb(hex));\n\n\treturn styles;\n}\n\n// Make the export immutable\nObject.defineProperty(module, 'exports', {\n\tenumerable: true,\n\tget: assembleStyles\n});\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/ansi-styles/index.js?");

/***/ }),

/***/ "./node_modules/arch/index.js":
/*!************************************!*\
  !*** ./node_modules/arch/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var cp = __webpack_require__(/*! child_process */ \"child_process\")\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar path = __webpack_require__(/*! path */ \"path\")\n\n/**\n * Returns the operating system's CPU architecture. This is different than\n * `process.arch` or `os.arch()` which returns the architecture the Node.js (or\n * Electron) binary was compiled for.\n */\nmodule.exports = function arch () {\n  /**\n   * The running binary is 64-bit, so the OS is clearly 64-bit.\n   */\n  if (process.arch === 'x64') {\n    return 'x64'\n  }\n\n  /**\n   * All recent versions of Mac OS are 64-bit.\n   */\n  if (process.platform === 'darwin') {\n    return 'x64'\n  }\n\n  /**\n   * On Windows, the most reliable way to detect a 64-bit OS from within a 32-bit\n   * app is based on the presence of a WOW64 file: %SystemRoot%\\SysNative.\n   * See: https://twitter.com/feross/status/776949077208510464\n   */\n  if (process.platform === 'win32') {\n    var useEnv = false\n    try {\n      useEnv = !!(process.env.SYSTEMROOT && fs.statSync(process.env.SYSTEMROOT))\n    } catch (err) {}\n\n    var sysRoot = useEnv ? process.env.SYSTEMROOT : 'C:\\\\Windows'\n\n    // If %SystemRoot%\\SysNative exists, we are in a WOW64 FS Redirected application.\n    var isWOW64 = false\n    try {\n      isWOW64 = !!fs.statSync(path.join(sysRoot, 'sysnative'))\n    } catch (err) {}\n\n    return isWOW64 ? 'x64' : 'x86'\n  }\n\n  /**\n   * On Linux, use the `getconf` command to get the architecture.\n   */\n  if (process.platform === 'linux') {\n    var output = cp.execSync('getconf LONG_BIT', {encoding: 'utf8'})\n    return output === '64\\n' ? 'x64' : 'x86'\n  }\n\n  /**\n   * If none of the above, assume the architecture is 32-bit.\n   */\n  return 'x86'\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/arch/index.js?");

/***/ }),

/***/ "./node_modules/at-least-node/index.js":
/*!*********************************************!*\
  !*** ./node_modules/at-least-node/index.js ***!
  \*********************************************/
/***/ ((module) => {

eval("module.exports = r => {\n  const n = process.versions.node.split('.').map(x => parseInt(x, 10))\n  r = r.split('.').map(x => parseInt(x, 10))\n  return n[0] > r[0] || (n[0] === r[0] && (n[1] > r[1] || (n[1] === r[1] && n[2] >= r[2])))\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/at-least-node/index.js?");

/***/ }),

/***/ "./node_modules/balanced-match/index.js":
/*!**********************************************!*\
  !*** ./node_modules/balanced-match/index.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/balanced-match/index.js?");

/***/ }),

/***/ "./node_modules/big-integer/BigInteger.js":
/*!************************************************!*\
  !*** ./node_modules/big-integer/BigInteger.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;var bigInt = (function (undefined) {\r\n    \"use strict\";\r\n\r\n    var BASE = 1e7,\r\n        LOG_BASE = 7,\r\n        MAX_INT = 9007199254740992,\r\n        MAX_INT_ARR = smallToArray(MAX_INT),\r\n        DEFAULT_ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\";\r\n\r\n    var supportsNativeBigInt = typeof BigInt === \"function\";\r\n\r\n    function Integer(v, radix, alphabet, caseSensitive) {\r\n        if (typeof v === \"undefined\") return Integer[0];\r\n        if (typeof radix !== \"undefined\") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);\r\n        return parseValue(v);\r\n    }\r\n\r\n    function BigInteger(value, sign) {\r\n        this.value = value;\r\n        this.sign = sign;\r\n        this.isSmall = false;\r\n    }\r\n    BigInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function SmallInteger(value) {\r\n        this.value = value;\r\n        this.sign = value < 0;\r\n        this.isSmall = true;\r\n    }\r\n    SmallInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function NativeBigInt(value) {\r\n        this.value = value;\r\n    }\r\n    NativeBigInt.prototype = Object.create(Integer.prototype);\r\n\r\n    function isPrecise(n) {\r\n        return -MAX_INT < n && n < MAX_INT;\r\n    }\r\n\r\n    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes\r\n        if (n < 1e7)\r\n            return [n];\r\n        if (n < 1e14)\r\n            return [n % 1e7, Math.floor(n / 1e7)];\r\n        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\r\n    }\r\n\r\n    function arrayToSmall(arr) { // If BASE changes this function may need to change\r\n        trim(arr);\r\n        var length = arr.length;\r\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\r\n            switch (length) {\r\n                case 0: return 0;\r\n                case 1: return arr[0];\r\n                case 2: return arr[0] + arr[1] * BASE;\r\n                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function trim(v) {\r\n        var i = v.length;\r\n        while (v[--i] === 0);\r\n        v.length = i + 1;\r\n    }\r\n\r\n    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger\r\n        var x = new Array(length);\r\n        var i = -1;\r\n        while (++i < length) {\r\n            x[i] = 0;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    function truncate(n) {\r\n        if (n > 0) return Math.floor(n);\r\n        return Math.ceil(n);\r\n    }\r\n\r\n    function add(a, b) { // assumes a and b are arrays with a.length >= b.length\r\n        var l_a = a.length,\r\n            l_b = b.length,\r\n            r = new Array(l_a),\r\n            carry = 0,\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l_b; i++) {\r\n            sum = a[i] + b[i] + carry;\r\n            carry = sum >= base ? 1 : 0;\r\n            r[i] = sum - carry * base;\r\n        }\r\n        while (i < l_a) {\r\n            sum = a[i] + carry;\r\n            carry = sum === base ? 1 : 0;\r\n            r[i++] = sum - carry * base;\r\n        }\r\n        if (carry > 0) r.push(carry);\r\n        return r;\r\n    }\r\n\r\n    function addAny(a, b) {\r\n        if (a.length >= b.length) return add(a, b);\r\n        return add(b, a);\r\n    }\r\n\r\n    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l; i++) {\r\n            sum = a[i] - base + carry;\r\n            carry = Math.floor(sum / base);\r\n            r[i] = sum - carry * base;\r\n            carry += 1;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall) {\r\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\r\n        }\r\n        return new BigInteger(addAny(a, b), this.sign);\r\n    };\r\n    BigInteger.prototype.plus = BigInteger.prototype.add;\r\n\r\n    SmallInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\r\n            b = smallToArray(Math.abs(b));\r\n        }\r\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\r\n    };\r\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\r\n\r\n    NativeBigInt.prototype.add = function (v) {\r\n        return new NativeBigInt(this.value + parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;\r\n\r\n    function subtract(a, b) { // assumes a and b are arrays with a >= b\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            r = new Array(a_l),\r\n            borrow = 0,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < b_l; i++) {\r\n            difference = a[i] - borrow - b[i];\r\n            if (difference < 0) {\r\n                difference += base;\r\n                borrow = 1;\r\n            } else borrow = 0;\r\n            r[i] = difference;\r\n        }\r\n        for (i = b_l; i < a_l; i++) {\r\n            difference = a[i] - borrow;\r\n            if (difference < 0) difference += base;\r\n            else {\r\n                r[i++] = difference;\r\n                break;\r\n            }\r\n            r[i] = difference;\r\n        }\r\n        for (; i < a_l; i++) {\r\n            r[i] = a[i];\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function subtractAny(a, b, sign) {\r\n        var value;\r\n        if (compareAbs(a, b) >= 0) {\r\n            value = subtract(a, b);\r\n        } else {\r\n            value = subtract(b, a);\r\n            sign = !sign;\r\n        }\r\n        value = arrayToSmall(value);\r\n        if (typeof value === \"number\") {\r\n            if (sign) value = -value;\r\n            return new SmallInteger(value);\r\n        }\r\n        return new BigInteger(value, sign);\r\n    }\r\n\r\n    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            carry = -b,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < l; i++) {\r\n            difference = a[i] + carry;\r\n            carry = Math.floor(difference / base);\r\n            difference %= base;\r\n            r[i] = difference < 0 ? difference + base : difference;\r\n        }\r\n        r = arrayToSmall(r);\r\n        if (typeof r === \"number\") {\r\n            if (sign) r = -r;\r\n            return new SmallInteger(r);\r\n        } return new BigInteger(r, sign);\r\n    }\r\n\r\n    BigInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall)\r\n            return subtractSmall(a, Math.abs(b), this.sign);\r\n        return subtractAny(a, b, this.sign);\r\n    };\r\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\r\n\r\n    SmallInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            return new SmallInteger(a - b);\r\n        }\r\n        return subtractSmall(b, Math.abs(a), a >= 0);\r\n    };\r\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\r\n\r\n    NativeBigInt.prototype.subtract = function (v) {\r\n        return new NativeBigInt(this.value - parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;\r\n\r\n    BigInteger.prototype.negate = function () {\r\n        return new BigInteger(this.value, !this.sign);\r\n    };\r\n    SmallInteger.prototype.negate = function () {\r\n        var sign = this.sign;\r\n        var small = new SmallInteger(-this.value);\r\n        small.sign = !sign;\r\n        return small;\r\n    };\r\n    NativeBigInt.prototype.negate = function () {\r\n        return new NativeBigInt(-this.value);\r\n    }\r\n\r\n    BigInteger.prototype.abs = function () {\r\n        return new BigInteger(this.value, false);\r\n    };\r\n    SmallInteger.prototype.abs = function () {\r\n        return new SmallInteger(Math.abs(this.value));\r\n    };\r\n    NativeBigInt.prototype.abs = function () {\r\n        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);\r\n    }\r\n\r\n\r\n    function multiplyLong(a, b) {\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            l = a_l + b_l,\r\n            r = createArray(l),\r\n            base = BASE,\r\n            product, carry, i, a_i, b_j;\r\n        for (i = 0; i < a_l; ++i) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < b_l; ++j) {\r\n                b_j = b[j];\r\n                product = a_i * b_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            carry = 0,\r\n            product, i;\r\n        for (i = 0; i < l; i++) {\r\n            product = a[i] * b + carry;\r\n            carry = Math.floor(product / base);\r\n            r[i] = product - carry * base;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function shiftLeft(x, n) {\r\n        var r = [];\r\n        while (n-- > 0) r.push(0);\r\n        return r.concat(x);\r\n    }\r\n\r\n    function multiplyKaratsuba(x, y) {\r\n        var n = Math.max(x.length, y.length);\r\n\r\n        if (n <= 30) return multiplyLong(x, y);\r\n        n = Math.ceil(n / 2);\r\n\r\n        var b = x.slice(n),\r\n            a = x.slice(0, n),\r\n            d = y.slice(n),\r\n            c = y.slice(0, n);\r\n\r\n        var ac = multiplyKaratsuba(a, c),\r\n            bd = multiplyKaratsuba(b, d),\r\n            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\r\n\r\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\r\n        trim(product);\r\n        return product;\r\n    }\r\n\r\n    // The following function is derived from a surface fit of a graph plotting the performance difference\r\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\r\n    function useKaratsuba(l1, l2) {\r\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\r\n    }\r\n\r\n    BigInteger.prototype.multiply = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value, b = n.value,\r\n            sign = this.sign !== n.sign,\r\n            abs;\r\n        if (n.isSmall) {\r\n            if (b === 0) return Integer[0];\r\n            if (b === 1) return this;\r\n            if (b === -1) return this.negate();\r\n            abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                return new BigInteger(multiplySmall(a, abs), sign);\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes\r\n            return new BigInteger(multiplyKaratsuba(a, b), sign);\r\n        return new BigInteger(multiplyLong(a, b), sign);\r\n    };\r\n\r\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\r\n\r\n    function multiplySmallAndArray(a, b, sign) { // a >= 0\r\n        if (a < BASE) {\r\n            return new BigInteger(multiplySmall(b, a), sign);\r\n        }\r\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\r\n    }\r\n    SmallInteger.prototype._multiplyBySmall = function (a) {\r\n        if (isPrecise(a.value * this.value)) {\r\n            return new SmallInteger(a.value * this.value);\r\n        }\r\n        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\r\n    };\r\n    BigInteger.prototype._multiplyBySmall = function (a) {\r\n        if (a.value === 0) return Integer[0];\r\n        if (a.value === 1) return this;\r\n        if (a.value === -1) return this.negate();\r\n        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\r\n    };\r\n    SmallInteger.prototype.multiply = function (v) {\r\n        return parseValue(v)._multiplyBySmall(this);\r\n    };\r\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\r\n\r\n    NativeBigInt.prototype.multiply = function (v) {\r\n        return new NativeBigInt(this.value * parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;\r\n\r\n    function square(a) {\r\n        //console.assert(2 * BASE * BASE < MAX_INT);\r\n        var l = a.length,\r\n            r = createArray(l + l),\r\n            base = BASE,\r\n            product, carry, i, a_i, a_j;\r\n        for (i = 0; i < l; i++) {\r\n            a_i = a[i];\r\n            carry = 0 - a_i * a_i;\r\n            for (var j = i; j < l; j++) {\r\n                a_j = a[j];\r\n                product = 2 * (a_i * a_j) + r[i + j] + carry;\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n            }\r\n            r[i + l] = carry;\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.square = function () {\r\n        return new BigInteger(square(this.value), false);\r\n    };\r\n\r\n    SmallInteger.prototype.square = function () {\r\n        var value = this.value * this.value;\r\n        if (isPrecise(value)) return new SmallInteger(value);\r\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\r\n    };\r\n\r\n    NativeBigInt.prototype.square = function (v) {\r\n        return new NativeBigInt(this.value * this.value);\r\n    }\r\n\r\n    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            base = BASE,\r\n            result = createArray(b.length),\r\n            divisorMostSignificantDigit = b[b_l - 1],\r\n            // normalization\r\n            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),\r\n            remainder = multiplySmall(a, lambda),\r\n            divisor = multiplySmall(b, lambda),\r\n            quotientDigit, shift, carry, borrow, i, l, q;\r\n        if (remainder.length <= a_l) remainder.push(0);\r\n        divisor.push(0);\r\n        divisorMostSignificantDigit = divisor[b_l - 1];\r\n        for (shift = a_l - b_l; shift >= 0; shift--) {\r\n            quotientDigit = base - 1;\r\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\r\n                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\r\n            }\r\n            // quotientDigit <= base - 1\r\n            carry = 0;\r\n            borrow = 0;\r\n            l = divisor.length;\r\n            for (i = 0; i < l; i++) {\r\n                carry += quotientDigit * divisor[i];\r\n                q = Math.floor(carry / base);\r\n                borrow += remainder[shift + i] - (carry - q * base);\r\n                carry = q;\r\n                if (borrow < 0) {\r\n                    remainder[shift + i] = borrow + base;\r\n                    borrow = -1;\r\n                } else {\r\n                    remainder[shift + i] = borrow;\r\n                    borrow = 0;\r\n                }\r\n            }\r\n            while (borrow !== 0) {\r\n                quotientDigit -= 1;\r\n                carry = 0;\r\n                for (i = 0; i < l; i++) {\r\n                    carry += remainder[shift + i] - base + divisor[i];\r\n                    if (carry < 0) {\r\n                        remainder[shift + i] = carry + base;\r\n                        carry = 0;\r\n                    } else {\r\n                        remainder[shift + i] = carry;\r\n                        carry = 1;\r\n                    }\r\n                }\r\n                borrow += carry;\r\n            }\r\n            result[shift] = quotientDigit;\r\n        }\r\n        // denormalization\r\n        remainder = divModSmall(remainder, lambda)[0];\r\n        return [arrayToSmall(result), arrayToSmall(remainder)];\r\n    }\r\n\r\n    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/\r\n        // Performs faster than divMod1 on larger input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            result = [],\r\n            part = [],\r\n            base = BASE,\r\n            guess, xlen, highx, highy, check;\r\n        while (a_l) {\r\n            part.unshift(a[--a_l]);\r\n            trim(part);\r\n            if (compareAbs(part, b) < 0) {\r\n                result.push(0);\r\n                continue;\r\n            }\r\n            xlen = part.length;\r\n            highx = part[xlen - 1] * base + part[xlen - 2];\r\n            highy = b[b_l - 1] * base + b[b_l - 2];\r\n            if (xlen > b_l) {\r\n                highx = (highx + 1) * base;\r\n            }\r\n            guess = Math.ceil(highx / highy);\r\n            do {\r\n                check = multiplySmall(b, guess);\r\n                if (compareAbs(check, part) <= 0) break;\r\n                guess--;\r\n            } while (guess);\r\n            result.push(guess);\r\n            part = subtract(part, check);\r\n        }\r\n        result.reverse();\r\n        return [arrayToSmall(result), arrayToSmall(part)];\r\n    }\r\n\r\n    function divModSmall(value, lambda) {\r\n        var length = value.length,\r\n            quotient = createArray(length),\r\n            base = BASE,\r\n            i, q, remainder, divisor;\r\n        remainder = 0;\r\n        for (i = length - 1; i >= 0; --i) {\r\n            divisor = remainder * base + value[i];\r\n            q = truncate(divisor / lambda);\r\n            remainder = divisor - q * lambda;\r\n            quotient[i] = q | 0;\r\n        }\r\n        return [quotient, remainder | 0];\r\n    }\r\n\r\n    function divModAny(self, v) {\r\n        var value, n = parseValue(v);\r\n        if (supportsNativeBigInt) {\r\n            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];\r\n        }\r\n        var a = self.value, b = n.value;\r\n        var quotient;\r\n        if (b === 0) throw new Error(\"Cannot divide by zero\");\r\n        if (self.isSmall) {\r\n            if (n.isSmall) {\r\n                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\r\n            }\r\n            return [Integer[0], self];\r\n        }\r\n        if (n.isSmall) {\r\n            if (b === 1) return [self, Integer[0]];\r\n            if (b == -1) return [self.negate(), Integer[0]];\r\n            var abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                value = divModSmall(a, abs);\r\n                quotient = arrayToSmall(value[0]);\r\n                var remainder = value[1];\r\n                if (self.sign) remainder = -remainder;\r\n                if (typeof quotient === \"number\") {\r\n                    if (self.sign !== n.sign) quotient = -quotient;\r\n                    return [new SmallInteger(quotient), new SmallInteger(remainder)];\r\n                }\r\n                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        var comparison = compareAbs(a, b);\r\n        if (comparison === -1) return [Integer[0], self];\r\n        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\r\n\r\n        // divMod1 is faster on smaller input sizes\r\n        if (a.length + b.length <= 200)\r\n            value = divMod1(a, b);\r\n        else value = divMod2(a, b);\r\n\r\n        quotient = value[0];\r\n        var qSign = self.sign !== n.sign,\r\n            mod = value[1],\r\n            mSign = self.sign;\r\n        if (typeof quotient === \"number\") {\r\n            if (qSign) quotient = -quotient;\r\n            quotient = new SmallInteger(quotient);\r\n        } else quotient = new BigInteger(quotient, qSign);\r\n        if (typeof mod === \"number\") {\r\n            if (mSign) mod = -mod;\r\n            mod = new SmallInteger(mod);\r\n        } else mod = new BigInteger(mod, mSign);\r\n        return [quotient, mod];\r\n    }\r\n\r\n    BigInteger.prototype.divmod = function (v) {\r\n        var result = divModAny(this, v);\r\n        return {\r\n            quotient: result[0],\r\n            remainder: result[1]\r\n        };\r\n    };\r\n    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\r\n\r\n\r\n    BigInteger.prototype.divide = function (v) {\r\n        return divModAny(this, v)[0];\r\n    };\r\n    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {\r\n        return new NativeBigInt(this.value / parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\r\n\r\n    BigInteger.prototype.mod = function (v) {\r\n        return divModAny(this, v)[1];\r\n    };\r\n    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {\r\n        return new NativeBigInt(this.value % parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\r\n\r\n    BigInteger.prototype.pow = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            value, x, y;\r\n        if (b === 0) return Integer[1];\r\n        if (a === 0) return Integer[0];\r\n        if (a === 1) return Integer[1];\r\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.sign) {\r\n            return Integer[0];\r\n        }\r\n        if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\r\n        if (this.isSmall) {\r\n            if (isPrecise(value = Math.pow(a, b)))\r\n                return new SmallInteger(truncate(value));\r\n        }\r\n        x = this;\r\n        y = Integer[1];\r\n        while (true) {\r\n            if (b & 1 === 1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === 0) break;\r\n            b /= 2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\r\n\r\n    NativeBigInt.prototype.pow = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value, b = n.value;\r\n        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);\r\n        if (b === _0) return Integer[1];\r\n        if (a === _0) return Integer[0];\r\n        if (a === _1) return Integer[1];\r\n        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.isNegative()) return new NativeBigInt(_0);\r\n        var x = this;\r\n        var y = Integer[1];\r\n        while (true) {\r\n            if ((b & _1) === _1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === _0) break;\r\n            b /= _2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    }\r\n\r\n    BigInteger.prototype.modPow = function (exp, mod) {\r\n        exp = parseValue(exp);\r\n        mod = parseValue(mod);\r\n        if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\r\n        var r = Integer[1],\r\n            base = this.mod(mod);\r\n        if (exp.isNegative()) {\r\n            exp = exp.multiply(Integer[-1]);\r\n            base = base.modInv(mod);\r\n        }\r\n        while (exp.isPositive()) {\r\n            if (base.isZero()) return Integer[0];\r\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\r\n            exp = exp.divide(2);\r\n            base = base.square().mod(mod);\r\n        }\r\n        return r;\r\n    };\r\n    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\r\n\r\n    function compareAbs(a, b) {\r\n        if (a.length !== b.length) {\r\n            return a.length > b.length ? 1 : -1;\r\n        }\r\n        for (var i = a.length - 1; i >= 0; i--) {\r\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    BigInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) return 1;\r\n        return compareAbs(a, b);\r\n    };\r\n    SmallInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = Math.abs(this.value),\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            b = Math.abs(b);\r\n            return a === b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        return -1;\r\n    };\r\n    NativeBigInt.prototype.compareAbs = function (v) {\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        a = a >= 0 ? a : -a;\r\n        b = b >= 0 ? b : -b;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    }\r\n\r\n    BigInteger.prototype.compare = function (v) {\r\n        // See discussion about comparison with Infinity:\r\n        // https://github.com/peterolson/BigInteger.js/issues/61\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (this.sign !== n.sign) {\r\n            return n.sign ? 1 : -1;\r\n        }\r\n        if (n.isSmall) {\r\n            return this.sign ? -1 : 1;\r\n        }\r\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\r\n    };\r\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\r\n\r\n    SmallInteger.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            return a == b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        if (a < 0 !== n.sign) {\r\n            return a < 0 ? -1 : 1;\r\n        }\r\n        return a < 0 ? 1 : -1;\r\n    };\r\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\r\n\r\n    NativeBigInt.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    }\r\n    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;\r\n\r\n    BigInteger.prototype.equals = function (v) {\r\n        return this.compare(v) === 0;\r\n    };\r\n    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\r\n\r\n    BigInteger.prototype.notEquals = function (v) {\r\n        return this.compare(v) !== 0;\r\n    };\r\n    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\r\n\r\n    BigInteger.prototype.greater = function (v) {\r\n        return this.compare(v) > 0;\r\n    };\r\n    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\r\n\r\n    BigInteger.prototype.lesser = function (v) {\r\n        return this.compare(v) < 0;\r\n    };\r\n    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\r\n\r\n    BigInteger.prototype.greaterOrEquals = function (v) {\r\n        return this.compare(v) >= 0;\r\n    };\r\n    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\r\n\r\n    BigInteger.prototype.lesserOrEquals = function (v) {\r\n        return this.compare(v) <= 0;\r\n    };\r\n    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\r\n\r\n    BigInteger.prototype.isEven = function () {\r\n        return (this.value[0] & 1) === 0;\r\n    };\r\n    SmallInteger.prototype.isEven = function () {\r\n        return (this.value & 1) === 0;\r\n    };\r\n    NativeBigInt.prototype.isEven = function () {\r\n        return (this.value & BigInt(1)) === BigInt(0);\r\n    }\r\n\r\n    BigInteger.prototype.isOdd = function () {\r\n        return (this.value[0] & 1) === 1;\r\n    };\r\n    SmallInteger.prototype.isOdd = function () {\r\n        return (this.value & 1) === 1;\r\n    };\r\n    NativeBigInt.prototype.isOdd = function () {\r\n        return (this.value & BigInt(1)) === BigInt(1);\r\n    }\r\n\r\n    BigInteger.prototype.isPositive = function () {\r\n        return !this.sign;\r\n    };\r\n    SmallInteger.prototype.isPositive = function () {\r\n        return this.value > 0;\r\n    };\r\n    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;\r\n\r\n    BigInteger.prototype.isNegative = function () {\r\n        return this.sign;\r\n    };\r\n    SmallInteger.prototype.isNegative = function () {\r\n        return this.value < 0;\r\n    };\r\n    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;\r\n\r\n    BigInteger.prototype.isUnit = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isUnit = function () {\r\n        return Math.abs(this.value) === 1;\r\n    };\r\n    NativeBigInt.prototype.isUnit = function () {\r\n        return this.abs().value === BigInt(1);\r\n    }\r\n\r\n    BigInteger.prototype.isZero = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isZero = function () {\r\n        return this.value === 0;\r\n    };\r\n    NativeBigInt.prototype.isZero = function () {\r\n        return this.value === BigInt(0);\r\n    }\r\n\r\n    BigInteger.prototype.isDivisibleBy = function (v) {\r\n        var n = parseValue(v);\r\n        if (n.isZero()) return false;\r\n        if (n.isUnit()) return true;\r\n        if (n.compareAbs(2) === 0) return this.isEven();\r\n        return this.mod(n).isZero();\r\n    };\r\n    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\r\n\r\n    function isBasicPrime(v) {\r\n        var n = v.abs();\r\n        if (n.isUnit()) return false;\r\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\r\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\r\n        if (n.lesser(49)) return true;\r\n        // we don't know if it's prime: let the other functions figure it out\r\n    }\r\n\r\n    function millerRabinTest(n, a) {\r\n        var nPrev = n.prev(),\r\n            b = nPrev,\r\n            r = 0,\r\n            d, t, i, x;\r\n        while (b.isEven()) b = b.divide(2), r++;\r\n        next: for (i = 0; i < a.length; i++) {\r\n            if (n.lesser(a[i])) continue;\r\n            x = bigInt(a[i]).modPow(b, n);\r\n            if (x.isUnit() || x.equals(nPrev)) continue;\r\n            for (d = r - 1; d != 0; d--) {\r\n                x = x.square().mod(n);\r\n                if (x.isUnit()) return false;\r\n                if (x.equals(nPrev)) continue next;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // Set \"strict\" to true to force GRH-supported lower bound of 2*log(N)^2\r\n    BigInteger.prototype.isPrime = function (strict) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var bits = n.bitLength();\r\n        if (bits <= 64)\r\n            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);\r\n        var logN = Math.log(2) * bits.toJSNumber();\r\n        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt(i + 2));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\r\n\r\n    BigInteger.prototype.isProbablePrime = function (iterations, rng) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var t = iterations === undefined ? 5 : iterations;\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt.randBetween(2, n.minus(2), rng));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\r\n\r\n    BigInteger.prototype.modInv = function (n) {\r\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\r\n        while (!newR.isZero()) {\r\n            q = r.divide(newR);\r\n            lastT = t;\r\n            lastR = r;\r\n            t = newT;\r\n            r = newR;\r\n            newT = lastT.subtract(q.multiply(newT));\r\n            newR = lastR.subtract(q.multiply(newR));\r\n        }\r\n        if (!r.isUnit()) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\r\n        if (t.compare(0) === -1) {\r\n            t = t.add(n);\r\n        }\r\n        if (this.isNegative()) {\r\n            return t.negate();\r\n        }\r\n        return t;\r\n    };\r\n\r\n    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\r\n\r\n    BigInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return subtractSmall(value, 1, this.sign);\r\n        }\r\n        return new BigInteger(addSmall(value, 1), this.sign);\r\n    };\r\n    SmallInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\r\n        return new BigInteger(MAX_INT_ARR, false);\r\n    };\r\n    NativeBigInt.prototype.next = function () {\r\n        return new NativeBigInt(this.value + BigInt(1));\r\n    }\r\n\r\n    BigInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return new BigInteger(addSmall(value, 1), true);\r\n        }\r\n        return subtractSmall(value, 1, this.sign);\r\n    };\r\n    SmallInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\r\n        return new BigInteger(MAX_INT_ARR, true);\r\n    };\r\n    NativeBigInt.prototype.prev = function () {\r\n        return new NativeBigInt(this.value - BigInt(1));\r\n    }\r\n\r\n    var powersOfTwo = [1];\r\n    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\r\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\r\n\r\n    function shift_isSmall(n) {\r\n        return Math.abs(n) <= BASE;\r\n    }\r\n\r\n    BigInteger.prototype.shiftLeft = function (v) {\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftRight(-n);\r\n        var result = this;\r\n        if (result.isZero()) return result;\r\n        while (n >= powers2Length) {\r\n            result = result.multiply(highestPower2);\r\n            n -= powers2Length - 1;\r\n        }\r\n        return result.multiply(powersOfTwo[n]);\r\n    };\r\n    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\r\n\r\n    BigInteger.prototype.shiftRight = function (v) {\r\n        var remQuo;\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftLeft(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;\r\n            remQuo = divModAny(result, highestPower2);\r\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n            n -= powers2Length - 1;\r\n        }\r\n        remQuo = divModAny(result, powersOfTwo[n]);\r\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n    };\r\n    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\r\n\r\n    function bitwise(x, y, fn) {\r\n        y = parseValue(y);\r\n        var xSign = x.isNegative(), ySign = y.isNegative();\r\n        var xRem = xSign ? x.not() : x,\r\n            yRem = ySign ? y.not() : y;\r\n        var xDigit = 0, yDigit = 0;\r\n        var xDivMod = null, yDivMod = null;\r\n        var result = [];\r\n        while (!xRem.isZero() || !yRem.isZero()) {\r\n            xDivMod = divModAny(xRem, highestPower2);\r\n            xDigit = xDivMod[1].toJSNumber();\r\n            if (xSign) {\r\n                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            yDivMod = divModAny(yRem, highestPower2);\r\n            yDigit = yDivMod[1].toJSNumber();\r\n            if (ySign) {\r\n                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            xRem = xDivMod[0];\r\n            yRem = yDivMod[0];\r\n            result.push(fn(xDigit, yDigit));\r\n        }\r\n        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\r\n        for (var i = result.length - 1; i >= 0; i -= 1) {\r\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    BigInteger.prototype.not = function () {\r\n        return this.negate().prev();\r\n    };\r\n    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;\r\n\r\n    BigInteger.prototype.and = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a & b; });\r\n    };\r\n    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;\r\n\r\n    BigInteger.prototype.or = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a | b; });\r\n    };\r\n    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;\r\n\r\n    BigInteger.prototype.xor = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a ^ b; });\r\n    };\r\n    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;\r\n\r\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\r\n    function roughLOB(n) { // get lowestOneBit (rough)\r\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\r\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\r\n        var v = n.value,\r\n            x = typeof v === \"number\" ? v | LOBMASK_I :\r\n                typeof v === \"bigint\" ? v | BigInt(LOBMASK_I) :\r\n                    v[0] + v[1] * BASE | LOBMASK_BI;\r\n        return x & -x;\r\n    }\r\n\r\n    function integerLogarithm(value, base) {\r\n        if (base.compareTo(value) <= 0) {\r\n            var tmp = integerLogarithm(value, base.square(base));\r\n            var p = tmp.p;\r\n            var e = tmp.e;\r\n            var t = p.multiply(base);\r\n            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };\r\n        }\r\n        return { p: bigInt(1), e: 0 };\r\n    }\r\n\r\n    BigInteger.prototype.bitLength = function () {\r\n        var n = this;\r\n        if (n.compareTo(bigInt(0)) < 0) {\r\n            n = n.negate().subtract(bigInt(1));\r\n        }\r\n        if (n.compareTo(bigInt(0)) === 0) {\r\n            return bigInt(0);\r\n        }\r\n        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));\r\n    }\r\n    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\r\n\r\n    function max(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.greater(b) ? a : b;\r\n    }\r\n    function min(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.lesser(b) ? a : b;\r\n    }\r\n    function gcd(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        if (a.equals(b)) return a;\r\n        if (a.isZero()) return b;\r\n        if (b.isZero()) return a;\r\n        var c = Integer[1], d, t;\r\n        while (a.isEven() && b.isEven()) {\r\n            d = min(roughLOB(a), roughLOB(b));\r\n            a = a.divide(d);\r\n            b = b.divide(d);\r\n            c = c.multiply(d);\r\n        }\r\n        while (a.isEven()) {\r\n            a = a.divide(roughLOB(a));\r\n        }\r\n        do {\r\n            while (b.isEven()) {\r\n                b = b.divide(roughLOB(b));\r\n            }\r\n            if (a.greater(b)) {\r\n                t = b; b = a; a = t;\r\n            }\r\n            b = b.subtract(a);\r\n        } while (!b.isZero());\r\n        return c.isUnit() ? a : a.multiply(c);\r\n    }\r\n    function lcm(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        return a.divide(gcd(a, b)).multiply(b);\r\n    }\r\n    function randBetween(a, b, rng) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        var usedRNG = rng || Math.random;\r\n        var low = min(a, b), high = max(a, b);\r\n        var range = high.subtract(low).add(1);\r\n        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));\r\n        var digits = toBase(range, BASE).value;\r\n        var result = [], restricted = true;\r\n        for (var i = 0; i < digits.length; i++) {\r\n            var top = restricted ? digits[i] : BASE;\r\n            var digit = truncate(usedRNG() * top);\r\n            result.push(digit);\r\n            if (digit < top) restricted = false;\r\n        }\r\n        return low.add(Integer.fromArray(result, BASE, false));\r\n    }\r\n\r\n    var parseBase = function (text, base, alphabet, caseSensitive) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        text = String(text);\r\n        if (!caseSensitive) {\r\n            text = text.toLowerCase();\r\n            alphabet = alphabet.toLowerCase();\r\n        }\r\n        var length = text.length;\r\n        var i;\r\n        var absBase = Math.abs(base);\r\n        var alphabetValues = {};\r\n        for (i = 0; i < alphabet.length; i++) {\r\n            alphabetValues[alphabet[i]] = i;\r\n        }\r\n        for (i = 0; i < length; i++) {\r\n            var c = text[i];\r\n            if (c === \"-\") continue;\r\n            if (c in alphabetValues) {\r\n                if (alphabetValues[c] >= absBase) {\r\n                    if (c === \"1\" && absBase === 1) continue;\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n                }\r\n            }\r\n        }\r\n        base = parseValue(base);\r\n        var digits = [];\r\n        var isNegative = text[0] === \"-\";\r\n        for (i = isNegative ? 1 : 0; i < text.length; i++) {\r\n            var c = text[i];\r\n            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));\r\n            else if (c === \"<\") {\r\n                var start = i;\r\n                do { i++; } while (text[i] !== \">\" && i < text.length);\r\n                digits.push(parseValue(text.slice(start + 1, i)));\r\n            }\r\n            else throw new Error(c + \" is not a valid character\");\r\n        }\r\n        return parseBaseFromArray(digits, base, isNegative);\r\n    };\r\n\r\n    function parseBaseFromArray(digits, base, isNegative) {\r\n        var val = Integer[0], pow = Integer[1], i;\r\n        for (i = digits.length - 1; i >= 0; i--) {\r\n            val = val.add(digits[i].times(pow));\r\n            pow = pow.times(base);\r\n        }\r\n        return isNegative ? val.negate() : val;\r\n    }\r\n\r\n    function stringify(digit, alphabet) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        if (digit < alphabet.length) {\r\n            return alphabet[digit];\r\n        }\r\n        return \"<\" + digit + \">\";\r\n    }\r\n\r\n    function toBase(n, base) {\r\n        base = bigInt(base);\r\n        if (base.isZero()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\r\n        }\r\n        if (base.equals(-1)) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            if (n.isNegative())\r\n                return {\r\n                    value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber()))\r\n                        .map(Array.prototype.valueOf, [1, 0])\r\n                    ),\r\n                    isNegative: false\r\n                };\r\n\r\n            var arr = Array.apply(null, Array(n.toJSNumber() - 1))\r\n                .map(Array.prototype.valueOf, [0, 1]);\r\n            arr.unshift([1]);\r\n            return {\r\n                value: [].concat.apply([], arr),\r\n                isNegative: false\r\n            };\r\n        }\r\n\r\n        var neg = false;\r\n        if (n.isNegative() && base.isPositive()) {\r\n            neg = true;\r\n            n = n.abs();\r\n        }\r\n        if (base.isUnit()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n\r\n            return {\r\n                value: Array.apply(null, Array(n.toJSNumber()))\r\n                    .map(Number.prototype.valueOf, 1),\r\n                isNegative: neg\r\n            };\r\n        }\r\n        var out = [];\r\n        var left = n, divmod;\r\n        while (left.isNegative() || left.compareAbs(base) >= 0) {\r\n            divmod = left.divmod(base);\r\n            left = divmod.quotient;\r\n            var digit = divmod.remainder;\r\n            if (digit.isNegative()) {\r\n                digit = base.minus(digit).abs();\r\n                left = left.next();\r\n            }\r\n            out.push(digit.toJSNumber());\r\n        }\r\n        out.push(left.toJSNumber());\r\n        return { value: out.reverse(), isNegative: neg };\r\n    }\r\n\r\n    function toBaseString(n, base, alphabet) {\r\n        var arr = toBase(n, base);\r\n        return (arr.isNegative ? \"-\" : \"\") + arr.value.map(function (x) {\r\n            return stringify(x, alphabet);\r\n        }).join('');\r\n    }\r\n\r\n    BigInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    SmallInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    NativeBigInt.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    BigInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix !== 10) return toBaseString(this, radix, alphabet);\r\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\r\n        while (--l >= 0) {\r\n            digit = String(v[l]);\r\n            str += zeros.slice(digit.length) + digit;\r\n        }\r\n        var sign = this.sign ? \"-\" : \"\";\r\n        return sign + str;\r\n    };\r\n\r\n    SmallInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix != 10) return toBaseString(this, radix, alphabet);\r\n        return String(this.value);\r\n    };\r\n\r\n    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;\r\n\r\n    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); }\r\n\r\n    BigInteger.prototype.valueOf = function () {\r\n        return parseInt(this.toString(), 10);\r\n    };\r\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\r\n\r\n    SmallInteger.prototype.valueOf = function () {\r\n        return this.value;\r\n    };\r\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\r\n    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {\r\n        return parseInt(this.toString(), 10);\r\n    }\r\n\r\n    function parseStringValue(v) {\r\n        if (isPrecise(+v)) {\r\n            var x = +v;\r\n            if (x === truncate(x))\r\n                return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);\r\n            throw new Error(\"Invalid integer: \" + v);\r\n        }\r\n        var sign = v[0] === \"-\";\r\n        if (sign) v = v.slice(1);\r\n        var split = v.split(/e/i);\r\n        if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\r\n        if (split.length === 2) {\r\n            var exp = split[1];\r\n            if (exp[0] === \"+\") exp = exp.slice(1);\r\n            exp = +exp;\r\n            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\r\n            var text = split[0];\r\n            var decimalPlace = text.indexOf(\".\");\r\n            if (decimalPlace >= 0) {\r\n                exp -= text.length - decimalPlace - 1;\r\n                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\r\n            }\r\n            if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\r\n            text += (new Array(exp + 1)).join(\"0\");\r\n            v = text;\r\n        }\r\n        var isValid = /^([0-9][0-9]*)$/.test(v);\r\n        if (!isValid) throw new Error(\"Invalid integer: \" + v);\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(sign ? \"-\" + v : v));\r\n        }\r\n        var r = [], max = v.length, l = LOG_BASE, min = max - l;\r\n        while (max > 0) {\r\n            r.push(+v.slice(min, max));\r\n            min -= l;\r\n            if (min < 0) min = 0;\r\n            max -= l;\r\n        }\r\n        trim(r);\r\n        return new BigInteger(r, sign);\r\n    }\r\n\r\n    function parseNumberValue(v) {\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(v));\r\n        }\r\n        if (isPrecise(v)) {\r\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\r\n            return new SmallInteger(v);\r\n        }\r\n        return parseStringValue(v.toString());\r\n    }\r\n\r\n    function parseValue(v) {\r\n        if (typeof v === \"number\") {\r\n            return parseNumberValue(v);\r\n        }\r\n        if (typeof v === \"string\") {\r\n            return parseStringValue(v);\r\n        }\r\n        if (typeof v === \"bigint\") {\r\n            return new NativeBigInt(v);\r\n        }\r\n        return v;\r\n    }\r\n    // Pre-define numbers in range [-999,999]\r\n    for (var i = 0; i < 1000; i++) {\r\n        Integer[i] = parseValue(i);\r\n        if (i > 0) Integer[-i] = parseValue(-i);\r\n    }\r\n    // Backwards compatibility\r\n    Integer.one = Integer[1];\r\n    Integer.zero = Integer[0];\r\n    Integer.minusOne = Integer[-1];\r\n    Integer.max = max;\r\n    Integer.min = min;\r\n    Integer.gcd = gcd;\r\n    Integer.lcm = lcm;\r\n    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt; };\r\n    Integer.randBetween = randBetween;\r\n\r\n    Integer.fromArray = function (digits, base, isNegative) {\r\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\r\n    };\r\n\r\n    return Integer;\r\n})();\r\n\r\n// Node.js check\r\nif ( true && module.hasOwnProperty(\"exports\")) {\r\n    module.exports = bigInt;\r\n}\r\n\r\n//amd check\r\nif (true) {\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n        return bigInt;\r\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n}\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/big-integer/BigInteger.js?");

/***/ }),

/***/ "./node_modules/binary/index.js":
/*!**************************************!*\
  !*** ./node_modules/binary/index.js ***!
  \**************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var Chainsaw = __webpack_require__(/*! chainsaw */ \"./node_modules/chainsaw/index.js\");\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar Buffers = __webpack_require__(/*! buffers */ \"./node_modules/buffers/index.js\");\nvar Vars = __webpack_require__(/*! ./lib/vars.js */ \"./node_modules/binary/lib/vars.js\");\nvar Stream = __webpack_require__(/*! stream */ \"stream\").Stream;\n\nexports = module.exports = function (bufOrEm, eventName) {\n    if (Buffer.isBuffer(bufOrEm)) {\n        return exports.parse(bufOrEm);\n    }\n    \n    var s = exports.stream();\n    if (bufOrEm && bufOrEm.pipe) {\n        bufOrEm.pipe(s);\n    }\n    else if (bufOrEm) {\n        bufOrEm.on(eventName || 'data', function (buf) {\n            s.write(buf);\n        });\n        \n        bufOrEm.on('end', function () {\n            s.end();\n        });\n    }\n    return s;\n};\n\nexports.stream = function (input) {\n    if (input) return exports.apply(null, arguments);\n    \n    var pending = null;\n    function getBytes (bytes, cb, skip) {\n        pending = {\n            bytes : bytes,\n            skip : skip,\n            cb : function (buf) {\n                pending = null;\n                cb(buf);\n            },\n        };\n        dispatch();\n    }\n    \n    var offset = null;\n    function dispatch () {\n        if (!pending) {\n            if (caughtEnd) done = true;\n            return;\n        }\n        if (typeof pending === 'function') {\n            pending();\n        }\n        else {\n            var bytes = offset + pending.bytes;\n            \n            if (buffers.length >= bytes) {\n                var buf;\n                if (offset == null) {\n                    buf = buffers.splice(0, bytes);\n                    if (!pending.skip) {\n                        buf = buf.slice();\n                    }\n                }\n                else {\n                    if (!pending.skip) {\n                        buf = buffers.slice(offset, bytes);\n                    }\n                    offset = bytes;\n                }\n                \n                if (pending.skip) {\n                    pending.cb();\n                }\n                else {\n                    pending.cb(buf);\n                }\n            }\n        }\n    }\n    \n    function builder (saw) {\n        function next () { if (!done) saw.next() }\n        \n        var self = words(function (bytes, cb) {\n            return function (name) {\n                getBytes(bytes, function (buf) {\n                    vars.set(name, cb(buf));\n                    next();\n                });\n            };\n        });\n        \n        self.tap = function (cb) {\n            saw.nest(cb, vars.store);\n        };\n        \n        self.into = function (key, cb) {\n            if (!vars.get(key)) vars.set(key, {});\n            var parent = vars;\n            vars = Vars(parent.get(key));\n            \n            saw.nest(function () {\n                cb.apply(this, arguments);\n                this.tap(function () {\n                    vars = parent;\n                });\n            }, vars.store);\n        };\n        \n        self.flush = function () {\n            vars.store = {};\n            next();\n        };\n        \n        self.loop = function (cb) {\n            var end = false;\n            \n            saw.nest(false, function loop () {\n                this.vars = vars.store;\n                cb.call(this, function () {\n                    end = true;\n                    next();\n                }, vars.store);\n                this.tap(function () {\n                    if (end) saw.next()\n                    else loop.call(this)\n                }.bind(this));\n            }, vars.store);\n        };\n        \n        self.buffer = function (name, bytes) {\n            if (typeof bytes === 'string') {\n                bytes = vars.get(bytes);\n            }\n            \n            getBytes(bytes, function (buf) {\n                vars.set(name, buf);\n                next();\n            });\n        };\n        \n        self.skip = function (bytes) {\n            if (typeof bytes === 'string') {\n                bytes = vars.get(bytes);\n            }\n            \n            getBytes(bytes, function () {\n                next();\n            });\n        };\n        \n        self.scan = function find (name, search) {\n            if (typeof search === 'string') {\n                search = new Buffer(search);\n            }\n            else if (!Buffer.isBuffer(search)) {\n                throw new Error('search must be a Buffer or a string');\n            }\n            \n            var taken = 0;\n            pending = function () {\n                var pos = buffers.indexOf(search, offset + taken);\n                var i = pos-offset-taken;\n                if (pos !== -1) {\n                    pending = null;\n                    if (offset != null) {\n                        vars.set(\n                            name,\n                            buffers.slice(offset, offset + taken + i)\n                        );\n                        offset += taken + i + search.length;\n                    }\n                    else {\n                        vars.set(\n                            name,\n                            buffers.slice(0, taken + i)\n                        );\n                        buffers.splice(0, taken + i + search.length);\n                    }\n                    next();\n                    dispatch();\n                } else {\n                    i = Math.max(buffers.length - search.length - offset - taken, 0);\n\t\t\t\t}\n                taken += i;\n            };\n            dispatch();\n        };\n        \n        self.peek = function (cb) {\n            offset = 0;\n            saw.nest(function () {\n                cb.call(this, vars.store);\n                this.tap(function () {\n                    offset = null;\n                });\n            });\n        };\n        \n        return self;\n    };\n    \n    var stream = Chainsaw.light(builder);\n    stream.writable = true;\n    \n    var buffers = Buffers();\n    \n    stream.write = function (buf) {\n        buffers.push(buf);\n        dispatch();\n    };\n    \n    var vars = Vars();\n    \n    var done = false, caughtEnd = false;\n    stream.end = function () {\n        caughtEnd = true;\n    };\n    \n    stream.pipe = Stream.prototype.pipe;\n    Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function (name) {\n        stream[name] = EventEmitter.prototype[name];\n    });\n    \n    return stream;\n};\n\nexports.parse = function parse (buffer) {\n    var self = words(function (bytes, cb) {\n        return function (name) {\n            if (offset + bytes <= buffer.length) {\n                var buf = buffer.slice(offset, offset + bytes);\n                offset += bytes;\n                vars.set(name, cb(buf));\n            }\n            else {\n                vars.set(name, null);\n            }\n            return self;\n        };\n    });\n    \n    var offset = 0;\n    var vars = Vars();\n    self.vars = vars.store;\n    \n    self.tap = function (cb) {\n        cb.call(self, vars.store);\n        return self;\n    };\n    \n    self.into = function (key, cb) {\n        if (!vars.get(key)) {\n            vars.set(key, {});\n        }\n        var parent = vars;\n        vars = Vars(parent.get(key));\n        cb.call(self, vars.store);\n        vars = parent;\n        return self;\n    };\n    \n    self.loop = function (cb) {\n        var end = false;\n        var ender = function () { end = true };\n        while (end === false) {\n            cb.call(self, ender, vars.store);\n        }\n        return self;\n    };\n    \n    self.buffer = function (name, size) {\n        if (typeof size === 'string') {\n            size = vars.get(size);\n        }\n        var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));\n        offset += size;\n        vars.set(name, buf);\n        \n        return self;\n    };\n    \n    self.skip = function (bytes) {\n        if (typeof bytes === 'string') {\n            bytes = vars.get(bytes);\n        }\n        offset += bytes;\n        \n        return self;\n    };\n    \n    self.scan = function (name, search) {\n        if (typeof search === 'string') {\n            search = new Buffer(search);\n        }\n        else if (!Buffer.isBuffer(search)) {\n            throw new Error('search must be a Buffer or a string');\n        }\n        vars.set(name, null);\n        \n        // simple but slow string search\n        for (var i = 0; i + offset <= buffer.length - search.length + 1; i++) {\n            for (\n                var j = 0;\n                j < search.length && buffer[offset+i+j] === search[j];\n                j++\n            );\n            if (j === search.length) break;\n        }\n        \n        vars.set(name, buffer.slice(offset, offset + i));\n        offset += i + search.length;\n        return self;\n    };\n    \n    self.peek = function (cb) {\n        var was = offset;\n        cb.call(self, vars.store);\n        offset = was;\n        return self;\n    };\n    \n    self.flush = function () {\n        vars.store = {};\n        return self;\n    };\n    \n    self.eof = function () {\n        return offset >= buffer.length;\n    };\n    \n    return self;\n};\n\n// convert byte strings to unsigned little endian numbers\nfunction decodeLEu (bytes) {\n    var acc = 0;\n    for (var i = 0; i < bytes.length; i++) {\n        acc += Math.pow(256,i) * bytes[i];\n    }\n    return acc;\n}\n\n// convert byte strings to unsigned big endian numbers\nfunction decodeBEu (bytes) {\n    var acc = 0;\n    for (var i = 0; i < bytes.length; i++) {\n        acc += Math.pow(256, bytes.length - i - 1) * bytes[i];\n    }\n    return acc;\n}\n\n// convert byte strings to signed big endian numbers\nfunction decodeBEs (bytes) {\n    var val = decodeBEu(bytes);\n    if ((bytes[0] & 0x80) == 0x80) {\n        val -= Math.pow(256, bytes.length);\n    }\n    return val;\n}\n\n// convert byte strings to signed little endian numbers\nfunction decodeLEs (bytes) {\n    var val = decodeLEu(bytes);\n    if ((bytes[bytes.length - 1] & 0x80) == 0x80) {\n        val -= Math.pow(256, bytes.length);\n    }\n    return val;\n}\n\nfunction words (decode) {\n    var self = {};\n    \n    [ 1, 2, 4, 8 ].forEach(function (bytes) {\n        var bits = bytes * 8;\n        \n        self['word' + bits + 'le']\n        = self['word' + bits + 'lu']\n        = decode(bytes, decodeLEu);\n        \n        self['word' + bits + 'ls']\n        = decode(bytes, decodeLEs);\n        \n        self['word' + bits + 'be']\n        = self['word' + bits + 'bu']\n        = decode(bytes, decodeBEu);\n        \n        self['word' + bits + 'bs']\n        = decode(bytes, decodeBEs);\n    });\n    \n    // word8be(n) == word8le(n) for all n\n    self.word8 = self.word8u = self.word8be;\n    self.word8s = self.word8bs;\n    \n    return self;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/binary/index.js?");

/***/ }),

/***/ "./node_modules/binary/lib/vars.js":
/*!*****************************************!*\
  !*** ./node_modules/binary/lib/vars.js ***!
  \*****************************************/
/***/ ((module) => {

eval("module.exports = function (store) {\n    function getset (name, value) {\n        var node = vars.store;\n        var keys = name.split('.');\n        keys.slice(0,-1).forEach(function (k) {\n            if (node[k] === undefined) node[k] = {};\n            node = node[k]\n        });\n        var key = keys[keys.length - 1];\n        if (arguments.length == 1) {\n            return node[key];\n        }\n        else {\n            return node[key] = value;\n        }\n    }\n    \n    var vars = {\n        get : function (name) {\n            return getset(name);\n        },\n        set : function (name, value) {\n            return getset(name, value);\n        },\n        store : store || {},\n    };\n    return vars;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/binary/lib/vars.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/any.js":
/*!*************************************************!*\
  !*** ./node_modules/bluebird/js/release/any.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function(Promise) {\nvar SomePromiseArray = Promise._SomePromiseArray;\nfunction any(promises) {\n    var ret = new SomePromiseArray(promises);\n    var promise = ret.promise();\n    ret.setHowMany(1);\n    ret.setUnwrap();\n    ret.init();\n    return promise;\n}\n\nPromise.any = function (promises) {\n    return any(promises);\n};\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/any.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/async.js":
/*!***************************************************!*\
  !*** ./node_modules/bluebird/js/release/async.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar firstLineError;\ntry {throw new Error(); } catch (e) {firstLineError = e;}\nvar schedule = __webpack_require__(/*! ./schedule */ \"./node_modules/bluebird/js/release/schedule.js\");\nvar Queue = __webpack_require__(/*! ./queue */ \"./node_modules/bluebird/js/release/queue.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\n\nfunction Async() {\n    this._customScheduler = false;\n    this._isTickUsed = false;\n    this._lateQueue = new Queue(16);\n    this._normalQueue = new Queue(16);\n    this._haveDrainedQueues = false;\n    this._trampolineEnabled = true;\n    var self = this;\n    this.drainQueues = function () {\n        self._drainQueues();\n    };\n    this._schedule = schedule;\n}\n\nAsync.prototype.setScheduler = function(fn) {\n    var prev = this._schedule;\n    this._schedule = fn;\n    this._customScheduler = true;\n    return prev;\n};\n\nAsync.prototype.hasCustomScheduler = function() {\n    return this._customScheduler;\n};\n\nAsync.prototype.enableTrampoline = function() {\n    this._trampolineEnabled = true;\n};\n\nAsync.prototype.disableTrampolineIfNecessary = function() {\n    if (util.hasDevTools) {\n        this._trampolineEnabled = false;\n    }\n};\n\nAsync.prototype.haveItemsQueued = function () {\n    return this._isTickUsed || this._haveDrainedQueues;\n};\n\n\nAsync.prototype.fatalError = function(e, isNode) {\n    if (isNode) {\n        process.stderr.write(\"Fatal \" + (e instanceof Error ? e.stack : e) +\n            \"\\n\");\n        process.exit(2);\n    } else {\n        this.throwLater(e);\n    }\n};\n\nAsync.prototype.throwLater = function(fn, arg) {\n    if (arguments.length === 1) {\n        arg = fn;\n        fn = function () { throw arg; };\n    }\n    if (typeof setTimeout !== \"undefined\") {\n        setTimeout(function() {\n            fn(arg);\n        }, 0);\n    } else try {\n        this._schedule(function() {\n            fn(arg);\n        });\n    } catch (e) {\n        throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n};\n\nfunction AsyncInvokeLater(fn, receiver, arg) {\n    this._lateQueue.push(fn, receiver, arg);\n    this._queueTick();\n}\n\nfunction AsyncInvoke(fn, receiver, arg) {\n    this._normalQueue.push(fn, receiver, arg);\n    this._queueTick();\n}\n\nfunction AsyncSettlePromises(promise) {\n    this._normalQueue._pushOne(promise);\n    this._queueTick();\n}\n\nif (!util.hasDevTools) {\n    Async.prototype.invokeLater = AsyncInvokeLater;\n    Async.prototype.invoke = AsyncInvoke;\n    Async.prototype.settlePromises = AsyncSettlePromises;\n} else {\n    Async.prototype.invokeLater = function (fn, receiver, arg) {\n        if (this._trampolineEnabled) {\n            AsyncInvokeLater.call(this, fn, receiver, arg);\n        } else {\n            this._schedule(function() {\n                setTimeout(function() {\n                    fn.call(receiver, arg);\n                }, 100);\n            });\n        }\n    };\n\n    Async.prototype.invoke = function (fn, receiver, arg) {\n        if (this._trampolineEnabled) {\n            AsyncInvoke.call(this, fn, receiver, arg);\n        } else {\n            this._schedule(function() {\n                fn.call(receiver, arg);\n            });\n        }\n    };\n\n    Async.prototype.settlePromises = function(promise) {\n        if (this._trampolineEnabled) {\n            AsyncSettlePromises.call(this, promise);\n        } else {\n            this._schedule(function() {\n                promise._settlePromises();\n            });\n        }\n    };\n}\n\nAsync.prototype._drainQueue = function(queue) {\n    while (queue.length() > 0) {\n        var fn = queue.shift();\n        if (typeof fn !== \"function\") {\n            fn._settlePromises();\n            continue;\n        }\n        var receiver = queue.shift();\n        var arg = queue.shift();\n        fn.call(receiver, arg);\n    }\n};\n\nAsync.prototype._drainQueues = function () {\n    this._drainQueue(this._normalQueue);\n    this._reset();\n    this._haveDrainedQueues = true;\n    this._drainQueue(this._lateQueue);\n};\n\nAsync.prototype._queueTick = function () {\n    if (!this._isTickUsed) {\n        this._isTickUsed = true;\n        this._schedule(this.drainQueues);\n    }\n};\n\nAsync.prototype._reset = function () {\n    this._isTickUsed = false;\n};\n\nmodule.exports = Async;\nmodule.exports.firstLineError = firstLineError;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/async.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/bind.js":
/*!**************************************************!*\
  !*** ./node_modules/bluebird/js/release/bind.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {\nvar calledBind = false;\nvar rejectThis = function(_, e) {\n    this._reject(e);\n};\n\nvar targetRejected = function(e, context) {\n    context.promiseRejectionQueued = true;\n    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);\n};\n\nvar bindingResolved = function(thisArg, context) {\n    if (((this._bitField & 50397184) === 0)) {\n        this._resolveCallback(context.target);\n    }\n};\n\nvar bindingRejected = function(e, context) {\n    if (!context.promiseRejectionQueued) this._reject(e);\n};\n\nPromise.prototype.bind = function (thisArg) {\n    if (!calledBind) {\n        calledBind = true;\n        Promise.prototype._propagateFrom = debug.propagateFromFunction();\n        Promise.prototype._boundValue = debug.boundValueFunction();\n    }\n    var maybePromise = tryConvertToPromise(thisArg);\n    var ret = new Promise(INTERNAL);\n    ret._propagateFrom(this, 1);\n    var target = this._target();\n    ret._setBoundTo(maybePromise);\n    if (maybePromise instanceof Promise) {\n        var context = {\n            promiseRejectionQueued: false,\n            promise: ret,\n            target: target,\n            bindingPromise: maybePromise\n        };\n        target._then(INTERNAL, targetRejected, undefined, ret, context);\n        maybePromise._then(\n            bindingResolved, bindingRejected, undefined, ret, context);\n        ret._setOnCancel(maybePromise);\n    } else {\n        ret._resolveCallback(target);\n    }\n    return ret;\n};\n\nPromise.prototype._setBoundTo = function (obj) {\n    if (obj !== undefined) {\n        this._bitField = this._bitField | 2097152;\n        this._boundTo = obj;\n    } else {\n        this._bitField = this._bitField & (~2097152);\n    }\n};\n\nPromise.prototype._isBound = function () {\n    return (this._bitField & 2097152) === 2097152;\n};\n\nPromise.bind = function (thisArg, value) {\n    return Promise.resolve(value).bind(thisArg);\n};\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/bind.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/bluebird.js":
/*!******************************************************!*\
  !*** ./node_modules/bluebird/js/release/bluebird.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar old;\nif (typeof Promise !== \"undefined\") old = Promise;\nfunction noConflict() {\n    try { if (Promise === bluebird) Promise = old; }\n    catch (e) {}\n    return bluebird;\n}\nvar bluebird = __webpack_require__(/*! ./promise */ \"./node_modules/bluebird/js/release/promise.js\")();\nbluebird.noConflict = noConflict;\nmodule.exports = bluebird;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/bluebird.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/call_get.js":
/*!******************************************************!*\
  !*** ./node_modules/bluebird/js/release/call_get.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar cr = Object.create;\nif (cr) {\n    var callerCache = cr(null);\n    var getterCache = cr(null);\n    callerCache[\" size\"] = getterCache[\" size\"] = 0;\n}\n\nmodule.exports = function(Promise) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar canEvaluate = util.canEvaluate;\nvar isIdentifier = util.isIdentifier;\n\nvar getMethodCaller;\nvar getGetter;\nif (true) {\nvar makeMethodCaller = function (methodName) {\n    return new Function(\"ensureMethod\", \"                                    \\n\\\n        return function(obj) {                                               \\n\\\n            'use strict'                                                     \\n\\\n            var len = this.length;                                           \\n\\\n            ensureMethod(obj, 'methodName');                                 \\n\\\n            switch(len) {                                                    \\n\\\n                case 1: return obj.methodName(this[0]);                      \\n\\\n                case 2: return obj.methodName(this[0], this[1]);             \\n\\\n                case 3: return obj.methodName(this[0], this[1], this[2]);    \\n\\\n                case 0: return obj.methodName();                             \\n\\\n                default:                                                     \\n\\\n                    return obj.methodName.apply(obj, this);                  \\n\\\n            }                                                                \\n\\\n        };                                                                   \\n\\\n        \".replace(/methodName/g, methodName))(ensureMethod);\n};\n\nvar makeGetter = function (propertyName) {\n    return new Function(\"obj\", \"                                             \\n\\\n        'use strict';                                                        \\n\\\n        return obj.propertyName;                                             \\n\\\n        \".replace(\"propertyName\", propertyName));\n};\n\nvar getCompiled = function(name, compiler, cache) {\n    var ret = cache[name];\n    if (typeof ret !== \"function\") {\n        if (!isIdentifier(name)) {\n            return null;\n        }\n        ret = compiler(name);\n        cache[name] = ret;\n        cache[\" size\"]++;\n        if (cache[\" size\"] > 512) {\n            var keys = Object.keys(cache);\n            for (var i = 0; i < 256; ++i) delete cache[keys[i]];\n            cache[\" size\"] = keys.length - 256;\n        }\n    }\n    return ret;\n};\n\ngetMethodCaller = function(name) {\n    return getCompiled(name, makeMethodCaller, callerCache);\n};\n\ngetGetter = function(name) {\n    return getCompiled(name, makeGetter, getterCache);\n};\n}\n\nfunction ensureMethod(obj, methodName) {\n    var fn;\n    if (obj != null) fn = obj[methodName];\n    if (typeof fn !== \"function\") {\n        var message = \"Object \" + util.classString(obj) + \" has no method '\" +\n            util.toString(methodName) + \"'\";\n        throw new Promise.TypeError(message);\n    }\n    return fn;\n}\n\nfunction caller(obj) {\n    var methodName = this.pop();\n    var fn = ensureMethod(obj, methodName);\n    return fn.apply(obj, this);\n}\nPromise.prototype.call = function (methodName) {\n    var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0)); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];};\n    if (true) {\n        if (canEvaluate) {\n            var maybeCaller = getMethodCaller(methodName);\n            if (maybeCaller !== null) {\n                return this._then(\n                    maybeCaller, undefined, undefined, args, undefined);\n            }\n        }\n    }\n    args.push(methodName);\n    return this._then(caller, undefined, undefined, args, undefined);\n};\n\nfunction namedGetter(obj) {\n    return obj[this];\n}\nfunction indexedGetter(obj) {\n    var index = +this;\n    if (index < 0) index = Math.max(0, index + obj.length);\n    return obj[index];\n}\nPromise.prototype.get = function (propertyName) {\n    var isIndex = (typeof propertyName === \"number\");\n    var getter;\n    if (!isIndex) {\n        if (canEvaluate) {\n            var maybeGetter = getGetter(propertyName);\n            getter = maybeGetter !== null ? maybeGetter : namedGetter;\n        } else {\n            getter = namedGetter;\n        }\n    } else {\n        getter = indexedGetter;\n    }\n    return this._then(getter, undefined, undefined, propertyName, undefined);\n};\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/call_get.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/cancel.js":
/*!****************************************************!*\
  !*** ./node_modules/bluebird/js/release/cancel.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = function(Promise, PromiseArray, apiRejection, debug) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar async = Promise._async;\n\nPromise.prototype[\"break\"] = Promise.prototype.cancel = function() {\n    if (!debug.cancellation()) return this._warn(\"cancellation is disabled\");\n\n    var promise = this;\n    var child = promise;\n    while (promise._isCancellable()) {\n        if (!promise._cancelBy(child)) {\n            if (child._isFollowing()) {\n                child._followee().cancel();\n            } else {\n                child._cancelBranched();\n            }\n            break;\n        }\n\n        var parent = promise._cancellationParent;\n        if (parent == null || !parent._isCancellable()) {\n            if (promise._isFollowing()) {\n                promise._followee().cancel();\n            } else {\n                promise._cancelBranched();\n            }\n            break;\n        } else {\n            if (promise._isFollowing()) promise._followee().cancel();\n            promise._setWillBeCancelled();\n            child = promise;\n            promise = parent;\n        }\n    }\n};\n\nPromise.prototype._branchHasCancelled = function() {\n    this._branchesRemainingToCancel--;\n};\n\nPromise.prototype._enoughBranchesHaveCancelled = function() {\n    return this._branchesRemainingToCancel === undefined ||\n           this._branchesRemainingToCancel <= 0;\n};\n\nPromise.prototype._cancelBy = function(canceller) {\n    if (canceller === this) {\n        this._branchesRemainingToCancel = 0;\n        this._invokeOnCancel();\n        return true;\n    } else {\n        this._branchHasCancelled();\n        if (this._enoughBranchesHaveCancelled()) {\n            this._invokeOnCancel();\n            return true;\n        }\n    }\n    return false;\n};\n\nPromise.prototype._cancelBranched = function() {\n    if (this._enoughBranchesHaveCancelled()) {\n        this._cancel();\n    }\n};\n\nPromise.prototype._cancel = function() {\n    if (!this._isCancellable()) return;\n    this._setCancelled();\n    async.invoke(this._cancelPromises, this, undefined);\n};\n\nPromise.prototype._cancelPromises = function() {\n    if (this._length() > 0) this._settlePromises();\n};\n\nPromise.prototype._unsetOnCancel = function() {\n    this._onCancelField = undefined;\n};\n\nPromise.prototype._isCancellable = function() {\n    return this.isPending() && !this._isCancelled();\n};\n\nPromise.prototype.isCancellable = function() {\n    return this.isPending() && !this.isCancelled();\n};\n\nPromise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {\n    if (util.isArray(onCancelCallback)) {\n        for (var i = 0; i < onCancelCallback.length; ++i) {\n            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);\n        }\n    } else if (onCancelCallback !== undefined) {\n        if (typeof onCancelCallback === \"function\") {\n            if (!internalOnly) {\n                var e = tryCatch(onCancelCallback).call(this._boundValue());\n                if (e === errorObj) {\n                    this._attachExtraTrace(e.e);\n                    async.throwLater(e.e);\n                }\n            }\n        } else {\n            onCancelCallback._resultCancelled(this);\n        }\n    }\n};\n\nPromise.prototype._invokeOnCancel = function() {\n    var onCancelCallback = this._onCancel();\n    this._unsetOnCancel();\n    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);\n};\n\nPromise.prototype._invokeInternalOnCancel = function() {\n    if (this._isCancellable()) {\n        this._doInvokeOnCancel(this._onCancel(), true);\n        this._unsetOnCancel();\n    }\n};\n\nPromise.prototype._resultCancelled = function() {\n    this.cancel();\n};\n\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/cancel.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/catch_filter.js":
/*!**********************************************************!*\
  !*** ./node_modules/bluebird/js/release/catch_filter.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = function(NEXT_FILTER) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar getKeys = __webpack_require__(/*! ./es5 */ \"./node_modules/bluebird/js/release/es5.js\").keys;\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\n\nfunction catchFilter(instances, cb, promise) {\n    return function(e) {\n        var boundTo = promise._boundValue();\n        predicateLoop: for (var i = 0; i < instances.length; ++i) {\n            var item = instances[i];\n\n            if (item === Error ||\n                (item != null && item.prototype instanceof Error)) {\n                if (e instanceof item) {\n                    return tryCatch(cb).call(boundTo, e);\n                }\n            } else if (typeof item === \"function\") {\n                var matchesPredicate = tryCatch(item).call(boundTo, e);\n                if (matchesPredicate === errorObj) {\n                    return matchesPredicate;\n                } else if (matchesPredicate) {\n                    return tryCatch(cb).call(boundTo, e);\n                }\n            } else if (util.isObject(e)) {\n                var keys = getKeys(item);\n                for (var j = 0; j < keys.length; ++j) {\n                    var key = keys[j];\n                    if (item[key] != e[key]) {\n                        continue predicateLoop;\n                    }\n                }\n                return tryCatch(cb).call(boundTo, e);\n            }\n        }\n        return NEXT_FILTER;\n    };\n}\n\nreturn catchFilter;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/catch_filter.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/context.js":
/*!*****************************************************!*\
  !*** ./node_modules/bluebird/js/release/context.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function(Promise) {\nvar longStackTraces = false;\nvar contextStack = [];\n\nPromise.prototype._promiseCreated = function() {};\nPromise.prototype._pushContext = function() {};\nPromise.prototype._popContext = function() {return null;};\nPromise._peekContext = Promise.prototype._peekContext = function() {};\n\nfunction Context() {\n    this._trace = new Context.CapturedTrace(peekContext());\n}\nContext.prototype._pushContext = function () {\n    if (this._trace !== undefined) {\n        this._trace._promiseCreated = null;\n        contextStack.push(this._trace);\n    }\n};\n\nContext.prototype._popContext = function () {\n    if (this._trace !== undefined) {\n        var trace = contextStack.pop();\n        var ret = trace._promiseCreated;\n        trace._promiseCreated = null;\n        return ret;\n    }\n    return null;\n};\n\nfunction createContext() {\n    if (longStackTraces) return new Context();\n}\n\nfunction peekContext() {\n    var lastIndex = contextStack.length - 1;\n    if (lastIndex >= 0) {\n        return contextStack[lastIndex];\n    }\n    return undefined;\n}\nContext.CapturedTrace = null;\nContext.create = createContext;\nContext.deactivateLongStackTraces = function() {};\nContext.activateLongStackTraces = function() {\n    var Promise_pushContext = Promise.prototype._pushContext;\n    var Promise_popContext = Promise.prototype._popContext;\n    var Promise_PeekContext = Promise._peekContext;\n    var Promise_peekContext = Promise.prototype._peekContext;\n    var Promise_promiseCreated = Promise.prototype._promiseCreated;\n    Context.deactivateLongStackTraces = function() {\n        Promise.prototype._pushContext = Promise_pushContext;\n        Promise.prototype._popContext = Promise_popContext;\n        Promise._peekContext = Promise_PeekContext;\n        Promise.prototype._peekContext = Promise_peekContext;\n        Promise.prototype._promiseCreated = Promise_promiseCreated;\n        longStackTraces = false;\n    };\n    longStackTraces = true;\n    Promise.prototype._pushContext = Context.prototype._pushContext;\n    Promise.prototype._popContext = Context.prototype._popContext;\n    Promise._peekContext = Promise.prototype._peekContext = peekContext;\n    Promise.prototype._promiseCreated = function() {\n        var ctx = this._peekContext();\n        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;\n    };\n};\nreturn Context;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/context.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/debuggability.js":
/*!***********************************************************!*\
  !*** ./node_modules/bluebird/js/release/debuggability.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = function(Promise, Context) {\nvar getDomain = Promise._getDomain;\nvar async = Promise._async;\nvar Warning = __webpack_require__(/*! ./errors */ \"./node_modules/bluebird/js/release/errors.js\").Warning;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar canAttachTrace = util.canAttachTrace;\nvar unhandledRejectionHandled;\nvar possiblyUnhandledRejection;\nvar bluebirdFramePattern =\n    /[\\\\\\/]bluebird[\\\\\\/]js[\\\\\\/](release|debug|instrumented)/;\nvar nodeFramePattern = /\\((?:timers\\.js):\\d+:\\d+\\)/;\nvar parseLinePattern = /[\\/<\\(](.+?):(\\d+):(\\d+)\\)?\\s*$/;\nvar stackFramePattern = null;\nvar formatStack = null;\nvar indentStackFrames = false;\nvar printWarning;\nvar debugging = !!(util.env(\"BLUEBIRD_DEBUG\") != 0 &&\n                        ( false ||\n                         util.env(\"BLUEBIRD_DEBUG\") ||\n                         util.env(\"NODE_ENV\") === \"development\"));\n\nvar warnings = !!(util.env(\"BLUEBIRD_WARNINGS\") != 0 &&\n    (debugging || util.env(\"BLUEBIRD_WARNINGS\")));\n\nvar longStackTraces = !!(util.env(\"BLUEBIRD_LONG_STACK_TRACES\") != 0 &&\n    (debugging || util.env(\"BLUEBIRD_LONG_STACK_TRACES\")));\n\nvar wForgottenReturn = util.env(\"BLUEBIRD_W_FORGOTTEN_RETURN\") != 0 &&\n    (warnings || !!util.env(\"BLUEBIRD_W_FORGOTTEN_RETURN\"));\n\nPromise.prototype.suppressUnhandledRejections = function() {\n    var target = this._target();\n    target._bitField = ((target._bitField & (~1048576)) |\n                      524288);\n};\n\nPromise.prototype._ensurePossibleRejectionHandled = function () {\n    if ((this._bitField & 524288) !== 0) return;\n    this._setRejectionIsUnhandled();\n    async.invokeLater(this._notifyUnhandledRejection, this, undefined);\n};\n\nPromise.prototype._notifyUnhandledRejectionIsHandled = function () {\n    fireRejectionEvent(\"rejectionHandled\",\n                                  unhandledRejectionHandled, undefined, this);\n};\n\nPromise.prototype._setReturnedNonUndefined = function() {\n    this._bitField = this._bitField | 268435456;\n};\n\nPromise.prototype._returnedNonUndefined = function() {\n    return (this._bitField & 268435456) !== 0;\n};\n\nPromise.prototype._notifyUnhandledRejection = function () {\n    if (this._isRejectionUnhandled()) {\n        var reason = this._settledValue();\n        this._setUnhandledRejectionIsNotified();\n        fireRejectionEvent(\"unhandledRejection\",\n                                      possiblyUnhandledRejection, reason, this);\n    }\n};\n\nPromise.prototype._setUnhandledRejectionIsNotified = function () {\n    this._bitField = this._bitField | 262144;\n};\n\nPromise.prototype._unsetUnhandledRejectionIsNotified = function () {\n    this._bitField = this._bitField & (~262144);\n};\n\nPromise.prototype._isUnhandledRejectionNotified = function () {\n    return (this._bitField & 262144) > 0;\n};\n\nPromise.prototype._setRejectionIsUnhandled = function () {\n    this._bitField = this._bitField | 1048576;\n};\n\nPromise.prototype._unsetRejectionIsUnhandled = function () {\n    this._bitField = this._bitField & (~1048576);\n    if (this._isUnhandledRejectionNotified()) {\n        this._unsetUnhandledRejectionIsNotified();\n        this._notifyUnhandledRejectionIsHandled();\n    }\n};\n\nPromise.prototype._isRejectionUnhandled = function () {\n    return (this._bitField & 1048576) > 0;\n};\n\nPromise.prototype._warn = function(message, shouldUseOwnTrace, promise) {\n    return warn(message, shouldUseOwnTrace, promise || this);\n};\n\nPromise.onPossiblyUnhandledRejection = function (fn) {\n    var domain = getDomain();\n    possiblyUnhandledRejection =\n        typeof fn === \"function\" ? (domain === null ?\n                                            fn : util.domainBind(domain, fn))\n                                 : undefined;\n};\n\nPromise.onUnhandledRejectionHandled = function (fn) {\n    var domain = getDomain();\n    unhandledRejectionHandled =\n        typeof fn === \"function\" ? (domain === null ?\n                                            fn : util.domainBind(domain, fn))\n                                 : undefined;\n};\n\nvar disableLongStackTraces = function() {};\nPromise.longStackTraces = function () {\n    if (async.haveItemsQueued() && !config.longStackTraces) {\n        throw new Error(\"cannot enable long stack traces after promises have been created\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    if (!config.longStackTraces && longStackTracesIsSupported()) {\n        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;\n        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;\n        config.longStackTraces = true;\n        disableLongStackTraces = function() {\n            if (async.haveItemsQueued() && !config.longStackTraces) {\n                throw new Error(\"cannot enable long stack traces after promises have been created\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n            }\n            Promise.prototype._captureStackTrace = Promise_captureStackTrace;\n            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;\n            Context.deactivateLongStackTraces();\n            async.enableTrampoline();\n            config.longStackTraces = false;\n        };\n        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;\n        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;\n        Context.activateLongStackTraces();\n        async.disableTrampolineIfNecessary();\n    }\n};\n\nPromise.hasLongStackTraces = function () {\n    return config.longStackTraces && longStackTracesIsSupported();\n};\n\nvar fireDomEvent = (function() {\n    try {\n        if (typeof CustomEvent === \"function\") {\n            var event = new CustomEvent(\"CustomEvent\");\n            util.global.dispatchEvent(event);\n            return function(name, event) {\n                var domEvent = new CustomEvent(name.toLowerCase(), {\n                    detail: event,\n                    cancelable: true\n                });\n                return !util.global.dispatchEvent(domEvent);\n            };\n        } else if (typeof Event === \"function\") {\n            var event = new Event(\"CustomEvent\");\n            util.global.dispatchEvent(event);\n            return function(name, event) {\n                var domEvent = new Event(name.toLowerCase(), {\n                    cancelable: true\n                });\n                domEvent.detail = event;\n                return !util.global.dispatchEvent(domEvent);\n            };\n        } else {\n            var event = document.createEvent(\"CustomEvent\");\n            event.initCustomEvent(\"testingtheevent\", false, true, {});\n            util.global.dispatchEvent(event);\n            return function(name, event) {\n                var domEvent = document.createEvent(\"CustomEvent\");\n                domEvent.initCustomEvent(name.toLowerCase(), false, true,\n                    event);\n                return !util.global.dispatchEvent(domEvent);\n            };\n        }\n    } catch (e) {}\n    return function() {\n        return false;\n    };\n})();\n\nvar fireGlobalEvent = (function() {\n    if (util.isNode) {\n        return function() {\n            return process.emit.apply(process, arguments);\n        };\n    } else {\n        if (!util.global) {\n            return function() {\n                return false;\n            };\n        }\n        return function(name) {\n            var methodName = \"on\" + name.toLowerCase();\n            var method = util.global[methodName];\n            if (!method) return false;\n            method.apply(util.global, [].slice.call(arguments, 1));\n            return true;\n        };\n    }\n})();\n\nfunction generatePromiseLifecycleEventObject(name, promise) {\n    return {promise: promise};\n}\n\nvar eventToObjectGenerator = {\n    promiseCreated: generatePromiseLifecycleEventObject,\n    promiseFulfilled: generatePromiseLifecycleEventObject,\n    promiseRejected: generatePromiseLifecycleEventObject,\n    promiseResolved: generatePromiseLifecycleEventObject,\n    promiseCancelled: generatePromiseLifecycleEventObject,\n    promiseChained: function(name, promise, child) {\n        return {promise: promise, child: child};\n    },\n    warning: function(name, warning) {\n        return {warning: warning};\n    },\n    unhandledRejection: function (name, reason, promise) {\n        return {reason: reason, promise: promise};\n    },\n    rejectionHandled: generatePromiseLifecycleEventObject\n};\n\nvar activeFireEvent = function (name) {\n    var globalEventFired = false;\n    try {\n        globalEventFired = fireGlobalEvent.apply(null, arguments);\n    } catch (e) {\n        async.throwLater(e);\n        globalEventFired = true;\n    }\n\n    var domEventFired = false;\n    try {\n        domEventFired = fireDomEvent(name,\n                    eventToObjectGenerator[name].apply(null, arguments));\n    } catch (e) {\n        async.throwLater(e);\n        domEventFired = true;\n    }\n\n    return domEventFired || globalEventFired;\n};\n\nPromise.config = function(opts) {\n    opts = Object(opts);\n    if (\"longStackTraces\" in opts) {\n        if (opts.longStackTraces) {\n            Promise.longStackTraces();\n        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {\n            disableLongStackTraces();\n        }\n    }\n    if (\"warnings\" in opts) {\n        var warningsOption = opts.warnings;\n        config.warnings = !!warningsOption;\n        wForgottenReturn = config.warnings;\n\n        if (util.isObject(warningsOption)) {\n            if (\"wForgottenReturn\" in warningsOption) {\n                wForgottenReturn = !!warningsOption.wForgottenReturn;\n            }\n        }\n    }\n    if (\"cancellation\" in opts && opts.cancellation && !config.cancellation) {\n        if (async.haveItemsQueued()) {\n            throw new Error(\n                \"cannot enable cancellation after promises are in use\");\n        }\n        Promise.prototype._clearCancellationData =\n            cancellationClearCancellationData;\n        Promise.prototype._propagateFrom = cancellationPropagateFrom;\n        Promise.prototype._onCancel = cancellationOnCancel;\n        Promise.prototype._setOnCancel = cancellationSetOnCancel;\n        Promise.prototype._attachCancellationCallback =\n            cancellationAttachCancellationCallback;\n        Promise.prototype._execute = cancellationExecute;\n        propagateFromFunction = cancellationPropagateFrom;\n        config.cancellation = true;\n    }\n    if (\"monitoring\" in opts) {\n        if (opts.monitoring && !config.monitoring) {\n            config.monitoring = true;\n            Promise.prototype._fireEvent = activeFireEvent;\n        } else if (!opts.monitoring && config.monitoring) {\n            config.monitoring = false;\n            Promise.prototype._fireEvent = defaultFireEvent;\n        }\n    }\n    return Promise;\n};\n\nfunction defaultFireEvent() { return false; }\n\nPromise.prototype._fireEvent = defaultFireEvent;\nPromise.prototype._execute = function(executor, resolve, reject) {\n    try {\n        executor(resolve, reject);\n    } catch (e) {\n        return e;\n    }\n};\nPromise.prototype._onCancel = function () {};\nPromise.prototype._setOnCancel = function (handler) { ; };\nPromise.prototype._attachCancellationCallback = function(onCancel) {\n    ;\n};\nPromise.prototype._captureStackTrace = function () {};\nPromise.prototype._attachExtraTrace = function () {};\nPromise.prototype._clearCancellationData = function() {};\nPromise.prototype._propagateFrom = function (parent, flags) {\n    ;\n    ;\n};\n\nfunction cancellationExecute(executor, resolve, reject) {\n    var promise = this;\n    try {\n        executor(resolve, reject, function(onCancel) {\n            if (typeof onCancel !== \"function\") {\n                throw new TypeError(\"onCancel must be a function, got: \" +\n                                    util.toString(onCancel));\n            }\n            promise._attachCancellationCallback(onCancel);\n        });\n    } catch (e) {\n        return e;\n    }\n}\n\nfunction cancellationAttachCancellationCallback(onCancel) {\n    if (!this._isCancellable()) return this;\n\n    var previousOnCancel = this._onCancel();\n    if (previousOnCancel !== undefined) {\n        if (util.isArray(previousOnCancel)) {\n            previousOnCancel.push(onCancel);\n        } else {\n            this._setOnCancel([previousOnCancel, onCancel]);\n        }\n    } else {\n        this._setOnCancel(onCancel);\n    }\n}\n\nfunction cancellationOnCancel() {\n    return this._onCancelField;\n}\n\nfunction cancellationSetOnCancel(onCancel) {\n    this._onCancelField = onCancel;\n}\n\nfunction cancellationClearCancellationData() {\n    this._cancellationParent = undefined;\n    this._onCancelField = undefined;\n}\n\nfunction cancellationPropagateFrom(parent, flags) {\n    if ((flags & 1) !== 0) {\n        this._cancellationParent = parent;\n        var branchesRemainingToCancel = parent._branchesRemainingToCancel;\n        if (branchesRemainingToCancel === undefined) {\n            branchesRemainingToCancel = 0;\n        }\n        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;\n    }\n    if ((flags & 2) !== 0 && parent._isBound()) {\n        this._setBoundTo(parent._boundTo);\n    }\n}\n\nfunction bindingPropagateFrom(parent, flags) {\n    if ((flags & 2) !== 0 && parent._isBound()) {\n        this._setBoundTo(parent._boundTo);\n    }\n}\nvar propagateFromFunction = bindingPropagateFrom;\n\nfunction boundValueFunction() {\n    var ret = this._boundTo;\n    if (ret !== undefined) {\n        if (ret instanceof Promise) {\n            if (ret.isFulfilled()) {\n                return ret.value();\n            } else {\n                return undefined;\n            }\n        }\n    }\n    return ret;\n}\n\nfunction longStackTracesCaptureStackTrace() {\n    this._trace = new CapturedTrace(this._peekContext());\n}\n\nfunction longStackTracesAttachExtraTrace(error, ignoreSelf) {\n    if (canAttachTrace(error)) {\n        var trace = this._trace;\n        if (trace !== undefined) {\n            if (ignoreSelf) trace = trace._parent;\n        }\n        if (trace !== undefined) {\n            trace.attachExtraTrace(error);\n        } else if (!error.__stackCleaned__) {\n            var parsed = parseStackAndMessage(error);\n            util.notEnumerableProp(error, \"stack\",\n                parsed.message + \"\\n\" + parsed.stack.join(\"\\n\"));\n            util.notEnumerableProp(error, \"__stackCleaned__\", true);\n        }\n    }\n}\n\nfunction checkForgottenReturns(returnValue, promiseCreated, name, promise,\n                               parent) {\n    if (returnValue === undefined && promiseCreated !== null &&\n        wForgottenReturn) {\n        if (parent !== undefined && parent._returnedNonUndefined()) return;\n        if ((promise._bitField & 65535) === 0) return;\n\n        if (name) name = name + \" \";\n        var handlerLine = \"\";\n        var creatorLine = \"\";\n        if (promiseCreated._trace) {\n            var traceLines = promiseCreated._trace.stack.split(\"\\n\");\n            var stack = cleanStack(traceLines);\n            for (var i = stack.length - 1; i >= 0; --i) {\n                var line = stack[i];\n                if (!nodeFramePattern.test(line)) {\n                    var lineMatches = line.match(parseLinePattern);\n                    if (lineMatches) {\n                        handlerLine  = \"at \" + lineMatches[1] +\n                            \":\" + lineMatches[2] + \":\" + lineMatches[3] + \" \";\n                    }\n                    break;\n                }\n            }\n\n            if (stack.length > 0) {\n                var firstUserLine = stack[0];\n                for (var i = 0; i < traceLines.length; ++i) {\n\n                    if (traceLines[i] === firstUserLine) {\n                        if (i > 0) {\n                            creatorLine = \"\\n\" + traceLines[i - 1];\n                        }\n                        break;\n                    }\n                }\n\n            }\n        }\n        var msg = \"a promise was created in a \" + name +\n            \"handler \" + handlerLine + \"but was not returned from it, \" +\n            \"see http://goo.gl/rRqMUw\" +\n            creatorLine;\n        promise._warn(msg, true, promiseCreated);\n    }\n}\n\nfunction deprecated(name, replacement) {\n    var message = name +\n        \" is deprecated and will be removed in a future version.\";\n    if (replacement) message += \" Use \" + replacement + \" instead.\";\n    return warn(message);\n}\n\nfunction warn(message, shouldUseOwnTrace, promise) {\n    if (!config.warnings) return;\n    var warning = new Warning(message);\n    var ctx;\n    if (shouldUseOwnTrace) {\n        promise._attachExtraTrace(warning);\n    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {\n        ctx.attachExtraTrace(warning);\n    } else {\n        var parsed = parseStackAndMessage(warning);\n        warning.stack = parsed.message + \"\\n\" + parsed.stack.join(\"\\n\");\n    }\n\n    if (!activeFireEvent(\"warning\", warning)) {\n        formatAndLogError(warning, \"\", true);\n    }\n}\n\nfunction reconstructStack(message, stacks) {\n    for (var i = 0; i < stacks.length - 1; ++i) {\n        stacks[i].push(\"From previous event:\");\n        stacks[i] = stacks[i].join(\"\\n\");\n    }\n    if (i < stacks.length) {\n        stacks[i] = stacks[i].join(\"\\n\");\n    }\n    return message + \"\\n\" + stacks.join(\"\\n\");\n}\n\nfunction removeDuplicateOrEmptyJumps(stacks) {\n    for (var i = 0; i < stacks.length; ++i) {\n        if (stacks[i].length === 0 ||\n            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {\n            stacks.splice(i, 1);\n            i--;\n        }\n    }\n}\n\nfunction removeCommonRoots(stacks) {\n    var current = stacks[0];\n    for (var i = 1; i < stacks.length; ++i) {\n        var prev = stacks[i];\n        var currentLastIndex = current.length - 1;\n        var currentLastLine = current[currentLastIndex];\n        var commonRootMeetPoint = -1;\n\n        for (var j = prev.length - 1; j >= 0; --j) {\n            if (prev[j] === currentLastLine) {\n                commonRootMeetPoint = j;\n                break;\n            }\n        }\n\n        for (var j = commonRootMeetPoint; j >= 0; --j) {\n            var line = prev[j];\n            if (current[currentLastIndex] === line) {\n                current.pop();\n                currentLastIndex--;\n            } else {\n                break;\n            }\n        }\n        current = prev;\n    }\n}\n\nfunction cleanStack(stack) {\n    var ret = [];\n    for (var i = 0; i < stack.length; ++i) {\n        var line = stack[i];\n        var isTraceLine = \"    (No stack trace)\" === line ||\n            stackFramePattern.test(line);\n        var isInternalFrame = isTraceLine && shouldIgnore(line);\n        if (isTraceLine && !isInternalFrame) {\n            if (indentStackFrames && line.charAt(0) !== \" \") {\n                line = \"    \" + line;\n            }\n            ret.push(line);\n        }\n    }\n    return ret;\n}\n\nfunction stackFramesAsArray(error) {\n    var stack = error.stack.replace(/\\s+$/g, \"\").split(\"\\n\");\n    for (var i = 0; i < stack.length; ++i) {\n        var line = stack[i];\n        if (\"    (No stack trace)\" === line || stackFramePattern.test(line)) {\n            break;\n        }\n    }\n    if (i > 0 && error.name != \"SyntaxError\") {\n        stack = stack.slice(i);\n    }\n    return stack;\n}\n\nfunction parseStackAndMessage(error) {\n    var stack = error.stack;\n    var message = error.toString();\n    stack = typeof stack === \"string\" && stack.length > 0\n                ? stackFramesAsArray(error) : [\"    (No stack trace)\"];\n    return {\n        message: message,\n        stack: error.name == \"SyntaxError\" ? stack : cleanStack(stack)\n    };\n}\n\nfunction formatAndLogError(error, title, isSoft) {\n    if (typeof console !== \"undefined\") {\n        var message;\n        if (util.isObject(error)) {\n            var stack = error.stack;\n            message = title + formatStack(stack, error);\n        } else {\n            message = title + String(error);\n        }\n        if (typeof printWarning === \"function\") {\n            printWarning(message, isSoft);\n        } else if (typeof console.log === \"function\" ||\n            typeof console.log === \"object\") {\n            console.log(message);\n        }\n    }\n}\n\nfunction fireRejectionEvent(name, localHandler, reason, promise) {\n    var localEventFired = false;\n    try {\n        if (typeof localHandler === \"function\") {\n            localEventFired = true;\n            if (name === \"rejectionHandled\") {\n                localHandler(promise);\n            } else {\n                localHandler(reason, promise);\n            }\n        }\n    } catch (e) {\n        async.throwLater(e);\n    }\n\n    if (name === \"unhandledRejection\") {\n        if (!activeFireEvent(name, reason, promise) && !localEventFired) {\n            formatAndLogError(reason, \"Unhandled rejection \");\n        }\n    } else {\n        activeFireEvent(name, promise);\n    }\n}\n\nfunction formatNonError(obj) {\n    var str;\n    if (typeof obj === \"function\") {\n        str = \"[function \" +\n            (obj.name || \"anonymous\") +\n            \"]\";\n    } else {\n        str = obj && typeof obj.toString === \"function\"\n            ? obj.toString() : util.toString(obj);\n        var ruselessToString = /\\[object [a-zA-Z0-9$_]+\\]/;\n        if (ruselessToString.test(str)) {\n            try {\n                var newStr = JSON.stringify(obj);\n                str = newStr;\n            }\n            catch(e) {\n\n            }\n        }\n        if (str.length === 0) {\n            str = \"(empty array)\";\n        }\n    }\n    return (\"(<\" + snip(str) + \">, no stack trace)\");\n}\n\nfunction snip(str) {\n    var maxChars = 41;\n    if (str.length < maxChars) {\n        return str;\n    }\n    return str.substr(0, maxChars - 3) + \"...\";\n}\n\nfunction longStackTracesIsSupported() {\n    return typeof captureStackTrace === \"function\";\n}\n\nvar shouldIgnore = function() { return false; };\nvar parseLineInfoRegex = /[\\/<\\(]([^:\\/]+):(\\d+):(?:\\d+)\\)?\\s*$/;\nfunction parseLineInfo(line) {\n    var matches = line.match(parseLineInfoRegex);\n    if (matches) {\n        return {\n            fileName: matches[1],\n            line: parseInt(matches[2], 10)\n        };\n    }\n}\n\nfunction setBounds(firstLineError, lastLineError) {\n    if (!longStackTracesIsSupported()) return;\n    var firstStackLines = firstLineError.stack.split(\"\\n\");\n    var lastStackLines = lastLineError.stack.split(\"\\n\");\n    var firstIndex = -1;\n    var lastIndex = -1;\n    var firstFileName;\n    var lastFileName;\n    for (var i = 0; i < firstStackLines.length; ++i) {\n        var result = parseLineInfo(firstStackLines[i]);\n        if (result) {\n            firstFileName = result.fileName;\n            firstIndex = result.line;\n            break;\n        }\n    }\n    for (var i = 0; i < lastStackLines.length; ++i) {\n        var result = parseLineInfo(lastStackLines[i]);\n        if (result) {\n            lastFileName = result.fileName;\n            lastIndex = result.line;\n            break;\n        }\n    }\n    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||\n        firstFileName !== lastFileName || firstIndex >= lastIndex) {\n        return;\n    }\n\n    shouldIgnore = function(line) {\n        if (bluebirdFramePattern.test(line)) return true;\n        var info = parseLineInfo(line);\n        if (info) {\n            if (info.fileName === firstFileName &&\n                (firstIndex <= info.line && info.line <= lastIndex)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n\nfunction CapturedTrace(parent) {\n    this._parent = parent;\n    this._promisesCreated = 0;\n    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);\n    captureStackTrace(this, CapturedTrace);\n    if (length > 32) this.uncycle();\n}\nutil.inherits(CapturedTrace, Error);\nContext.CapturedTrace = CapturedTrace;\n\nCapturedTrace.prototype.uncycle = function() {\n    var length = this._length;\n    if (length < 2) return;\n    var nodes = [];\n    var stackToIndex = {};\n\n    for (var i = 0, node = this; node !== undefined; ++i) {\n        nodes.push(node);\n        node = node._parent;\n    }\n    length = this._length = i;\n    for (var i = length - 1; i >= 0; --i) {\n        var stack = nodes[i].stack;\n        if (stackToIndex[stack] === undefined) {\n            stackToIndex[stack] = i;\n        }\n    }\n    for (var i = 0; i < length; ++i) {\n        var currentStack = nodes[i].stack;\n        var index = stackToIndex[currentStack];\n        if (index !== undefined && index !== i) {\n            if (index > 0) {\n                nodes[index - 1]._parent = undefined;\n                nodes[index - 1]._length = 1;\n            }\n            nodes[i]._parent = undefined;\n            nodes[i]._length = 1;\n            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;\n\n            if (index < length - 1) {\n                cycleEdgeNode._parent = nodes[index + 1];\n                cycleEdgeNode._parent.uncycle();\n                cycleEdgeNode._length =\n                    cycleEdgeNode._parent._length + 1;\n            } else {\n                cycleEdgeNode._parent = undefined;\n                cycleEdgeNode._length = 1;\n            }\n            var currentChildLength = cycleEdgeNode._length + 1;\n            for (var j = i - 2; j >= 0; --j) {\n                nodes[j]._length = currentChildLength;\n                currentChildLength++;\n            }\n            return;\n        }\n    }\n};\n\nCapturedTrace.prototype.attachExtraTrace = function(error) {\n    if (error.__stackCleaned__) return;\n    this.uncycle();\n    var parsed = parseStackAndMessage(error);\n    var message = parsed.message;\n    var stacks = [parsed.stack];\n\n    var trace = this;\n    while (trace !== undefined) {\n        stacks.push(cleanStack(trace.stack.split(\"\\n\")));\n        trace = trace._parent;\n    }\n    removeCommonRoots(stacks);\n    removeDuplicateOrEmptyJumps(stacks);\n    util.notEnumerableProp(error, \"stack\", reconstructStack(message, stacks));\n    util.notEnumerableProp(error, \"__stackCleaned__\", true);\n};\n\nvar captureStackTrace = (function stackDetection() {\n    var v8stackFramePattern = /^\\s*at\\s*/;\n    var v8stackFormatter = function(stack, error) {\n        if (typeof stack === \"string\") return stack;\n\n        if (error.name !== undefined &&\n            error.message !== undefined) {\n            return error.toString();\n        }\n        return formatNonError(error);\n    };\n\n    if (typeof Error.stackTraceLimit === \"number\" &&\n        typeof Error.captureStackTrace === \"function\") {\n        Error.stackTraceLimit += 6;\n        stackFramePattern = v8stackFramePattern;\n        formatStack = v8stackFormatter;\n        var captureStackTrace = Error.captureStackTrace;\n\n        shouldIgnore = function(line) {\n            return bluebirdFramePattern.test(line);\n        };\n        return function(receiver, ignoreUntil) {\n            Error.stackTraceLimit += 6;\n            captureStackTrace(receiver, ignoreUntil);\n            Error.stackTraceLimit -= 6;\n        };\n    }\n    var err = new Error();\n\n    if (typeof err.stack === \"string\" &&\n        err.stack.split(\"\\n\")[0].indexOf(\"stackDetection@\") >= 0) {\n        stackFramePattern = /@/;\n        formatStack = v8stackFormatter;\n        indentStackFrames = true;\n        return function captureStackTrace(o) {\n            o.stack = new Error().stack;\n        };\n    }\n\n    var hasStackAfterThrow;\n    try { throw new Error(); }\n    catch(e) {\n        hasStackAfterThrow = (\"stack\" in e);\n    }\n    if (!(\"stack\" in err) && hasStackAfterThrow &&\n        typeof Error.stackTraceLimit === \"number\") {\n        stackFramePattern = v8stackFramePattern;\n        formatStack = v8stackFormatter;\n        return function captureStackTrace(o) {\n            Error.stackTraceLimit += 6;\n            try { throw new Error(); }\n            catch(e) { o.stack = e.stack; }\n            Error.stackTraceLimit -= 6;\n        };\n    }\n\n    formatStack = function(stack, error) {\n        if (typeof stack === \"string\") return stack;\n\n        if ((typeof error === \"object\" ||\n            typeof error === \"function\") &&\n            error.name !== undefined &&\n            error.message !== undefined) {\n            return error.toString();\n        }\n        return formatNonError(error);\n    };\n\n    return null;\n\n})([]);\n\nif (typeof console !== \"undefined\" && typeof console.warn !== \"undefined\") {\n    printWarning = function (message) {\n        console.warn(message);\n    };\n    if (util.isNode && process.stderr.isTTY) {\n        printWarning = function(message, isSoft) {\n            var color = isSoft ? \"\\u001b[33m\" : \"\\u001b[31m\";\n            console.warn(color + message + \"\\u001b[0m\\n\");\n        };\n    } else if (!util.isNode && typeof (new Error().stack) === \"string\") {\n        printWarning = function(message, isSoft) {\n            console.warn(\"%c\" + message,\n                        isSoft ? \"color: darkorange\" : \"color: red\");\n        };\n    }\n}\n\nvar config = {\n    warnings: warnings,\n    longStackTraces: false,\n    cancellation: false,\n    monitoring: false\n};\n\nif (longStackTraces) Promise.longStackTraces();\n\nreturn {\n    longStackTraces: function() {\n        return config.longStackTraces;\n    },\n    warnings: function() {\n        return config.warnings;\n    },\n    cancellation: function() {\n        return config.cancellation;\n    },\n    monitoring: function() {\n        return config.monitoring;\n    },\n    propagateFromFunction: function() {\n        return propagateFromFunction;\n    },\n    boundValueFunction: function() {\n        return boundValueFunction;\n    },\n    checkForgottenReturns: checkForgottenReturns,\n    setBounds: setBounds,\n    warn: warn,\n    deprecated: deprecated,\n    CapturedTrace: CapturedTrace,\n    fireDomEvent: fireDomEvent,\n    fireGlobalEvent: fireGlobalEvent\n};\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/debuggability.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/direct_resolve.js":
/*!************************************************************!*\
  !*** ./node_modules/bluebird/js/release/direct_resolve.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function(Promise) {\nfunction returner() {\n    return this.value;\n}\nfunction thrower() {\n    throw this.reason;\n}\n\nPromise.prototype[\"return\"] =\nPromise.prototype.thenReturn = function (value) {\n    if (value instanceof Promise) value.suppressUnhandledRejections();\n    return this._then(\n        returner, undefined, undefined, {value: value}, undefined);\n};\n\nPromise.prototype[\"throw\"] =\nPromise.prototype.thenThrow = function (reason) {\n    return this._then(\n        thrower, undefined, undefined, {reason: reason}, undefined);\n};\n\nPromise.prototype.catchThrow = function (reason) {\n    if (arguments.length <= 1) {\n        return this._then(\n            undefined, thrower, undefined, {reason: reason}, undefined);\n    } else {\n        var _reason = arguments[1];\n        var handler = function() {throw _reason;};\n        return this.caught(reason, handler);\n    }\n};\n\nPromise.prototype.catchReturn = function (value) {\n    if (arguments.length <= 1) {\n        if (value instanceof Promise) value.suppressUnhandledRejections();\n        return this._then(\n            undefined, returner, undefined, {value: value}, undefined);\n    } else {\n        var _value = arguments[1];\n        if (_value instanceof Promise) _value.suppressUnhandledRejections();\n        var handler = function() {return _value;};\n        return this.caught(value, handler);\n    }\n};\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/direct_resolve.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/each.js":
/*!**************************************************!*\
  !*** ./node_modules/bluebird/js/release/each.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar PromiseReduce = Promise.reduce;\nvar PromiseAll = Promise.all;\n\nfunction promiseAllThis() {\n    return PromiseAll(this);\n}\n\nfunction PromiseMapSeries(promises, fn) {\n    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);\n}\n\nPromise.prototype.each = function (fn) {\n    return PromiseReduce(this, fn, INTERNAL, 0)\n              ._then(promiseAllThis, undefined, undefined, this, undefined);\n};\n\nPromise.prototype.mapSeries = function (fn) {\n    return PromiseReduce(this, fn, INTERNAL, INTERNAL);\n};\n\nPromise.each = function (promises, fn) {\n    return PromiseReduce(promises, fn, INTERNAL, 0)\n              ._then(promiseAllThis, undefined, undefined, promises, undefined);\n};\n\nPromise.mapSeries = PromiseMapSeries;\n};\n\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/each.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/errors.js":
/*!****************************************************!*\
  !*** ./node_modules/bluebird/js/release/errors.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar es5 = __webpack_require__(/*! ./es5 */ \"./node_modules/bluebird/js/release/es5.js\");\nvar Objectfreeze = es5.freeze;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar inherits = util.inherits;\nvar notEnumerableProp = util.notEnumerableProp;\n\nfunction subError(nameProperty, defaultMessage) {\n    function SubError(message) {\n        if (!(this instanceof SubError)) return new SubError(message);\n        notEnumerableProp(this, \"message\",\n            typeof message === \"string\" ? message : defaultMessage);\n        notEnumerableProp(this, \"name\", nameProperty);\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            Error.call(this);\n        }\n    }\n    inherits(SubError, Error);\n    return SubError;\n}\n\nvar _TypeError, _RangeError;\nvar Warning = subError(\"Warning\", \"warning\");\nvar CancellationError = subError(\"CancellationError\", \"cancellation error\");\nvar TimeoutError = subError(\"TimeoutError\", \"timeout error\");\nvar AggregateError = subError(\"AggregateError\", \"aggregate error\");\ntry {\n    _TypeError = TypeError;\n    _RangeError = RangeError;\n} catch(e) {\n    _TypeError = subError(\"TypeError\", \"type error\");\n    _RangeError = subError(\"RangeError\", \"range error\");\n}\n\nvar methods = (\"join pop push shift unshift slice filter forEach some \" +\n    \"every map indexOf lastIndexOf reduce reduceRight sort reverse\").split(\" \");\n\nfor (var i = 0; i < methods.length; ++i) {\n    if (typeof Array.prototype[methods[i]] === \"function\") {\n        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];\n    }\n}\n\nes5.defineProperty(AggregateError.prototype, \"length\", {\n    value: 0,\n    configurable: false,\n    writable: true,\n    enumerable: true\n});\nAggregateError.prototype[\"isOperational\"] = true;\nvar level = 0;\nAggregateError.prototype.toString = function() {\n    var indent = Array(level * 4 + 1).join(\" \");\n    var ret = \"\\n\" + indent + \"AggregateError of:\" + \"\\n\";\n    level++;\n    indent = Array(level * 4 + 1).join(\" \");\n    for (var i = 0; i < this.length; ++i) {\n        var str = this[i] === this ? \"[Circular AggregateError]\" : this[i] + \"\";\n        var lines = str.split(\"\\n\");\n        for (var j = 0; j < lines.length; ++j) {\n            lines[j] = indent + lines[j];\n        }\n        str = lines.join(\"\\n\");\n        ret += str + \"\\n\";\n    }\n    level--;\n    return ret;\n};\n\nfunction OperationalError(message) {\n    if (!(this instanceof OperationalError))\n        return new OperationalError(message);\n    notEnumerableProp(this, \"name\", \"OperationalError\");\n    notEnumerableProp(this, \"message\", message);\n    this.cause = message;\n    this[\"isOperational\"] = true;\n\n    if (message instanceof Error) {\n        notEnumerableProp(this, \"message\", message.message);\n        notEnumerableProp(this, \"stack\", message.stack);\n    } else if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, this.constructor);\n    }\n\n}\ninherits(OperationalError, Error);\n\nvar errorTypes = Error[\"__BluebirdErrorTypes__\"];\nif (!errorTypes) {\n    errorTypes = Objectfreeze({\n        CancellationError: CancellationError,\n        TimeoutError: TimeoutError,\n        OperationalError: OperationalError,\n        RejectionError: OperationalError,\n        AggregateError: AggregateError\n    });\n    es5.defineProperty(Error, \"__BluebirdErrorTypes__\", {\n        value: errorTypes,\n        writable: false,\n        enumerable: false,\n        configurable: false\n    });\n}\n\nmodule.exports = {\n    Error: Error,\n    TypeError: _TypeError,\n    RangeError: _RangeError,\n    CancellationError: errorTypes.CancellationError,\n    OperationalError: errorTypes.OperationalError,\n    TimeoutError: errorTypes.TimeoutError,\n    AggregateError: errorTypes.AggregateError,\n    Warning: Warning\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/errors.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/es5.js":
/*!*************************************************!*\
  !*** ./node_modules/bluebird/js/release/es5.js ***!
  \*************************************************/
/***/ ((module) => {

eval("var isES5 = (function(){\n    \"use strict\";\n    return this === undefined;\n})();\n\nif (isES5) {\n    module.exports = {\n        freeze: Object.freeze,\n        defineProperty: Object.defineProperty,\n        getDescriptor: Object.getOwnPropertyDescriptor,\n        keys: Object.keys,\n        names: Object.getOwnPropertyNames,\n        getPrototypeOf: Object.getPrototypeOf,\n        isArray: Array.isArray,\n        isES5: isES5,\n        propertyIsWritable: function(obj, prop) {\n            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n            return !!(!descriptor || descriptor.writable || descriptor.set);\n        }\n    };\n} else {\n    var has = {}.hasOwnProperty;\n    var str = {}.toString;\n    var proto = {}.constructor.prototype;\n\n    var ObjectKeys = function (o) {\n        var ret = [];\n        for (var key in o) {\n            if (has.call(o, key)) {\n                ret.push(key);\n            }\n        }\n        return ret;\n    };\n\n    var ObjectGetDescriptor = function(o, key) {\n        return {value: o[key]};\n    };\n\n    var ObjectDefineProperty = function (o, key, desc) {\n        o[key] = desc.value;\n        return o;\n    };\n\n    var ObjectFreeze = function (obj) {\n        return obj;\n    };\n\n    var ObjectGetPrototypeOf = function (obj) {\n        try {\n            return Object(obj).constructor.prototype;\n        }\n        catch (e) {\n            return proto;\n        }\n    };\n\n    var ArrayIsArray = function (obj) {\n        try {\n            return str.call(obj) === \"[object Array]\";\n        }\n        catch(e) {\n            return false;\n        }\n    };\n\n    module.exports = {\n        isArray: ArrayIsArray,\n        keys: ObjectKeys,\n        names: ObjectKeys,\n        defineProperty: ObjectDefineProperty,\n        getDescriptor: ObjectGetDescriptor,\n        freeze: ObjectFreeze,\n        getPrototypeOf: ObjectGetPrototypeOf,\n        isES5: isES5,\n        propertyIsWritable: function() {\n            return true;\n        }\n    };\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/es5.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/filter.js":
/*!****************************************************!*\
  !*** ./node_modules/bluebird/js/release/filter.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar PromiseMap = Promise.map;\n\nPromise.prototype.filter = function (fn, options) {\n    return PromiseMap(this, fn, options, INTERNAL);\n};\n\nPromise.filter = function (promises, fn, options) {\n    return PromiseMap(promises, fn, options, INTERNAL);\n};\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/filter.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/finally.js":
/*!*****************************************************!*\
  !*** ./node_modules/bluebird/js/release/finally.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = function(Promise, tryConvertToPromise) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar CancellationError = Promise.CancellationError;\nvar errorObj = util.errorObj;\n\nfunction PassThroughHandlerContext(promise, type, handler) {\n    this.promise = promise;\n    this.type = type;\n    this.handler = handler;\n    this.called = false;\n    this.cancelPromise = null;\n}\n\nPassThroughHandlerContext.prototype.isFinallyHandler = function() {\n    return this.type === 0;\n};\n\nfunction FinallyHandlerCancelReaction(finallyHandler) {\n    this.finallyHandler = finallyHandler;\n}\n\nFinallyHandlerCancelReaction.prototype._resultCancelled = function() {\n    checkCancel(this.finallyHandler);\n};\n\nfunction checkCancel(ctx, reason) {\n    if (ctx.cancelPromise != null) {\n        if (arguments.length > 1) {\n            ctx.cancelPromise._reject(reason);\n        } else {\n            ctx.cancelPromise._cancel();\n        }\n        ctx.cancelPromise = null;\n        return true;\n    }\n    return false;\n}\n\nfunction succeed() {\n    return finallyHandler.call(this, this.promise._target()._settledValue());\n}\nfunction fail(reason) {\n    if (checkCancel(this, reason)) return;\n    errorObj.e = reason;\n    return errorObj;\n}\nfunction finallyHandler(reasonOrValue) {\n    var promise = this.promise;\n    var handler = this.handler;\n\n    if (!this.called) {\n        this.called = true;\n        var ret = this.isFinallyHandler()\n            ? handler.call(promise._boundValue())\n            : handler.call(promise._boundValue(), reasonOrValue);\n        if (ret !== undefined) {\n            promise._setReturnedNonUndefined();\n            var maybePromise = tryConvertToPromise(ret, promise);\n            if (maybePromise instanceof Promise) {\n                if (this.cancelPromise != null) {\n                    if (maybePromise._isCancelled()) {\n                        var reason =\n                            new CancellationError(\"late cancellation observer\");\n                        promise._attachExtraTrace(reason);\n                        errorObj.e = reason;\n                        return errorObj;\n                    } else if (maybePromise.isPending()) {\n                        maybePromise._attachCancellationCallback(\n                            new FinallyHandlerCancelReaction(this));\n                    }\n                }\n                return maybePromise._then(\n                    succeed, fail, undefined, this, undefined);\n            }\n        }\n    }\n\n    if (promise.isRejected()) {\n        checkCancel(this);\n        errorObj.e = reasonOrValue;\n        return errorObj;\n    } else {\n        checkCancel(this);\n        return reasonOrValue;\n    }\n}\n\nPromise.prototype._passThrough = function(handler, type, success, fail) {\n    if (typeof handler !== \"function\") return this.then();\n    return this._then(success,\n                      fail,\n                      undefined,\n                      new PassThroughHandlerContext(this, type, handler),\n                      undefined);\n};\n\nPromise.prototype.lastly =\nPromise.prototype[\"finally\"] = function (handler) {\n    return this._passThrough(handler,\n                             0,\n                             finallyHandler,\n                             finallyHandler);\n};\n\nPromise.prototype.tap = function (handler) {\n    return this._passThrough(handler, 1, finallyHandler);\n};\n\nreturn PassThroughHandlerContext;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/finally.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/generators.js":
/*!********************************************************!*\
  !*** ./node_modules/bluebird/js/release/generators.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = function(Promise,\n                          apiRejection,\n                          INTERNAL,\n                          tryConvertToPromise,\n                          Proxyable,\n                          debug) {\nvar errors = __webpack_require__(/*! ./errors */ \"./node_modules/bluebird/js/release/errors.js\");\nvar TypeError = errors.TypeError;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar errorObj = util.errorObj;\nvar tryCatch = util.tryCatch;\nvar yieldHandlers = [];\n\nfunction promiseFromYieldHandler(value, yieldHandlers, traceParent) {\n    for (var i = 0; i < yieldHandlers.length; ++i) {\n        traceParent._pushContext();\n        var result = tryCatch(yieldHandlers[i])(value);\n        traceParent._popContext();\n        if (result === errorObj) {\n            traceParent._pushContext();\n            var ret = Promise.reject(errorObj.e);\n            traceParent._popContext();\n            return ret;\n        }\n        var maybePromise = tryConvertToPromise(result, traceParent);\n        if (maybePromise instanceof Promise) return maybePromise;\n    }\n    return null;\n}\n\nfunction PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {\n    if (debug.cancellation()) {\n        var internal = new Promise(INTERNAL);\n        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);\n        this._promise = internal.lastly(function() {\n            return _finallyPromise;\n        });\n        internal._captureStackTrace();\n        internal._setOnCancel(this);\n    } else {\n        var promise = this._promise = new Promise(INTERNAL);\n        promise._captureStackTrace();\n    }\n    this._stack = stack;\n    this._generatorFunction = generatorFunction;\n    this._receiver = receiver;\n    this._generator = undefined;\n    this._yieldHandlers = typeof yieldHandler === \"function\"\n        ? [yieldHandler].concat(yieldHandlers)\n        : yieldHandlers;\n    this._yieldedPromise = null;\n    this._cancellationPhase = false;\n}\nutil.inherits(PromiseSpawn, Proxyable);\n\nPromiseSpawn.prototype._isResolved = function() {\n    return this._promise === null;\n};\n\nPromiseSpawn.prototype._cleanup = function() {\n    this._promise = this._generator = null;\n    if (debug.cancellation() && this._finallyPromise !== null) {\n        this._finallyPromise._fulfill();\n        this._finallyPromise = null;\n    }\n};\n\nPromiseSpawn.prototype._promiseCancelled = function() {\n    if (this._isResolved()) return;\n    var implementsReturn = typeof this._generator[\"return\"] !== \"undefined\";\n\n    var result;\n    if (!implementsReturn) {\n        var reason = new Promise.CancellationError(\n            \"generator .return() sentinel\");\n        Promise.coroutine.returnSentinel = reason;\n        this._promise._attachExtraTrace(reason);\n        this._promise._pushContext();\n        result = tryCatch(this._generator[\"throw\"]).call(this._generator,\n                                                         reason);\n        this._promise._popContext();\n    } else {\n        this._promise._pushContext();\n        result = tryCatch(this._generator[\"return\"]).call(this._generator,\n                                                          undefined);\n        this._promise._popContext();\n    }\n    this._cancellationPhase = true;\n    this._yieldedPromise = null;\n    this._continue(result);\n};\n\nPromiseSpawn.prototype._promiseFulfilled = function(value) {\n    this._yieldedPromise = null;\n    this._promise._pushContext();\n    var result = tryCatch(this._generator.next).call(this._generator, value);\n    this._promise._popContext();\n    this._continue(result);\n};\n\nPromiseSpawn.prototype._promiseRejected = function(reason) {\n    this._yieldedPromise = null;\n    this._promise._attachExtraTrace(reason);\n    this._promise._pushContext();\n    var result = tryCatch(this._generator[\"throw\"])\n        .call(this._generator, reason);\n    this._promise._popContext();\n    this._continue(result);\n};\n\nPromiseSpawn.prototype._resultCancelled = function() {\n    if (this._yieldedPromise instanceof Promise) {\n        var promise = this._yieldedPromise;\n        this._yieldedPromise = null;\n        promise.cancel();\n    }\n};\n\nPromiseSpawn.prototype.promise = function () {\n    return this._promise;\n};\n\nPromiseSpawn.prototype._run = function () {\n    this._generator = this._generatorFunction.call(this._receiver);\n    this._receiver =\n        this._generatorFunction = undefined;\n    this._promiseFulfilled(undefined);\n};\n\nPromiseSpawn.prototype._continue = function (result) {\n    var promise = this._promise;\n    if (result === errorObj) {\n        this._cleanup();\n        if (this._cancellationPhase) {\n            return promise.cancel();\n        } else {\n            return promise._rejectCallback(result.e, false);\n        }\n    }\n\n    var value = result.value;\n    if (result.done === true) {\n        this._cleanup();\n        if (this._cancellationPhase) {\n            return promise.cancel();\n        } else {\n            return promise._resolveCallback(value);\n        }\n    } else {\n        var maybePromise = tryConvertToPromise(value, this._promise);\n        if (!(maybePromise instanceof Promise)) {\n            maybePromise =\n                promiseFromYieldHandler(maybePromise,\n                                        this._yieldHandlers,\n                                        this._promise);\n            if (maybePromise === null) {\n                this._promiseRejected(\n                    new TypeError(\n                        \"A value %s was yielded that could not be treated as a promise\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\\u000a\".replace(\"%s\", value) +\n                        \"From coroutine:\\u000a\" +\n                        this._stack.split(\"\\n\").slice(1, -7).join(\"\\n\")\n                    )\n                );\n                return;\n            }\n        }\n        maybePromise = maybePromise._target();\n        var bitField = maybePromise._bitField;\n        ;\n        if (((bitField & 50397184) === 0)) {\n            this._yieldedPromise = maybePromise;\n            maybePromise._proxy(this, null);\n        } else if (((bitField & 33554432) !== 0)) {\n            Promise._async.invoke(\n                this._promiseFulfilled, this, maybePromise._value()\n            );\n        } else if (((bitField & 16777216) !== 0)) {\n            Promise._async.invoke(\n                this._promiseRejected, this, maybePromise._reason()\n            );\n        } else {\n            this._promiseCancelled();\n        }\n    }\n};\n\nPromise.coroutine = function (generatorFunction, options) {\n    if (typeof generatorFunction !== \"function\") {\n        throw new TypeError(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    var yieldHandler = Object(options).yieldHandler;\n    var PromiseSpawn$ = PromiseSpawn;\n    var stack = new Error().stack;\n    return function () {\n        var generator = generatorFunction.apply(this, arguments);\n        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,\n                                      stack);\n        var ret = spawn.promise();\n        spawn._generator = generator;\n        spawn._promiseFulfilled(undefined);\n        return ret;\n    };\n};\n\nPromise.coroutine.addYieldHandler = function(fn) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    yieldHandlers.push(fn);\n};\n\nPromise.spawn = function (generatorFunction) {\n    debug.deprecated(\"Promise.spawn()\", \"Promise.coroutine()\");\n    if (typeof generatorFunction !== \"function\") {\n        return apiRejection(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    var spawn = new PromiseSpawn(generatorFunction, this);\n    var ret = spawn.promise();\n    spawn._run(Promise.spawn);\n    return ret;\n};\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/generators.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/join.js":
/*!**************************************************!*\
  !*** ./node_modules/bluebird/js/release/join.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports =\nfunction(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async,\n         getDomain) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar canEvaluate = util.canEvaluate;\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar reject;\n\nif (true) {\nif (canEvaluate) {\n    var thenCallback = function(i) {\n        return new Function(\"value\", \"holder\", \"                             \\n\\\n            'use strict';                                                    \\n\\\n            holder.pIndex = value;                                           \\n\\\n            holder.checkFulfillment(this);                                   \\n\\\n            \".replace(/Index/g, i));\n    };\n\n    var promiseSetter = function(i) {\n        return new Function(\"promise\", \"holder\", \"                           \\n\\\n            'use strict';                                                    \\n\\\n            holder.pIndex = promise;                                         \\n\\\n            \".replace(/Index/g, i));\n    };\n\n    var generateHolderClass = function(total) {\n        var props = new Array(total);\n        for (var i = 0; i < props.length; ++i) {\n            props[i] = \"this.p\" + (i+1);\n        }\n        var assignment = props.join(\" = \") + \" = null;\";\n        var cancellationCode= \"var promise;\\n\" + props.map(function(prop) {\n            return \"                                                         \\n\\\n                promise = \" + prop + \";                                      \\n\\\n                if (promise instanceof Promise) {                            \\n\\\n                    promise.cancel();                                        \\n\\\n                }                                                            \\n\\\n            \";\n        }).join(\"\\n\");\n        var passedArguments = props.join(\", \");\n        var name = \"Holder$\" + total;\n\n\n        var code = \"return function(tryCatch, errorObj, Promise, async) {    \\n\\\n            'use strict';                                                    \\n\\\n            function [TheName](fn) {                                         \\n\\\n                [TheProperties]                                              \\n\\\n                this.fn = fn;                                                \\n\\\n                this.asyncNeeded = true;                                     \\n\\\n                this.now = 0;                                                \\n\\\n            }                                                                \\n\\\n                                                                             \\n\\\n            [TheName].prototype._callFunction = function(promise) {          \\n\\\n                promise._pushContext();                                      \\n\\\n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \\n\\\n                promise._popContext();                                       \\n\\\n                if (ret === errorObj) {                                      \\n\\\n                    promise._rejectCallback(ret.e, false);                   \\n\\\n                } else {                                                     \\n\\\n                    promise._resolveCallback(ret);                           \\n\\\n                }                                                            \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            [TheName].prototype.checkFulfillment = function(promise) {       \\n\\\n                var now = ++this.now;                                        \\n\\\n                if (now === [TheTotal]) {                                    \\n\\\n                    if (this.asyncNeeded) {                                  \\n\\\n                        async.invoke(this._callFunction, this, promise);     \\n\\\n                    } else {                                                 \\n\\\n                        this._callFunction(promise);                         \\n\\\n                    }                                                        \\n\\\n                                                                             \\n\\\n                }                                                            \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            [TheName].prototype._resultCancelled = function() {              \\n\\\n                [CancellationCode]                                           \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            return [TheName];                                                \\n\\\n        }(tryCatch, errorObj, Promise, async);                               \\n\\\n        \";\n\n        code = code.replace(/\\[TheName\\]/g, name)\n            .replace(/\\[TheTotal\\]/g, total)\n            .replace(/\\[ThePassedArguments\\]/g, passedArguments)\n            .replace(/\\[TheProperties\\]/g, assignment)\n            .replace(/\\[CancellationCode\\]/g, cancellationCode);\n\n        return new Function(\"tryCatch\", \"errorObj\", \"Promise\", \"async\", code)\n                           (tryCatch, errorObj, Promise, async);\n    };\n\n    var holderClasses = [];\n    var thenCallbacks = [];\n    var promiseSetters = [];\n\n    for (var i = 0; i < 8; ++i) {\n        holderClasses.push(generateHolderClass(i + 1));\n        thenCallbacks.push(thenCallback(i + 1));\n        promiseSetters.push(promiseSetter(i + 1));\n    }\n\n    reject = function (reason) {\n        this._reject(reason);\n    };\n}}\n\nPromise.join = function () {\n    var last = arguments.length - 1;\n    var fn;\n    if (last > 0 && typeof arguments[last] === \"function\") {\n        fn = arguments[last];\n        if (true) {\n            if (last <= 8 && canEvaluate) {\n                var ret = new Promise(INTERNAL);\n                ret._captureStackTrace();\n                var HolderClass = holderClasses[last - 1];\n                var holder = new HolderClass(fn);\n                var callbacks = thenCallbacks;\n\n                for (var i = 0; i < last; ++i) {\n                    var maybePromise = tryConvertToPromise(arguments[i], ret);\n                    if (maybePromise instanceof Promise) {\n                        maybePromise = maybePromise._target();\n                        var bitField = maybePromise._bitField;\n                        ;\n                        if (((bitField & 50397184) === 0)) {\n                            maybePromise._then(callbacks[i], reject,\n                                               undefined, ret, holder);\n                            promiseSetters[i](maybePromise, holder);\n                            holder.asyncNeeded = false;\n                        } else if (((bitField & 33554432) !== 0)) {\n                            callbacks[i].call(ret,\n                                              maybePromise._value(), holder);\n                        } else if (((bitField & 16777216) !== 0)) {\n                            ret._reject(maybePromise._reason());\n                        } else {\n                            ret._cancel();\n                        }\n                    } else {\n                        callbacks[i].call(ret, maybePromise, holder);\n                    }\n                }\n\n                if (!ret._isFateSealed()) {\n                    if (holder.asyncNeeded) {\n                        var domain = getDomain();\n                        if (domain !== null) {\n                            holder.fn = util.domainBind(domain, holder.fn);\n                        }\n                    }\n                    ret._setAsyncGuaranteed();\n                    ret._setOnCancel(holder);\n                }\n                return ret;\n            }\n        }\n    }\n    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];};\n    if (fn) args.pop();\n    var ret = new PromiseArray(args).promise();\n    return fn !== undefined ? ret.spread(fn) : ret;\n};\n\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/join.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/map.js":
/*!*************************************************!*\
  !*** ./node_modules/bluebird/js/release/map.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = function(Promise,\n                          PromiseArray,\n                          apiRejection,\n                          tryConvertToPromise,\n                          INTERNAL,\n                          debug) {\nvar getDomain = Promise._getDomain;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar async = Promise._async;\n\nfunction MappingPromiseArray(promises, fn, limit, _filter) {\n    this.constructor$(promises);\n    this._promise._captureStackTrace();\n    var domain = getDomain();\n    this._callback = domain === null ? fn : util.domainBind(domain, fn);\n    this._preservedValues = _filter === INTERNAL\n        ? new Array(this.length())\n        : null;\n    this._limit = limit;\n    this._inFlight = 0;\n    this._queue = [];\n    async.invoke(this._asyncInit, this, undefined);\n}\nutil.inherits(MappingPromiseArray, PromiseArray);\n\nMappingPromiseArray.prototype._asyncInit = function() {\n    this._init$(undefined, -2);\n};\n\nMappingPromiseArray.prototype._init = function () {};\n\nMappingPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var values = this._values;\n    var length = this.length();\n    var preservedValues = this._preservedValues;\n    var limit = this._limit;\n\n    if (index < 0) {\n        index = (index * -1) - 1;\n        values[index] = value;\n        if (limit >= 1) {\n            this._inFlight--;\n            this._drainQueue();\n            if (this._isResolved()) return true;\n        }\n    } else {\n        if (limit >= 1 && this._inFlight >= limit) {\n            values[index] = value;\n            this._queue.push(index);\n            return false;\n        }\n        if (preservedValues !== null) preservedValues[index] = value;\n\n        var promise = this._promise;\n        var callback = this._callback;\n        var receiver = promise._boundValue();\n        promise._pushContext();\n        var ret = tryCatch(callback).call(receiver, value, index, length);\n        var promiseCreated = promise._popContext();\n        debug.checkForgottenReturns(\n            ret,\n            promiseCreated,\n            preservedValues !== null ? \"Promise.filter\" : \"Promise.map\",\n            promise\n        );\n        if (ret === errorObj) {\n            this._reject(ret.e);\n            return true;\n        }\n\n        var maybePromise = tryConvertToPromise(ret, this._promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            var bitField = maybePromise._bitField;\n            ;\n            if (((bitField & 50397184) === 0)) {\n                if (limit >= 1) this._inFlight++;\n                values[index] = maybePromise;\n                maybePromise._proxy(this, (index + 1) * -1);\n                return false;\n            } else if (((bitField & 33554432) !== 0)) {\n                ret = maybePromise._value();\n            } else if (((bitField & 16777216) !== 0)) {\n                this._reject(maybePromise._reason());\n                return true;\n            } else {\n                this._cancel();\n                return true;\n            }\n        }\n        values[index] = ret;\n    }\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= length) {\n        if (preservedValues !== null) {\n            this._filter(values, preservedValues);\n        } else {\n            this._resolve(values);\n        }\n        return true;\n    }\n    return false;\n};\n\nMappingPromiseArray.prototype._drainQueue = function () {\n    var queue = this._queue;\n    var limit = this._limit;\n    var values = this._values;\n    while (queue.length > 0 && this._inFlight < limit) {\n        if (this._isResolved()) return;\n        var index = queue.pop();\n        this._promiseFulfilled(values[index], index);\n    }\n};\n\nMappingPromiseArray.prototype._filter = function (booleans, values) {\n    var len = values.length;\n    var ret = new Array(len);\n    var j = 0;\n    for (var i = 0; i < len; ++i) {\n        if (booleans[i]) ret[j++] = values[i];\n    }\n    ret.length = j;\n    this._resolve(ret);\n};\n\nMappingPromiseArray.prototype.preservedValues = function () {\n    return this._preservedValues;\n};\n\nfunction map(promises, fn, options, _filter) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n\n    var limit = 0;\n    if (options !== undefined) {\n        if (typeof options === \"object\" && options !== null) {\n            if (typeof options.concurrency !== \"number\") {\n                return Promise.reject(\n                    new TypeError(\"'concurrency' must be a number but it is \" +\n                                    util.classString(options.concurrency)));\n            }\n            limit = options.concurrency;\n        } else {\n            return Promise.reject(new TypeError(\n                            \"options argument must be an object but it is \" +\n                             util.classString(options)));\n        }\n    }\n    limit = typeof limit === \"number\" &&\n        isFinite(limit) && limit >= 1 ? limit : 0;\n    return new MappingPromiseArray(promises, fn, limit, _filter).promise();\n}\n\nPromise.prototype.map = function (fn, options) {\n    return map(this, fn, options, null);\n};\n\nPromise.map = function (promises, fn, options, _filter) {\n    return map(promises, fn, options, _filter);\n};\n\n\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/map.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/method.js":
/*!****************************************************!*\
  !*** ./node_modules/bluebird/js/release/method.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports =\nfunction(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar tryCatch = util.tryCatch;\n\nPromise.method = function (fn) {\n    if (typeof fn !== \"function\") {\n        throw new Promise.TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    return function () {\n        var ret = new Promise(INTERNAL);\n        ret._captureStackTrace();\n        ret._pushContext();\n        var value = tryCatch(fn).apply(this, arguments);\n        var promiseCreated = ret._popContext();\n        debug.checkForgottenReturns(\n            value, promiseCreated, \"Promise.method\", ret);\n        ret._resolveFromSyncValue(value);\n        return ret;\n    };\n};\n\nPromise.attempt = Promise[\"try\"] = function (fn) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    ret._pushContext();\n    var value;\n    if (arguments.length > 1) {\n        debug.deprecated(\"calling Promise.try with more than 1 argument\");\n        var arg = arguments[1];\n        var ctx = arguments[2];\n        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)\n                                  : tryCatch(fn).call(ctx, arg);\n    } else {\n        value = tryCatch(fn)();\n    }\n    var promiseCreated = ret._popContext();\n    debug.checkForgottenReturns(\n        value, promiseCreated, \"Promise.try\", ret);\n    ret._resolveFromSyncValue(value);\n    return ret;\n};\n\nPromise.prototype._resolveFromSyncValue = function (value) {\n    if (value === util.errorObj) {\n        this._rejectCallback(value.e, false);\n    } else {\n        this._resolveCallback(value, true);\n    }\n};\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/method.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/nodeback.js":
/*!******************************************************!*\
  !*** ./node_modules/bluebird/js/release/nodeback.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar errors = __webpack_require__(/*! ./errors */ \"./node_modules/bluebird/js/release/errors.js\");\nvar OperationalError = errors.OperationalError;\nvar es5 = __webpack_require__(/*! ./es5 */ \"./node_modules/bluebird/js/release/es5.js\");\n\nfunction isUntypedError(obj) {\n    return obj instanceof Error &&\n        es5.getPrototypeOf(obj) === Error.prototype;\n}\n\nvar rErrorKey = /^(?:name|message|stack|cause)$/;\nfunction wrapAsOperationalError(obj) {\n    var ret;\n    if (isUntypedError(obj)) {\n        ret = new OperationalError(obj);\n        ret.name = obj.name;\n        ret.message = obj.message;\n        ret.stack = obj.stack;\n        var keys = es5.keys(obj);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (!rErrorKey.test(key)) {\n                ret[key] = obj[key];\n            }\n        }\n        return ret;\n    }\n    util.markAsOriginatingFromRejection(obj);\n    return obj;\n}\n\nfunction nodebackForPromise(promise, multiArgs) {\n    return function(err, value) {\n        if (promise === null) return;\n        if (err) {\n            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));\n            promise._attachExtraTrace(wrapped);\n            promise._reject(wrapped);\n        } else if (!multiArgs) {\n            promise._fulfill(value);\n        } else {\n            var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0)); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];};\n            promise._fulfill(args);\n        }\n        promise = null;\n    };\n}\n\nmodule.exports = nodebackForPromise;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/nodeback.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/nodeify.js":
/*!*****************************************************!*\
  !*** ./node_modules/bluebird/js/release/nodeify.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = function(Promise) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar async = Promise._async;\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\n\nfunction spreadAdapter(val, nodeback) {\n    var promise = this;\n    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);\n    var ret =\n        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\n\nfunction successAdapter(val, nodeback) {\n    var promise = this;\n    var receiver = promise._boundValue();\n    var ret = val === undefined\n        ? tryCatch(nodeback).call(receiver, null)\n        : tryCatch(nodeback).call(receiver, null, val);\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\nfunction errorAdapter(reason, nodeback) {\n    var promise = this;\n    if (!reason) {\n        var newReason = new Error(reason + \"\");\n        newReason.cause = reason;\n        reason = newReason;\n    }\n    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\n\nPromise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback,\n                                                                     options) {\n    if (typeof nodeback == \"function\") {\n        var adapter = successAdapter;\n        if (options !== undefined && Object(options).spread) {\n            adapter = spreadAdapter;\n        }\n        this._then(\n            adapter,\n            errorAdapter,\n            undefined,\n            this,\n            nodeback\n        );\n    }\n    return this;\n};\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/nodeify.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/promise.js":
/*!*****************************************************!*\
  !*** ./node_modules/bluebird/js/release/promise.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = function() {\nvar makeSelfResolutionError = function () {\n    return new TypeError(\"circular promise resolution chain\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n};\nvar reflectHandler = function() {\n    return new Promise.PromiseInspection(this._target());\n};\nvar apiRejection = function(msg) {\n    return Promise.reject(new TypeError(msg));\n};\nfunction Proxyable() {}\nvar UNDEFINED_BINDING = {};\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\n\nvar getDomain;\nif (util.isNode) {\n    getDomain = function() {\n        var ret = process.domain;\n        if (ret === undefined) ret = null;\n        return ret;\n    };\n} else {\n    getDomain = function() {\n        return null;\n    };\n}\nutil.notEnumerableProp(Promise, \"_getDomain\", getDomain);\n\nvar es5 = __webpack_require__(/*! ./es5 */ \"./node_modules/bluebird/js/release/es5.js\");\nvar Async = __webpack_require__(/*! ./async */ \"./node_modules/bluebird/js/release/async.js\");\nvar async = new Async();\nes5.defineProperty(Promise, \"_async\", {value: async});\nvar errors = __webpack_require__(/*! ./errors */ \"./node_modules/bluebird/js/release/errors.js\");\nvar TypeError = Promise.TypeError = errors.TypeError;\nPromise.RangeError = errors.RangeError;\nvar CancellationError = Promise.CancellationError = errors.CancellationError;\nPromise.TimeoutError = errors.TimeoutError;\nPromise.OperationalError = errors.OperationalError;\nPromise.RejectionError = errors.OperationalError;\nPromise.AggregateError = errors.AggregateError;\nvar INTERNAL = function(){};\nvar APPLY = {};\nvar NEXT_FILTER = {};\nvar tryConvertToPromise = __webpack_require__(/*! ./thenables */ \"./node_modules/bluebird/js/release/thenables.js\")(Promise, INTERNAL);\nvar PromiseArray =\n    __webpack_require__(/*! ./promise_array */ \"./node_modules/bluebird/js/release/promise_array.js\")(Promise, INTERNAL,\n                               tryConvertToPromise, apiRejection, Proxyable);\nvar Context = __webpack_require__(/*! ./context */ \"./node_modules/bluebird/js/release/context.js\")(Promise);\n /*jshint unused:false*/\nvar createContext = Context.create;\nvar debug = __webpack_require__(/*! ./debuggability */ \"./node_modules/bluebird/js/release/debuggability.js\")(Promise, Context);\nvar CapturedTrace = debug.CapturedTrace;\nvar PassThroughHandlerContext =\n    __webpack_require__(/*! ./finally */ \"./node_modules/bluebird/js/release/finally.js\")(Promise, tryConvertToPromise);\nvar catchFilter = __webpack_require__(/*! ./catch_filter */ \"./node_modules/bluebird/js/release/catch_filter.js\")(NEXT_FILTER);\nvar nodebackForPromise = __webpack_require__(/*! ./nodeback */ \"./node_modules/bluebird/js/release/nodeback.js\");\nvar errorObj = util.errorObj;\nvar tryCatch = util.tryCatch;\nfunction check(self, executor) {\n    if (typeof executor !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(executor));\n    }\n    if (self.constructor !== Promise) {\n        throw new TypeError(\"the promise constructor cannot be invoked directly\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n}\n\nfunction Promise(executor) {\n    this._bitField = 0;\n    this._fulfillmentHandler0 = undefined;\n    this._rejectionHandler0 = undefined;\n    this._promise0 = undefined;\n    this._receiver0 = undefined;\n    if (executor !== INTERNAL) {\n        check(this, executor);\n        this._resolveFromExecutor(executor);\n    }\n    this._promiseCreated();\n    this._fireEvent(\"promiseCreated\", this);\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.caught = Promise.prototype[\"catch\"] = function (fn) {\n    var len = arguments.length;\n    if (len > 1) {\n        var catchInstances = new Array(len - 1),\n            j = 0, i;\n        for (i = 0; i < len - 1; ++i) {\n            var item = arguments[i];\n            if (util.isObject(item)) {\n                catchInstances[j++] = item;\n            } else {\n                return apiRejection(\"expecting an object but got \" +\n                    \"A catch statement predicate \" + util.classString(item));\n            }\n        }\n        catchInstances.length = j;\n        fn = arguments[i];\n        return this.then(undefined, catchFilter(catchInstances, fn, this));\n    }\n    return this.then(undefined, fn);\n};\n\nPromise.prototype.reflect = function () {\n    return this._then(reflectHandler,\n        reflectHandler, undefined, this, undefined);\n};\n\nPromise.prototype.then = function (didFulfill, didReject) {\n    if (debug.warnings() && arguments.length > 0 &&\n        typeof didFulfill !== \"function\" &&\n        typeof didReject !== \"function\") {\n        var msg = \".then() only accepts functions but was passed: \" +\n                util.classString(didFulfill);\n        if (arguments.length > 1) {\n            msg += \", \" + util.classString(didReject);\n        }\n        this._warn(msg);\n    }\n    return this._then(didFulfill, didReject, undefined, undefined, undefined);\n};\n\nPromise.prototype.done = function (didFulfill, didReject) {\n    var promise =\n        this._then(didFulfill, didReject, undefined, undefined, undefined);\n    promise._setIsFinal();\n};\n\nPromise.prototype.spread = function (fn) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n    return this.all()._then(fn, undefined, undefined, APPLY, undefined);\n};\n\nPromise.prototype.toJSON = function () {\n    var ret = {\n        isFulfilled: false,\n        isRejected: false,\n        fulfillmentValue: undefined,\n        rejectionReason: undefined\n    };\n    if (this.isFulfilled()) {\n        ret.fulfillmentValue = this.value();\n        ret.isFulfilled = true;\n    } else if (this.isRejected()) {\n        ret.rejectionReason = this.reason();\n        ret.isRejected = true;\n    }\n    return ret;\n};\n\nPromise.prototype.all = function () {\n    if (arguments.length > 0) {\n        this._warn(\".all() was passed arguments but it does not take any\");\n    }\n    return new PromiseArray(this).promise();\n};\n\nPromise.prototype.error = function (fn) {\n    return this.caught(util.originatesFromRejection, fn);\n};\n\nPromise.getNewLibraryCopy = module.exports;\n\nPromise.is = function (val) {\n    return val instanceof Promise;\n};\n\nPromise.fromNode = Promise.fromCallback = function(fn) {\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs\n                                         : false;\n    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));\n    if (result === errorObj) {\n        ret._rejectCallback(result.e, true);\n    }\n    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();\n    return ret;\n};\n\nPromise.all = function (promises) {\n    return new PromiseArray(promises).promise();\n};\n\nPromise.cast = function (obj) {\n    var ret = tryConvertToPromise(obj);\n    if (!(ret instanceof Promise)) {\n        ret = new Promise(INTERNAL);\n        ret._captureStackTrace();\n        ret._setFulfilled();\n        ret._rejectionHandler0 = obj;\n    }\n    return ret;\n};\n\nPromise.resolve = Promise.fulfilled = Promise.cast;\n\nPromise.reject = Promise.rejected = function (reason) {\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    ret._rejectCallback(reason, true);\n    return ret;\n};\n\nPromise.setScheduler = function(fn) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    return async.setScheduler(fn);\n};\n\nPromise.prototype._then = function (\n    didFulfill,\n    didReject,\n    _,    receiver,\n    internalData\n) {\n    var haveInternalData = internalData !== undefined;\n    var promise = haveInternalData ? internalData : new Promise(INTERNAL);\n    var target = this._target();\n    var bitField = target._bitField;\n\n    if (!haveInternalData) {\n        promise._propagateFrom(this, 3);\n        promise._captureStackTrace();\n        if (receiver === undefined &&\n            ((this._bitField & 2097152) !== 0)) {\n            if (!((bitField & 50397184) === 0)) {\n                receiver = this._boundValue();\n            } else {\n                receiver = target === this ? undefined : this._boundTo;\n            }\n        }\n        this._fireEvent(\"promiseChained\", this, promise);\n    }\n\n    var domain = getDomain();\n    if (!((bitField & 50397184) === 0)) {\n        var handler, value, settler = target._settlePromiseCtx;\n        if (((bitField & 33554432) !== 0)) {\n            value = target._rejectionHandler0;\n            handler = didFulfill;\n        } else if (((bitField & 16777216) !== 0)) {\n            value = target._fulfillmentHandler0;\n            handler = didReject;\n            target._unsetRejectionIsUnhandled();\n        } else {\n            settler = target._settlePromiseLateCancellationObserver;\n            value = new CancellationError(\"late cancellation observer\");\n            target._attachExtraTrace(value);\n            handler = didReject;\n        }\n\n        async.invoke(settler, target, {\n            handler: domain === null ? handler\n                : (typeof handler === \"function\" &&\n                    util.domainBind(domain, handler)),\n            promise: promise,\n            receiver: receiver,\n            value: value\n        });\n    } else {\n        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);\n    }\n\n    return promise;\n};\n\nPromise.prototype._length = function () {\n    return this._bitField & 65535;\n};\n\nPromise.prototype._isFateSealed = function () {\n    return (this._bitField & 117506048) !== 0;\n};\n\nPromise.prototype._isFollowing = function () {\n    return (this._bitField & 67108864) === 67108864;\n};\n\nPromise.prototype._setLength = function (len) {\n    this._bitField = (this._bitField & -65536) |\n        (len & 65535);\n};\n\nPromise.prototype._setFulfilled = function () {\n    this._bitField = this._bitField | 33554432;\n    this._fireEvent(\"promiseFulfilled\", this);\n};\n\nPromise.prototype._setRejected = function () {\n    this._bitField = this._bitField | 16777216;\n    this._fireEvent(\"promiseRejected\", this);\n};\n\nPromise.prototype._setFollowing = function () {\n    this._bitField = this._bitField | 67108864;\n    this._fireEvent(\"promiseResolved\", this);\n};\n\nPromise.prototype._setIsFinal = function () {\n    this._bitField = this._bitField | 4194304;\n};\n\nPromise.prototype._isFinal = function () {\n    return (this._bitField & 4194304) > 0;\n};\n\nPromise.prototype._unsetCancelled = function() {\n    this._bitField = this._bitField & (~65536);\n};\n\nPromise.prototype._setCancelled = function() {\n    this._bitField = this._bitField | 65536;\n    this._fireEvent(\"promiseCancelled\", this);\n};\n\nPromise.prototype._setWillBeCancelled = function() {\n    this._bitField = this._bitField | 8388608;\n};\n\nPromise.prototype._setAsyncGuaranteed = function() {\n    if (async.hasCustomScheduler()) return;\n    this._bitField = this._bitField | 134217728;\n};\n\nPromise.prototype._receiverAt = function (index) {\n    var ret = index === 0 ? this._receiver0 : this[\n            index * 4 - 4 + 3];\n    if (ret === UNDEFINED_BINDING) {\n        return undefined;\n    } else if (ret === undefined && this._isBound()) {\n        return this._boundValue();\n    }\n    return ret;\n};\n\nPromise.prototype._promiseAt = function (index) {\n    return this[\n            index * 4 - 4 + 2];\n};\n\nPromise.prototype._fulfillmentHandlerAt = function (index) {\n    return this[\n            index * 4 - 4 + 0];\n};\n\nPromise.prototype._rejectionHandlerAt = function (index) {\n    return this[\n            index * 4 - 4 + 1];\n};\n\nPromise.prototype._boundValue = function() {};\n\nPromise.prototype._migrateCallback0 = function (follower) {\n    var bitField = follower._bitField;\n    var fulfill = follower._fulfillmentHandler0;\n    var reject = follower._rejectionHandler0;\n    var promise = follower._promise0;\n    var receiver = follower._receiverAt(0);\n    if (receiver === undefined) receiver = UNDEFINED_BINDING;\n    this._addCallbacks(fulfill, reject, promise, receiver, null);\n};\n\nPromise.prototype._migrateCallbackAt = function (follower, index) {\n    var fulfill = follower._fulfillmentHandlerAt(index);\n    var reject = follower._rejectionHandlerAt(index);\n    var promise = follower._promiseAt(index);\n    var receiver = follower._receiverAt(index);\n    if (receiver === undefined) receiver = UNDEFINED_BINDING;\n    this._addCallbacks(fulfill, reject, promise, receiver, null);\n};\n\nPromise.prototype._addCallbacks = function (\n    fulfill,\n    reject,\n    promise,\n    receiver,\n    domain\n) {\n    var index = this._length();\n\n    if (index >= 65535 - 4) {\n        index = 0;\n        this._setLength(0);\n    }\n\n    if (index === 0) {\n        this._promise0 = promise;\n        this._receiver0 = receiver;\n        if (typeof fulfill === \"function\") {\n            this._fulfillmentHandler0 =\n                domain === null ? fulfill : util.domainBind(domain, fulfill);\n        }\n        if (typeof reject === \"function\") {\n            this._rejectionHandler0 =\n                domain === null ? reject : util.domainBind(domain, reject);\n        }\n    } else {\n        var base = index * 4 - 4;\n        this[base + 2] = promise;\n        this[base + 3] = receiver;\n        if (typeof fulfill === \"function\") {\n            this[base + 0] =\n                domain === null ? fulfill : util.domainBind(domain, fulfill);\n        }\n        if (typeof reject === \"function\") {\n            this[base + 1] =\n                domain === null ? reject : util.domainBind(domain, reject);\n        }\n    }\n    this._setLength(index + 1);\n    return index;\n};\n\nPromise.prototype._proxy = function (proxyable, arg) {\n    this._addCallbacks(undefined, undefined, arg, proxyable, null);\n};\n\nPromise.prototype._resolveCallback = function(value, shouldBind) {\n    if (((this._bitField & 117506048) !== 0)) return;\n    if (value === this)\n        return this._rejectCallback(makeSelfResolutionError(), false);\n    var maybePromise = tryConvertToPromise(value, this);\n    if (!(maybePromise instanceof Promise)) return this._fulfill(value);\n\n    if (shouldBind) this._propagateFrom(maybePromise, 2);\n\n    var promise = maybePromise._target();\n\n    if (promise === this) {\n        this._reject(makeSelfResolutionError());\n        return;\n    }\n\n    var bitField = promise._bitField;\n    if (((bitField & 50397184) === 0)) {\n        var len = this._length();\n        if (len > 0) promise._migrateCallback0(this);\n        for (var i = 1; i < len; ++i) {\n            promise._migrateCallbackAt(this, i);\n        }\n        this._setFollowing();\n        this._setLength(0);\n        this._setFollowee(promise);\n    } else if (((bitField & 33554432) !== 0)) {\n        this._fulfill(promise._value());\n    } else if (((bitField & 16777216) !== 0)) {\n        this._reject(promise._reason());\n    } else {\n        var reason = new CancellationError(\"late cancellation observer\");\n        promise._attachExtraTrace(reason);\n        this._reject(reason);\n    }\n};\n\nPromise.prototype._rejectCallback =\nfunction(reason, synchronous, ignoreNonErrorWarnings) {\n    var trace = util.ensureErrorObject(reason);\n    var hasStack = trace === reason;\n    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {\n        var message = \"a promise was rejected with a non-error: \" +\n            util.classString(reason);\n        this._warn(message, true);\n    }\n    this._attachExtraTrace(trace, synchronous ? hasStack : false);\n    this._reject(reason);\n};\n\nPromise.prototype._resolveFromExecutor = function (executor) {\n    var promise = this;\n    this._captureStackTrace();\n    this._pushContext();\n    var synchronous = true;\n    var r = this._execute(executor, function(value) {\n        promise._resolveCallback(value);\n    }, function (reason) {\n        promise._rejectCallback(reason, synchronous);\n    });\n    synchronous = false;\n    this._popContext();\n\n    if (r !== undefined) {\n        promise._rejectCallback(r, true);\n    }\n};\n\nPromise.prototype._settlePromiseFromHandler = function (\n    handler, receiver, value, promise\n) {\n    var bitField = promise._bitField;\n    if (((bitField & 65536) !== 0)) return;\n    promise._pushContext();\n    var x;\n    if (receiver === APPLY) {\n        if (!value || typeof value.length !== \"number\") {\n            x = errorObj;\n            x.e = new TypeError(\"cannot .spread() a non-array: \" +\n                                    util.classString(value));\n        } else {\n            x = tryCatch(handler).apply(this._boundValue(), value);\n        }\n    } else {\n        x = tryCatch(handler).call(receiver, value);\n    }\n    var promiseCreated = promise._popContext();\n    bitField = promise._bitField;\n    if (((bitField & 65536) !== 0)) return;\n\n    if (x === NEXT_FILTER) {\n        promise._reject(value);\n    } else if (x === errorObj) {\n        promise._rejectCallback(x.e, false);\n    } else {\n        debug.checkForgottenReturns(x, promiseCreated, \"\",  promise, this);\n        promise._resolveCallback(x);\n    }\n};\n\nPromise.prototype._target = function() {\n    var ret = this;\n    while (ret._isFollowing()) ret = ret._followee();\n    return ret;\n};\n\nPromise.prototype._followee = function() {\n    return this._rejectionHandler0;\n};\n\nPromise.prototype._setFollowee = function(promise) {\n    this._rejectionHandler0 = promise;\n};\n\nPromise.prototype._settlePromise = function(promise, handler, receiver, value) {\n    var isPromise = promise instanceof Promise;\n    var bitField = this._bitField;\n    var asyncGuaranteed = ((bitField & 134217728) !== 0);\n    if (((bitField & 65536) !== 0)) {\n        if (isPromise) promise._invokeInternalOnCancel();\n\n        if (receiver instanceof PassThroughHandlerContext &&\n            receiver.isFinallyHandler()) {\n            receiver.cancelPromise = promise;\n            if (tryCatch(handler).call(receiver, value) === errorObj) {\n                promise._reject(errorObj.e);\n            }\n        } else if (handler === reflectHandler) {\n            promise._fulfill(reflectHandler.call(receiver));\n        } else if (receiver instanceof Proxyable) {\n            receiver._promiseCancelled(promise);\n        } else if (isPromise || promise instanceof PromiseArray) {\n            promise._cancel();\n        } else {\n            receiver.cancel();\n        }\n    } else if (typeof handler === \"function\") {\n        if (!isPromise) {\n            handler.call(receiver, value, promise);\n        } else {\n            if (asyncGuaranteed) promise._setAsyncGuaranteed();\n            this._settlePromiseFromHandler(handler, receiver, value, promise);\n        }\n    } else if (receiver instanceof Proxyable) {\n        if (!receiver._isResolved()) {\n            if (((bitField & 33554432) !== 0)) {\n                receiver._promiseFulfilled(value, promise);\n            } else {\n                receiver._promiseRejected(value, promise);\n            }\n        }\n    } else if (isPromise) {\n        if (asyncGuaranteed) promise._setAsyncGuaranteed();\n        if (((bitField & 33554432) !== 0)) {\n            promise._fulfill(value);\n        } else {\n            promise._reject(value);\n        }\n    }\n};\n\nPromise.prototype._settlePromiseLateCancellationObserver = function(ctx) {\n    var handler = ctx.handler;\n    var promise = ctx.promise;\n    var receiver = ctx.receiver;\n    var value = ctx.value;\n    if (typeof handler === \"function\") {\n        if (!(promise instanceof Promise)) {\n            handler.call(receiver, value, promise);\n        } else {\n            this._settlePromiseFromHandler(handler, receiver, value, promise);\n        }\n    } else if (promise instanceof Promise) {\n        promise._reject(value);\n    }\n};\n\nPromise.prototype._settlePromiseCtx = function(ctx) {\n    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);\n};\n\nPromise.prototype._settlePromise0 = function(handler, value, bitField) {\n    var promise = this._promise0;\n    var receiver = this._receiverAt(0);\n    this._promise0 = undefined;\n    this._receiver0 = undefined;\n    this._settlePromise(promise, handler, receiver, value);\n};\n\nPromise.prototype._clearCallbackDataAtIndex = function(index) {\n    var base = index * 4 - 4;\n    this[base + 2] =\n    this[base + 3] =\n    this[base + 0] =\n    this[base + 1] = undefined;\n};\n\nPromise.prototype._fulfill = function (value) {\n    var bitField = this._bitField;\n    if (((bitField & 117506048) >>> 16)) return;\n    if (value === this) {\n        var err = makeSelfResolutionError();\n        this._attachExtraTrace(err);\n        return this._reject(err);\n    }\n    this._setFulfilled();\n    this._rejectionHandler0 = value;\n\n    if ((bitField & 65535) > 0) {\n        if (((bitField & 134217728) !== 0)) {\n            this._settlePromises();\n        } else {\n            async.settlePromises(this);\n        }\n    }\n};\n\nPromise.prototype._reject = function (reason) {\n    var bitField = this._bitField;\n    if (((bitField & 117506048) >>> 16)) return;\n    this._setRejected();\n    this._fulfillmentHandler0 = reason;\n\n    if (this._isFinal()) {\n        return async.fatalError(reason, util.isNode);\n    }\n\n    if ((bitField & 65535) > 0) {\n        async.settlePromises(this);\n    } else {\n        this._ensurePossibleRejectionHandled();\n    }\n};\n\nPromise.prototype._fulfillPromises = function (len, value) {\n    for (var i = 1; i < len; i++) {\n        var handler = this._fulfillmentHandlerAt(i);\n        var promise = this._promiseAt(i);\n        var receiver = this._receiverAt(i);\n        this._clearCallbackDataAtIndex(i);\n        this._settlePromise(promise, handler, receiver, value);\n    }\n};\n\nPromise.prototype._rejectPromises = function (len, reason) {\n    for (var i = 1; i < len; i++) {\n        var handler = this._rejectionHandlerAt(i);\n        var promise = this._promiseAt(i);\n        var receiver = this._receiverAt(i);\n        this._clearCallbackDataAtIndex(i);\n        this._settlePromise(promise, handler, receiver, reason);\n    }\n};\n\nPromise.prototype._settlePromises = function () {\n    var bitField = this._bitField;\n    var len = (bitField & 65535);\n\n    if (len > 0) {\n        if (((bitField & 16842752) !== 0)) {\n            var reason = this._fulfillmentHandler0;\n            this._settlePromise0(this._rejectionHandler0, reason, bitField);\n            this._rejectPromises(len, reason);\n        } else {\n            var value = this._rejectionHandler0;\n            this._settlePromise0(this._fulfillmentHandler0, value, bitField);\n            this._fulfillPromises(len, value);\n        }\n        this._setLength(0);\n    }\n    this._clearCancellationData();\n};\n\nPromise.prototype._settledValue = function() {\n    var bitField = this._bitField;\n    if (((bitField & 33554432) !== 0)) {\n        return this._rejectionHandler0;\n    } else if (((bitField & 16777216) !== 0)) {\n        return this._fulfillmentHandler0;\n    }\n};\n\nfunction deferResolve(v) {this.promise._resolveCallback(v);}\nfunction deferReject(v) {this.promise._rejectCallback(v, false);}\n\nPromise.defer = Promise.pending = function() {\n    debug.deprecated(\"Promise.defer\", \"new Promise\");\n    var promise = new Promise(INTERNAL);\n    return {\n        promise: promise,\n        resolve: deferResolve,\n        reject: deferReject\n    };\n};\n\nutil.notEnumerableProp(Promise,\n                       \"_makeSelfResolutionError\",\n                       makeSelfResolutionError);\n\n__webpack_require__(/*! ./method */ \"./node_modules/bluebird/js/release/method.js\")(Promise, INTERNAL, tryConvertToPromise, apiRejection,\n    debug);\n__webpack_require__(/*! ./bind */ \"./node_modules/bluebird/js/release/bind.js\")(Promise, INTERNAL, tryConvertToPromise, debug);\n__webpack_require__(/*! ./cancel */ \"./node_modules/bluebird/js/release/cancel.js\")(Promise, PromiseArray, apiRejection, debug);\n__webpack_require__(/*! ./direct_resolve */ \"./node_modules/bluebird/js/release/direct_resolve.js\")(Promise);\n__webpack_require__(/*! ./synchronous_inspection */ \"./node_modules/bluebird/js/release/synchronous_inspection.js\")(Promise);\n__webpack_require__(/*! ./join */ \"./node_modules/bluebird/js/release/join.js\")(\n    Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);\nPromise.Promise = Promise;\nPromise.version = \"3.4.7\";\n__webpack_require__(/*! ./map.js */ \"./node_modules/bluebird/js/release/map.js\")(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);\n__webpack_require__(/*! ./call_get.js */ \"./node_modules/bluebird/js/release/call_get.js\")(Promise);\n__webpack_require__(/*! ./using.js */ \"./node_modules/bluebird/js/release/using.js\")(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);\n__webpack_require__(/*! ./timers.js */ \"./node_modules/bluebird/js/release/timers.js\")(Promise, INTERNAL, debug);\n__webpack_require__(/*! ./generators.js */ \"./node_modules/bluebird/js/release/generators.js\")(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);\n__webpack_require__(/*! ./nodeify.js */ \"./node_modules/bluebird/js/release/nodeify.js\")(Promise);\n__webpack_require__(/*! ./promisify.js */ \"./node_modules/bluebird/js/release/promisify.js\")(Promise, INTERNAL);\n__webpack_require__(/*! ./props.js */ \"./node_modules/bluebird/js/release/props.js\")(Promise, PromiseArray, tryConvertToPromise, apiRejection);\n__webpack_require__(/*! ./race.js */ \"./node_modules/bluebird/js/release/race.js\")(Promise, INTERNAL, tryConvertToPromise, apiRejection);\n__webpack_require__(/*! ./reduce.js */ \"./node_modules/bluebird/js/release/reduce.js\")(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);\n__webpack_require__(/*! ./settle.js */ \"./node_modules/bluebird/js/release/settle.js\")(Promise, PromiseArray, debug);\n__webpack_require__(/*! ./some.js */ \"./node_modules/bluebird/js/release/some.js\")(Promise, PromiseArray, apiRejection);\n__webpack_require__(/*! ./filter.js */ \"./node_modules/bluebird/js/release/filter.js\")(Promise, INTERNAL);\n__webpack_require__(/*! ./each.js */ \"./node_modules/bluebird/js/release/each.js\")(Promise, INTERNAL);\n__webpack_require__(/*! ./any.js */ \"./node_modules/bluebird/js/release/any.js\")(Promise);\n                                                         \n    util.toFastProperties(Promise);                                          \n    util.toFastProperties(Promise.prototype);                                \n    function fillTypes(value) {                                              \n        var p = new Promise(INTERNAL);                                       \n        p._fulfillmentHandler0 = value;                                      \n        p._rejectionHandler0 = value;                                        \n        p._promise0 = value;                                                 \n        p._receiver0 = value;                                                \n    }                                                                        \n    // Complete slack tracking, opt out of field-type tracking and           \n    // stabilize map                                                         \n    fillTypes({a: 1});                                                       \n    fillTypes({b: 2});                                                       \n    fillTypes({c: 3});                                                       \n    fillTypes(1);                                                            \n    fillTypes(function(){});                                                 \n    fillTypes(undefined);                                                    \n    fillTypes(false);                                                        \n    fillTypes(new Promise(INTERNAL));                                        \n    debug.setBounds(Async.firstLineError, util.lastLineError);               \n    return Promise;                                                          \n\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/promise.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/promise_array.js":
/*!***********************************************************!*\
  !*** ./node_modules/bluebird/js/release/promise_array.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL, tryConvertToPromise,\n    apiRejection, Proxyable) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar isArray = util.isArray;\n\nfunction toResolutionValue(val) {\n    switch(val) {\n    case -2: return [];\n    case -3: return {};\n    }\n}\n\nfunction PromiseArray(values) {\n    var promise = this._promise = new Promise(INTERNAL);\n    if (values instanceof Promise) {\n        promise._propagateFrom(values, 3);\n    }\n    promise._setOnCancel(this);\n    this._values = values;\n    this._length = 0;\n    this._totalResolved = 0;\n    this._init(undefined, -2);\n}\nutil.inherits(PromiseArray, Proxyable);\n\nPromiseArray.prototype.length = function () {\n    return this._length;\n};\n\nPromiseArray.prototype.promise = function () {\n    return this._promise;\n};\n\nPromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {\n    var values = tryConvertToPromise(this._values, this._promise);\n    if (values instanceof Promise) {\n        values = values._target();\n        var bitField = values._bitField;\n        ;\n        this._values = values;\n\n        if (((bitField & 50397184) === 0)) {\n            this._promise._setAsyncGuaranteed();\n            return values._then(\n                init,\n                this._reject,\n                undefined,\n                this,\n                resolveValueIfEmpty\n           );\n        } else if (((bitField & 33554432) !== 0)) {\n            values = values._value();\n        } else if (((bitField & 16777216) !== 0)) {\n            return this._reject(values._reason());\n        } else {\n            return this._cancel();\n        }\n    }\n    values = util.asArray(values);\n    if (values === null) {\n        var err = apiRejection(\n            \"expecting an array or an iterable object but got \" + util.classString(values)).reason();\n        this._promise._rejectCallback(err, false);\n        return;\n    }\n\n    if (values.length === 0) {\n        if (resolveValueIfEmpty === -5) {\n            this._resolveEmptyArray();\n        }\n        else {\n            this._resolve(toResolutionValue(resolveValueIfEmpty));\n        }\n        return;\n    }\n    this._iterate(values);\n};\n\nPromiseArray.prototype._iterate = function(values) {\n    var len = this.getActualLength(values.length);\n    this._length = len;\n    this._values = this.shouldCopyValues() ? new Array(len) : this._values;\n    var result = this._promise;\n    var isResolved = false;\n    var bitField = null;\n    for (var i = 0; i < len; ++i) {\n        var maybePromise = tryConvertToPromise(values[i], result);\n\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            bitField = maybePromise._bitField;\n        } else {\n            bitField = null;\n        }\n\n        if (isResolved) {\n            if (bitField !== null) {\n                maybePromise.suppressUnhandledRejections();\n            }\n        } else if (bitField !== null) {\n            if (((bitField & 50397184) === 0)) {\n                maybePromise._proxy(this, i);\n                this._values[i] = maybePromise;\n            } else if (((bitField & 33554432) !== 0)) {\n                isResolved = this._promiseFulfilled(maybePromise._value(), i);\n            } else if (((bitField & 16777216) !== 0)) {\n                isResolved = this._promiseRejected(maybePromise._reason(), i);\n            } else {\n                isResolved = this._promiseCancelled(i);\n            }\n        } else {\n            isResolved = this._promiseFulfilled(maybePromise, i);\n        }\n    }\n    if (!isResolved) result._setAsyncGuaranteed();\n};\n\nPromiseArray.prototype._isResolved = function () {\n    return this._values === null;\n};\n\nPromiseArray.prototype._resolve = function (value) {\n    this._values = null;\n    this._promise._fulfill(value);\n};\n\nPromiseArray.prototype._cancel = function() {\n    if (this._isResolved() || !this._promise._isCancellable()) return;\n    this._values = null;\n    this._promise._cancel();\n};\n\nPromiseArray.prototype._reject = function (reason) {\n    this._values = null;\n    this._promise._rejectCallback(reason, false);\n};\n\nPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    this._values[index] = value;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        this._resolve(this._values);\n        return true;\n    }\n    return false;\n};\n\nPromiseArray.prototype._promiseCancelled = function() {\n    this._cancel();\n    return true;\n};\n\nPromiseArray.prototype._promiseRejected = function (reason) {\n    this._totalResolved++;\n    this._reject(reason);\n    return true;\n};\n\nPromiseArray.prototype._resultCancelled = function() {\n    if (this._isResolved()) return;\n    var values = this._values;\n    this._cancel();\n    if (values instanceof Promise) {\n        values.cancel();\n    } else {\n        for (var i = 0; i < values.length; ++i) {\n            if (values[i] instanceof Promise) {\n                values[i].cancel();\n            }\n        }\n    }\n};\n\nPromiseArray.prototype.shouldCopyValues = function () {\n    return true;\n};\n\nPromiseArray.prototype.getActualLength = function (len) {\n    return len;\n};\n\nreturn PromiseArray;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/promise_array.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/promisify.js":
/*!*******************************************************!*\
  !*** ./node_modules/bluebird/js/release/promisify.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar THIS = {};\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar nodebackForPromise = __webpack_require__(/*! ./nodeback */ \"./node_modules/bluebird/js/release/nodeback.js\");\nvar withAppended = util.withAppended;\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar canEvaluate = util.canEvaluate;\nvar TypeError = __webpack_require__(/*! ./errors */ \"./node_modules/bluebird/js/release/errors.js\").TypeError;\nvar defaultSuffix = \"Async\";\nvar defaultPromisified = {__isPromisified__: true};\nvar noCopyProps = [\n    \"arity\",    \"length\",\n    \"name\",\n    \"arguments\",\n    \"caller\",\n    \"callee\",\n    \"prototype\",\n    \"__isPromisified__\"\n];\nvar noCopyPropsPattern = new RegExp(\"^(?:\" + noCopyProps.join(\"|\") + \")$\");\n\nvar defaultFilter = function(name) {\n    return util.isIdentifier(name) &&\n        name.charAt(0) !== \"_\" &&\n        name !== \"constructor\";\n};\n\nfunction propsFilter(key) {\n    return !noCopyPropsPattern.test(key);\n}\n\nfunction isPromisified(fn) {\n    try {\n        return fn.__isPromisified__ === true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n\nfunction hasPromisified(obj, key, suffix) {\n    var val = util.getDataPropertyOrDefault(obj, key + suffix,\n                                            defaultPromisified);\n    return val ? isPromisified(val) : false;\n}\nfunction checkValid(ret, suffix, suffixRegexp) {\n    for (var i = 0; i < ret.length; i += 2) {\n        var key = ret[i];\n        if (suffixRegexp.test(key)) {\n            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, \"\");\n            for (var j = 0; j < ret.length; j += 2) {\n                if (ret[j] === keyWithoutAsyncSuffix) {\n                    throw new TypeError(\"Cannot promisify an API that has normal methods with '%s'-suffix\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\"\n                        .replace(\"%s\", suffix));\n                }\n            }\n        }\n    }\n}\n\nfunction promisifiableMethods(obj, suffix, suffixRegexp, filter) {\n    var keys = util.inheritedDataKeys(obj);\n    var ret = [];\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var value = obj[key];\n        var passesDefaultFilter = filter === defaultFilter\n            ? true : defaultFilter(key, value, obj);\n        if (typeof value === \"function\" &&\n            !isPromisified(value) &&\n            !hasPromisified(obj, key, suffix) &&\n            filter(key, value, obj, passesDefaultFilter)) {\n            ret.push(key, value);\n        }\n    }\n    checkValid(ret, suffix, suffixRegexp);\n    return ret;\n}\n\nvar escapeIdentRegex = function(str) {\n    return str.replace(/([$])/, \"\\\\$\");\n};\n\nvar makeNodePromisifiedEval;\nif (true) {\nvar switchCaseArgumentOrder = function(likelyArgumentCount) {\n    var ret = [likelyArgumentCount];\n    var min = Math.max(0, likelyArgumentCount - 1 - 3);\n    for(var i = likelyArgumentCount - 1; i >= min; --i) {\n        ret.push(i);\n    }\n    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {\n        ret.push(i);\n    }\n    return ret;\n};\n\nvar argumentSequence = function(argumentCount) {\n    return util.filledRange(argumentCount, \"_arg\", \"\");\n};\n\nvar parameterDeclaration = function(parameterCount) {\n    return util.filledRange(\n        Math.max(parameterCount, 3), \"_arg\", \"\");\n};\n\nvar parameterCount = function(fn) {\n    if (typeof fn.length === \"number\") {\n        return Math.max(Math.min(fn.length, 1023 + 1), 0);\n    }\n    return 0;\n};\n\nmakeNodePromisifiedEval =\nfunction(callback, receiver, originalName, fn, _, multiArgs) {\n    var newParameterCount = Math.max(0, parameterCount(fn) - 1);\n    var argumentOrder = switchCaseArgumentOrder(newParameterCount);\n    var shouldProxyThis = typeof callback === \"string\" || receiver === THIS;\n\n    function generateCallForArgumentCount(count) {\n        var args = argumentSequence(count).join(\", \");\n        var comma = count > 0 ? \", \" : \"\";\n        var ret;\n        if (shouldProxyThis) {\n            ret = \"ret = callback.call(this, {{args}}, nodeback); break;\\n\";\n        } else {\n            ret = receiver === undefined\n                ? \"ret = callback({{args}}, nodeback); break;\\n\"\n                : \"ret = callback.call(receiver, {{args}}, nodeback); break;\\n\";\n        }\n        return ret.replace(\"{{args}}\", args).replace(\", \", comma);\n    }\n\n    function generateArgumentSwitchCase() {\n        var ret = \"\";\n        for (var i = 0; i < argumentOrder.length; ++i) {\n            ret += \"case \" + argumentOrder[i] +\":\" +\n                generateCallForArgumentCount(argumentOrder[i]);\n        }\n\n        ret += \"                                                             \\n\\\n        default:                                                             \\n\\\n            var args = new Array(len + 1);                                   \\n\\\n            var i = 0;                                                       \\n\\\n            for (var i = 0; i < len; ++i) {                                  \\n\\\n               args[i] = arguments[i];                                       \\n\\\n            }                                                                \\n\\\n            args[i] = nodeback;                                              \\n\\\n            [CodeForCall]                                                    \\n\\\n            break;                                                           \\n\\\n        \".replace(\"[CodeForCall]\", (shouldProxyThis\n                                ? \"ret = callback.apply(this, args);\\n\"\n                                : \"ret = callback.apply(receiver, args);\\n\"));\n        return ret;\n    }\n\n    var getFunctionCode = typeof callback === \"string\"\n                                ? (\"this != null ? this['\"+callback+\"'] : fn\")\n                                : \"fn\";\n    var body = \"'use strict';                                                \\n\\\n        var ret = function (Parameters) {                                    \\n\\\n            'use strict';                                                    \\n\\\n            var len = arguments.length;                                      \\n\\\n            var promise = new Promise(INTERNAL);                             \\n\\\n            promise._captureStackTrace();                                    \\n\\\n            var nodeback = nodebackForPromise(promise, \" + multiArgs + \");   \\n\\\n            var ret;                                                         \\n\\\n            var callback = tryCatch([GetFunctionCode]);                      \\n\\\n            switch(len) {                                                    \\n\\\n                [CodeForSwitchCase]                                          \\n\\\n            }                                                                \\n\\\n            if (ret === errorObj) {                                          \\n\\\n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\\n\\\n            }                                                                \\n\\\n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \\n\\\n            return promise;                                                  \\n\\\n        };                                                                   \\n\\\n        notEnumerableProp(ret, '__isPromisified__', true);                   \\n\\\n        return ret;                                                          \\n\\\n    \".replace(\"[CodeForSwitchCase]\", generateArgumentSwitchCase())\n        .replace(\"[GetFunctionCode]\", getFunctionCode);\n    body = body.replace(\"Parameters\", parameterDeclaration(newParameterCount));\n    return new Function(\"Promise\",\n                        \"fn\",\n                        \"receiver\",\n                        \"withAppended\",\n                        \"maybeWrapAsError\",\n                        \"nodebackForPromise\",\n                        \"tryCatch\",\n                        \"errorObj\",\n                        \"notEnumerableProp\",\n                        \"INTERNAL\",\n                        body)(\n                    Promise,\n                    fn,\n                    receiver,\n                    withAppended,\n                    maybeWrapAsError,\n                    nodebackForPromise,\n                    util.tryCatch,\n                    util.errorObj,\n                    util.notEnumerableProp,\n                    INTERNAL);\n};\n}\n\nfunction makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {\n    var defaultThis = (function() {return this;})();\n    var method = callback;\n    if (typeof method === \"string\") {\n        callback = fn;\n    }\n    function promisified() {\n        var _receiver = receiver;\n        if (receiver === THIS) _receiver = this;\n        var promise = new Promise(INTERNAL);\n        promise._captureStackTrace();\n        var cb = typeof method === \"string\" && this !== defaultThis\n            ? this[method] : callback;\n        var fn = nodebackForPromise(promise, multiArgs);\n        try {\n            cb.apply(_receiver, withAppended(arguments, fn));\n        } catch(e) {\n            promise._rejectCallback(maybeWrapAsError(e), true, true);\n        }\n        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();\n        return promise;\n    }\n    util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n    return promisified;\n}\n\nvar makeNodePromisified = canEvaluate\n    ? makeNodePromisifiedEval\n    : makeNodePromisifiedClosure;\n\nfunction promisifyAll(obj, suffix, filter, promisifier, multiArgs) {\n    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + \"$\");\n    var methods =\n        promisifiableMethods(obj, suffix, suffixRegexp, filter);\n\n    for (var i = 0, len = methods.length; i < len; i+= 2) {\n        var key = methods[i];\n        var fn = methods[i+1];\n        var promisifiedKey = key + suffix;\n        if (promisifier === makeNodePromisified) {\n            obj[promisifiedKey] =\n                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);\n        } else {\n            var promisified = promisifier(fn, function() {\n                return makeNodePromisified(key, THIS, key,\n                                           fn, suffix, multiArgs);\n            });\n            util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n            obj[promisifiedKey] = promisified;\n        }\n    }\n    util.toFastProperties(obj);\n    return obj;\n}\n\nfunction promisify(callback, receiver, multiArgs) {\n    return makeNodePromisified(callback, receiver, undefined,\n                                callback, null, multiArgs);\n}\n\nPromise.promisify = function (fn, options) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    if (isPromisified(fn)) {\n        return fn;\n    }\n    options = Object(options);\n    var receiver = options.context === undefined ? THIS : options.context;\n    var multiArgs = !!options.multiArgs;\n    var ret = promisify(fn, receiver, multiArgs);\n    util.copyDescriptors(fn, ret, propsFilter);\n    return ret;\n};\n\nPromise.promisifyAll = function (target, options) {\n    if (typeof target !== \"function\" && typeof target !== \"object\") {\n        throw new TypeError(\"the target of promisifyAll must be an object or a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    options = Object(options);\n    var multiArgs = !!options.multiArgs;\n    var suffix = options.suffix;\n    if (typeof suffix !== \"string\") suffix = defaultSuffix;\n    var filter = options.filter;\n    if (typeof filter !== \"function\") filter = defaultFilter;\n    var promisifier = options.promisifier;\n    if (typeof promisifier !== \"function\") promisifier = makeNodePromisified;\n\n    if (!util.isIdentifier(suffix)) {\n        throw new RangeError(\"suffix must be a valid identifier\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n\n    var keys = util.inheritedDataKeys(target);\n    for (var i = 0; i < keys.length; ++i) {\n        var value = target[keys[i]];\n        if (keys[i] !== \"constructor\" &&\n            util.isClass(value)) {\n            promisifyAll(value.prototype, suffix, filter, promisifier,\n                multiArgs);\n            promisifyAll(value, suffix, filter, promisifier, multiArgs);\n        }\n    }\n\n    return promisifyAll(target, suffix, filter, promisifier, multiArgs);\n};\n};\n\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/promisify.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/props.js":
/*!***************************************************!*\
  !*** ./node_modules/bluebird/js/release/props.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = function(\n    Promise, PromiseArray, tryConvertToPromise, apiRejection) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar isObject = util.isObject;\nvar es5 = __webpack_require__(/*! ./es5 */ \"./node_modules/bluebird/js/release/es5.js\");\nvar Es6Map;\nif (typeof Map === \"function\") Es6Map = Map;\n\nvar mapToEntries = (function() {\n    var index = 0;\n    var size = 0;\n\n    function extractEntry(value, key) {\n        this[index] = value;\n        this[index + size] = key;\n        index++;\n    }\n\n    return function mapToEntries(map) {\n        size = map.size;\n        index = 0;\n        var ret = new Array(map.size * 2);\n        map.forEach(extractEntry, ret);\n        return ret;\n    };\n})();\n\nvar entriesToMap = function(entries) {\n    var ret = new Es6Map();\n    var length = entries.length / 2 | 0;\n    for (var i = 0; i < length; ++i) {\n        var key = entries[length + i];\n        var value = entries[i];\n        ret.set(key, value);\n    }\n    return ret;\n};\n\nfunction PropertiesPromiseArray(obj) {\n    var isMap = false;\n    var entries;\n    if (Es6Map !== undefined && obj instanceof Es6Map) {\n        entries = mapToEntries(obj);\n        isMap = true;\n    } else {\n        var keys = es5.keys(obj);\n        var len = keys.length;\n        entries = new Array(len * 2);\n        for (var i = 0; i < len; ++i) {\n            var key = keys[i];\n            entries[i] = obj[key];\n            entries[i + len] = key;\n        }\n    }\n    this.constructor$(entries);\n    this._isMap = isMap;\n    this._init$(undefined, -3);\n}\nutil.inherits(PropertiesPromiseArray, PromiseArray);\n\nPropertiesPromiseArray.prototype._init = function () {};\n\nPropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    this._values[index] = value;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        var val;\n        if (this._isMap) {\n            val = entriesToMap(this._values);\n        } else {\n            val = {};\n            var keyOffset = this.length();\n            for (var i = 0, len = this.length(); i < len; ++i) {\n                val[this._values[i + keyOffset]] = this._values[i];\n            }\n        }\n        this._resolve(val);\n        return true;\n    }\n    return false;\n};\n\nPropertiesPromiseArray.prototype.shouldCopyValues = function () {\n    return false;\n};\n\nPropertiesPromiseArray.prototype.getActualLength = function (len) {\n    return len >> 1;\n};\n\nfunction props(promises) {\n    var ret;\n    var castValue = tryConvertToPromise(promises);\n\n    if (!isObject(castValue)) {\n        return apiRejection(\"cannot await properties of a non-object\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    } else if (castValue instanceof Promise) {\n        ret = castValue._then(\n            Promise.props, undefined, undefined, undefined, undefined);\n    } else {\n        ret = new PropertiesPromiseArray(castValue).promise();\n    }\n\n    if (castValue instanceof Promise) {\n        ret._propagateFrom(castValue, 2);\n    }\n    return ret;\n}\n\nPromise.prototype.props = function () {\n    return props(this);\n};\n\nPromise.props = function (promises) {\n    return props(promises);\n};\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/props.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/queue.js":
/*!***************************************************!*\
  !*** ./node_modules/bluebird/js/release/queue.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\nfunction arrayMove(src, srcIndex, dst, dstIndex, len) {\n    for (var j = 0; j < len; ++j) {\n        dst[j + dstIndex] = src[j + srcIndex];\n        src[j + srcIndex] = void 0;\n    }\n}\n\nfunction Queue(capacity) {\n    this._capacity = capacity;\n    this._length = 0;\n    this._front = 0;\n}\n\nQueue.prototype._willBeOverCapacity = function (size) {\n    return this._capacity < size;\n};\n\nQueue.prototype._pushOne = function (arg) {\n    var length = this.length();\n    this._checkCapacity(length + 1);\n    var i = (this._front + length) & (this._capacity - 1);\n    this[i] = arg;\n    this._length = length + 1;\n};\n\nQueue.prototype.push = function (fn, receiver, arg) {\n    var length = this.length() + 3;\n    if (this._willBeOverCapacity(length)) {\n        this._pushOne(fn);\n        this._pushOne(receiver);\n        this._pushOne(arg);\n        return;\n    }\n    var j = this._front + length - 3;\n    this._checkCapacity(length);\n    var wrapMask = this._capacity - 1;\n    this[(j + 0) & wrapMask] = fn;\n    this[(j + 1) & wrapMask] = receiver;\n    this[(j + 2) & wrapMask] = arg;\n    this._length = length;\n};\n\nQueue.prototype.shift = function () {\n    var front = this._front,\n        ret = this[front];\n\n    this[front] = undefined;\n    this._front = (front + 1) & (this._capacity - 1);\n    this._length--;\n    return ret;\n};\n\nQueue.prototype.length = function () {\n    return this._length;\n};\n\nQueue.prototype._checkCapacity = function (size) {\n    if (this._capacity < size) {\n        this._resizeTo(this._capacity << 1);\n    }\n};\n\nQueue.prototype._resizeTo = function (capacity) {\n    var oldCapacity = this._capacity;\n    this._capacity = capacity;\n    var front = this._front;\n    var length = this._length;\n    var moveItemsCount = (front + length) & (oldCapacity - 1);\n    arrayMove(this, 0, this, oldCapacity, moveItemsCount);\n};\n\nmodule.exports = Queue;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/queue.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/race.js":
/*!**************************************************!*\
  !*** ./node_modules/bluebird/js/release/race.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = function(\n    Promise, INTERNAL, tryConvertToPromise, apiRejection) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\n\nvar raceLater = function (promise) {\n    return promise.then(function(array) {\n        return race(array, promise);\n    });\n};\n\nfunction race(promises, parent) {\n    var maybePromise = tryConvertToPromise(promises);\n\n    if (maybePromise instanceof Promise) {\n        return raceLater(maybePromise);\n    } else {\n        promises = util.asArray(promises);\n        if (promises === null)\n            return apiRejection(\"expecting an array or an iterable object but got \" + util.classString(promises));\n    }\n\n    var ret = new Promise(INTERNAL);\n    if (parent !== undefined) {\n        ret._propagateFrom(parent, 3);\n    }\n    var fulfill = ret._fulfill;\n    var reject = ret._reject;\n    for (var i = 0, len = promises.length; i < len; ++i) {\n        var val = promises[i];\n\n        if (val === undefined && !(i in promises)) {\n            continue;\n        }\n\n        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);\n    }\n    return ret;\n}\n\nPromise.race = function (promises) {\n    return race(promises, undefined);\n};\n\nPromise.prototype.race = function () {\n    return race(this, undefined);\n};\n\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/race.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/reduce.js":
/*!****************************************************!*\
  !*** ./node_modules/bluebird/js/release/reduce.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = function(Promise,\n                          PromiseArray,\n                          apiRejection,\n                          tryConvertToPromise,\n                          INTERNAL,\n                          debug) {\nvar getDomain = Promise._getDomain;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar tryCatch = util.tryCatch;\n\nfunction ReductionPromiseArray(promises, fn, initialValue, _each) {\n    this.constructor$(promises);\n    var domain = getDomain();\n    this._fn = domain === null ? fn : util.domainBind(domain, fn);\n    if (initialValue !== undefined) {\n        initialValue = Promise.resolve(initialValue);\n        initialValue._attachCancellationCallback(this);\n    }\n    this._initialValue = initialValue;\n    this._currentCancellable = null;\n    if(_each === INTERNAL) {\n        this._eachValues = Array(this._length);\n    } else if (_each === 0) {\n        this._eachValues = null;\n    } else {\n        this._eachValues = undefined;\n    }\n    this._promise._captureStackTrace();\n    this._init$(undefined, -5);\n}\nutil.inherits(ReductionPromiseArray, PromiseArray);\n\nReductionPromiseArray.prototype._gotAccum = function(accum) {\n    if (this._eachValues !== undefined && \n        this._eachValues !== null && \n        accum !== INTERNAL) {\n        this._eachValues.push(accum);\n    }\n};\n\nReductionPromiseArray.prototype._eachComplete = function(value) {\n    if (this._eachValues !== null) {\n        this._eachValues.push(value);\n    }\n    return this._eachValues;\n};\n\nReductionPromiseArray.prototype._init = function() {};\n\nReductionPromiseArray.prototype._resolveEmptyArray = function() {\n    this._resolve(this._eachValues !== undefined ? this._eachValues\n                                                 : this._initialValue);\n};\n\nReductionPromiseArray.prototype.shouldCopyValues = function () {\n    return false;\n};\n\nReductionPromiseArray.prototype._resolve = function(value) {\n    this._promise._resolveCallback(value);\n    this._values = null;\n};\n\nReductionPromiseArray.prototype._resultCancelled = function(sender) {\n    if (sender === this._initialValue) return this._cancel();\n    if (this._isResolved()) return;\n    this._resultCancelled$();\n    if (this._currentCancellable instanceof Promise) {\n        this._currentCancellable.cancel();\n    }\n    if (this._initialValue instanceof Promise) {\n        this._initialValue.cancel();\n    }\n};\n\nReductionPromiseArray.prototype._iterate = function (values) {\n    this._values = values;\n    var value;\n    var i;\n    var length = values.length;\n    if (this._initialValue !== undefined) {\n        value = this._initialValue;\n        i = 0;\n    } else {\n        value = Promise.resolve(values[0]);\n        i = 1;\n    }\n\n    this._currentCancellable = value;\n\n    if (!value.isRejected()) {\n        for (; i < length; ++i) {\n            var ctx = {\n                accum: null,\n                value: values[i],\n                index: i,\n                length: length,\n                array: this\n            };\n            value = value._then(gotAccum, undefined, undefined, ctx, undefined);\n        }\n    }\n\n    if (this._eachValues !== undefined) {\n        value = value\n            ._then(this._eachComplete, undefined, undefined, this, undefined);\n    }\n    value._then(completed, completed, undefined, value, this);\n};\n\nPromise.prototype.reduce = function (fn, initialValue) {\n    return reduce(this, fn, initialValue, null);\n};\n\nPromise.reduce = function (promises, fn, initialValue, _each) {\n    return reduce(promises, fn, initialValue, _each);\n};\n\nfunction completed(valueOrReason, array) {\n    if (this.isFulfilled()) {\n        array._resolve(valueOrReason);\n    } else {\n        array._reject(valueOrReason);\n    }\n}\n\nfunction reduce(promises, fn, initialValue, _each) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);\n    return array.promise();\n}\n\nfunction gotAccum(accum) {\n    this.accum = accum;\n    this.array._gotAccum(accum);\n    var value = tryConvertToPromise(this.value, this.array._promise);\n    if (value instanceof Promise) {\n        this.array._currentCancellable = value;\n        return value._then(gotValue, undefined, undefined, this, undefined);\n    } else {\n        return gotValue.call(this, value);\n    }\n}\n\nfunction gotValue(value) {\n    var array = this.array;\n    var promise = array._promise;\n    var fn = tryCatch(array._fn);\n    promise._pushContext();\n    var ret;\n    if (array._eachValues !== undefined) {\n        ret = fn.call(promise._boundValue(), value, this.index, this.length);\n    } else {\n        ret = fn.call(promise._boundValue(),\n                              this.accum, value, this.index, this.length);\n    }\n    if (ret instanceof Promise) {\n        array._currentCancellable = ret;\n    }\n    var promiseCreated = promise._popContext();\n    debug.checkForgottenReturns(\n        ret,\n        promiseCreated,\n        array._eachValues !== undefined ? \"Promise.each\" : \"Promise.reduce\",\n        promise\n    );\n    return ret;\n}\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/reduce.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/schedule.js":
/*!******************************************************!*\
  !*** ./node_modules/bluebird/js/release/schedule.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar schedule;\nvar noAsyncScheduler = function() {\n    throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n};\nvar NativePromise = util.getNativePromise();\nif (util.isNode && typeof MutationObserver === \"undefined\") {\n    var GlobalSetImmediate = global.setImmediate;\n    var ProcessNextTick = process.nextTick;\n    schedule = util.isRecentNode\n                ? function(fn) { GlobalSetImmediate.call(global, fn); }\n                : function(fn) { ProcessNextTick.call(process, fn); };\n} else if (typeof NativePromise === \"function\" &&\n           typeof NativePromise.resolve === \"function\") {\n    var nativePromise = NativePromise.resolve();\n    schedule = function(fn) {\n        nativePromise.then(fn);\n    };\n} else if ((typeof MutationObserver !== \"undefined\") &&\n          !(typeof window !== \"undefined\" &&\n            window.navigator &&\n            (window.navigator.standalone || window.cordova))) {\n    schedule = (function() {\n        var div = document.createElement(\"div\");\n        var opts = {attributes: true};\n        var toggleScheduled = false;\n        var div2 = document.createElement(\"div\");\n        var o2 = new MutationObserver(function() {\n            div.classList.toggle(\"foo\");\n            toggleScheduled = false;\n        });\n        o2.observe(div2, opts);\n\n        var scheduleToggle = function() {\n            if (toggleScheduled) return;\n                toggleScheduled = true;\n                div2.classList.toggle(\"foo\");\n            };\n\n            return function schedule(fn) {\n            var o = new MutationObserver(function() {\n                o.disconnect();\n                fn();\n            });\n            o.observe(div, opts);\n            scheduleToggle();\n        };\n    })();\n} else if (typeof setImmediate !== \"undefined\") {\n    schedule = function (fn) {\n        setImmediate(fn);\n    };\n} else if (typeof setTimeout !== \"undefined\") {\n    schedule = function (fn) {\n        setTimeout(fn, 0);\n    };\n} else {\n    schedule = noAsyncScheduler;\n}\nmodule.exports = schedule;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/schedule.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/settle.js":
/*!****************************************************!*\
  !*** ./node_modules/bluebird/js/release/settle.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports =\n    function(Promise, PromiseArray, debug) {\nvar PromiseInspection = Promise.PromiseInspection;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\n\nfunction SettledPromiseArray(values) {\n    this.constructor$(values);\n}\nutil.inherits(SettledPromiseArray, PromiseArray);\n\nSettledPromiseArray.prototype._promiseResolved = function (index, inspection) {\n    this._values[index] = inspection;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        this._resolve(this._values);\n        return true;\n    }\n    return false;\n};\n\nSettledPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var ret = new PromiseInspection();\n    ret._bitField = 33554432;\n    ret._settledValueField = value;\n    return this._promiseResolved(index, ret);\n};\nSettledPromiseArray.prototype._promiseRejected = function (reason, index) {\n    var ret = new PromiseInspection();\n    ret._bitField = 16777216;\n    ret._settledValueField = reason;\n    return this._promiseResolved(index, ret);\n};\n\nPromise.settle = function (promises) {\n    debug.deprecated(\".settle()\", \".reflect()\");\n    return new SettledPromiseArray(promises).promise();\n};\n\nPromise.prototype.settle = function () {\n    return Promise.settle(this);\n};\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/settle.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/some.js":
/*!**************************************************!*\
  !*** ./node_modules/bluebird/js/release/some.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports =\nfunction(Promise, PromiseArray, apiRejection) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar RangeError = __webpack_require__(/*! ./errors */ \"./node_modules/bluebird/js/release/errors.js\").RangeError;\nvar AggregateError = __webpack_require__(/*! ./errors */ \"./node_modules/bluebird/js/release/errors.js\").AggregateError;\nvar isArray = util.isArray;\nvar CANCELLATION = {};\n\n\nfunction SomePromiseArray(values) {\n    this.constructor$(values);\n    this._howMany = 0;\n    this._unwrap = false;\n    this._initialized = false;\n}\nutil.inherits(SomePromiseArray, PromiseArray);\n\nSomePromiseArray.prototype._init = function () {\n    if (!this._initialized) {\n        return;\n    }\n    if (this._howMany === 0) {\n        this._resolve([]);\n        return;\n    }\n    this._init$(undefined, -5);\n    var isArrayResolved = isArray(this._values);\n    if (!this._isResolved() &&\n        isArrayResolved &&\n        this._howMany > this._canPossiblyFulfill()) {\n        this._reject(this._getRangeError(this.length()));\n    }\n};\n\nSomePromiseArray.prototype.init = function () {\n    this._initialized = true;\n    this._init();\n};\n\nSomePromiseArray.prototype.setUnwrap = function () {\n    this._unwrap = true;\n};\n\nSomePromiseArray.prototype.howMany = function () {\n    return this._howMany;\n};\n\nSomePromiseArray.prototype.setHowMany = function (count) {\n    this._howMany = count;\n};\n\nSomePromiseArray.prototype._promiseFulfilled = function (value) {\n    this._addFulfilled(value);\n    if (this._fulfilled() === this.howMany()) {\n        this._values.length = this.howMany();\n        if (this.howMany() === 1 && this._unwrap) {\n            this._resolve(this._values[0]);\n        } else {\n            this._resolve(this._values);\n        }\n        return true;\n    }\n    return false;\n\n};\nSomePromiseArray.prototype._promiseRejected = function (reason) {\n    this._addRejected(reason);\n    return this._checkOutcome();\n};\n\nSomePromiseArray.prototype._promiseCancelled = function () {\n    if (this._values instanceof Promise || this._values == null) {\n        return this._cancel();\n    }\n    this._addRejected(CANCELLATION);\n    return this._checkOutcome();\n};\n\nSomePromiseArray.prototype._checkOutcome = function() {\n    if (this.howMany() > this._canPossiblyFulfill()) {\n        var e = new AggregateError();\n        for (var i = this.length(); i < this._values.length; ++i) {\n            if (this._values[i] !== CANCELLATION) {\n                e.push(this._values[i]);\n            }\n        }\n        if (e.length > 0) {\n            this._reject(e);\n        } else {\n            this._cancel();\n        }\n        return true;\n    }\n    return false;\n};\n\nSomePromiseArray.prototype._fulfilled = function () {\n    return this._totalResolved;\n};\n\nSomePromiseArray.prototype._rejected = function () {\n    return this._values.length - this.length();\n};\n\nSomePromiseArray.prototype._addRejected = function (reason) {\n    this._values.push(reason);\n};\n\nSomePromiseArray.prototype._addFulfilled = function (value) {\n    this._values[this._totalResolved++] = value;\n};\n\nSomePromiseArray.prototype._canPossiblyFulfill = function () {\n    return this.length() - this._rejected();\n};\n\nSomePromiseArray.prototype._getRangeError = function (count) {\n    var message = \"Input array must contain at least \" +\n            this._howMany + \" items but contains only \" + count + \" items\";\n    return new RangeError(message);\n};\n\nSomePromiseArray.prototype._resolveEmptyArray = function () {\n    this._reject(this._getRangeError(0));\n};\n\nfunction some(promises, howMany) {\n    if ((howMany | 0) !== howMany || howMany < 0) {\n        return apiRejection(\"expecting a positive integer\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    var ret = new SomePromiseArray(promises);\n    var promise = ret.promise();\n    ret.setHowMany(howMany);\n    ret.init();\n    return promise;\n}\n\nPromise.some = function (promises, howMany) {\n    return some(promises, howMany);\n};\n\nPromise.prototype.some = function (howMany) {\n    return some(this, howMany);\n};\n\nPromise._SomePromiseArray = SomePromiseArray;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/some.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/synchronous_inspection.js":
/*!********************************************************************!*\
  !*** ./node_modules/bluebird/js/release/synchronous_inspection.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function(Promise) {\nfunction PromiseInspection(promise) {\n    if (promise !== undefined) {\n        promise = promise._target();\n        this._bitField = promise._bitField;\n        this._settledValueField = promise._isFateSealed()\n            ? promise._settledValue() : undefined;\n    }\n    else {\n        this._bitField = 0;\n        this._settledValueField = undefined;\n    }\n}\n\nPromiseInspection.prototype._settledValue = function() {\n    return this._settledValueField;\n};\n\nvar value = PromiseInspection.prototype.value = function () {\n    if (!this.isFulfilled()) {\n        throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    return this._settledValue();\n};\n\nvar reason = PromiseInspection.prototype.error =\nPromiseInspection.prototype.reason = function () {\n    if (!this.isRejected()) {\n        throw new TypeError(\"cannot get rejection reason of a non-rejected promise\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    return this._settledValue();\n};\n\nvar isFulfilled = PromiseInspection.prototype.isFulfilled = function() {\n    return (this._bitField & 33554432) !== 0;\n};\n\nvar isRejected = PromiseInspection.prototype.isRejected = function () {\n    return (this._bitField & 16777216) !== 0;\n};\n\nvar isPending = PromiseInspection.prototype.isPending = function () {\n    return (this._bitField & 50397184) === 0;\n};\n\nvar isResolved = PromiseInspection.prototype.isResolved = function () {\n    return (this._bitField & 50331648) !== 0;\n};\n\nPromiseInspection.prototype.isCancelled = function() {\n    return (this._bitField & 8454144) !== 0;\n};\n\nPromise.prototype.__isCancelled = function() {\n    return (this._bitField & 65536) === 65536;\n};\n\nPromise.prototype._isCancelled = function() {\n    return this._target().__isCancelled();\n};\n\nPromise.prototype.isCancelled = function() {\n    return (this._target()._bitField & 8454144) !== 0;\n};\n\nPromise.prototype.isPending = function() {\n    return isPending.call(this._target());\n};\n\nPromise.prototype.isRejected = function() {\n    return isRejected.call(this._target());\n};\n\nPromise.prototype.isFulfilled = function() {\n    return isFulfilled.call(this._target());\n};\n\nPromise.prototype.isResolved = function() {\n    return isResolved.call(this._target());\n};\n\nPromise.prototype.value = function() {\n    return value.call(this._target());\n};\n\nPromise.prototype.reason = function() {\n    var target = this._target();\n    target._unsetRejectionIsUnhandled();\n    return reason.call(target);\n};\n\nPromise.prototype._value = function() {\n    return this._settledValue();\n};\n\nPromise.prototype._reason = function() {\n    this._unsetRejectionIsUnhandled();\n    return this._settledValue();\n};\n\nPromise.PromiseInspection = PromiseInspection;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/synchronous_inspection.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/thenables.js":
/*!*******************************************************!*\
  !*** ./node_modules/bluebird/js/release/thenables.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar errorObj = util.errorObj;\nvar isObject = util.isObject;\n\nfunction tryConvertToPromise(obj, context) {\n    if (isObject(obj)) {\n        if (obj instanceof Promise) return obj;\n        var then = getThen(obj);\n        if (then === errorObj) {\n            if (context) context._pushContext();\n            var ret = Promise.reject(then.e);\n            if (context) context._popContext();\n            return ret;\n        } else if (typeof then === \"function\") {\n            if (isAnyBluebirdPromise(obj)) {\n                var ret = new Promise(INTERNAL);\n                obj._then(\n                    ret._fulfill,\n                    ret._reject,\n                    undefined,\n                    ret,\n                    null\n                );\n                return ret;\n            }\n            return doThenable(obj, then, context);\n        }\n    }\n    return obj;\n}\n\nfunction doGetThen(obj) {\n    return obj.then;\n}\n\nfunction getThen(obj) {\n    try {\n        return doGetThen(obj);\n    } catch (e) {\n        errorObj.e = e;\n        return errorObj;\n    }\n}\n\nvar hasProp = {}.hasOwnProperty;\nfunction isAnyBluebirdPromise(obj) {\n    try {\n        return hasProp.call(obj, \"_promise0\");\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction doThenable(x, then, context) {\n    var promise = new Promise(INTERNAL);\n    var ret = promise;\n    if (context) context._pushContext();\n    promise._captureStackTrace();\n    if (context) context._popContext();\n    var synchronous = true;\n    var result = util.tryCatch(then).call(x, resolve, reject);\n    synchronous = false;\n\n    if (promise && result === errorObj) {\n        promise._rejectCallback(result.e, true, true);\n        promise = null;\n    }\n\n    function resolve(value) {\n        if (!promise) return;\n        promise._resolveCallback(value);\n        promise = null;\n    }\n\n    function reject(reason) {\n        if (!promise) return;\n        promise._rejectCallback(reason, synchronous, true);\n        promise = null;\n    }\n    return ret;\n}\n\nreturn tryConvertToPromise;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/thenables.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/timers.js":
/*!****************************************************!*\
  !*** ./node_modules/bluebird/js/release/timers.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL, debug) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar TimeoutError = Promise.TimeoutError;\n\nfunction HandleWrapper(handle)  {\n    this.handle = handle;\n}\n\nHandleWrapper.prototype._resultCancelled = function() {\n    clearTimeout(this.handle);\n};\n\nvar afterValue = function(value) { return delay(+this).thenReturn(value); };\nvar delay = Promise.delay = function (ms, value) {\n    var ret;\n    var handle;\n    if (value !== undefined) {\n        ret = Promise.resolve(value)\n                ._then(afterValue, null, null, ms, undefined);\n        if (debug.cancellation() && value instanceof Promise) {\n            ret._setOnCancel(value);\n        }\n    } else {\n        ret = new Promise(INTERNAL);\n        handle = setTimeout(function() { ret._fulfill(); }, +ms);\n        if (debug.cancellation()) {\n            ret._setOnCancel(new HandleWrapper(handle));\n        }\n        ret._captureStackTrace();\n    }\n    ret._setAsyncGuaranteed();\n    return ret;\n};\n\nPromise.prototype.delay = function (ms) {\n    return delay(ms, this);\n};\n\nvar afterTimeout = function (promise, message, parent) {\n    var err;\n    if (typeof message !== \"string\") {\n        if (message instanceof Error) {\n            err = message;\n        } else {\n            err = new TimeoutError(\"operation timed out\");\n        }\n    } else {\n        err = new TimeoutError(message);\n    }\n    util.markAsOriginatingFromRejection(err);\n    promise._attachExtraTrace(err);\n    promise._reject(err);\n\n    if (parent != null) {\n        parent.cancel();\n    }\n};\n\nfunction successClear(value) {\n    clearTimeout(this.handle);\n    return value;\n}\n\nfunction failureClear(reason) {\n    clearTimeout(this.handle);\n    throw reason;\n}\n\nPromise.prototype.timeout = function (ms, message) {\n    ms = +ms;\n    var ret, parent;\n\n    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {\n        if (ret.isPending()) {\n            afterTimeout(ret, message, parent);\n        }\n    }, ms));\n\n    if (debug.cancellation()) {\n        parent = this.then();\n        ret = parent._then(successClear, failureClear,\n                            undefined, handleWrapper, undefined);\n        ret._setOnCancel(handleWrapper);\n    } else {\n        ret = this._then(successClear, failureClear,\n                            undefined, handleWrapper, undefined);\n    }\n\n    return ret;\n};\n\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/timers.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/using.js":
/*!***************************************************!*\
  !*** ./node_modules/bluebird/js/release/using.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = function (Promise, apiRejection, tryConvertToPromise,\n    createContext, INTERNAL, debug) {\n    var util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\n    var TypeError = __webpack_require__(/*! ./errors */ \"./node_modules/bluebird/js/release/errors.js\").TypeError;\n    var inherits = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\").inherits;\n    var errorObj = util.errorObj;\n    var tryCatch = util.tryCatch;\n    var NULL = {};\n\n    function thrower(e) {\n        setTimeout(function(){throw e;}, 0);\n    }\n\n    function castPreservingDisposable(thenable) {\n        var maybePromise = tryConvertToPromise(thenable);\n        if (maybePromise !== thenable &&\n            typeof thenable._isDisposable === \"function\" &&\n            typeof thenable._getDisposer === \"function\" &&\n            thenable._isDisposable()) {\n            maybePromise._setDisposable(thenable._getDisposer());\n        }\n        return maybePromise;\n    }\n    function dispose(resources, inspection) {\n        var i = 0;\n        var len = resources.length;\n        var ret = new Promise(INTERNAL);\n        function iterator() {\n            if (i >= len) return ret._fulfill();\n            var maybePromise = castPreservingDisposable(resources[i++]);\n            if (maybePromise instanceof Promise &&\n                maybePromise._isDisposable()) {\n                try {\n                    maybePromise = tryConvertToPromise(\n                        maybePromise._getDisposer().tryDispose(inspection),\n                        resources.promise);\n                } catch (e) {\n                    return thrower(e);\n                }\n                if (maybePromise instanceof Promise) {\n                    return maybePromise._then(iterator, thrower,\n                                              null, null, null);\n                }\n            }\n            iterator();\n        }\n        iterator();\n        return ret;\n    }\n\n    function Disposer(data, promise, context) {\n        this._data = data;\n        this._promise = promise;\n        this._context = context;\n    }\n\n    Disposer.prototype.data = function () {\n        return this._data;\n    };\n\n    Disposer.prototype.promise = function () {\n        return this._promise;\n    };\n\n    Disposer.prototype.resource = function () {\n        if (this.promise().isFulfilled()) {\n            return this.promise().value();\n        }\n        return NULL;\n    };\n\n    Disposer.prototype.tryDispose = function(inspection) {\n        var resource = this.resource();\n        var context = this._context;\n        if (context !== undefined) context._pushContext();\n        var ret = resource !== NULL\n            ? this.doDispose(resource, inspection) : null;\n        if (context !== undefined) context._popContext();\n        this._promise._unsetDisposable();\n        this._data = null;\n        return ret;\n    };\n\n    Disposer.isDisposer = function (d) {\n        return (d != null &&\n                typeof d.resource === \"function\" &&\n                typeof d.tryDispose === \"function\");\n    };\n\n    function FunctionDisposer(fn, promise, context) {\n        this.constructor$(fn, promise, context);\n    }\n    inherits(FunctionDisposer, Disposer);\n\n    FunctionDisposer.prototype.doDispose = function (resource, inspection) {\n        var fn = this.data();\n        return fn.call(resource, resource, inspection);\n    };\n\n    function maybeUnwrapDisposer(value) {\n        if (Disposer.isDisposer(value)) {\n            this.resources[this.index]._setDisposable(value);\n            return value.promise();\n        }\n        return value;\n    }\n\n    function ResourceList(length) {\n        this.length = length;\n        this.promise = null;\n        this[length-1] = null;\n    }\n\n    ResourceList.prototype._resultCancelled = function() {\n        var len = this.length;\n        for (var i = 0; i < len; ++i) {\n            var item = this[i];\n            if (item instanceof Promise) {\n                item.cancel();\n            }\n        }\n    };\n\n    Promise.using = function () {\n        var len = arguments.length;\n        if (len < 2) return apiRejection(\n                        \"you must pass at least 2 arguments to Promise.using\");\n        var fn = arguments[len - 1];\n        if (typeof fn !== \"function\") {\n            return apiRejection(\"expecting a function but got \" + util.classString(fn));\n        }\n        var input;\n        var spreadArgs = true;\n        if (len === 2 && Array.isArray(arguments[0])) {\n            input = arguments[0];\n            len = input.length;\n            spreadArgs = false;\n        } else {\n            input = arguments;\n            len--;\n        }\n        var resources = new ResourceList(len);\n        for (var i = 0; i < len; ++i) {\n            var resource = input[i];\n            if (Disposer.isDisposer(resource)) {\n                var disposer = resource;\n                resource = resource.promise();\n                resource._setDisposable(disposer);\n            } else {\n                var maybePromise = tryConvertToPromise(resource);\n                if (maybePromise instanceof Promise) {\n                    resource =\n                        maybePromise._then(maybeUnwrapDisposer, null, null, {\n                            resources: resources,\n                            index: i\n                    }, undefined);\n                }\n            }\n            resources[i] = resource;\n        }\n\n        var reflectedResources = new Array(resources.length);\n        for (var i = 0; i < reflectedResources.length; ++i) {\n            reflectedResources[i] = Promise.resolve(resources[i]).reflect();\n        }\n\n        var resultPromise = Promise.all(reflectedResources)\n            .then(function(inspections) {\n                for (var i = 0; i < inspections.length; ++i) {\n                    var inspection = inspections[i];\n                    if (inspection.isRejected()) {\n                        errorObj.e = inspection.error();\n                        return errorObj;\n                    } else if (!inspection.isFulfilled()) {\n                        resultPromise.cancel();\n                        return;\n                    }\n                    inspections[i] = inspection.value();\n                }\n                promise._pushContext();\n\n                fn = tryCatch(fn);\n                var ret = spreadArgs\n                    ? fn.apply(undefined, inspections) : fn(inspections);\n                var promiseCreated = promise._popContext();\n                debug.checkForgottenReturns(\n                    ret, promiseCreated, \"Promise.using\", promise);\n                return ret;\n            });\n\n        var promise = resultPromise.lastly(function() {\n            var inspection = new Promise.PromiseInspection(resultPromise);\n            return dispose(resources, inspection);\n        });\n        resources.promise = promise;\n        promise._setOnCancel(resources);\n        return promise;\n    };\n\n    Promise.prototype._setDisposable = function (disposer) {\n        this._bitField = this._bitField | 131072;\n        this._disposer = disposer;\n    };\n\n    Promise.prototype._isDisposable = function () {\n        return (this._bitField & 131072) > 0;\n    };\n\n    Promise.prototype._getDisposer = function () {\n        return this._disposer;\n    };\n\n    Promise.prototype._unsetDisposable = function () {\n        this._bitField = this._bitField & (~131072);\n        this._disposer = undefined;\n    };\n\n    Promise.prototype.disposer = function (fn) {\n        if (typeof fn === \"function\") {\n            return new FunctionDisposer(fn, this, createContext());\n        }\n        throw new TypeError();\n    };\n\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/using.js?");

/***/ }),

/***/ "./node_modules/bluebird/js/release/util.js":
/*!**************************************************!*\
  !*** ./node_modules/bluebird/js/release/util.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar es5 = __webpack_require__(/*! ./es5 */ \"./node_modules/bluebird/js/release/es5.js\");\nvar canEvaluate = typeof navigator == \"undefined\";\n\nvar errorObj = {e: {}};\nvar tryCatchTarget;\nvar globalObject = typeof self !== \"undefined\" ? self :\n    typeof window !== \"undefined\" ? window :\n    typeof global !== \"undefined\" ? global :\n    this !== undefined ? this : null;\n\nfunction tryCatcher() {\n    try {\n        var target = tryCatchTarget;\n        tryCatchTarget = null;\n        return target.apply(this, arguments);\n    } catch (e) {\n        errorObj.e = e;\n        return errorObj;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\n\nvar inherits = function(Child, Parent) {\n    var hasProp = {}.hasOwnProperty;\n\n    function T() {\n        this.constructor = Child;\n        this.constructor$ = Parent;\n        for (var propertyName in Parent.prototype) {\n            if (hasProp.call(Parent.prototype, propertyName) &&\n                propertyName.charAt(propertyName.length-1) !== \"$\"\n           ) {\n                this[propertyName + \"$\"] = Parent.prototype[propertyName];\n            }\n        }\n    }\n    T.prototype = Parent.prototype;\n    Child.prototype = new T();\n    return Child.prototype;\n};\n\n\nfunction isPrimitive(val) {\n    return val == null || val === true || val === false ||\n        typeof val === \"string\" || typeof val === \"number\";\n\n}\n\nfunction isObject(value) {\n    return typeof value === \"function\" ||\n           typeof value === \"object\" && value !== null;\n}\n\nfunction maybeWrapAsError(maybeError) {\n    if (!isPrimitive(maybeError)) return maybeError;\n\n    return new Error(safeToString(maybeError));\n}\n\nfunction withAppended(target, appendee) {\n    var len = target.length;\n    var ret = new Array(len + 1);\n    var i;\n    for (i = 0; i < len; ++i) {\n        ret[i] = target[i];\n    }\n    ret[i] = appendee;\n    return ret;\n}\n\nfunction getDataPropertyOrDefault(obj, key, defaultValue) {\n    if (es5.isES5) {\n        var desc = Object.getOwnPropertyDescriptor(obj, key);\n\n        if (desc != null) {\n            return desc.get == null && desc.set == null\n                    ? desc.value\n                    : defaultValue;\n        }\n    } else {\n        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;\n    }\n}\n\nfunction notEnumerableProp(obj, name, value) {\n    if (isPrimitive(obj)) return obj;\n    var descriptor = {\n        value: value,\n        configurable: true,\n        enumerable: false,\n        writable: true\n    };\n    es5.defineProperty(obj, name, descriptor);\n    return obj;\n}\n\nfunction thrower(r) {\n    throw r;\n}\n\nvar inheritedDataKeys = (function() {\n    var excludedPrototypes = [\n        Array.prototype,\n        Object.prototype,\n        Function.prototype\n    ];\n\n    var isExcludedProto = function(val) {\n        for (var i = 0; i < excludedPrototypes.length; ++i) {\n            if (excludedPrototypes[i] === val) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    if (es5.isES5) {\n        var getKeys = Object.getOwnPropertyNames;\n        return function(obj) {\n            var ret = [];\n            var visitedKeys = Object.create(null);\n            while (obj != null && !isExcludedProto(obj)) {\n                var keys;\n                try {\n                    keys = getKeys(obj);\n                } catch (e) {\n                    return ret;\n                }\n                for (var i = 0; i < keys.length; ++i) {\n                    var key = keys[i];\n                    if (visitedKeys[key]) continue;\n                    visitedKeys[key] = true;\n                    var desc = Object.getOwnPropertyDescriptor(obj, key);\n                    if (desc != null && desc.get == null && desc.set == null) {\n                        ret.push(key);\n                    }\n                }\n                obj = es5.getPrototypeOf(obj);\n            }\n            return ret;\n        };\n    } else {\n        var hasProp = {}.hasOwnProperty;\n        return function(obj) {\n            if (isExcludedProto(obj)) return [];\n            var ret = [];\n\n            /*jshint forin:false */\n            enumeration: for (var key in obj) {\n                if (hasProp.call(obj, key)) {\n                    ret.push(key);\n                } else {\n                    for (var i = 0; i < excludedPrototypes.length; ++i) {\n                        if (hasProp.call(excludedPrototypes[i], key)) {\n                            continue enumeration;\n                        }\n                    }\n                    ret.push(key);\n                }\n            }\n            return ret;\n        };\n    }\n\n})();\n\nvar thisAssignmentPattern = /this\\s*\\.\\s*\\S+\\s*=/;\nfunction isClass(fn) {\n    try {\n        if (typeof fn === \"function\") {\n            var keys = es5.names(fn.prototype);\n\n            var hasMethods = es5.isES5 && keys.length > 1;\n            var hasMethodsOtherThanConstructor = keys.length > 0 &&\n                !(keys.length === 1 && keys[0] === \"constructor\");\n            var hasThisAssignmentAndStaticMethods =\n                thisAssignmentPattern.test(fn + \"\") && es5.names(fn).length > 0;\n\n            if (hasMethods || hasMethodsOtherThanConstructor ||\n                hasThisAssignmentAndStaticMethods) {\n                return true;\n            }\n        }\n        return false;\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction toFastProperties(obj) {\n    /*jshint -W027,-W055,-W031*/\n    function FakeConstructor() {}\n    FakeConstructor.prototype = obj;\n    var l = 8;\n    while (l--) new FakeConstructor();\n    return obj;\n    eval(obj);\n}\n\nvar rident = /^[a-z$_][a-z$_0-9]*$/i;\nfunction isIdentifier(str) {\n    return rident.test(str);\n}\n\nfunction filledRange(count, prefix, suffix) {\n    var ret = new Array(count);\n    for(var i = 0; i < count; ++i) {\n        ret[i] = prefix + i + suffix;\n    }\n    return ret;\n}\n\nfunction safeToString(obj) {\n    try {\n        return obj + \"\";\n    } catch (e) {\n        return \"[no string representation]\";\n    }\n}\n\nfunction isError(obj) {\n    return obj !== null &&\n           typeof obj === \"object\" &&\n           typeof obj.message === \"string\" &&\n           typeof obj.name === \"string\";\n}\n\nfunction markAsOriginatingFromRejection(e) {\n    try {\n        notEnumerableProp(e, \"isOperational\", true);\n    }\n    catch(ignore) {}\n}\n\nfunction originatesFromRejection(e) {\n    if (e == null) return false;\n    return ((e instanceof Error[\"__BluebirdErrorTypes__\"].OperationalError) ||\n        e[\"isOperational\"] === true);\n}\n\nfunction canAttachTrace(obj) {\n    return isError(obj) && es5.propertyIsWritable(obj, \"stack\");\n}\n\nvar ensureErrorObject = (function() {\n    if (!(\"stack\" in new Error())) {\n        return function(value) {\n            if (canAttachTrace(value)) return value;\n            try {throw new Error(safeToString(value));}\n            catch(err) {return err;}\n        };\n    } else {\n        return function(value) {\n            if (canAttachTrace(value)) return value;\n            return new Error(safeToString(value));\n        };\n    }\n})();\n\nfunction classString(obj) {\n    return {}.toString.call(obj);\n}\n\nfunction copyDescriptors(from, to, filter) {\n    var keys = es5.names(from);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        if (filter(key)) {\n            try {\n                es5.defineProperty(to, key, es5.getDescriptor(from, key));\n            } catch (ignore) {}\n        }\n    }\n}\n\nvar asArray = function(v) {\n    if (es5.isArray(v)) {\n        return v;\n    }\n    return null;\n};\n\nif (typeof Symbol !== \"undefined\" && Symbol.iterator) {\n    var ArrayFrom = typeof Array.from === \"function\" ? function(v) {\n        return Array.from(v);\n    } : function(v) {\n        var ret = [];\n        var it = v[Symbol.iterator]();\n        var itResult;\n        while (!((itResult = it.next()).done)) {\n            ret.push(itResult.value);\n        }\n        return ret;\n    };\n\n    asArray = function(v) {\n        if (es5.isArray(v)) {\n            return v;\n        } else if (v != null && typeof v[Symbol.iterator] === \"function\") {\n            return ArrayFrom(v);\n        }\n        return null;\n    };\n}\n\nvar isNode = typeof process !== \"undefined\" &&\n        classString(process).toLowerCase() === \"[object process]\";\n\nvar hasEnvVariables = typeof process !== \"undefined\" &&\n    typeof process.env !== \"undefined\";\n\nfunction env(key) {\n    return hasEnvVariables ? process.env[key] : undefined;\n}\n\nfunction getNativePromise() {\n    if (typeof Promise === \"function\") {\n        try {\n            var promise = new Promise(function(){});\n            if ({}.toString.call(promise) === \"[object Promise]\") {\n                return Promise;\n            }\n        } catch (e) {}\n    }\n}\n\nfunction domainBind(self, cb) {\n    return self.bind(cb);\n}\n\nvar ret = {\n    isClass: isClass,\n    isIdentifier: isIdentifier,\n    inheritedDataKeys: inheritedDataKeys,\n    getDataPropertyOrDefault: getDataPropertyOrDefault,\n    thrower: thrower,\n    isArray: es5.isArray,\n    asArray: asArray,\n    notEnumerableProp: notEnumerableProp,\n    isPrimitive: isPrimitive,\n    isObject: isObject,\n    isError: isError,\n    canEvaluate: canEvaluate,\n    errorObj: errorObj,\n    tryCatch: tryCatch,\n    inherits: inherits,\n    withAppended: withAppended,\n    maybeWrapAsError: maybeWrapAsError,\n    toFastProperties: toFastProperties,\n    filledRange: filledRange,\n    toString: safeToString,\n    canAttachTrace: canAttachTrace,\n    ensureErrorObject: ensureErrorObject,\n    originatesFromRejection: originatesFromRejection,\n    markAsOriginatingFromRejection: markAsOriginatingFromRejection,\n    classString: classString,\n    copyDescriptors: copyDescriptors,\n    hasDevTools: typeof chrome !== \"undefined\" && chrome &&\n                 typeof chrome.loadTimes === \"function\",\n    isNode: isNode,\n    hasEnvVariables: hasEnvVariables,\n    env: env,\n    global: globalObject,\n    getNativePromise: getNativePromise,\n    domainBind: domainBind\n};\nret.isRecentNode = ret.isNode && (function() {\n    var version = process.versions.node.split(\".\").map(Number);\n    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);\n})();\n\nif (ret.isNode) ret.toFastProperties(process);\n\ntry {throw new Error(); } catch (e) {ret.lastLineError = e;}\nmodule.exports = ret;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bluebird/js/release/util.js?");

/***/ }),

/***/ "./node_modules/brace-expansion/index.js":
/*!***********************************************!*\
  !*** ./node_modules/brace-expansion/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var concatMap = __webpack_require__(/*! concat-map */ \"./node_modules/concat-map/index.js\");\nvar balanced = __webpack_require__(/*! balanced-match */ \"./node_modules/balanced-match/index.js\");\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/brace-expansion/index.js?");

/***/ }),

/***/ "./node_modules/bser/index.js":
/*!************************************!*\
  !*** ./node_modules/bser/index.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* Copyright 2015-present Facebook, Inc.\n * Licensed under the Apache License, Version 2.0 */\n\nvar EE = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar util = __webpack_require__(/*! util */ \"util\");\nvar os = __webpack_require__(/*! os */ \"os\");\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar Int64 = __webpack_require__(/*! node-int64 */ \"./node_modules/node-int64/Int64.js\");\n\n// BSER uses the local endianness to reduce byte swapping overheads\n// (the protocol is expressly local IPC only).  We need to tell node\n// to use the native endianness when reading various native values.\nvar isBigEndian = os.endianness() == 'BE';\n\n// Find the next power-of-2 >= size\nfunction nextPow2(size) {\n  return Math.pow(2, Math.ceil(Math.log(size) / Math.LN2));\n}\n\n// Expandable buffer that we can provide a size hint for\nfunction Accumulator(initsize) {\n  this.buf = Buffer.alloc(nextPow2(initsize || 8192));\n  this.readOffset = 0;\n  this.writeOffset = 0;\n}\n// For testing\nexports.Accumulator = Accumulator\n\n// How much we can write into this buffer without allocating\nAccumulator.prototype.writeAvail = function() {\n  return this.buf.length - this.writeOffset;\n}\n\n// How much we can read\nAccumulator.prototype.readAvail = function() {\n  return this.writeOffset - this.readOffset;\n}\n\n// Ensure that we have enough space for size bytes\nAccumulator.prototype.reserve = function(size) {\n  if (size < this.writeAvail()) {\n    return;\n  }\n\n  // If we can make room by shunting down, do so\n  if (this.readOffset > 0) {\n    this.buf.copy(this.buf, 0, this.readOffset, this.writeOffset);\n    this.writeOffset -= this.readOffset;\n    this.readOffset = 0;\n  }\n\n  // If we made enough room, no need to allocate more\n  if (size < this.writeAvail()) {\n    return;\n  }\n\n  // Allocate a replacement and copy it in\n  var buf = Buffer.alloc(nextPow2(this.buf.length + size - this.writeAvail()));\n  this.buf.copy(buf);\n  this.buf = buf;\n}\n\n// Append buffer or string.  Will resize as needed\nAccumulator.prototype.append = function(buf) {\n  if (Buffer.isBuffer(buf)) {\n    this.reserve(buf.length);\n    buf.copy(this.buf, this.writeOffset, 0, buf.length);\n    this.writeOffset += buf.length;\n  } else {\n    var size = Buffer.byteLength(buf);\n    this.reserve(size);\n    this.buf.write(buf, this.writeOffset);\n    this.writeOffset += size;\n  }\n}\n\nAccumulator.prototype.assertReadableSize = function(size) {\n  if (this.readAvail() < size) {\n    throw new Error(\"wanted to read \" + size +\n        \" bytes but only have \" + this.readAvail());\n  }\n}\n\nAccumulator.prototype.peekString = function(size) {\n  this.assertReadableSize(size);\n  return this.buf.toString('utf-8', this.readOffset, this.readOffset + size);\n}\n\nAccumulator.prototype.readString = function(size) {\n  var str = this.peekString(size);\n  this.readOffset += size;\n  return str;\n}\n\nAccumulator.prototype.peekInt = function(size) {\n  this.assertReadableSize(size);\n  switch (size) {\n    case 1:\n      return this.buf.readInt8(this.readOffset, size);\n    case 2:\n      return isBigEndian ?\n        this.buf.readInt16BE(this.readOffset, size) :\n        this.buf.readInt16LE(this.readOffset, size);\n    case 4:\n      return isBigEndian ?\n        this.buf.readInt32BE(this.readOffset, size) :\n        this.buf.readInt32LE(this.readOffset, size);\n    case 8:\n        var big = this.buf.slice(this.readOffset, this.readOffset + 8);\n        if (isBigEndian) {\n          // On a big endian system we can simply pass the buffer directly\n          return new Int64(big);\n        }\n        // Otherwise we need to byteswap\n        return new Int64(byteswap64(big));\n    default:\n      throw new Error(\"invalid integer size \" + size);\n  }\n}\n\nAccumulator.prototype.readInt = function(bytes) {\n  var ival = this.peekInt(bytes);\n  if (ival instanceof Int64 && isFinite(ival.valueOf())) {\n    ival = ival.valueOf();\n  }\n  this.readOffset += bytes;\n  return ival;\n}\n\nAccumulator.prototype.peekDouble = function() {\n  this.assertReadableSize(8);\n  return isBigEndian ?\n    this.buf.readDoubleBE(this.readOffset) :\n    this.buf.readDoubleLE(this.readOffset);\n}\n\nAccumulator.prototype.readDouble = function() {\n  var dval = this.peekDouble();\n  this.readOffset += 8;\n  return dval;\n}\n\nAccumulator.prototype.readAdvance = function(size) {\n  if (size > 0) {\n    this.assertReadableSize(size);\n  } else if (size < 0 && this.readOffset + size < 0) {\n    throw new Error(\"advance with negative offset \" + size +\n        \" would seek off the start of the buffer\");\n  }\n  this.readOffset += size;\n}\n\nAccumulator.prototype.writeByte = function(value) {\n  this.reserve(1);\n  this.buf.writeInt8(value, this.writeOffset);\n  ++this.writeOffset;\n}\n\nAccumulator.prototype.writeInt = function(value, size) {\n  this.reserve(size);\n  switch (size) {\n    case 1:\n      this.buf.writeInt8(value, this.writeOffset);\n      break;\n    case 2:\n      if (isBigEndian) {\n        this.buf.writeInt16BE(value, this.writeOffset);\n      } else {\n        this.buf.writeInt16LE(value, this.writeOffset);\n      }\n      break;\n    case 4:\n      if (isBigEndian) {\n        this.buf.writeInt32BE(value, this.writeOffset);\n      } else {\n        this.buf.writeInt32LE(value, this.writeOffset);\n      }\n      break;\n    default:\n      throw new Error(\"unsupported integer size \" + size);\n  }\n  this.writeOffset += size;\n}\n\nAccumulator.prototype.writeDouble = function(value) {\n  this.reserve(8);\n  if (isBigEndian) {\n    this.buf.writeDoubleBE(value, this.writeOffset);\n  } else {\n    this.buf.writeDoubleLE(value, this.writeOffset);\n  }\n  this.writeOffset += 8;\n}\n\nvar BSER_ARRAY     = 0x00;\nvar BSER_OBJECT    = 0x01;\nvar BSER_STRING    = 0x02;\nvar BSER_INT8      = 0x03;\nvar BSER_INT16     = 0x04;\nvar BSER_INT32     = 0x05;\nvar BSER_INT64     = 0x06;\nvar BSER_REAL      = 0x07;\nvar BSER_TRUE      = 0x08;\nvar BSER_FALSE     = 0x09;\nvar BSER_NULL      = 0x0a;\nvar BSER_TEMPLATE  = 0x0b;\nvar BSER_SKIP      = 0x0c;\n\nvar ST_NEED_PDU = 0; // Need to read and decode PDU length\nvar ST_FILL_PDU = 1; // Know the length, need to read whole content\n\nvar MAX_INT8 = 127;\nvar MAX_INT16 = 32767;\nvar MAX_INT32 = 2147483647;\n\nfunction BunserBuf() {\n  EE.call(this);\n  this.buf = new Accumulator();\n  this.state = ST_NEED_PDU;\n}\nutil.inherits(BunserBuf, EE);\nexports.BunserBuf = BunserBuf;\n\nBunserBuf.prototype.append = function(buf, synchronous) {\n  if (synchronous) {\n    this.buf.append(buf);\n    return this.process(synchronous);\n  }\n\n  try {\n    this.buf.append(buf);\n  } catch (err) {\n    this.emit('error', err);\n    return;\n  }\n  // Arrange to decode later.  This allows the consuming\n  // application to make progress with other work in the\n  // case that we have a lot of subscription updates coming\n  // in from a large tree.\n  this.processLater();\n}\n\nBunserBuf.prototype.processLater = function() {\n  var self = this;\n  process.nextTick(function() {\n    try {\n      self.process(false);\n    } catch (err) {\n      self.emit('error', err);\n    }\n  });\n}\n\n// Do something with the buffer to advance our state.\n// If we're running synchronously we'll return either\n// the value we've decoded or undefined if we don't\n// yet have enought data.\n// If we're running asynchronously, we'll emit the value\n// when it becomes ready and schedule another invocation\n// of process on the next tick if we still have data we\n// can process.\nBunserBuf.prototype.process = function(synchronous) {\n  if (this.state == ST_NEED_PDU) {\n    if (this.buf.readAvail() < 2) {\n      return;\n    }\n    // Validate BSER header\n    this.expectCode(0);\n    this.expectCode(1);\n    this.pduLen = this.decodeInt(true /* relaxed */);\n    if (this.pduLen === false) {\n      // Need more data, walk backwards\n      this.buf.readAdvance(-2);\n      return;\n    }\n    // Ensure that we have a big enough buffer to read the rest of the PDU\n    this.buf.reserve(this.pduLen);\n    this.state = ST_FILL_PDU;\n  }\n\n  if (this.state == ST_FILL_PDU) {\n    if (this.buf.readAvail() < this.pduLen) {\n      // Need more data\n      return;\n    }\n\n    // We have enough to decode it\n    var val = this.decodeAny();\n    if (synchronous) {\n      return val;\n    }\n    this.emit('value', val);\n    this.state = ST_NEED_PDU;\n  }\n\n  if (!synchronous && this.buf.readAvail() > 0) {\n    this.processLater();\n  }\n}\n\nBunserBuf.prototype.raise = function(reason) {\n  throw new Error(reason + \", in Buffer of length \" +\n      this.buf.buf.length + \" (\" + this.buf.readAvail() +\n      \" readable) at offset \" + this.buf.readOffset + \" buffer: \" +\n      JSON.stringify(this.buf.buf.slice(\n          this.buf.readOffset, this.buf.readOffset + 32).toJSON()));\n}\n\nBunserBuf.prototype.expectCode = function(expected) {\n  var code = this.buf.readInt(1);\n  if (code != expected) {\n    this.raise(\"expected bser opcode \" + expected + \" but got \" + code);\n  }\n}\n\nBunserBuf.prototype.decodeAny = function() {\n  var code = this.buf.peekInt(1);\n  switch (code) {\n    case BSER_INT8:\n    case BSER_INT16:\n    case BSER_INT32:\n    case BSER_INT64:\n      return this.decodeInt();\n    case BSER_REAL:\n      this.buf.readAdvance(1);\n      return this.buf.readDouble();\n    case BSER_TRUE:\n      this.buf.readAdvance(1);\n      return true;\n    case BSER_FALSE:\n      this.buf.readAdvance(1);\n      return false;\n    case BSER_NULL:\n      this.buf.readAdvance(1);\n      return null;\n    case BSER_STRING:\n      return this.decodeString();\n    case BSER_ARRAY:\n      return this.decodeArray();\n    case BSER_OBJECT:\n      return this.decodeObject();\n    case BSER_TEMPLATE:\n      return this.decodeTemplate();\n    default:\n      this.raise(\"unhandled bser opcode \" + code);\n  }\n}\n\nBunserBuf.prototype.decodeArray = function() {\n  this.expectCode(BSER_ARRAY);\n  var nitems = this.decodeInt();\n  var arr = [];\n  for (var i = 0; i < nitems; ++i) {\n    arr.push(this.decodeAny());\n  }\n  return arr;\n}\n\nBunserBuf.prototype.decodeObject = function() {\n  this.expectCode(BSER_OBJECT);\n  var nitems = this.decodeInt();\n  var res = {};\n  for (var i = 0; i < nitems; ++i) {\n    var key = this.decodeString();\n    var val = this.decodeAny();\n    res[key] = val;\n  }\n  return res;\n}\n\nBunserBuf.prototype.decodeTemplate = function() {\n  this.expectCode(BSER_TEMPLATE);\n  var keys = this.decodeArray();\n  var nitems = this.decodeInt();\n  var arr = [];\n  for (var i = 0; i < nitems; ++i) {\n    var obj = {};\n    for (var keyidx = 0; keyidx < keys.length; ++keyidx) {\n      if (this.buf.peekInt(1) == BSER_SKIP) {\n        this.buf.readAdvance(1);\n        continue;\n      }\n      var val = this.decodeAny();\n      obj[keys[keyidx]] = val;\n    }\n    arr.push(obj);\n  }\n  return arr;\n}\n\nBunserBuf.prototype.decodeString = function() {\n  this.expectCode(BSER_STRING);\n  var len = this.decodeInt();\n  return this.buf.readString(len);\n}\n\n// This is unusual compared to the other decode functions in that\n// we may not have enough data available to satisfy the read, and\n// we don't want to throw.  This is only true when we're reading\n// the PDU length from the PDU header; we'll set relaxSizeAsserts\n// in that case.\nBunserBuf.prototype.decodeInt = function(relaxSizeAsserts) {\n  if (relaxSizeAsserts && (this.buf.readAvail() < 1)) {\n    return false;\n  } else {\n    this.buf.assertReadableSize(1);\n  }\n  var code = this.buf.peekInt(1);\n  var size = 0;\n  switch (code) {\n    case BSER_INT8:\n      size = 1;\n      break;\n    case BSER_INT16:\n      size = 2;\n      break;\n    case BSER_INT32:\n      size = 4;\n      break;\n    case BSER_INT64:\n      size = 8;\n      break;\n    default:\n      this.raise(\"invalid bser int encoding \" + code);\n  }\n\n  if (relaxSizeAsserts && (this.buf.readAvail() < 1 + size)) {\n    return false;\n  }\n  this.buf.readAdvance(1);\n  return this.buf.readInt(size);\n}\n\n// synchronously BSER decode a string and return the value\nfunction loadFromBuffer(input) {\n  var buf = new BunserBuf();\n  var result = buf.append(input, true);\n  if (buf.buf.readAvail()) {\n    throw Error(\n        'excess data found after input buffer, use BunserBuf instead');\n  }\n  if (typeof result === 'undefined') {\n    throw Error(\n        'no bser found in string and no error raised!?');\n  }\n  return result;\n}\nexports.loadFromBuffer = loadFromBuffer\n\n// Byteswap an arbitrary buffer, flipping from one endian\n// to the other, returning a new buffer with the resultant data\nfunction byteswap64(buf) {\n  var swap = Buffer.alloc(buf.length);\n  for (var i = 0; i < buf.length; i++) {\n    swap[i] = buf[buf.length -1 - i];\n  }\n  return swap;\n}\n\nfunction dump_int64(buf, val) {\n  // Get the raw bytes.  The Int64 buffer is big endian\n  var be = val.toBuffer();\n\n  if (isBigEndian) {\n    // We're a big endian system, so the buffer is exactly how we\n    // want it to be\n    buf.writeByte(BSER_INT64);\n    buf.append(be);\n    return;\n  }\n  // We need to byte swap to get the correct representation\n  var le = byteswap64(be);\n  buf.writeByte(BSER_INT64);\n  buf.append(le);\n}\n\nfunction dump_int(buf, val) {\n  var abs = Math.abs(val);\n  if (abs <= MAX_INT8) {\n    buf.writeByte(BSER_INT8);\n    buf.writeInt(val, 1);\n  } else if (abs <= MAX_INT16) {\n    buf.writeByte(BSER_INT16);\n    buf.writeInt(val, 2);\n  } else if (abs <= MAX_INT32) {\n    buf.writeByte(BSER_INT32);\n    buf.writeInt(val, 4);\n  } else {\n    dump_int64(buf, new Int64(val));\n  }\n}\n\nfunction dump_any(buf, val) {\n  switch (typeof(val)) {\n    case 'number':\n      // check if it is an integer or a float\n      if (isFinite(val) && Math.floor(val) === val) {\n        dump_int(buf, val);\n      } else {\n        buf.writeByte(BSER_REAL);\n        buf.writeDouble(val);\n      }\n      return;\n    case 'string':\n      buf.writeByte(BSER_STRING);\n      dump_int(buf, Buffer.byteLength(val));\n      buf.append(val);\n      return;\n    case 'boolean':\n      buf.writeByte(val ? BSER_TRUE : BSER_FALSE);\n      return;\n    case 'object':\n      if (val === null) {\n        buf.writeByte(BSER_NULL);\n        return;\n      }\n      if (val instanceof Int64) {\n        dump_int64(buf, val);\n        return;\n      }\n      if (Array.isArray(val)) {\n        buf.writeByte(BSER_ARRAY);\n        dump_int(buf, val.length);\n        for (var i = 0; i < val.length; ++i) {\n          dump_any(buf, val[i]);\n        }\n        return;\n      }\n      buf.writeByte(BSER_OBJECT);\n      var keys = Object.keys(val);\n\n      // First pass to compute number of defined keys\n      var num_keys = keys.length;\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var v = val[key];\n        if (typeof(v) == 'undefined') {\n          num_keys--;\n        }\n      }\n      dump_int(buf, num_keys);\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var v = val[key];\n        if (typeof(v) == 'undefined') {\n          // Don't include it\n          continue;\n        }\n        dump_any(buf, key);\n        try {\n          dump_any(buf, v);\n        } catch (e) {\n          throw new Error(\n            e.message + ' (while serializing object property with name `' +\n              key + \"')\");\n        }\n      }\n      return;\n\n    default:\n      throw new Error('cannot serialize type ' + typeof(val) + ' to BSER');\n  }\n}\n\n// BSER encode value and return a buffer of the contents\nfunction dumpToBuffer(val) {\n  var buf = new Accumulator();\n  // Build out the header\n  buf.writeByte(0);\n  buf.writeByte(1);\n  // Reserve room for an int32 to hold our PDU length\n  buf.writeByte(BSER_INT32);\n  buf.writeInt(0, 4); // We'll come back and fill this in at the end\n\n  dump_any(buf, val);\n\n  // Compute PDU length\n  var off = buf.writeOffset;\n  var len = off - 7 /* the header length */;\n  buf.writeOffset = 3; // The length value to fill in\n  buf.writeInt(len, 4); // write the length in the space we reserved\n  buf.writeOffset = off;\n\n  return buf.buf.slice(0, off);\n}\nexports.dumpToBuffer = dumpToBuffer\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bser/index.js?");

/***/ }),

/***/ "./node_modules/buffer-indexof-polyfill/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/buffer-indexof-polyfill/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar initBuffer = __webpack_require__(/*! ./init-buffer */ \"./node_modules/buffer-indexof-polyfill/init-buffer.js\");\n\nif (!Buffer.prototype.indexOf) {\n    Buffer.prototype.indexOf = function (value, offset) {\n        offset = offset || 0;\n\n        // Always wrap the input as a Buffer so that this method will support any\n        // data type such as array octet, string or buffer.\n        if (typeof value === \"string\" || value instanceof String) {\n            value = initBuffer(value);\n        } else if (typeof value === \"number\" || value instanceof Number) {\n            value = initBuffer([ value ]);\n        }\n\n        var len = value.length;\n\n        for (var i = offset; i <= this.length - len; i++) {\n            var mismatch = false;\n            for (var j = 0; j < len; j++) {\n                if (this[i + j] != value[j]) {\n                    mismatch = true;\n                    break;\n                }\n            }\n\n            if (!mismatch) {\n                return i;\n            }\n        }\n\n        return -1;\n    };\n}\n\nfunction bufferLastIndexOf (value, offset) {\n\n    // Always wrap the input as a Buffer so that this method will support any\n    // data type such as array octet, string or buffer.\n    if (typeof value === \"string\" || value instanceof String) {\n        value = initBuffer(value);\n    } else if (typeof value === \"number\" || value instanceof Number) {\n        value = initBuffer([ value ]);\n    }\n\n    var len = value.length;\n    offset = offset || this.length - len;\n\n    for (var i = offset; i >= 0; i--) {\n        var mismatch = false;\n        for (var j = 0; j < len; j++) {\n            if (this[i + j] != value[j]) {\n                mismatch = true;\n                break;\n            }\n        }\n\n        if (!mismatch) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\n\nif (Buffer.prototype.lastIndexOf) {\n    // check Buffer#lastIndexOf is usable: https://github.com/nodejs/node/issues/4604\n    if (initBuffer(\"ABC\").lastIndexOf (\"ABC\") === -1)\n        Buffer.prototype.lastIndexOf = bufferLastIndexOf;\n} else {\n    Buffer.prototype.lastIndexOf = bufferLastIndexOf;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/buffer-indexof-polyfill/index.js?");

/***/ }),

/***/ "./node_modules/buffer-indexof-polyfill/init-buffer.js":
/*!*************************************************************!*\
  !*** ./node_modules/buffer-indexof-polyfill/init-buffer.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("module.exports = function initBuffer(val) {\n  // assume old version\n    var nodeVersion = process && process.version ? process.version : \"v5.0.0\";\n    var major = nodeVersion.split(\".\")[0].replace(\"v\", \"\");\n    return major < 6\n      ? new Buffer(val)\n      : Buffer.from(val);\n};\n\n//# sourceURL=webpack://coc.nvim/./node_modules/buffer-indexof-polyfill/init-buffer.js?");

/***/ }),

/***/ "./node_modules/buffers/index.js":
/*!***************************************!*\
  !*** ./node_modules/buffers/index.js ***!
  \***************************************/
/***/ ((module) => {

eval("module.exports = Buffers;\n\nfunction Buffers (bufs) {\n    if (!(this instanceof Buffers)) return new Buffers(bufs);\n    this.buffers = bufs || [];\n    this.length = this.buffers.reduce(function (size, buf) {\n        return size + buf.length\n    }, 0);\n}\n\nBuffers.prototype.push = function () {\n    for (var i = 0; i < arguments.length; i++) {\n        if (!Buffer.isBuffer(arguments[i])) {\n            throw new TypeError('Tried to push a non-buffer');\n        }\n    }\n    \n    for (var i = 0; i < arguments.length; i++) {\n        var buf = arguments[i];\n        this.buffers.push(buf);\n        this.length += buf.length;\n    }\n    return this.length;\n};\n\nBuffers.prototype.unshift = function () {\n    for (var i = 0; i < arguments.length; i++) {\n        if (!Buffer.isBuffer(arguments[i])) {\n            throw new TypeError('Tried to unshift a non-buffer');\n        }\n    }\n    \n    for (var i = 0; i < arguments.length; i++) {\n        var buf = arguments[i];\n        this.buffers.unshift(buf);\n        this.length += buf.length;\n    }\n    return this.length;\n};\n\nBuffers.prototype.copy = function (dst, dStart, start, end) {\n    return this.slice(start, end).copy(dst, dStart, 0, end - start);\n};\n\nBuffers.prototype.splice = function (i, howMany) {\n    var buffers = this.buffers;\n    var index = i >= 0 ? i : this.length - i;\n    var reps = [].slice.call(arguments, 2);\n    \n    if (howMany === undefined) {\n        howMany = this.length - index;\n    }\n    else if (howMany > this.length - index) {\n        howMany = this.length - index;\n    }\n    \n    for (var i = 0; i < reps.length; i++) {\n        this.length += reps[i].length;\n    }\n    \n    var removed = new Buffers();\n    var bytes = 0;\n    \n    var startBytes = 0;\n    for (\n        var ii = 0;\n        ii < buffers.length && startBytes + buffers[ii].length < index;\n        ii ++\n    ) { startBytes += buffers[ii].length }\n    \n    if (index - startBytes > 0) {\n        var start = index - startBytes;\n        \n        if (start + howMany < buffers[ii].length) {\n            removed.push(buffers[ii].slice(start, start + howMany));\n            \n            var orig = buffers[ii];\n            //var buf = new Buffer(orig.length - howMany);\n            var buf0 = new Buffer(start);\n            for (var i = 0; i < start; i++) {\n                buf0[i] = orig[i];\n            }\n            \n            var buf1 = new Buffer(orig.length - start - howMany);\n            for (var i = start + howMany; i < orig.length; i++) {\n                buf1[ i - howMany - start ] = orig[i]\n            }\n            \n            if (reps.length > 0) {\n                var reps_ = reps.slice();\n                reps_.unshift(buf0);\n                reps_.push(buf1);\n                buffers.splice.apply(buffers, [ ii, 1 ].concat(reps_));\n                ii += reps_.length;\n                reps = [];\n            }\n            else {\n                buffers.splice(ii, 1, buf0, buf1);\n                //buffers[ii] = buf;\n                ii += 2;\n            }\n        }\n        else {\n            removed.push(buffers[ii].slice(start));\n            buffers[ii] = buffers[ii].slice(0, start);\n            ii ++;\n        }\n    }\n    \n    if (reps.length > 0) {\n        buffers.splice.apply(buffers, [ ii, 0 ].concat(reps));\n        ii += reps.length;\n    }\n    \n    while (removed.length < howMany) {\n        var buf = buffers[ii];\n        var len = buf.length;\n        var take = Math.min(len, howMany - removed.length);\n        \n        if (take === len) {\n            removed.push(buf);\n            buffers.splice(ii, 1);\n        }\n        else {\n            removed.push(buf.slice(0, take));\n            buffers[ii] = buffers[ii].slice(take);\n        }\n    }\n    \n    this.length -= removed.length;\n    \n    return removed;\n};\n \nBuffers.prototype.slice = function (i, j) {\n    var buffers = this.buffers;\n    if (j === undefined) j = this.length;\n    if (i === undefined) i = 0;\n    \n    if (j > this.length) j = this.length;\n    \n    var startBytes = 0;\n    for (\n        var si = 0;\n        si < buffers.length && startBytes + buffers[si].length <= i;\n        si ++\n    ) { startBytes += buffers[si].length }\n    \n    var target = new Buffer(j - i);\n    \n    var ti = 0;\n    for (var ii = si; ti < j - i && ii < buffers.length; ii++) {\n        var len = buffers[ii].length;\n        \n        var start = ti === 0 ? i - startBytes : 0;\n        var end = ti + len >= j - i\n            ? Math.min(start + (j - i) - ti, len)\n            : len\n        ;\n        \n        buffers[ii].copy(target, ti, start, end);\n        ti += end - start;\n    }\n    \n    return target;\n};\n\nBuffers.prototype.pos = function (i) {\n    if (i < 0 || i >= this.length) throw new Error('oob');\n    var l = i, bi = 0, bu = null;\n    for (;;) {\n        bu = this.buffers[bi];\n        if (l < bu.length) {\n            return {buf: bi, offset: l};\n        } else {\n            l -= bu.length;\n        }\n        bi++;\n    }\n};\n\nBuffers.prototype.get = function get (i) {\n    var pos = this.pos(i);\n\n    return this.buffers[pos.buf].get(pos.offset);\n};\n\nBuffers.prototype.set = function set (i, b) {\n    var pos = this.pos(i);\n\n    return this.buffers[pos.buf].set(pos.offset, b);\n};\n\nBuffers.prototype.indexOf = function (needle, offset) {\n    if (\"string\" === typeof needle) {\n        needle = new Buffer(needle);\n    } else if (needle instanceof Buffer) {\n        // already a buffer\n    } else {\n        throw new Error('Invalid type for a search string');\n    }\n\n    if (!needle.length) {\n        return 0;\n    }\n\n    if (!this.length) {\n        return -1;\n    }\n\n    var i = 0, j = 0, match = 0, mstart, pos = 0;\n\n    // start search from a particular point in the virtual buffer\n    if (offset) {\n        var p = this.pos(offset);\n        i = p.buf;\n        j = p.offset;\n        pos = offset;\n    }\n\n    // for each character in virtual buffer\n    for (;;) {\n        while (j >= this.buffers[i].length) {\n            j = 0;\n            i++;\n\n            if (i >= this.buffers.length) {\n                // search string not found\n                return -1;\n            }\n        }\n\n        var char = this.buffers[i][j];\n\n        if (char == needle[match]) {\n            // keep track where match started\n            if (match == 0) {\n                mstart = {\n                    i: i,\n                    j: j,\n                    pos: pos\n                };\n            }\n            match++;\n            if (match == needle.length) {\n                // full match\n                return mstart.pos;\n            }\n        } else if (match != 0) {\n            // a partial match ended, go back to match starting position\n            // this will continue the search at the next character\n            i = mstart.i;\n            j = mstart.j;\n            pos = mstart.pos;\n            match = 0;\n        }\n\n        j++;\n        pos++;\n    }\n};\n\nBuffers.prototype.toBuffer = function() {\n    return this.slice();\n}\n\nBuffers.prototype.toString = function(encoding, start, end) {\n    return this.slice(start, end).toString(encoding);\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/buffers/index.js?");

/***/ }),

/***/ "./node_modules/bytes/index.js":
/*!*************************************!*\
  !*** ./node_modules/bytes/index.js ***!
  \*************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * bytes\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015 Jed Watson\n * MIT Licensed\n */\n\n\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = bytes;\nmodule.exports.format = format;\nmodule.exports.parse = parse;\n\n/**\n * Module variables.\n * @private\n */\n\nvar formatThousandsRegExp = /\\B(?=(\\d{3})+(?!\\d))/g;\n\nvar formatDecimalsRegExp = /(?:\\.0*|(\\.[^0]+)0+)$/;\n\nvar map = {\n  b:  1,\n  kb: 1 << 10,\n  mb: 1 << 20,\n  gb: 1 << 30,\n  tb: Math.pow(1024, 4),\n  pb: Math.pow(1024, 5),\n};\n\nvar parseRegExp = /^((-|\\+)?(\\d+(?:\\.\\d+)?)) *(kb|mb|gb|tb|pb)$/i;\n\n/**\n * Convert the given value in bytes into a string or parse to string to an integer in bytes.\n *\n * @param {string|number} value\n * @param {{\n *  case: [string],\n *  decimalPlaces: [number]\n *  fixedDecimals: [boolean]\n *  thousandsSeparator: [string]\n *  unitSeparator: [string]\n *  }} [options] bytes options.\n *\n * @returns {string|number|null}\n */\n\nfunction bytes(value, options) {\n  if (typeof value === 'string') {\n    return parse(value);\n  }\n\n  if (typeof value === 'number') {\n    return format(value, options);\n  }\n\n  return null;\n}\n\n/**\n * Format the given value in bytes into a string.\n *\n * If the value is negative, it is kept as such. If it is a float,\n * it is rounded.\n *\n * @param {number} value\n * @param {object} [options]\n * @param {number} [options.decimalPlaces=2]\n * @param {number} [options.fixedDecimals=false]\n * @param {string} [options.thousandsSeparator=]\n * @param {string} [options.unit=]\n * @param {string} [options.unitSeparator=]\n *\n * @returns {string|null}\n * @public\n */\n\nfunction format(value, options) {\n  if (!Number.isFinite(value)) {\n    return null;\n  }\n\n  var mag = Math.abs(value);\n  var thousandsSeparator = (options && options.thousandsSeparator) || '';\n  var unitSeparator = (options && options.unitSeparator) || '';\n  var decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2;\n  var fixedDecimals = Boolean(options && options.fixedDecimals);\n  var unit = (options && options.unit) || '';\n\n  if (!unit || !map[unit.toLowerCase()]) {\n    if (mag >= map.pb) {\n      unit = 'PB';\n    } else if (mag >= map.tb) {\n      unit = 'TB';\n    } else if (mag >= map.gb) {\n      unit = 'GB';\n    } else if (mag >= map.mb) {\n      unit = 'MB';\n    } else if (mag >= map.kb) {\n      unit = 'KB';\n    } else {\n      unit = 'B';\n    }\n  }\n\n  var val = value / map[unit.toLowerCase()];\n  var str = val.toFixed(decimalPlaces);\n\n  if (!fixedDecimals) {\n    str = str.replace(formatDecimalsRegExp, '$1');\n  }\n\n  if (thousandsSeparator) {\n    str = str.replace(formatThousandsRegExp, thousandsSeparator);\n  }\n\n  return str + unitSeparator + unit;\n}\n\n/**\n * Parse the string value into an integer in bytes.\n *\n * If no unit is given, it is assumed the value is in bytes.\n *\n * @param {number|string} val\n *\n * @returns {number|null}\n * @public\n */\n\nfunction parse(val) {\n  if (typeof val === 'number' && !isNaN(val)) {\n    return val;\n  }\n\n  if (typeof val !== 'string') {\n    return null;\n  }\n\n  // Test if the string passed is valid\n  var results = parseRegExp.exec(val);\n  var floatValue;\n  var unit = 'b';\n\n  if (!results) {\n    // Nothing could be extracted from the given string\n    floatValue = parseInt(val, 10);\n    unit = 'b'\n  } else {\n    // Retrieve the value and the unit\n    floatValue = parseFloat(results[1]);\n    unit = results[4].toLowerCase();\n  }\n\n  return Math.floor(map[unit] * floatValue);\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/bytes/index.js?");

/***/ }),

/***/ "./node_modules/chainsaw/index.js":
/*!****************************************!*\
  !*** ./node_modules/chainsaw/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Traverse = __webpack_require__(/*! traverse */ \"./node_modules/traverse/index.js\");\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\n\nmodule.exports = Chainsaw;\nfunction Chainsaw (builder) {\n    var saw = Chainsaw.saw(builder, {});\n    var r = builder.call(saw.handlers, saw);\n    if (r !== undefined) saw.handlers = r;\n    saw.record();\n    return saw.chain();\n};\n\nChainsaw.light = function ChainsawLight (builder) {\n    var saw = Chainsaw.saw(builder, {});\n    var r = builder.call(saw.handlers, saw);\n    if (r !== undefined) saw.handlers = r;\n    return saw.chain();\n};\n\nChainsaw.saw = function (builder, handlers) {\n    var saw = new EventEmitter;\n    saw.handlers = handlers;\n    saw.actions = [];\n\n    saw.chain = function () {\n        var ch = Traverse(saw.handlers).map(function (node) {\n            if (this.isRoot) return node;\n            var ps = this.path;\n\n            if (typeof node === 'function') {\n                this.update(function () {\n                    saw.actions.push({\n                        path : ps,\n                        args : [].slice.call(arguments)\n                    });\n                    return ch;\n                });\n            }\n        });\n\n        process.nextTick(function () {\n            saw.emit('begin');\n            saw.next();\n        });\n\n        return ch;\n    };\n\n    saw.pop = function () {\n        return saw.actions.shift();\n    };\n\n    saw.next = function () {\n        var action = saw.pop();\n\n        if (!action) {\n            saw.emit('end');\n        }\n        else if (!action.trap) {\n            var node = saw.handlers;\n            action.path.forEach(function (key) { node = node[key] });\n            node.apply(saw.handlers, action.args);\n        }\n    };\n\n    saw.nest = function (cb) {\n        var args = [].slice.call(arguments, 1);\n        var autonext = true;\n\n        if (typeof cb === 'boolean') {\n            var autonext = cb;\n            cb = args.shift();\n        }\n\n        var s = Chainsaw.saw(builder, {});\n        var r = builder.call(s.handlers, s);\n\n        if (r !== undefined) s.handlers = r;\n\n        // If we are recording...\n        if (\"undefined\" !== typeof saw.step) {\n            // ... our children should, too\n            s.record();\n        }\n\n        cb.apply(s.chain(), args);\n        if (autonext !== false) s.on('end', saw.next);\n    };\n\n    saw.record = function () {\n        upgradeChainsaw(saw);\n    };\n\n    ['trap', 'down', 'jump'].forEach(function (method) {\n        saw[method] = function () {\n            throw new Error(\"To use the trap, down and jump features, please \"+\n                            \"call record() first to start recording actions.\");\n        };\n    });\n\n    return saw;\n};\n\nfunction upgradeChainsaw(saw) {\n    saw.step = 0;\n\n    // override pop\n    saw.pop = function () {\n        return saw.actions[saw.step++];\n    };\n\n    saw.trap = function (name, cb) {\n        var ps = Array.isArray(name) ? name : [name];\n        saw.actions.push({\n            path : ps,\n            step : saw.step,\n            cb : cb,\n            trap : true\n        });\n    };\n\n    saw.down = function (name) {\n        var ps = (Array.isArray(name) ? name : [name]).join('/');\n        var i = saw.actions.slice(saw.step).map(function (x) {\n            if (x.trap && x.step <= saw.step) return false;\n            return x.path.join('/') == ps;\n        }).indexOf(true);\n\n        if (i >= 0) saw.step += i;\n        else saw.step = saw.actions.length;\n\n        var act = saw.actions[saw.step - 1];\n        if (act && act.trap) {\n            // It's a trap!\n            saw.step = act.step;\n            act.cb();\n        }\n        else saw.next();\n    };\n\n    saw.jump = function (step) {\n        saw.step = step;\n        saw.next();\n    };\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/chainsaw/index.js?");

/***/ }),

/***/ "./node_modules/chownr/chownr.js":
/*!***************************************!*\
  !*** ./node_modules/chownr/chownr.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\n/* istanbul ignore next */\nconst LCHOWN = fs.lchown ? 'lchown' : 'chown'\n/* istanbul ignore next */\nconst LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync'\n\n/* istanbul ignore next */\nconst needEISDIRHandled = fs.lchown &&\n  !process.version.match(/v1[1-9]+\\./) &&\n  !process.version.match(/v10\\.[6-9]/)\n\nconst lchownSync = (path, uid, gid) => {\n  try {\n    return fs[LCHOWNSYNC](path, uid, gid)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n  }\n}\n\n/* istanbul ignore next */\nconst chownSync = (path, uid, gid) => {\n  try {\n    return fs.chownSync(path, uid, gid)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n  }\n}\n\n/* istanbul ignore next */\nconst handleEISDIR =\n  needEISDIRHandled ? (path, uid, gid, cb) => er => {\n    // Node prior to v10 had a very questionable implementation of\n    // fs.lchown, which would always try to call fs.open on a directory\n    // Fall back to fs.chown in those cases.\n    if (!er || er.code !== 'EISDIR')\n      cb(er)\n    else\n      fs.chown(path, uid, gid, cb)\n  }\n  : (_, __, ___, cb) => cb\n\n/* istanbul ignore next */\nconst handleEISDirSync =\n  needEISDIRHandled ? (path, uid, gid) => {\n    try {\n      return lchownSync(path, uid, gid)\n    } catch (er) {\n      if (er.code !== 'EISDIR')\n        throw er\n      chownSync(path, uid, gid)\n    }\n  }\n  : (path, uid, gid) => lchownSync(path, uid, gid)\n\n// fs.readdir could only accept an options object as of node v6\nconst nodeVersion = process.version\nlet readdir = (path, options, cb) => fs.readdir(path, options, cb)\nlet readdirSync = (path, options) => fs.readdirSync(path, options)\n/* istanbul ignore next */\nif (/^v4\\./.test(nodeVersion))\n  readdir = (path, options, cb) => fs.readdir(path, cb)\n\nconst chown = (cpath, uid, gid, cb) => {\n  fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, er => {\n    // Skip ENOENT error\n    cb(er && er.code !== 'ENOENT' ? er : null)\n  }))\n}\n\nconst chownrKid = (p, child, uid, gid, cb) => {\n  if (typeof child === 'string')\n    return fs.lstat(path.resolve(p, child), (er, stats) => {\n      // Skip ENOENT error\n      if (er)\n        return cb(er.code !== 'ENOENT' ? er : null)\n      stats.name = child\n      chownrKid(p, stats, uid, gid, cb)\n    })\n\n  if (child.isDirectory()) {\n    chownr(path.resolve(p, child.name), uid, gid, er => {\n      if (er)\n        return cb(er)\n      const cpath = path.resolve(p, child.name)\n      chown(cpath, uid, gid, cb)\n    })\n  } else {\n    const cpath = path.resolve(p, child.name)\n    chown(cpath, uid, gid, cb)\n  }\n}\n\n\nconst chownr = (p, uid, gid, cb) => {\n  readdir(p, { withFileTypes: true }, (er, children) => {\n    // any error other than ENOTDIR or ENOTSUP means it's not readable,\n    // or doesn't exist.  give up.\n    if (er) {\n      if (er.code === 'ENOENT')\n        return cb()\n      else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')\n        return cb(er)\n    }\n    if (er || !children.length)\n      return chown(p, uid, gid, cb)\n\n    let len = children.length\n    let errState = null\n    const then = er => {\n      if (errState)\n        return\n      if (er)\n        return cb(errState = er)\n      if (-- len === 0)\n        return chown(p, uid, gid, cb)\n    }\n\n    children.forEach(child => chownrKid(p, child, uid, gid, then))\n  })\n}\n\nconst chownrKidSync = (p, child, uid, gid) => {\n  if (typeof child === 'string') {\n    try {\n      const stats = fs.lstatSync(path.resolve(p, child))\n      stats.name = child\n      child = stats\n    } catch (er) {\n      if (er.code === 'ENOENT')\n        return\n      else\n        throw er\n    }\n  }\n\n  if (child.isDirectory())\n    chownrSync(path.resolve(p, child.name), uid, gid)\n\n  handleEISDirSync(path.resolve(p, child.name), uid, gid)\n}\n\nconst chownrSync = (p, uid, gid) => {\n  let children\n  try {\n    children = readdirSync(p, { withFileTypes: true })\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return\n    else if (er.code === 'ENOTDIR' || er.code === 'ENOTSUP')\n      return handleEISDirSync(p, uid, gid)\n    else\n      throw er\n  }\n\n  if (children && children.length)\n    children.forEach(child => chownrKidSync(p, child, uid, gid))\n\n  return handleEISDirSync(p, uid, gid)\n}\n\nmodule.exports = chownr\nchownr.sync = chownrSync\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/chownr/chownr.js?");

/***/ }),

/***/ "./node_modules/cli-table/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/cli-table/lib/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * Module dependencies.\n */\n\nvar colors = __webpack_require__(/*! chalk */ \"./node_modules/cli-table/node_modules/chalk/index.js\")\n  , utils = __webpack_require__(/*! ./utils */ \"./node_modules/cli-table/lib/utils.js\")\n  , repeat = utils.repeat\n  , truncate = utils.truncate\n  , pad = utils.pad;\n\n/**\n * Table constructor\n *\n * @param {Object} options\n * @api public\n */\n\nfunction Table (options){\n  this.options = utils.options({\n      chars: {\n          'top': ''\n        , 'top-mid': ''\n        , 'top-left': ''\n        , 'top-right': ''\n        , 'bottom': ''\n        , 'bottom-mid': ''\n        , 'bottom-left': ''\n        , 'bottom-right': ''\n        , 'left': ''\n        , 'left-mid': ''\n        , 'mid': ''\n        , 'mid-mid': ''\n        , 'right': ''\n        , 'right-mid': ''\n        , 'middle': ''\n      }\n    , truncate: ''\n    , colors: true\n    , colWidths: []\n    , colAligns: []\n    , style: {\n          'padding-left': 1\n        , 'padding-right': 1\n        , head: ['red']\n        , border: ['white']\n        , compact : false\n      }\n    , head: []\n  }, options);\n};\n\n/**\n * Inherit from Array.\n */\n\nTable.prototype.__proto__ = Array.prototype;\n\n/**\n * Width getter\n *\n * @return {Number} width\n * @api public\n */\n\nTable.prototype.__defineGetter__('width', function (){\n  var str = this.toString().split(\"\\n\");\n  if (str.length) return str[0].length;\n  return 0;\n});\n\n/**\n * Render to a string.\n *\n * @return {String} table representation\n * @api public\n */\n\nTable.prototype.render\nTable.prototype.toString = function (){\n  var ret = ''\n    , options = this.options\n    , style = options.style\n    , head = options.head\n    , chars = options.chars\n    , truncater = options.truncate\n      , colWidths = options.colWidths || new Array(this.head.length)\n      , totalWidth = 0;\n\n    if (!head.length && !this.length) return '';\n\n    if (!colWidths.length){\n      var all_rows = this.slice(0);\n      if (head.length) { all_rows = all_rows.concat([head]) };\n\n      all_rows.forEach(function(cells){\n        // horizontal (arrays)\n        if (Array.isArray(cells) && cells.length) {\n          extractColumnWidths(cells);\n\n        // vertical (objects)\n        } else {\n          var header_cell = Object.keys(cells)[0]\n            , value_cell = cells[header_cell];\n\n          colWidths[0] = Math.max(colWidths[0] || 0, get_width(header_cell) || 0);\n\n          // cross (objects w/ array values)\n          if (Array.isArray(value_cell) && value_cell.length) {\n            extractColumnWidths(value_cell, 1);\n          } else {\n            colWidths[1] = Math.max(colWidths[1] || 0, get_width(value_cell) || 0);\n          }\n        }\n    });\n  };\n\n  totalWidth = (colWidths.length == 1 ? colWidths[0] : colWidths.reduce(\n    function (a, b){\n      return a + b\n    })) + colWidths.length + 1;\n\n  function extractColumnWidths(arr, offset) {\n    var offset = offset || 0;\n    arr.forEach(function(cell, i){\n      colWidths[i + offset] = Math.max(colWidths[i + offset] || 0, get_width(cell) || 0);\n    });\n  };\n\n  function get_width(obj) {\n    return typeof obj == 'object' && obj && obj.width != undefined\n         ? obj.width\n         : ((typeof obj == 'object' && obj !== null ? utils.strlen(obj.text) : utils.strlen(obj)) + (style['padding-left'] || 0) + (style['padding-right'] || 0))\n  }\n\n  // draws a line\n  function line (line, left, right, intersection){\n    var width = 0\n      , line =\n          left\n        + repeat(line, totalWidth - 2)\n        + right;\n\n    colWidths.forEach(function (w, i){\n      if (i == colWidths.length - 1) return;\n      width += w + 1;\n      line = line.substr(0, width) + intersection + line.substr(width + 1);\n    });\n\n    return applyStyles(options.style.border, line);\n  };\n\n  // draws the top line\n  function lineTop (){\n    var l = line(chars.top\n               , chars['top-left'] || chars.top\n               , chars['top-right'] ||  chars.top\n               , chars['top-mid']);\n    if (l)\n      ret += l + \"\\n\";\n  };\n\n  function generateRow (items, style) {\n    var cells = []\n      , max_height = 0;\n\n    // prepare vertical and cross table data\n    if (!Array.isArray(items) && typeof items === \"object\") {\n      var key = Object.keys(items)[0]\n        , value = items[key]\n        , first_cell_head = true;\n\n      if (Array.isArray(value)) {\n        items = value;\n        items.unshift(key);\n      } else {\n        items = [key, value];\n      }\n    }\n\n    // transform array of item strings into structure of cells\n    items.forEach(function (item, i) {\n      var contents = (item == null ? '' : item).toString().split(\"\\n\").reduce(function (memo, l) {\n        memo.push(string(l, i));\n        return memo;\n      }, [])\n\n      var height = contents.length;\n      if (height > max_height) { max_height = height };\n\n      cells.push({ contents: contents , height: height });\n    });\n\n    // transform vertical cells into horizontal lines\n    var lines = new Array(max_height);\n    cells.forEach(function (cell, i) {\n      cell.contents.forEach(function (line, j) {\n        if (!lines[j]) { lines[j] = [] };\n        if (style || (first_cell_head && i === 0 && options.style.head)) {\n          line = applyStyles(options.style.head, line)\n        }\n\n        lines[j].push(line);\n      });\n\n      // populate empty lines in cell\n      for (var j = cell.height, l = max_height; j < l; j++) {\n        if (!lines[j]) { lines[j] = [] };\n        lines[j].push(string('', i));\n      }\n    });\n    var ret = \"\";\n    lines.forEach(function (line, index) {\n      if (ret.length > 0) {\n        ret += \"\\n\" + applyStyles(options.style.border, chars.left);\n      }\n\n      ret += line.join(applyStyles(options.style.border, chars.middle)) + applyStyles(options.style.border, chars.right);\n    });\n\n    return applyStyles(options.style.border, chars.left) + ret;\n  };\n\n  function applyStyles(styles, subject) {\n    if (!subject)\n      return '';\n    if (!options.colors)\n      return subject;\n    styles.forEach(function(style) {\n      subject = colors[style](subject);\n    });\n    return subject;\n  };\n\n  // renders a string, by padding it or truncating it\n  function string (str, index){\n    var str = String(typeof str == 'object' && str.text ? str.text : str)\n      , length = utils.strlen(str)\n      , width = colWidths[index]\n          - (style['padding-left'] || 0)\n          - (style['padding-right'] || 0)\n      , align = options.colAligns[index] || 'left';\n\n    return repeat(' ', style['padding-left'] || 0)\n         + (length == width ? str :\n             (length < width\n              ? pad(str, ( width + (str.length - length) ), ' ', align == 'left' ? 'right' :\n                  (align == 'middle' ? 'both' : 'left'))\n              : (truncater ? truncate(str, width, truncater) : str))\n           )\n         + repeat(' ', style['padding-right'] || 0);\n  };\n\n  if (head.length){\n    lineTop();\n\n    ret += generateRow(head, style.head) + \"\\n\"\n  }\n\n  if (this.length)\n    this.forEach(function (cells, i){\n      if (!head.length && i == 0)\n        lineTop();\n      else {\n        if (!style.compact || i<(!!head.length) ?1: false || cells.length == 0){\n          var l = line(chars.mid\n                     , chars['left-mid']\n                     , chars['right-mid']\n                     , chars['mid-mid']);\n          if (l)\n            ret += l + \"\\n\"\n        }\n      }\n\n      if (Array.isArray(cells) && !cells.length) {\n        return\n      } else {\n        ret += generateRow(cells) + \"\\n\";\n      };\n    });\n\n  var l = line(chars.bottom\n             , chars['bottom-left'] || chars.bottom\n             , chars['bottom-right'] || chars.bottom\n             , chars['bottom-mid']);\n  if (l)\n    ret += l;\n  else\n    // trim the last '\\n' if we didn't add the bottom decoration\n    ret = ret.slice(0, -1);\n\n  return ret;\n};\n\n/**\n * Module exports.\n */\n\nmodule.exports = Table;\n\nmodule.exports.version = __webpack_require__(/*! ../package.json */ \"./node_modules/cli-table/package.json\").version;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/cli-table/lib/index.js?");

/***/ }),

/***/ "./node_modules/cli-table/lib/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/cli-table/lib/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var stringWidth = __webpack_require__(/*! string-width */ \"./node_modules/string-width/index.js\");\n\n/**\n * Repeats a string.\n *\n * @param {String} char(s)\n * @param {Number} number of times\n * @return {String} repeated string\n */\n\nexports.repeat = function (str, times){\n  return Array(times + 1).join(str);\n};\n\n/**\n * Pads a string\n *\n * @api public\n */\n\nexports.pad = function (str, len, pad, dir) {\n  if (len + 1 >= str.length)\n    switch (dir){\n      case 'left':\n        str = Array(len + 1 - str.length).join(pad) + str;\n        break;\n\n      case 'both':\n        var right = Math.ceil((padlen = len - str.length) / 2);\n        var left = padlen - right;\n        str = Array(left + 1).join(pad) + str + Array(right + 1).join(pad);\n        break;\n\n      default:\n        str = str + Array(len + 1 - str.length).join(pad);\n    };\n\n  return str;\n};\n\n/**\n * Truncates a string\n *\n * @api public\n */\n\nexports.truncate = function (str, length, chr){\n  chr = chr || '';\n  return str.length >= length ? str.substr(0, length - chr.length) + chr : str;\n};\n\n/**\n * Copies and merges options with defaults.\n *\n * @param {Object} defaults\n * @param {Object} supplied options\n * @return {Object} new (merged) object\n */\n\nfunction options(defaults, opts) {\n  for (var p in opts) {\n    if (opts[p] && opts[p].constructor && opts[p].constructor === Object) {\n      defaults[p] = defaults[p] || {};\n      options(defaults[p], opts[p]);\n    } else {\n      defaults[p] = opts[p];\n    }\n  }\n  return defaults;\n};\nexports.options = options;\n\n//\n// For consideration of terminal \"color\" programs like colors.js,\n// which can add ANSI escape color codes to strings,\n// we destyle the ANSI color escape codes for padding calculations.\n//\n// see: http://en.wikipedia.org/wiki/ANSI_escape_code\n//\nexports.strlen = function(str){\n  var code = /\\u001b\\[(?:\\d*;){0,5}\\d*m/g;\n  var stripped = (\"\" + (str != null ? str : '')).replace(code,'');\n  var split = stripped.split(\"\\n\");\n  return split.reduce(function (memo, s) {\n      var len = stringWidth(s);\n      return (len > memo) ? len : memo;\n  }, 0);\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/cli-table/lib/utils.js?");

/***/ }),

/***/ "./node_modules/cli-table/node_modules/ansi-styles/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/cli-table/node_modules/ansi-styles/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nconst colorConvert = __webpack_require__(/*! color-convert */ \"./node_modules/cli-table/node_modules/color-convert/index.js\");\n\nconst wrapAnsi16 = (fn, offset) => function () {\n\tconst code = fn.apply(colorConvert, arguments);\n\treturn `\\u001B[${code + offset}m`;\n};\n\nconst wrapAnsi256 = (fn, offset) => function () {\n\tconst code = fn.apply(colorConvert, arguments);\n\treturn `\\u001B[${38 + offset};5;${code}m`;\n};\n\nconst wrapAnsi16m = (fn, offset) => function () {\n\tconst rgb = fn.apply(colorConvert, arguments);\n\treturn `\\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;\n};\n\nfunction assembleStyles() {\n\tconst codes = new Map();\n\tconst styles = {\n\t\tmodifier: {\n\t\t\treset: [0, 0],\n\t\t\t// 21 isn't widely supported and 22 does the same thing\n\t\t\tbold: [1, 22],\n\t\t\tdim: [2, 22],\n\t\t\titalic: [3, 23],\n\t\t\tunderline: [4, 24],\n\t\t\tinverse: [7, 27],\n\t\t\thidden: [8, 28],\n\t\t\tstrikethrough: [9, 29]\n\t\t},\n\t\tcolor: {\n\t\t\tblack: [30, 39],\n\t\t\tred: [31, 39],\n\t\t\tgreen: [32, 39],\n\t\t\tyellow: [33, 39],\n\t\t\tblue: [34, 39],\n\t\t\tmagenta: [35, 39],\n\t\t\tcyan: [36, 39],\n\t\t\twhite: [37, 39],\n\t\t\tgray: [90, 39],\n\n\t\t\t// Bright color\n\t\t\tredBright: [91, 39],\n\t\t\tgreenBright: [92, 39],\n\t\t\tyellowBright: [93, 39],\n\t\t\tblueBright: [94, 39],\n\t\t\tmagentaBright: [95, 39],\n\t\t\tcyanBright: [96, 39],\n\t\t\twhiteBright: [97, 39]\n\t\t},\n\t\tbgColor: {\n\t\t\tbgBlack: [40, 49],\n\t\t\tbgRed: [41, 49],\n\t\t\tbgGreen: [42, 49],\n\t\t\tbgYellow: [43, 49],\n\t\t\tbgBlue: [44, 49],\n\t\t\tbgMagenta: [45, 49],\n\t\t\tbgCyan: [46, 49],\n\t\t\tbgWhite: [47, 49],\n\n\t\t\t// Bright color\n\t\t\tbgBlackBright: [100, 49],\n\t\t\tbgRedBright: [101, 49],\n\t\t\tbgGreenBright: [102, 49],\n\t\t\tbgYellowBright: [103, 49],\n\t\t\tbgBlueBright: [104, 49],\n\t\t\tbgMagentaBright: [105, 49],\n\t\t\tbgCyanBright: [106, 49],\n\t\t\tbgWhiteBright: [107, 49]\n\t\t}\n\t};\n\n\t// Fix humans\n\tstyles.color.grey = styles.color.gray;\n\n\tfor (const groupName of Object.keys(styles)) {\n\t\tconst group = styles[groupName];\n\n\t\tfor (const styleName of Object.keys(group)) {\n\t\t\tconst style = group[styleName];\n\n\t\t\tstyles[styleName] = {\n\t\t\t\topen: `\\u001B[${style[0]}m`,\n\t\t\t\tclose: `\\u001B[${style[1]}m`\n\t\t\t};\n\n\t\t\tgroup[styleName] = styles[styleName];\n\n\t\t\tcodes.set(style[0], style[1]);\n\t\t}\n\n\t\tObject.defineProperty(styles, groupName, {\n\t\t\tvalue: group,\n\t\t\tenumerable: false\n\t\t});\n\n\t\tObject.defineProperty(styles, 'codes', {\n\t\t\tvalue: codes,\n\t\t\tenumerable: false\n\t\t});\n\t}\n\n\tconst ansi2ansi = n => n;\n\tconst rgb2rgb = (r, g, b) => [r, g, b];\n\n\tstyles.color.close = '\\u001B[39m';\n\tstyles.bgColor.close = '\\u001B[49m';\n\n\tstyles.color.ansi = {\n\t\tansi: wrapAnsi16(ansi2ansi, 0)\n\t};\n\tstyles.color.ansi256 = {\n\t\tansi256: wrapAnsi256(ansi2ansi, 0)\n\t};\n\tstyles.color.ansi16m = {\n\t\trgb: wrapAnsi16m(rgb2rgb, 0)\n\t};\n\n\tstyles.bgColor.ansi = {\n\t\tansi: wrapAnsi16(ansi2ansi, 10)\n\t};\n\tstyles.bgColor.ansi256 = {\n\t\tansi256: wrapAnsi256(ansi2ansi, 10)\n\t};\n\tstyles.bgColor.ansi16m = {\n\t\trgb: wrapAnsi16m(rgb2rgb, 10)\n\t};\n\n\tfor (let key of Object.keys(colorConvert)) {\n\t\tif (typeof colorConvert[key] !== 'object') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst suite = colorConvert[key];\n\n\t\tif (key === 'ansi16') {\n\t\t\tkey = 'ansi';\n\t\t}\n\n\t\tif ('ansi16' in suite) {\n\t\t\tstyles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);\n\t\t\tstyles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);\n\t\t}\n\n\t\tif ('ansi256' in suite) {\n\t\t\tstyles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);\n\t\t\tstyles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);\n\t\t}\n\n\t\tif ('rgb' in suite) {\n\t\t\tstyles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);\n\t\t\tstyles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);\n\t\t}\n\t}\n\n\treturn styles;\n}\n\n// Make the export immutable\nObject.defineProperty(module, 'exports', {\n\tenumerable: true,\n\tget: assembleStyles\n});\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/cli-table/node_modules/ansi-styles/index.js?");

/***/ }),

/***/ "./node_modules/cli-table/node_modules/chalk/index.js":
/*!************************************************************!*\
  !*** ./node_modules/cli-table/node_modules/chalk/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst escapeStringRegexp = __webpack_require__(/*! escape-string-regexp */ \"./node_modules/escape-string-regexp/index.js\");\nconst ansiStyles = __webpack_require__(/*! ansi-styles */ \"./node_modules/cli-table/node_modules/ansi-styles/index.js\");\nconst stdoutColor = __webpack_require__(/*! supports-color */ \"./node_modules/cli-table/node_modules/supports-color/index.js\").stdout;\n\nconst template = __webpack_require__(/*! ./templates.js */ \"./node_modules/cli-table/node_modules/chalk/templates.js\");\n\nconst isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm');\n\n// `supportsColor.level`  `ansiStyles.color[name]` mapping\nconst levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];\n\n// `color-convert` models to exclude from the Chalk API due to conflicts and such\nconst skipModels = new Set(['gray']);\n\nconst styles = Object.create(null);\n\nfunction applyOptions(obj, options) {\n\toptions = options || {};\n\n\t// Detect level if not set manually\n\tconst scLevel = stdoutColor ? stdoutColor.level : 0;\n\tobj.level = options.level === undefined ? scLevel : options.level;\n\tobj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;\n}\n\nfunction Chalk(options) {\n\t// We check for this.template here since calling `chalk.constructor()`\n\t// by itself will have a `this` of a previously constructed chalk object\n\tif (!this || !(this instanceof Chalk) || this.template) {\n\t\tconst chalk = {};\n\t\tapplyOptions(chalk, options);\n\n\t\tchalk.template = function () {\n\t\t\tconst args = [].slice.call(arguments);\n\t\t\treturn chalkTag.apply(null, [chalk.template].concat(args));\n\t\t};\n\n\t\tObject.setPrototypeOf(chalk, Chalk.prototype);\n\t\tObject.setPrototypeOf(chalk.template, chalk);\n\n\t\tchalk.template.constructor = Chalk;\n\n\t\treturn chalk.template;\n\t}\n\n\tapplyOptions(this, options);\n}\n\n// Use bright blue on Windows as the normal blue color is illegible\nif (isSimpleWindowsTerm) {\n\tansiStyles.blue.open = '\\u001B[94m';\n}\n\nfor (const key of Object.keys(ansiStyles)) {\n\tansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');\n\n\tstyles[key] = {\n\t\tget() {\n\t\t\tconst codes = ansiStyles[key];\n\t\t\treturn build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);\n\t\t}\n\t};\n}\n\nstyles.visible = {\n\tget() {\n\t\treturn build.call(this, this._styles || [], true, 'visible');\n\t}\n};\n\nansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');\nfor (const model of Object.keys(ansiStyles.color.ansi)) {\n\tif (skipModels.has(model)) {\n\t\tcontinue;\n\t}\n\n\tstyles[model] = {\n\t\tget() {\n\t\t\tconst level = this.level;\n\t\t\treturn function () {\n\t\t\t\tconst open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);\n\t\t\t\tconst codes = {\n\t\t\t\t\topen,\n\t\t\t\t\tclose: ansiStyles.color.close,\n\t\t\t\t\tcloseRe: ansiStyles.color.closeRe\n\t\t\t\t};\n\t\t\t\treturn build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);\n\t\t\t};\n\t\t}\n\t};\n}\n\nansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');\nfor (const model of Object.keys(ansiStyles.bgColor.ansi)) {\n\tif (skipModels.has(model)) {\n\t\tcontinue;\n\t}\n\n\tconst bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);\n\tstyles[bgModel] = {\n\t\tget() {\n\t\t\tconst level = this.level;\n\t\t\treturn function () {\n\t\t\t\tconst open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);\n\t\t\t\tconst codes = {\n\t\t\t\t\topen,\n\t\t\t\t\tclose: ansiStyles.bgColor.close,\n\t\t\t\t\tcloseRe: ansiStyles.bgColor.closeRe\n\t\t\t\t};\n\t\t\t\treturn build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);\n\t\t\t};\n\t\t}\n\t};\n}\n\nconst proto = Object.defineProperties(() => {}, styles);\n\nfunction build(_styles, _empty, key) {\n\tconst builder = function () {\n\t\treturn applyStyle.apply(builder, arguments);\n\t};\n\n\tbuilder._styles = _styles;\n\tbuilder._empty = _empty;\n\n\tconst self = this;\n\n\tObject.defineProperty(builder, 'level', {\n\t\tenumerable: true,\n\t\tget() {\n\t\t\treturn self.level;\n\t\t},\n\t\tset(level) {\n\t\t\tself.level = level;\n\t\t}\n\t});\n\n\tObject.defineProperty(builder, 'enabled', {\n\t\tenumerable: true,\n\t\tget() {\n\t\t\treturn self.enabled;\n\t\t},\n\t\tset(enabled) {\n\t\t\tself.enabled = enabled;\n\t\t}\n\t});\n\n\t// See below for fix regarding invisible grey/dim combination on Windows\n\tbuilder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';\n\n\t// `__proto__` is used because we must return a function, but there is\n\t// no way to create a function with a different prototype\n\tbuilder.__proto__ = proto; // eslint-disable-line no-proto\n\n\treturn builder;\n}\n\nfunction applyStyle() {\n\t// Support varags, but simply cast to string in case there's only one arg\n\tconst args = arguments;\n\tconst argsLen = args.length;\n\tlet str = String(arguments[0]);\n\n\tif (argsLen === 0) {\n\t\treturn '';\n\t}\n\n\tif (argsLen > 1) {\n\t\t// Don't slice `arguments`, it prevents V8 optimizations\n\t\tfor (let a = 1; a < argsLen; a++) {\n\t\t\tstr += ' ' + args[a];\n\t\t}\n\t}\n\n\tif (!this.enabled || this.level <= 0 || !str) {\n\t\treturn this._empty ? '' : str;\n\t}\n\n\t// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,\n\t// see https://github.com/chalk/chalk/issues/58\n\t// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.\n\tconst originalDim = ansiStyles.dim.open;\n\tif (isSimpleWindowsTerm && this.hasGrey) {\n\t\tansiStyles.dim.open = '';\n\t}\n\n\tfor (const code of this._styles.slice().reverse()) {\n\t\t// Replace any instances already present with a re-opening code\n\t\t// otherwise only the part of the string until said closing code\n\t\t// will be colored, and the rest will simply be 'plain'.\n\t\tstr = code.open + str.replace(code.closeRe, code.open) + code.close;\n\n\t\t// Close the styling before a linebreak and reopen\n\t\t// after next line to fix a bleed issue on macOS\n\t\t// https://github.com/chalk/chalk/pull/92\n\t\tstr = str.replace(/\\r?\\n/g, `${code.close}$&${code.open}`);\n\t}\n\n\t// Reset the original `dim` if we changed it to work around the Windows dimmed gray issue\n\tansiStyles.dim.open = originalDim;\n\n\treturn str;\n}\n\nfunction chalkTag(chalk, strings) {\n\tif (!Array.isArray(strings)) {\n\t\t// If chalk() was called by itself or with a string,\n\t\t// return the string itself as a string.\n\t\treturn [].slice.call(arguments, 1).join(' ');\n\t}\n\n\tconst args = [].slice.call(arguments, 2);\n\tconst parts = [strings.raw[0]];\n\n\tfor (let i = 1; i < strings.length; i++) {\n\t\tparts.push(String(args[i - 1]).replace(/[{}\\\\]/g, '\\\\$&'));\n\t\tparts.push(String(strings.raw[i]));\n\t}\n\n\treturn template(chalk, parts.join(''));\n}\n\nObject.defineProperties(Chalk.prototype, styles);\n\nmodule.exports = Chalk(); // eslint-disable-line new-cap\nmodule.exports.supportsColor = stdoutColor;\nmodule.exports.default = module.exports; // For TypeScript\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/cli-table/node_modules/chalk/index.js?");

/***/ }),

/***/ "./node_modules/cli-table/node_modules/chalk/templates.js":
/*!****************************************************************!*\
  !*** ./node_modules/cli-table/node_modules/chalk/templates.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("\nconst TEMPLATE_REGEX = /(?:\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;\nconst STYLE_REGEX = /(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;\nconst STRING_REGEX = /^(['\"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;\nconst ESCAPE_REGEX = /\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.)|([^\\\\])/gi;\n\nconst ESCAPES = new Map([\n\t['n', '\\n'],\n\t['r', '\\r'],\n\t['t', '\\t'],\n\t['b', '\\b'],\n\t['f', '\\f'],\n\t['v', '\\v'],\n\t['0', '\\0'],\n\t['\\\\', '\\\\'],\n\t['e', '\\u001B'],\n\t['a', '\\u0007']\n]);\n\nfunction unescape(c) {\n\tif ((c[0] === 'u' && c.length === 5) || (c[0] === 'x' && c.length === 3)) {\n\t\treturn String.fromCharCode(parseInt(c.slice(1), 16));\n\t}\n\n\treturn ESCAPES.get(c) || c;\n}\n\nfunction parseArguments(name, args) {\n\tconst results = [];\n\tconst chunks = args.trim().split(/\\s*,\\s*/g);\n\tlet matches;\n\n\tfor (const chunk of chunks) {\n\t\tif (!isNaN(chunk)) {\n\t\t\tresults.push(Number(chunk));\n\t\t} else if ((matches = chunk.match(STRING_REGEX))) {\n\t\t\tresults.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));\n\t\t} else {\n\t\t\tthrow new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);\n\t\t}\n\t}\n\n\treturn results;\n}\n\nfunction parseStyle(style) {\n\tSTYLE_REGEX.lastIndex = 0;\n\n\tconst results = [];\n\tlet matches;\n\n\twhile ((matches = STYLE_REGEX.exec(style)) !== null) {\n\t\tconst name = matches[1];\n\n\t\tif (matches[2]) {\n\t\t\tconst args = parseArguments(name, matches[2]);\n\t\t\tresults.push([name].concat(args));\n\t\t} else {\n\t\t\tresults.push([name]);\n\t\t}\n\t}\n\n\treturn results;\n}\n\nfunction buildStyle(chalk, styles) {\n\tconst enabled = {};\n\n\tfor (const layer of styles) {\n\t\tfor (const style of layer.styles) {\n\t\t\tenabled[style[0]] = layer.inverse ? null : style.slice(1);\n\t\t}\n\t}\n\n\tlet current = chalk;\n\tfor (const styleName of Object.keys(enabled)) {\n\t\tif (Array.isArray(enabled[styleName])) {\n\t\t\tif (!(styleName in current)) {\n\t\t\t\tthrow new Error(`Unknown Chalk style: ${styleName}`);\n\t\t\t}\n\n\t\t\tif (enabled[styleName].length > 0) {\n\t\t\t\tcurrent = current[styleName].apply(current, enabled[styleName]);\n\t\t\t} else {\n\t\t\t\tcurrent = current[styleName];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn current;\n}\n\nmodule.exports = (chalk, tmp) => {\n\tconst styles = [];\n\tconst chunks = [];\n\tlet chunk = [];\n\n\t// eslint-disable-next-line max-params\n\ttmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {\n\t\tif (escapeChar) {\n\t\t\tchunk.push(unescape(escapeChar));\n\t\t} else if (style) {\n\t\t\tconst str = chunk.join('');\n\t\t\tchunk = [];\n\t\t\tchunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));\n\t\t\tstyles.push({inverse, styles: parseStyle(style)});\n\t\t} else if (close) {\n\t\t\tif (styles.length === 0) {\n\t\t\t\tthrow new Error('Found extraneous } in Chalk template literal');\n\t\t\t}\n\n\t\t\tchunks.push(buildStyle(chalk, styles)(chunk.join('')));\n\t\t\tchunk = [];\n\t\t\tstyles.pop();\n\t\t} else {\n\t\t\tchunk.push(chr);\n\t\t}\n\t});\n\n\tchunks.push(chunk.join(''));\n\n\tif (styles.length > 0) {\n\t\tconst errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\\`}\\`)`;\n\t\tthrow new Error(errMsg);\n\t}\n\n\treturn chunks.join('');\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/cli-table/node_modules/chalk/templates.js?");

/***/ }),

/***/ "./node_modules/cli-table/node_modules/color-convert/conversions.js":
/*!**************************************************************************!*\
  !*** ./node_modules/cli-table/node_modules/color-convert/conversions.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* MIT license */\nvar cssKeywords = __webpack_require__(/*! color-name */ \"./node_modules/cli-table/node_modules/color-name/index.js\");\n\n// NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\n\nvar reverseKeywords = {};\nfor (var key in cssKeywords) {\n\tif (cssKeywords.hasOwnProperty(key)) {\n\t\treverseKeywords[cssKeywords[key]] = key;\n\t}\n}\n\nvar convert = module.exports = {\n\trgb: {channels: 3, labels: 'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb: {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz: {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels: 3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels: 1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256: {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\n// hide .channels and .labels properties\nfor (var model in convert) {\n\tif (convert.hasOwnProperty(model)) {\n\t\tif (!('channels' in convert[model])) {\n\t\t\tthrow new Error('missing channels property: ' + model);\n\t\t}\n\n\t\tif (!('labels' in convert[model])) {\n\t\t\tthrow new Error('missing channel labels property: ' + model);\n\t\t}\n\n\t\tif (convert[model].labels.length !== convert[model].channels) {\n\t\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t\t}\n\n\t\tvar channels = convert[model].channels;\n\t\tvar labels = convert[model].labels;\n\t\tdelete convert[model].channels;\n\t\tdelete convert[model].labels;\n\t\tObject.defineProperty(convert[model], 'channels', {value: channels});\n\t\tObject.defineProperty(convert[model], 'labels', {value: labels});\n\t}\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar min = Math.min(r, g, b);\n\tvar max = Math.max(r, g, b);\n\tvar delta = max - min;\n\tvar h;\n\tvar s;\n\tvar l;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tl = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tvar rdif;\n\tvar gdif;\n\tvar bdif;\n\tvar h;\n\tvar s;\n\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar v = Math.max(r, g, b);\n\tvar diff = v - Math.min(r, g, b);\n\tvar diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\n\tif (diff === 0) {\n\t\th = s = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif = diffc(g);\n\t\tbdif = diffc(b);\n\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t} else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v) {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t} else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\n\treturn [\n\t\th * 360,\n\t\ts * 100,\n\t\tv * 100\n\t];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tvar r = rgb[0];\n\tvar g = rgb[1];\n\tvar b = rgb[2];\n\tvar h = convert.rgb.hsl(rgb)[0];\n\tvar w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar c;\n\tvar m;\n\tvar y;\n\tvar k;\n\n\tk = Math.min(1 - r, 1 - g, 1 - b);\n\tc = (1 - r - k) / (1 - k) || 0;\n\tm = (1 - g - k) / (1 - k) || 0;\n\ty = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100, k * 100];\n};\n\n/**\n * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n * */\nfunction comparativeDistance(x, y) {\n\treturn (\n\t\tMath.pow(x[0] - y[0], 2) +\n\t\tMath.pow(x[1] - y[1], 2) +\n\t\tMath.pow(x[2] - y[2], 2)\n\t);\n}\n\nconvert.rgb.keyword = function (rgb) {\n\tvar reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn reversed;\n\t}\n\n\tvar currentClosestDistance = Infinity;\n\tvar currentClosestKeyword;\n\n\tfor (var keyword in cssKeywords) {\n\t\tif (cssKeywords.hasOwnProperty(keyword)) {\n\t\t\tvar value = cssKeywords[keyword];\n\n\t\t\t// Compute comparative distance\n\t\t\tvar distance = comparativeDistance(rgb, value);\n\n\t\t\t// Check if its less, if so set as closest\n\t\t\tif (distance < currentClosestDistance) {\n\t\t\t\tcurrentClosestDistance = distance;\n\t\t\t\tcurrentClosestKeyword = keyword;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn cssKeywords[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\n\t// assume sRGB\n\tr = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n\tvar x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tvar y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tvar z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100, z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tvar xyz = convert.rgb.xyz(rgb);\n\tvar x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tvar h = hsl[0] / 360;\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar t1;\n\tvar t2;\n\tvar t3;\n\tvar rgb;\n\tvar val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val, val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l + s - l * s;\n\t}\n\n\tt1 = 2 * l - t2;\n\n\trgb = [0, 0, 0];\n\tfor (var i = 0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\t\tif (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv = function (hsl) {\n\tvar h = hsl[0];\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar smin = s;\n\tvar lmin = Math.max(l, 0.01);\n\tvar sv;\n\tvar v;\n\n\tl *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tv = (l + s) / 2;\n\tsv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tvar h = hsv[0] / 60;\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar hi = Math.floor(h) % 6;\n\n\tvar f = h - Math.floor(h);\n\tvar p = 255 * v * (1 - s);\n\tvar q = 255 * v * (1 - (s * f));\n\tvar t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v, p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase 4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl = function (hsv) {\n\tvar h = hsv[0];\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar vmin = Math.max(v, 0.01);\n\tvar lmin;\n\tvar sl;\n\tvar l;\n\n\tl = (2 - s) * v;\n\tlmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb) {\n\tvar h = hwb[0] / 360;\n\tvar wh = hwb[1] / 100;\n\tvar bl = hwb[2] / 100;\n\tvar ratio = wh + bl;\n\tvar i;\n\tvar v;\n\tvar f;\n\tvar n;\n\n\t// wh + bl cant be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\ti = Math.floor(6 * h);\n\tv = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1 - f;\n\t}\n\n\tn = wh + f * (v - wh); // linear interpolation\n\n\tvar r;\n\tvar g;\n\tvar b;\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v; g = n; b = wh; break;\n\t\tcase 1: r = n; g = v; b = wh; break;\n\t\tcase 2: r = wh; g = v; b = n; break;\n\t\tcase 3: r = wh; g = n; b = v; break;\n\t\tcase 4: r = n; g = wh; b = v; break;\n\t\tcase 5: r = v; g = wh; b = n; break;\n\t}\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tvar c = cmyk[0] / 100;\n\tvar m = cmyk[1] / 100;\n\tvar y = cmyk[2] / 100;\n\tvar k = cmyk[3] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = 1 - Math.min(1, c * (1 - k) + k);\n\tg = 1 - Math.min(1, m * (1 - k) + k);\n\tb = 1 - Math.min(1, y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb = function (xyz) {\n\tvar x = xyz[0] / 100;\n\tvar y = xyz[1] / 100;\n\tvar z = xyz[2] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// assume sRGB\n\tr = r > 0.0031308\n\t\t? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tvar x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tvar l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar x;\n\tvar y;\n\tvar z;\n\n\ty = (l + 16) / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tvar y2 = Math.pow(y, 3);\n\tvar x2 = Math.pow(x, 3);\n\tvar z2 = Math.pow(z, 3);\n\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tvar l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar hr;\n\tvar h;\n\tvar c;\n\n\thr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tc = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab = function (lch) {\n\tvar l = lch[0];\n\tvar c = lch[1];\n\tvar h = lch[2];\n\tvar a;\n\tvar b;\n\tvar hr;\n\n\thr = h / 360 * 2 * Math.PI;\n\ta = c * Math.cos(hr);\n\tb = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\tvar value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization\n\n\tvalue = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tvar ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t| Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// optimization here; we already know the value and don't need to get\n\t// it converted for us.\n\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256 = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\n\t// we use the extended greyscale palette here, with the exception of\n\t// black and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g === b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn 231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tvar ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb = function (args) {\n\tvar color = args % 10;\n\n\t// handle greyscale\n\tif (color === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tvar mult = (~~(args > 50) + 1) * 0.5;\n\tvar r = ((color & 1) * mult) * 255;\n\tvar g = (((color >> 1) & 1) * mult) * 255;\n\tvar b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// handle greyscale\n\tif (args >= 232) {\n\t\tvar c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs -= 16;\n\n\tvar rem;\n\tvar r = Math.floor(args / 36) / 5 * 255;\n\tvar g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\tvar b = (rem % 6) / 5 * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hex = function (args) {\n\tvar integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2]) & 0xFF);\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tvar match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tvar colorString = match[0];\n\n\tif (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(function (char) {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\n\tvar integer = parseInt(colorString, 16);\n\tvar r = (integer >> 16) & 0xFF;\n\tvar g = (integer >> 8) & 0xFF;\n\tvar b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar max = Math.max(Math.max(r, g), b);\n\tvar min = Math.min(Math.min(r, g), b);\n\tvar chroma = (max - min);\n\tvar grayscale;\n\tvar hue;\n\n\tif (chroma < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b) / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t} else {\n\t\thue = 4 + (r - g) / chroma + 4;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function (hsl) {\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar c = 1;\n\tvar f = 0;\n\n\tif (l < 0.5) {\n\t\tc = 2.0 * s * l;\n\t} else {\n\t\tc = 2.0 * s * (1.0 - l);\n\t}\n\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\n\tvar c = s * v;\n\tvar f = 0;\n\n\tif (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f * 100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tvar h = hcg[0] / 360;\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g * 255, g * 255, g * 255];\n\t}\n\n\tvar pure = [0, 0, 0];\n\tvar hi = (h % 1) * 6;\n\tvar v = hi % 1;\n\tvar w = 1 - v;\n\tvar mg = 0;\n\n\tswitch (Math.floor(hi)) {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase 1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\n\tmg = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1] + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar v = c + g * (1.0 - c);\n\tvar f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar l = g * (1.0 - c) + 0.5 * c;\n\tvar s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s * 100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\tvar v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tvar w = hwb[1] / 100;\n\tvar b = hwb[2] / 100;\n\tvar v = 1 - b;\n\tvar c = v - w;\n\tvar g = 0;\n\n\tif (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\n\nconvert.gray.hsl = convert.gray.hsv = function (args) {\n\treturn [0, 0, args[0]];\n};\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100, gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function (gray) {\n\tvar val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tvar integer = (val << 16) + (val << 8) + val;\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function (rgb) {\n\tvar val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/cli-table/node_modules/color-convert/conversions.js?");

/***/ }),

/***/ "./node_modules/cli-table/node_modules/color-convert/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/cli-table/node_modules/color-convert/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var conversions = __webpack_require__(/*! ./conversions */ \"./node_modules/cli-table/node_modules/color-convert/conversions.js\");\nvar route = __webpack_require__(/*! ./route */ \"./node_modules/cli-table/node_modules/color-convert/route.js\");\n\nvar convert = {};\n\nvar models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn args;\n\t\t}\n\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn args;\n\t\t}\n\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\tvar result = fn(args);\n\n\t\t// we're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (var len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(function (fromModel) {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tvar routes = route(fromModel);\n\tvar routeModels = Object.keys(routes);\n\n\trouteModels.forEach(function (toModel) {\n\t\tvar fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nmodule.exports = convert;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/cli-table/node_modules/color-convert/index.js?");

/***/ }),

/***/ "./node_modules/cli-table/node_modules/color-convert/route.js":
/*!********************************************************************!*\
  !*** ./node_modules/cli-table/node_modules/color-convert/route.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var conversions = __webpack_require__(/*! ./conversions */ \"./node_modules/cli-table/node_modules/color-convert/conversions.js\");\n\n/*\n\tthis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction buildGraph() {\n\tvar graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tvar models = Object.keys(conversions);\n\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tvar graph = buildGraph();\n\tvar queue = [fromModel]; // unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tvar current = queue.pop();\n\t\tvar adjacents = Object.keys(conversions[current]);\n\n\t\tfor (var len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tvar adjacent = adjacents[i];\n\t\t\tvar node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tvar path = [graph[toModel].parent, toModel];\n\tvar fn = conversions[graph[toModel].parent][toModel];\n\n\tvar cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nmodule.exports = function (fromModel) {\n\tvar graph = deriveBFS(fromModel);\n\tvar conversion = {};\n\n\tvar models = Object.keys(graph);\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tvar toModel = models[i];\n\t\tvar node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// no possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/cli-table/node_modules/color-convert/route.js?");

/***/ }),

/***/ "./node_modules/cli-table/node_modules/color-name/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/cli-table/node_modules/color-name/index.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/cli-table/node_modules/color-name/index.js?");

/***/ }),

/***/ "./node_modules/cli-table/node_modules/has-flag/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/cli-table/node_modules/has-flag/index.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = (flag, argv) => {\n\targv = argv || process.argv;\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst pos = argv.indexOf(prefix + flag);\n\tconst terminatorPos = argv.indexOf('--');\n\treturn pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/cli-table/node_modules/has-flag/index.js?");

/***/ }),

/***/ "./node_modules/cli-table/node_modules/supports-color/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/cli-table/node_modules/supports-color/index.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst os = __webpack_require__(/*! os */ \"os\");\nconst hasFlag = __webpack_require__(/*! has-flag */ \"./node_modules/cli-table/node_modules/has-flag/index.js\");\n\nconst env = process.env;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false')) {\n\tforceColor = false;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = true;\n}\nif ('FORCE_COLOR' in env) {\n\tforceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(stream) {\n\tif (forceColor === false) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (stream && !stream.isTTY && forceColor !== true) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor ? 1 : 0;\n\n\tif (process.platform === 'win32') {\n\t\t// Node.js 7.5.0 is the first version of Node.js to include a patch to\n\t\t// libuv that enables 256 color output on Windows. Anything earlier and it\n\t\t// won't work. However, here we target Node.js 8 at minimum as it is an LTS\n\t\t// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows\n\t\t// release that supports 256 colors. Windows 10 build 14931 is the first release\n\t\t// that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(process.versions.node.split('.')[0]) >= 8 &&\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: getSupportLevel(process.stdout),\n\tstderr: getSupportLevel(process.stderr)\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/cli-table/node_modules/supports-color/index.js?");

/***/ }),

/***/ "./node_modules/cli-table/package.json":
/*!*********************************************!*\
  !*** ./node_modules/cli-table/package.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse(\"{\\\"name\\\":\\\"cli-table\\\",\\\"description\\\":\\\"Pretty unicode tables for the CLI\\\",\\\"version\\\":\\\"0.3.4\\\",\\\"license\\\":\\\"MIT\\\",\\\"author\\\":\\\"Guillermo Rauch <guillermo@learnboost.com>\\\",\\\"contributors\\\":[\\\"Sonny Michaud <michaud.sonny@gmail.com> (http://github.com/sonnym)\\\",\\\"Gabriel Sambarino <gabriel.sambarino@gmail.com> (http://github.com/chrean)\\\"],\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"https://github.com/Automattic/cli-table.git\\\"},\\\"keywords\\\":[\\\"cli\\\",\\\"colors\\\",\\\"table\\\"],\\\"dependencies\\\":{\\\"chalk\\\":\\\"^2.4.1\\\",\\\"string-width\\\":\\\"^4.2.0\\\"},\\\"devDependencies\\\":{\\\"@babel/core\\\":\\\"^7.12.9\\\",\\\"@babel/preset-env\\\":\\\"^7.12.7\\\",\\\"@babel/preset-typescript\\\":\\\"^7.12.7\\\",\\\"babel-jest\\\":\\\"^26.6.3\\\",\\\"expect\\\":\\\"^26.6.2\\\",\\\"expresso\\\":\\\"~0.9\\\",\\\"jest\\\":\\\"^26.6.3\\\",\\\"jest-mock\\\":\\\"^26.6.2\\\",\\\"publish-please\\\":\\\"^5.5.2\\\",\\\"ts-node\\\":\\\"^9.1.0\\\",\\\"typescript\\\":\\\"^4.1.2\\\"},\\\"main\\\":\\\"lib\\\",\\\"files\\\":[\\\"lib\\\"],\\\"scripts\\\":{\\\"test\\\":\\\"jest\\\",\\\"publish-please\\\":\\\"publish-please --access public\\\"},\\\"engines\\\":{\\\"node\\\":\\\">= 10.0.0\\\"}}\");\n\n//# sourceURL=webpack://coc.nvim/./node_modules/cli-table/package.json?");

/***/ }),

/***/ "./node_modules/clipboardy/index.js":
/*!******************************************!*\
  !*** ./node_modules/clipboardy/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst isWSL = __webpack_require__(/*! is-wsl */ \"./node_modules/is-wsl/index.js\");\nconst termux = __webpack_require__(/*! ./lib/termux.js */ \"./node_modules/clipboardy/lib/termux.js\");\nconst linux = __webpack_require__(/*! ./lib/linux.js */ \"./node_modules/clipboardy/lib/linux.js\");\nconst macos = __webpack_require__(/*! ./lib/macos.js */ \"./node_modules/clipboardy/lib/macos.js\");\nconst windows = __webpack_require__(/*! ./lib/windows.js */ \"./node_modules/clipboardy/lib/windows.js\");\n\nconst platformLib = (() => {\n\tswitch (process.platform) {\n\t\tcase 'darwin':\n\t\t\treturn macos;\n\t\tcase 'win32':\n\t\t\treturn windows;\n\t\tcase 'android':\n\t\t\tif (process.env.PREFIX !== '/data/data/com.termux/files/usr') {\n\t\t\t\tthrow new Error('You need to install Termux for this module to work on Android: https://termux.com');\n\t\t\t}\n\n\t\t\treturn termux;\n\t\tdefault:\n\t\t\t// `process.platform === 'linux'` for WSL.\n\t\t\tif (isWSL) {\n\t\t\t\treturn windows;\n\t\t\t}\n\n\t\t\treturn linux;\n\t}\n})();\n\nexports.write = async text => {\n\tif (typeof text !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof text}`);\n\t}\n\n\tawait platformLib.copy({input: text});\n};\n\nexports.read = async () => platformLib.paste({stripEof: false});\n\nexports.writeSync = text => {\n\tif (typeof text !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof text}`);\n\t}\n\n\tplatformLib.copySync({input: text});\n};\n\nexports.readSync = () => platformLib.pasteSync({stripEof: false}).stdout;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/clipboardy/index.js?");

/***/ }),

/***/ "./node_modules/clipboardy/lib/linux.js":
/*!**********************************************!*\
  !*** ./node_modules/clipboardy/lib/linux.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst path = __webpack_require__(/*! path */ \"path\");\nconst execa = __webpack_require__(/*! execa */ \"./node_modules/execa/index.js\");\n\nconst xsel = 'xsel';\nconst xselFallback = path.join(__dirname, '../fallbacks/linux/xsel');\n\nconst copyArguments = ['--clipboard', '--input'];\nconst pasteArguments = ['--clipboard', '--output'];\n\nconst makeError = (xselError, fallbackError) => {\n\tlet error;\n\tif (xselError.code === 'ENOENT') {\n\t\terror = new Error('Couldn\\'t find the `xsel` binary and fallback didn\\'t work. On Debian/Ubuntu you can install xsel with: sudo apt install xsel');\n\t} else {\n\t\terror = new Error('Both xsel and fallback failed');\n\t\terror.xselError = xselError;\n\t}\n\n\terror.fallbackError = fallbackError;\n\treturn error;\n};\n\nconst xselWithFallback = async (argumentList, options) => {\n\ttry {\n\t\treturn await execa.stdout(xsel, argumentList, options);\n\t} catch (xselError) {\n\t\ttry {\n\t\t\treturn await execa.stdout(xselFallback, argumentList, options);\n\t\t} catch (fallbackError) {\n\t\t\tthrow makeError(xselError, fallbackError);\n\t\t}\n\t}\n};\n\nconst xselWithFallbackSync = (argumentList, options) => {\n\ttry {\n\t\treturn execa.sync(xsel, argumentList, options);\n\t} catch (xselError) {\n\t\ttry {\n\t\t\treturn execa.sync(xselFallback, argumentList, options);\n\t\t} catch (fallbackError) {\n\t\t\tthrow makeError(xselError, fallbackError);\n\t\t}\n\t}\n};\n\nmodule.exports = {\n\tcopy: async options => {\n\t\tawait xselWithFallback(copyArguments, options);\n\t},\n\tcopySync: options => {\n\t\txselWithFallbackSync(copyArguments, options);\n\t},\n\tpaste: options => xselWithFallback(pasteArguments, options),\n\tpasteSync: options => xselWithFallbackSync(pasteArguments, options)\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/clipboardy/lib/linux.js?");

/***/ }),

/***/ "./node_modules/clipboardy/lib/macos.js":
/*!**********************************************!*\
  !*** ./node_modules/clipboardy/lib/macos.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst execa = __webpack_require__(/*! execa */ \"./node_modules/execa/index.js\");\n\nconst env = {\n\t...process.env,\n\tLC_CTYPE: 'UTF-8'\n};\n\nmodule.exports = {\n\tcopy: async options => execa('pbcopy', {...options, env}),\n\tpaste: async options => execa.stdout('pbpaste', {...options, env}),\n\tcopySync: options => execa.sync('pbcopy', {...options, env}),\n\tpasteSync: options => execa.sync('pbpaste', {...options, env})\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/clipboardy/lib/macos.js?");

/***/ }),

/***/ "./node_modules/clipboardy/lib/termux.js":
/*!***********************************************!*\
  !*** ./node_modules/clipboardy/lib/termux.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst execa = __webpack_require__(/*! execa */ \"./node_modules/execa/index.js\");\n\nconst handler = error => {\n\tif (error.code === 'ENOENT') {\n\t\tthrow new Error('Couldn\\'t find the termux-api scripts. You can install them with: apt install termux-api');\n\t}\n\n\tthrow error;\n};\n\nmodule.exports = {\n\tcopy: async options => {\n\t\ttry {\n\t\t\tawait execa('termux-clipboard-set', options);\n\t\t} catch (error) {\n\t\t\thandler(error);\n\t\t}\n\t},\n\tpaste: async options => {\n\t\ttry {\n\t\t\treturn await execa.stdout('termux-clipboard-get', options);\n\t\t} catch (error) {\n\t\t\thandler(error);\n\t\t}\n\t},\n\tcopySync: options => {\n\t\ttry {\n\t\t\texeca.sync('termux-clipboard-set', options);\n\t\t} catch (error) {\n\t\t\thandler(error);\n\t\t}\n\t},\n\tpasteSync: options => {\n\t\ttry {\n\t\t\treturn execa.sync('termux-clipboard-get', options);\n\t\t} catch (error) {\n\t\t\thandler(error);\n\t\t}\n\t}\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/clipboardy/lib/termux.js?");

/***/ }),

/***/ "./node_modules/clipboardy/lib/windows.js":
/*!************************************************!*\
  !*** ./node_modules/clipboardy/lib/windows.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst path = __webpack_require__(/*! path */ \"path\");\nconst execa = __webpack_require__(/*! execa */ \"./node_modules/execa/index.js\");\nconst arch = __webpack_require__(/*! arch */ \"./node_modules/arch/index.js\");\n\n// Binaries from: https://github.com/sindresorhus/win-clipboard\nconst windowBinaryPath = arch() === 'x64' ?\n\tpath.join(__dirname, '../fallbacks/windows/clipboard_x86_64.exe') :\n\tpath.join(__dirname, '../fallbacks/windows/clipboard_i686.exe');\n\nmodule.exports = {\n\tcopy: async options => execa(windowBinaryPath, ['--copy'], options),\n\tpaste: async options => execa.stdout(windowBinaryPath, ['--paste'], options),\n\tcopySync: options => execa.sync(windowBinaryPath, ['--copy'], options),\n\tpasteSync: options => execa.sync(windowBinaryPath, ['--paste'], options)\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/clipboardy/lib/windows.js?");

/***/ }),

/***/ "./node_modules/concat-map/index.js":
/*!******************************************!*\
  !*** ./node_modules/concat-map/index.js ***!
  \******************************************/
/***/ ((module) => {

eval("module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/concat-map/index.js?");

/***/ }),

/***/ "./node_modules/content-disposition/index.js":
/*!***************************************************!*\
  !*** ./node_modules/content-disposition/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * content-disposition\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = contentDisposition\nmodule.exports.parse = parse\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar basename = __webpack_require__(/*! path */ \"path\").basename\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\n/**\n * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including \"%\")\n * @private\n */\n\nvar ENCODE_URL_ATTR_CHAR_REGEXP = /[\\x00-\\x20\"'()*,/:;<=>?@[\\\\\\]{}\\x7f]/g // eslint-disable-line no-control-regex\n\n/**\n * RegExp to match percent encoding escape.\n * @private\n */\n\nvar HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/\nvar HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g\n\n/**\n * RegExp to match non-latin1 characters.\n * @private\n */\n\nvar NON_LATIN1_REGEXP = /[^\\x20-\\x7e\\xa0-\\xff]/g\n\n/**\n * RegExp to match quoted-pair in RFC 2616\n *\n * quoted-pair = \"\\\" CHAR\n * CHAR        = <any US-ASCII character (octets 0 - 127)>\n * @private\n */\n\nvar QESC_REGEXP = /\\\\([\\u0000-\\u007f])/g // eslint-disable-line no-control-regex\n\n/**\n * RegExp to match chars that must be quoted-pair in RFC 2616\n * @private\n */\n\nvar QUOTE_REGEXP = /([\\\\\"])/g\n\n/**\n * RegExp for various RFC 2616 grammar\n *\n * parameter     = token \"=\" ( token | quoted-string )\n * token         = 1*<any CHAR except CTLs or separators>\n * separators    = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *               | \",\" | \";\" | \":\" | \"\\\" | <\">\n *               | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *               | \"{\" | \"}\" | SP | HT\n * quoted-string = ( <\"> *(qdtext | quoted-pair ) <\"> )\n * qdtext        = <any TEXT except <\">>\n * quoted-pair   = \"\\\" CHAR\n * CHAR          = <any US-ASCII character (octets 0 - 127)>\n * TEXT          = <any OCTET except CTLs, but including LWS>\n * LWS           = [CRLF] 1*( SP | HT )\n * CRLF          = CR LF\n * CR            = <US-ASCII CR, carriage return (13)>\n * LF            = <US-ASCII LF, linefeed (10)>\n * SP            = <US-ASCII SP, space (32)>\n * HT            = <US-ASCII HT, horizontal-tab (9)>\n * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>\n * OCTET         = <any 8-bit sequence of data>\n * @private\n */\n\nvar PARAM_REGEXP = /;[\\x09\\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\\x09\\x20]*=[\\x09\\x20]*(\"(?:[\\x20!\\x23-\\x5b\\x5d-\\x7e\\x80-\\xff]|\\\\[\\x20-\\x7e])*\"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\\x09\\x20]*/g // eslint-disable-line no-control-regex\nvar TEXT_REGEXP = /^[\\x20-\\x7e\\x80-\\xff]+$/\nvar TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/\n\n/**\n * RegExp for various RFC 5987 grammar\n *\n * ext-value     = charset  \"'\" [ language ] \"'\" value-chars\n * charset       = \"UTF-8\" / \"ISO-8859-1\" / mime-charset\n * mime-charset  = 1*mime-charsetc\n * mime-charsetc = ALPHA / DIGIT\n *               / \"!\" / \"#\" / \"$\" / \"%\" / \"&\"\n *               / \"+\" / \"-\" / \"^\" / \"_\" / \"`\"\n *               / \"{\" / \"}\" / \"~\"\n * language      = ( 2*3ALPHA [ extlang ] )\n *               / 4ALPHA\n *               / 5*8ALPHA\n * extlang       = *3( \"-\" 3ALPHA )\n * value-chars   = *( pct-encoded / attr-char )\n * pct-encoded   = \"%\" HEXDIG HEXDIG\n * attr-char     = ALPHA / DIGIT\n *               / \"!\" / \"#\" / \"$\" / \"&\" / \"+\" / \"-\" / \".\"\n *               / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n * @private\n */\n\nvar EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/\n\n/**\n * RegExp for various RFC 6266 grammar\n *\n * disposition-type = \"inline\" | \"attachment\" | disp-ext-type\n * disp-ext-type    = token\n * disposition-parm = filename-parm | disp-ext-parm\n * filename-parm    = \"filename\" \"=\" value\n *                  | \"filename*\" \"=\" ext-value\n * disp-ext-parm    = token \"=\" value\n *                  | ext-token \"=\" ext-value\n * ext-token        = <the characters in token, followed by \"*\">\n * @private\n */\n\nvar DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\\x09\\x20]*(?:$|;)/ // eslint-disable-line no-control-regex\n\n/**\n * Create an attachment Content-Disposition header.\n *\n * @param {string} [filename]\n * @param {object} [options]\n * @param {string} [options.type=attachment]\n * @param {string|boolean} [options.fallback=true]\n * @return {string}\n * @public\n */\n\nfunction contentDisposition (filename, options) {\n  var opts = options || {}\n\n  // get type\n  var type = opts.type || 'attachment'\n\n  // get parameters\n  var params = createparams(filename, opts.fallback)\n\n  // format into string\n  return format(new ContentDisposition(type, params))\n}\n\n/**\n * Create parameters object from filename and fallback.\n *\n * @param {string} [filename]\n * @param {string|boolean} [fallback=true]\n * @return {object}\n * @private\n */\n\nfunction createparams (filename, fallback) {\n  if (filename === undefined) {\n    return\n  }\n\n  var params = {}\n\n  if (typeof filename !== 'string') {\n    throw new TypeError('filename must be a string')\n  }\n\n  // fallback defaults to true\n  if (fallback === undefined) {\n    fallback = true\n  }\n\n  if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {\n    throw new TypeError('fallback must be a string or boolean')\n  }\n\n  if (typeof fallback === 'string' && NON_LATIN1_REGEXP.test(fallback)) {\n    throw new TypeError('fallback must be ISO-8859-1 string')\n  }\n\n  // restrict to file base name\n  var name = basename(filename)\n\n  // determine if name is suitable for quoted string\n  var isQuotedString = TEXT_REGEXP.test(name)\n\n  // generate fallback name\n  var fallbackName = typeof fallback !== 'string'\n    ? fallback && getlatin1(name)\n    : basename(fallback)\n  var hasFallback = typeof fallbackName === 'string' && fallbackName !== name\n\n  // set extended filename parameter\n  if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {\n    params['filename*'] = name\n  }\n\n  // set filename parameter\n  if (isQuotedString || hasFallback) {\n    params.filename = hasFallback\n      ? fallbackName\n      : name\n  }\n\n  return params\n}\n\n/**\n * Format object to Content-Disposition header.\n *\n * @param {object} obj\n * @param {string} obj.type\n * @param {object} [obj.parameters]\n * @return {string}\n * @private\n */\n\nfunction format (obj) {\n  var parameters = obj.parameters\n  var type = obj.type\n\n  if (!type || typeof type !== 'string' || !TOKEN_REGEXP.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  // start with normalized type\n  var string = String(type).toLowerCase()\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param\n    var params = Object.keys(parameters).sort()\n\n    for (var i = 0; i < params.length; i++) {\n      param = params[i]\n\n      var val = param.substr(-1) === '*'\n        ? ustring(parameters[param])\n        : qstring(parameters[param])\n\n      string += '; ' + param + '=' + val\n    }\n  }\n\n  return string\n}\n\n/**\n * Decode a RFC 6987 field value (gracefully).\n *\n * @param {string} str\n * @return {string}\n * @private\n */\n\nfunction decodefield (str) {\n  var match = EXT_VALUE_REGEXP.exec(str)\n\n  if (!match) {\n    throw new TypeError('invalid extended field value')\n  }\n\n  var charset = match[1].toLowerCase()\n  var encoded = match[2]\n  var value\n\n  // to binary string\n  var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode)\n\n  switch (charset) {\n    case 'iso-8859-1':\n      value = getlatin1(binary)\n      break\n    case 'utf-8':\n      value = Buffer.from(binary, 'binary').toString('utf8')\n      break\n    default:\n      throw new TypeError('unsupported charset in extended field')\n  }\n\n  return value\n}\n\n/**\n * Get ISO-8859-1 version of string.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction getlatin1 (val) {\n  // simple Unicode -> ISO-8859-1 transformation\n  return String(val).replace(NON_LATIN1_REGEXP, '?')\n}\n\n/**\n * Parse Content-Disposition header string.\n *\n * @param {string} string\n * @return {object}\n * @public\n */\n\nfunction parse (string) {\n  if (!string || typeof string !== 'string') {\n    throw new TypeError('argument string is required')\n  }\n\n  var match = DISPOSITION_TYPE_REGEXP.exec(string)\n\n  if (!match) {\n    throw new TypeError('invalid type format')\n  }\n\n  // normalize type\n  var index = match[0].length\n  var type = match[1].toLowerCase()\n\n  var key\n  var names = []\n  var params = {}\n  var value\n\n  // calculate index to start at\n  index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ';'\n    ? index - 1\n    : index\n\n  // match parameters\n  while ((match = PARAM_REGEXP.exec(string))) {\n    if (match.index !== index) {\n      throw new TypeError('invalid parameter format')\n    }\n\n    index += match[0].length\n    key = match[1].toLowerCase()\n    value = match[2]\n\n    if (names.indexOf(key) !== -1) {\n      throw new TypeError('invalid duplicate parameter')\n    }\n\n    names.push(key)\n\n    if (key.indexOf('*') + 1 === key.length) {\n      // decode extended value\n      key = key.slice(0, -1)\n      value = decodefield(value)\n\n      // overwrite existing value\n      params[key] = value\n      continue\n    }\n\n    if (typeof params[key] === 'string') {\n      continue\n    }\n\n    if (value[0] === '\"') {\n      // remove quotes and escapes\n      value = value\n        .substr(1, value.length - 2)\n        .replace(QESC_REGEXP, '$1')\n    }\n\n    params[key] = value\n  }\n\n  if (index !== -1 && index !== string.length) {\n    throw new TypeError('invalid parameter format')\n  }\n\n  return new ContentDisposition(type, params)\n}\n\n/**\n * Percent decode a single character.\n *\n * @param {string} str\n * @param {string} hex\n * @return {string}\n * @private\n */\n\nfunction pdecode (str, hex) {\n  return String.fromCharCode(parseInt(hex, 16))\n}\n\n/**\n * Percent encode a single character.\n *\n * @param {string} char\n * @return {string}\n * @private\n */\n\nfunction pencode (char) {\n  return '%' + String(char)\n    .charCodeAt(0)\n    .toString(16)\n    .toUpperCase()\n}\n\n/**\n * Quote a string for HTTP.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction qstring (val) {\n  var str = String(val)\n\n  return '\"' + str.replace(QUOTE_REGEXP, '\\\\$1') + '\"'\n}\n\n/**\n * Encode a Unicode string for HTTP (RFC 5987).\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction ustring (val) {\n  var str = String(val)\n\n  // percent encode as UTF-8\n  var encoded = encodeURIComponent(str)\n    .replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode)\n\n  return 'UTF-8\\'\\'' + encoded\n}\n\n/**\n * Class for parsed Content-Disposition header for v8 optimization\n *\n * @public\n * @param {string} type\n * @param {object} parameters\n * @constructor\n */\n\nfunction ContentDisposition (type, parameters) {\n  this.type = type\n  this.parameters = parameters\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/content-disposition/index.js?");

/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/core-util-is/lib/util.js?");

/***/ }),

/***/ "./node_modules/date-format/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/date-format/lib/index.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction padWithZeros(vNumber, width) {\n  var numAsString = vNumber.toString();\n  while (numAsString.length < width) {\n    numAsString = \"0\" + numAsString;\n  }\n  return numAsString;\n}\n\nfunction addZero(vNumber) {\n  return padWithZeros(vNumber, 2);\n}\n\n/**\n * Formats the TimeOffset\n * Thanks to http://www.svendtofte.com/code/date_format/\n * @private\n */\nfunction offset(timezoneOffset) {\n  var os = Math.abs(timezoneOffset);\n  var h = String(Math.floor(os / 60));\n  var m = String(os % 60);\n  if (h.length === 1) {\n    h = \"0\" + h;\n  }\n  if (m.length === 1) {\n    m = \"0\" + m;\n  }\n  return timezoneOffset < 0 ? \"+\" + h + m : \"-\" + h + m;\n}\n\nfunction asString(format, date) {\n  if (typeof format !== \"string\") {\n    date = format;\n    format = module.exports.ISO8601_FORMAT;\n  }\n  if (!date) {\n    date = module.exports.now();\n  }\n\n  // Issue # 14 - Per ISO8601 standard, the time string should be local time\n  // with timezone info.\n  // See https://en.wikipedia.org/wiki/ISO_8601 section \"Time offsets from UTC\"\n\n  var vDay = addZero(date.getDate());\n  var vMonth = addZero(date.getMonth() + 1);\n  var vYearLong = addZero(date.getFullYear());\n  var vYearShort = addZero(vYearLong.substring(2, 4));\n  var vYear = format.indexOf(\"yyyy\") > -1 ? vYearLong : vYearShort;\n  var vHour = addZero(date.getHours());\n  var vMinute = addZero(date.getMinutes());\n  var vSecond = addZero(date.getSeconds());\n  var vMillisecond = padWithZeros(date.getMilliseconds(), 3);\n  var vTimeZone = offset(date.getTimezoneOffset());\n  var formatted = format\n    .replace(/dd/g, vDay)\n    .replace(/MM/g, vMonth)\n    .replace(/y{1,4}/g, vYear)\n    .replace(/hh/g, vHour)\n    .replace(/mm/g, vMinute)\n    .replace(/ss/g, vSecond)\n    .replace(/SSS/g, vMillisecond)\n    .replace(/O/g, vTimeZone);\n  return formatted;\n}\n\nfunction setDatePart(date, part, value, local) {\n  date['set' + (local ? '' : 'UTC') + part](value);\n}\n\nfunction extractDateParts(pattern, str, missingValuesDate) {\n  // Javascript Date object doesn't support custom timezone.  Sets all felds as\n  // GMT based to begin with.  If the timezone offset is provided, then adjust\n  // it using provided timezone, otherwise, adjust it with the system timezone.\n  var local = pattern.indexOf('O') < 0;\n  var matchers = [\n    {\n      pattern: /y{1,4}/,\n      regexp: \"\\\\d{1,4}\",\n      fn: function(date, value) {\n        setDatePart(date, 'FullYear', value, local);\n      }\n    },\n    {\n      pattern: /MM/,\n      regexp: \"\\\\d{1,2}\",\n      fn: function(date, value) {\n        setDatePart(date, 'Month', (value - 1), local);\n      }\n    },\n    {\n      pattern: /dd/,\n      regexp: \"\\\\d{1,2}\",\n      fn: function(date, value) {\n        setDatePart(date, 'Date', value, local);\n      }\n    },\n    {\n      pattern: /hh/,\n      regexp: \"\\\\d{1,2}\",\n      fn: function(date, value) {\n        setDatePart(date, 'Hours', value, local);\n      }\n    },\n    {\n      pattern: /mm/,\n      regexp: \"\\\\d\\\\d\",\n      fn: function(date, value) {\n        setDatePart(date, 'Minutes', value, local);\n      }\n    },\n    {\n      pattern: /ss/,\n      regexp: \"\\\\d\\\\d\",\n      fn: function(date, value) {\n        setDatePart(date, 'Seconds', value, local);\n      }\n    },\n    {\n      pattern: /SSS/,\n      regexp: \"\\\\d\\\\d\\\\d\",\n      fn: function(date, value) {\n        setDatePart(date, 'Milliseconds', value, local);\n      }\n    },\n    {\n      pattern: /O/,\n      regexp: \"[+-]\\\\d{3,4}|Z\",\n      fn: function(date, value) {\n        if (value === \"Z\") {\n          value = 0;\n        }\n        var offset = Math.abs(value);\n        var timezoneOffset = (value > 0 ? -1 :  1 ) * ((offset % 100) + Math.floor(offset / 100) * 60);\n        // Per ISO8601 standard: UTC = local time - offset\n        //\n        // For example, 2000-01-01T01:00:00-0700\n        //   local time: 2000-01-01T01:00:00\n        //   ==> UTC   : 2000-01-01T08:00:00 ( 01 - (-7) = 8 )\n        //\n        // To make it even more confusing, the date.getTimezoneOffset() is\n        // opposite sign of offset string in the ISO8601 standard.  So if offset\n        // is '-0700' the getTimezoneOffset() would be (+)420. The line above\n        // calculates timezoneOffset to matche Javascript's behavior.\n        //\n        // The date/time of the input is actually the local time, so the date\n        // object that was constructed is actually local time even thought the\n        // UTC setters are used.  This means the date object's internal UTC\n        // representation was wrong.  It needs to be fixed by substracting the\n        // offset (or adding the offset minutes as they are opposite sign).\n        //\n        // Note: the time zone has to be processed after all other fileds are\n        // set.  The result would be incorrect if the offset was calculated\n        // first then overriden by the other filed setters.\n        date.setUTCMinutes(date.getUTCMinutes() + timezoneOffset);\n      }\n    }\n  ];\n\n  var parsedPattern = matchers.reduce(\n    function(p, m) {\n      if (m.pattern.test(p.regexp)) {\n        m.index = p.regexp.match(m.pattern).index;\n        p.regexp = p.regexp.replace(m.pattern, \"(\" + m.regexp + \")\");\n      } else {\n        m.index = -1;\n      }\n      return p;\n    },\n    { regexp: pattern, index: [] }\n  );\n\n  var dateFns = matchers.filter(function(m) {\n    return m.index > -1;\n  });\n  dateFns.sort(function(a, b) {\n    return a.index - b.index;\n  });\n\n  var matcher = new RegExp(parsedPattern.regexp);\n  var matches = matcher.exec(str);\n  if (matches) {\n    var date = missingValuesDate || module.exports.now();\n    dateFns.forEach(function(f, i) {\n      f.fn(date, matches[i + 1]);\n    });\n\n    return date;\n  }\n\n  throw new Error(\n    \"String '\" + str + \"' could not be parsed as '\" + pattern + \"'\"\n  );\n}\n\nfunction parse(pattern, str, missingValuesDate) {\n  if (!pattern) {\n    throw new Error(\"pattern must be supplied\");\n  }\n\n  return extractDateParts(pattern, str, missingValuesDate);\n}\n\n/**\n * Used for testing - replace this function with a fixed date.\n */\nfunction now() {\n  return new Date();\n}\n\nmodule.exports = asString;\nmodule.exports.asString = asString;\nmodule.exports.parse = parse;\nmodule.exports.now = now;\nmodule.exports.ISO8601_FORMAT = \"yyyy-MM-ddThh:mm:ss.SSS\";\nmodule.exports.ISO8601_WITH_TZ_OFFSET_FORMAT = \"yyyy-MM-ddThh:mm:ss.SSSO\";\nmodule.exports.DATETIME_FORMAT = \"dd MM yyyy hh:mm:ss.SSS\";\nmodule.exports.ABSOLUTETIME_FORMAT = \"hh:mm:ss.SSS\";\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/date-format/lib/index.js?");

/***/ }),

/***/ "./node_modules/debounce/index.js":
/*!****************************************!*\
  !*** ./node_modules/debounce/index.js ***!
  \****************************************/
/***/ ((module) => {

eval("/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing. The function also has a property 'clear' \n * that is a function which will clear the timer to prevent previously scheduled executions. \n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\nfunction debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = Date.now() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n    }\n  };\n\n  var debounced = function(){\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n\n  debounced.clear = function() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n  \n  debounced.flush = function() {\n    if (timeout) {\n      result = func.apply(context, args);\n      context = args = null;\n      \n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debounced;\n};\n\n// Adds compatibility for ES modules\ndebounce.debounce = debounce;\n\nmodule.exports = debounce;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/debounce/index.js?");

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/debug/src/common.js?");

/***/ }),

/***/ "./node_modules/debug/src/index.js":
/*!*****************************************!*\
  !*** ./node_modules/debug/src/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n\tmodule.exports = __webpack_require__(/*! ./browser.js */ \"./node_modules/debug/src/browser.js\");\n} else {\n\tmodule.exports = __webpack_require__(/*! ./node.js */ \"./node_modules/debug/src/node.js\");\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/debug/src/index.js?");

/***/ }),

/***/ "./node_modules/debug/src/node.js":
/*!****************************************!*\
  !*** ./node_modules/debug/src/node.js ***!
  \****************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */\n\nconst tty = __webpack_require__(/*! tty */ \"tty\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = __webpack_require__(/*! supports-color */ \"./node_modules/supports-color/index.js\");\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.format(...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.replace(/\\s*\\n\\s*/g, ' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/debug/src/node.js?");

/***/ }),

/***/ "./node_modules/deep-extend/lib/deep-extend.js":
/*!*****************************************************!*\
  !*** ./node_modules/deep-extend/lib/deep-extend.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * @description Recursive object extending\n * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>\n * @license MIT\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2013-2018 Viacheslav Lotsmanov\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\nfunction isSpecificValue(val) {\n\treturn (\n\t\tval instanceof Buffer\n\t\t|| val instanceof Date\n\t\t|| val instanceof RegExp\n\t) ? true : false;\n}\n\nfunction cloneSpecificValue(val) {\n\tif (val instanceof Buffer) {\n\t\tvar x = Buffer.alloc\n\t\t\t? Buffer.alloc(val.length)\n\t\t\t: new Buffer(val.length);\n\t\tval.copy(x);\n\t\treturn x;\n\t} else if (val instanceof Date) {\n\t\treturn new Date(val.getTime());\n\t} else if (val instanceof RegExp) {\n\t\treturn new RegExp(val);\n\t} else {\n\t\tthrow new Error('Unexpected situation');\n\t}\n}\n\n/**\n * Recursive cloning array.\n */\nfunction deepCloneArray(arr) {\n\tvar clone = [];\n\tarr.forEach(function (item, index) {\n\t\tif (typeof item === 'object' && item !== null) {\n\t\t\tif (Array.isArray(item)) {\n\t\t\t\tclone[index] = deepCloneArray(item);\n\t\t\t} else if (isSpecificValue(item)) {\n\t\t\t\tclone[index] = cloneSpecificValue(item);\n\t\t\t} else {\n\t\t\t\tclone[index] = deepExtend({}, item);\n\t\t\t}\n\t\t} else {\n\t\t\tclone[index] = item;\n\t\t}\n\t});\n\treturn clone;\n}\n\nfunction safeGetProperty(object, property) {\n\treturn property === '__proto__' ? undefined : object[property];\n}\n\n/**\n * Extening object that entered in first argument.\n *\n * Returns extended object or false if have no target object or incorrect type.\n *\n * If you wish to clone source object (without modify it), just use empty new\n * object as first argument, like this:\n *   deepExtend({}, yourObj_1, [yourObj_N]);\n */\nvar deepExtend = module.exports = function (/*obj_1, [obj_2], [obj_N]*/) {\n\tif (arguments.length < 1 || typeof arguments[0] !== 'object') {\n\t\treturn false;\n\t}\n\n\tif (arguments.length < 2) {\n\t\treturn arguments[0];\n\t}\n\n\tvar target = arguments[0];\n\n\t// convert arguments to array and cut off target object\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\n\tvar val, src, clone;\n\n\targs.forEach(function (obj) {\n\t\t// skip argument if isn't an object, is null, or is an array\n\t\tif (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {\n\t\t\treturn;\n\t\t}\n\n\t\tObject.keys(obj).forEach(function (key) {\n\t\t\tsrc = safeGetProperty(target, key); // source value\n\t\t\tval = safeGetProperty(obj, key); // new value\n\n\t\t\t// recursion prevention\n\t\t\tif (val === target) {\n\t\t\t\treturn;\n\n\t\t\t/**\n\t\t\t * if new value isn't object then just overwrite by new value\n\t\t\t * instead of extending.\n\t\t\t */\n\t\t\t} else if (typeof val !== 'object' || val === null) {\n\t\t\t\ttarget[key] = val;\n\t\t\t\treturn;\n\n\t\t\t// just clone arrays (and recursive clone objects inside)\n\t\t\t} else if (Array.isArray(val)) {\n\t\t\t\ttarget[key] = deepCloneArray(val);\n\t\t\t\treturn;\n\n\t\t\t// custom cloning and overwrite for specific objects\n\t\t\t} else if (isSpecificValue(val)) {\n\t\t\t\ttarget[key] = cloneSpecificValue(val);\n\t\t\t\treturn;\n\n\t\t\t// overwrite by new value if source isn't object or array\n\t\t\t} else if (typeof src !== 'object' || src === null || Array.isArray(src)) {\n\t\t\t\ttarget[key] = deepExtend({}, val);\n\t\t\t\treturn;\n\n\t\t\t// source value and new value is objects both, extending...\n\t\t\t} else {\n\t\t\t\ttarget[key] = deepExtend(src, val);\n\t\t\t\treturn;\n\t\t\t}\n\t\t});\n\t});\n\n\treturn target;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/deep-extend/lib/deep-extend.js?");

/***/ }),

/***/ "./node_modules/define-properties/index.js":
/*!*************************************************!*\
  !*** ./node_modules/define-properties/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar keys = __webpack_require__(/*! object-keys */ \"./node_modules/object-keys/index.js\");\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';\n\nvar toStr = Object.prototype.toString;\nvar concat = Array.prototype.concat;\nvar origDefineProperty = Object.defineProperty;\n\nvar isFunction = function (fn) {\n\treturn typeof fn === 'function' && toStr.call(fn) === '[object Function]';\n};\n\nvar arePropertyDescriptorsSupported = function () {\n\tvar obj = {};\n\ttry {\n\t\torigDefineProperty(obj, 'x', { enumerable: false, value: obj });\n\t\t// eslint-disable-next-line no-unused-vars, no-restricted-syntax\n\t\tfor (var _ in obj) { // jscs:ignore disallowUnusedVariables\n\t\t\treturn false;\n\t\t}\n\t\treturn obj.x === obj;\n\t} catch (e) { /* this is IE 8. */\n\t\treturn false;\n\t}\n};\nvar supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();\n\nvar defineProperty = function (object, name, value, predicate) {\n\tif (name in object && (!isFunction(predicate) || !predicate())) {\n\t\treturn;\n\t}\n\tif (supportsDescriptors) {\n\t\torigDefineProperty(object, name, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: value,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\tobject[name] = value;\n\t}\n};\n\nvar defineProperties = function (object, map) {\n\tvar predicates = arguments.length > 2 ? arguments[2] : {};\n\tvar props = keys(map);\n\tif (hasSymbols) {\n\t\tprops = concat.call(props, Object.getOwnPropertySymbols(map));\n\t}\n\tfor (var i = 0; i < props.length; i += 1) {\n\t\tdefineProperty(object, props[i], map[props[i]], predicates[props[i]]);\n\t}\n};\n\ndefineProperties.supportsDescriptors = !!supportsDescriptors;\n\nmodule.exports = defineProperties;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/define-properties/index.js?");

/***/ }),

/***/ "./node_modules/duplexer2/index.js":
/*!*****************************************!*\
  !*** ./node_modules/duplexer2/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar stream = __webpack_require__(/*! readable-stream */ \"./node_modules/readable-stream/readable.js\");\n\nfunction DuplexWrapper(options, writable, readable) {\n  if (typeof readable === \"undefined\") {\n    readable = writable;\n    writable = options;\n    options = null;\n  }\n\n  stream.Duplex.call(this, options);\n\n  if (typeof readable.read !== \"function\") {\n    readable = (new stream.Readable(options)).wrap(readable);\n  }\n\n  this._writable = writable;\n  this._readable = readable;\n  this._waiting = false;\n\n  var self = this;\n\n  writable.once(\"finish\", function() {\n    self.end();\n  });\n\n  this.once(\"finish\", function() {\n    writable.end();\n  });\n\n  readable.on(\"readable\", function() {\n    if (self._waiting) {\n      self._waiting = false;\n      self._read();\n    }\n  });\n\n  readable.once(\"end\", function() {\n    self.push(null);\n  });\n\n  if (!options || typeof options.bubbleErrors === \"undefined\" || options.bubbleErrors) {\n    writable.on(\"error\", function(err) {\n      self.emit(\"error\", err);\n    });\n\n    readable.on(\"error\", function(err) {\n      self.emit(\"error\", err);\n    });\n  }\n}\n\nDuplexWrapper.prototype = Object.create(stream.Duplex.prototype, {constructor: {value: DuplexWrapper}});\n\nDuplexWrapper.prototype._write = function _write(input, encoding, done) {\n  this._writable.write(input, encoding, done);\n};\n\nDuplexWrapper.prototype._read = function _read() {\n  var buf;\n  var reads = 0;\n  while ((buf = this._readable.read()) !== null) {\n    this.push(buf);\n    reads++;\n  }\n  if (reads === 0) {\n    this._waiting = true;\n  }\n};\n\nmodule.exports = function duplex2(options, writable, readable) {\n  return new DuplexWrapper(options, writable, readable);\n};\n\nmodule.exports.DuplexWrapper = DuplexWrapper;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/duplexer2/index.js?");

/***/ }),

/***/ "./node_modules/emoji-regex/index.js":
/*!*******************************************!*\
  !*** ./node_modules/emoji-regex/index.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function () {\n  // https://mths.be/emoji\n  return /\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73)\\uDB40\\uDC7F|\\uD83D\\uDC68(?:\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C\\uDFFB|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFE])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83D[\\uDC66\\uDC67]|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|(?:\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C[\\uDFFB-\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)\\uD83C\\uDFFB|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])|\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1)|(?:\\uD83E\\uDDD1\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFE])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)(?:\\uD83C[\\uDFFB\\uDFFC])|\\uD83D\\uDC69(?:\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFC-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|(?:\\uD83E\\uDDD1\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)(?:\\uD83C[\\uDFFB-\\uDFFD])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83D\\uDC69(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|(?:(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)\\uFE0F|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD6-\\uDDDD])(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\u200D[\\u2640\\u2642])|\\uD83C\\uDFF4\\u200D\\u2620)\\uFE0F|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC15\\u200D\\uD83E\\uDDBA|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83C\\uDDF6\\uD83C\\uDDE6|[#\\*0-9]\\uFE0F\\u20E3|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC70\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDCAA\\uDD74\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD36\\uDDB5\\uDDB6\\uDDBB\\uDDD2-\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5\\uDEEB\\uDEEC\\uDEF4-\\uDEFA\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDDFF\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFA\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDDFF\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDC8F\\uDC91\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD0F\\uDD18-\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3C-\\uDD3E\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDBB\\uDDCD-\\uDDCF\\uDDD1-\\uDDDD])/g;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/emoji-regex/index.js?");

/***/ }),

/***/ "./node_modules/end-of-stream/index.js":
/*!*********************************************!*\
  !*** ./node_modules/end-of-stream/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var once = __webpack_require__(/*! once */ \"./node_modules/once/once.js\");\n\nvar noop = function() {};\n\nvar isRequest = function(stream) {\n\treturn stream.setHeader && typeof stream.abort === 'function';\n};\n\nvar isChildProcess = function(stream) {\n\treturn stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3\n};\n\nvar eos = function(stream, opts, callback) {\n\tif (typeof opts === 'function') return eos(stream, null, opts);\n\tif (!opts) opts = {};\n\n\tcallback = once(callback || noop);\n\n\tvar ws = stream._writableState;\n\tvar rs = stream._readableState;\n\tvar readable = opts.readable || (opts.readable !== false && stream.readable);\n\tvar writable = opts.writable || (opts.writable !== false && stream.writable);\n\tvar cancelled = false;\n\n\tvar onlegacyfinish = function() {\n\t\tif (!stream.writable) onfinish();\n\t};\n\n\tvar onfinish = function() {\n\t\twritable = false;\n\t\tif (!readable) callback.call(stream);\n\t};\n\n\tvar onend = function() {\n\t\treadable = false;\n\t\tif (!writable) callback.call(stream);\n\t};\n\n\tvar onexit = function(exitCode) {\n\t\tcallback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);\n\t};\n\n\tvar onerror = function(err) {\n\t\tcallback.call(stream, err);\n\t};\n\n\tvar onclose = function() {\n\t\tprocess.nextTick(onclosenexttick);\n\t};\n\n\tvar onclosenexttick = function() {\n\t\tif (cancelled) return;\n\t\tif (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));\n\t\tif (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));\n\t};\n\n\tvar onrequest = function() {\n\t\tstream.req.on('finish', onfinish);\n\t};\n\n\tif (isRequest(stream)) {\n\t\tstream.on('complete', onfinish);\n\t\tstream.on('abort', onclose);\n\t\tif (stream.req) onrequest();\n\t\telse stream.on('request', onrequest);\n\t} else if (writable && !ws) { // legacy streams\n\t\tstream.on('end', onlegacyfinish);\n\t\tstream.on('close', onlegacyfinish);\n\t}\n\n\tif (isChildProcess(stream)) stream.on('exit', onexit);\n\n\tstream.on('end', onend);\n\tstream.on('finish', onfinish);\n\tif (opts.error !== false) stream.on('error', onerror);\n\tstream.on('close', onclose);\n\n\treturn function() {\n\t\tcancelled = true;\n\t\tstream.removeListener('complete', onfinish);\n\t\tstream.removeListener('abort', onclose);\n\t\tstream.removeListener('request', onrequest);\n\t\tif (stream.req) stream.req.removeListener('finish', onfinish);\n\t\tstream.removeListener('end', onlegacyfinish);\n\t\tstream.removeListener('close', onlegacyfinish);\n\t\tstream.removeListener('finish', onfinish);\n\t\tstream.removeListener('exit', onexit);\n\t\tstream.removeListener('end', onend);\n\t\tstream.removeListener('error', onerror);\n\t\tstream.removeListener('close', onclose);\n\t};\n};\n\nmodule.exports = eos;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/end-of-stream/index.js?");

/***/ }),

/***/ "./node_modules/es-abstract/2018/IsCallable.js":
/*!*****************************************************!*\
  !*** ./node_modules/es-abstract/2018/IsCallable.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// http://www.ecma-international.org/ecma-262/5.1/#sec-9.11\n\nmodule.exports = __webpack_require__(/*! is-callable */ \"./node_modules/is-callable/index.js\");\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/es-abstract/2018/IsCallable.js?");

/***/ }),

/***/ "./node_modules/es-abstract/2018/IsConstructor.js":
/*!********************************************************!*\
  !*** ./node_modules/es-abstract/2018/IsConstructor.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-isconstructor\n\nmodule.exports = function IsConstructor(argument) {\n\treturn typeof argument === 'function' && !!argument.prototype; // unfortunately there's no way to truly check this without try/catch `new argument`\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/es-abstract/2018/IsConstructor.js?");

/***/ }),

/***/ "./node_modules/es-abstract/2018/SpeciesConstructor.js":
/*!*************************************************************!*\
  !*** ./node_modules/es-abstract/2018/SpeciesConstructor.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! ../GetIntrinsic */ \"./node_modules/es-abstract/GetIntrinsic.js\");\n\nvar $species = GetIntrinsic('%Symbol.species%', true);\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar IsConstructor = __webpack_require__(/*! ./IsConstructor */ \"./node_modules/es-abstract/2018/IsConstructor.js\");\nvar Type = __webpack_require__(/*! ./Type */ \"./node_modules/es-abstract/2018/Type.js\");\n\n// https://ecma-international.org/ecma-262/6.0/#sec-speciesconstructor\n\nmodule.exports = function SpeciesConstructor(O, defaultConstructor) {\n\tif (Type(O) !== 'Object') {\n\t\tthrow new $TypeError('Assertion failed: Type(O) is not Object');\n\t}\n\tvar C = O.constructor;\n\tif (typeof C === 'undefined') {\n\t\treturn defaultConstructor;\n\t}\n\tif (Type(C) !== 'Object') {\n\t\tthrow new $TypeError('O.constructor is not an Object');\n\t}\n\tvar S = $species ? C[$species] : void 0;\n\tif (S == null) {\n\t\treturn defaultConstructor;\n\t}\n\tif (IsConstructor(S)) {\n\t\treturn S;\n\t}\n\tthrow new $TypeError('no constructor found');\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/es-abstract/2018/SpeciesConstructor.js?");

/***/ }),

/***/ "./node_modules/es-abstract/2018/Type.js":
/*!***********************************************!*\
  !*** ./node_modules/es-abstract/2018/Type.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar ES5Type = __webpack_require__(/*! ../5/Type */ \"./node_modules/es-abstract/5/Type.js\");\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-tostring\n\nmodule.exports = function Type(x) {\n\tif (typeof x === 'symbol') {\n\t\treturn 'Symbol';\n\t}\n\treturn ES5Type(x);\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/es-abstract/2018/Type.js?");

/***/ }),

/***/ "./node_modules/es-abstract/5/Type.js":
/*!********************************************!*\
  !*** ./node_modules/es-abstract/5/Type.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// https://www.ecma-international.org/ecma-262/5.1/#sec-8\n\nmodule.exports = function Type(x) {\n\tif (x === null) {\n\t\treturn 'Null';\n\t}\n\tif (typeof x === 'undefined') {\n\t\treturn 'Undefined';\n\t}\n\tif (typeof x === 'function' || typeof x === 'object') {\n\t\treturn 'Object';\n\t}\n\tif (typeof x === 'number') {\n\t\treturn 'Number';\n\t}\n\tif (typeof x === 'boolean') {\n\t\treturn 'Boolean';\n\t}\n\tif (typeof x === 'string') {\n\t\treturn 'String';\n\t}\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/es-abstract/5/Type.js?");

/***/ }),

/***/ "./node_modules/es-abstract/GetIntrinsic.js":
/*!**************************************************!*\
  !*** ./node_modules/es-abstract/GetIntrinsic.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* globals\n\tAtomics,\n\tSharedArrayBuffer,\n*/\n\nvar undefined;\n\nvar $TypeError = TypeError;\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () { throw new $TypeError(); };\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = __webpack_require__(/*! has-symbols */ \"./node_modules/has-symbols/index.js\")();\n\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\n\nvar generator; // = function * () {};\nvar generatorFunction = generator ? getProto(generator) : undefined;\nvar asyncFn; // async function() {};\nvar asyncFunction = asyncFn ? asyncFn.constructor : undefined;\nvar asyncGen; // async function * () {};\nvar asyncGenFunction = asyncGen ? getProto(asyncGen) : undefined;\nvar asyncGenIterator = asyncGen ? asyncGen() : undefined;\n\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer.prototype,\n\t'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,\n\t'%ArrayPrototype%': Array.prototype,\n\t'%ArrayProto_entries%': Array.prototype.entries,\n\t'%ArrayProto_forEach%': Array.prototype.forEach,\n\t'%ArrayProto_keys%': Array.prototype.keys,\n\t'%ArrayProto_values%': Array.prototype.values,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': asyncFunction,\n\t'%AsyncFunctionPrototype%': asyncFunction ? asyncFunction.prototype : undefined,\n\t'%AsyncGenerator%': asyncGen ? getProto(asyncGenIterator) : undefined,\n\t'%AsyncGeneratorFunction%': asyncGenFunction,\n\t'%AsyncGeneratorPrototype%': asyncGenFunction ? asyncGenFunction.prototype : undefined,\n\t'%AsyncIteratorPrototype%': asyncGenIterator && hasSymbols && Symbol.asyncIterator ? asyncGenIterator[Symbol.asyncIterator]() : undefined,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%Boolean%': Boolean,\n\t'%BooleanPrototype%': Boolean.prototype,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%DataViewPrototype%': typeof DataView === 'undefined' ? undefined : DataView.prototype,\n\t'%Date%': Date,\n\t'%DatePrototype%': Date.prototype,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': Error,\n\t'%ErrorPrototype%': Error.prototype,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': EvalError,\n\t'%EvalErrorPrototype%': EvalError.prototype,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined : Float32Array.prototype,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined : Float64Array.prototype,\n\t'%Function%': Function,\n\t'%FunctionPrototype%': Function.prototype,\n\t'%Generator%': generator ? getProto(generator()) : undefined,\n\t'%GeneratorFunction%': generatorFunction,\n\t'%GeneratorPrototype%': generatorFunction ? generatorFunction.prototype : undefined,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined : Int8Array.prototype,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined : Int8Array.prototype,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined : Int32Array.prototype,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%JSONParse%': typeof JSON === 'object' ? JSON.parse : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%MapPrototype%': typeof Map === 'undefined' ? undefined : Map.prototype,\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%NumberPrototype%': Number.prototype,\n\t'%Object%': Object,\n\t'%ObjectPrototype%': Object.prototype,\n\t'%ObjProto_toString%': Object.prototype.toString,\n\t'%ObjProto_valueOf%': Object.prototype.valueOf,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%PromisePrototype%': typeof Promise === 'undefined' ? undefined : Promise.prototype,\n\t'%PromiseProto_then%': typeof Promise === 'undefined' ? undefined : Promise.prototype.then,\n\t'%Promise_all%': typeof Promise === 'undefined' ? undefined : Promise.all,\n\t'%Promise_reject%': typeof Promise === 'undefined' ? undefined : Promise.reject,\n\t'%Promise_resolve%': typeof Promise === 'undefined' ? undefined : Promise.resolve,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': RangeError,\n\t'%RangeErrorPrototype%': RangeError.prototype,\n\t'%ReferenceError%': ReferenceError,\n\t'%ReferenceErrorPrototype%': ReferenceError.prototype,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%RegExpPrototype%': RegExp.prototype,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SetPrototype%': typeof Set === 'undefined' ? undefined : Set.prototype,\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer.prototype,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%StringPrototype%': String.prototype,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SymbolPrototype%': hasSymbols ? Symbol.prototype : undefined,\n\t'%SyntaxError%': SyntaxError,\n\t'%SyntaxErrorPrototype%': SyntaxError.prototype,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined,\n\t'%TypeError%': $TypeError,\n\t'%TypeErrorPrototype%': $TypeError.prototype,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array.prototype,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray.prototype,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array.prototype,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array.prototype,\n\t'%URIError%': URIError,\n\t'%URIErrorPrototype%': URIError.prototype,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined : WeakMap.prototype,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,\n\t'%WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined : WeakSet.prototype\n};\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\nvar $replace = bind.call(Function.call, String.prototype.replace);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : (number || match);\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tif (!(name in INTRINSICS)) {\n\t\tthrow new SyntaxError('intrinsic ' + name + ' does not exist!');\n\t}\n\n\t// istanbul ignore if // hopefully this is impossible to test :-)\n\tif (typeof INTRINSICS[name] === 'undefined' && !allowMissing) {\n\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t}\n\n\treturn INTRINSICS[name];\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tvar parts = stringToPath(name);\n\n\tvar value = getBaseIntrinsic('%' + (parts.length > 0 ? parts[0] : '') + '%', allowMissing);\n\tfor (var i = 1; i < parts.length; i += 1) {\n\t\tif (value != null) {\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, parts[i]);\n\t\t\t\tif (!allowMissing && !(parts[i] in value)) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\tvalue = desc ? (desc.get || desc.value) : value[parts[i]];\n\t\t\t} else {\n\t\t\t\tvalue = value[parts[i]];\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/es-abstract/GetIntrinsic.js?");

/***/ }),

/***/ "./node_modules/escape-string-regexp/index.js":
/*!****************************************************!*\
  !*** ./node_modules/escape-string-regexp/index.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(matchOperatorsRe, '\\\\$&');\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/escape-string-regexp/index.js?");

/***/ }),

/***/ "./node_modules/event-lite/event-lite.js":
/*!***********************************************!*\
  !*** ./node_modules/event-lite/event-lite.js ***!
  \***********************************************/
/***/ ((module) => {

eval("/**\n * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)\n *\n * @copyright Yusuke Kawasaki\n * @license MIT\n * @constructor\n * @see https://github.com/kawanet/event-lite\n * @see http://kawanet.github.io/event-lite/EventLite.html\n * @example\n * var EventLite = require(\"event-lite\");\n *\n * function MyClass() {...}             // your class\n *\n * EventLite.mixin(MyClass.prototype);  // import event methods\n *\n * var obj = new MyClass();\n * obj.on(\"foo\", function() {...});     // add event listener\n * obj.once(\"bar\", function() {...});   // add one-time event listener\n * obj.emit(\"foo\");                     // dispatch event\n * obj.emit(\"bar\");                     // dispatch another event\n * obj.off(\"foo\");                      // remove event listener\n */\n\nfunction EventLite() {\n  if (!(this instanceof EventLite)) return new EventLite();\n}\n\n(function(EventLite) {\n  // export the class for node.js\n  if (true) module.exports = EventLite;\n\n  // property name to hold listeners\n  var LISTENERS = \"listeners\";\n\n  // methods to export\n  var methods = {\n    on: on,\n    once: once,\n    off: off,\n    emit: emit\n  };\n\n  // mixin to self\n  mixin(EventLite.prototype);\n\n  // export mixin function\n  EventLite.mixin = mixin;\n\n  /**\n   * Import on(), once(), off() and emit() methods into target object.\n   *\n   * @function EventLite.mixin\n   * @param target {Prototype}\n   */\n\n  function mixin(target) {\n    for (var key in methods) {\n      target[key] = methods[key];\n    }\n    return target;\n  }\n\n  /**\n   * Add an event listener.\n   *\n   * @function EventLite.prototype.on\n   * @param type {string}\n   * @param func {Function}\n   * @returns {EventLite} Self for method chaining\n   */\n\n  function on(type, func) {\n    getListeners(this, type).push(func);\n    return this;\n  }\n\n  /**\n   * Add one-time event listener.\n   *\n   * @function EventLite.prototype.once\n   * @param type {string}\n   * @param func {Function}\n   * @returns {EventLite} Self for method chaining\n   */\n\n  function once(type, func) {\n    var that = this;\n    wrap.originalListener = func;\n    getListeners(that, type).push(wrap);\n    return that;\n\n    function wrap() {\n      off.call(that, type, wrap);\n      func.apply(this, arguments);\n    }\n  }\n\n  /**\n   * Remove an event listener.\n   *\n   * @function EventLite.prototype.off\n   * @param [type] {string}\n   * @param [func] {Function}\n   * @returns {EventLite} Self for method chaining\n   */\n\n  function off(type, func) {\n    var that = this;\n    var listners;\n    if (!arguments.length) {\n      delete that[LISTENERS];\n    } else if (!func) {\n      listners = that[LISTENERS];\n      if (listners) {\n        delete listners[type];\n        if (!Object.keys(listners).length) return off.call(that);\n      }\n    } else {\n      listners = getListeners(that, type, true);\n      if (listners) {\n        listners = listners.filter(ne);\n        if (!listners.length) return off.call(that, type);\n        that[LISTENERS][type] = listners;\n      }\n    }\n    return that;\n\n    function ne(test) {\n      return test !== func && test.originalListener !== func;\n    }\n  }\n\n  /**\n   * Dispatch (trigger) an event.\n   *\n   * @function EventLite.prototype.emit\n   * @param type {string}\n   * @param [value] {*}\n   * @returns {boolean} True when a listener received the event\n   */\n\n  function emit(type, value) {\n    var that = this;\n    var listeners = getListeners(that, type, true);\n    if (!listeners) return false;\n    var arglen = arguments.length;\n    if (arglen === 1) {\n      listeners.forEach(zeroarg);\n    } else if (arglen === 2) {\n      listeners.forEach(onearg);\n    } else {\n      var args = Array.prototype.slice.call(arguments, 1);\n      listeners.forEach(moreargs);\n    }\n    return !!listeners.length;\n\n    function zeroarg(func) {\n      func.call(that);\n    }\n\n    function onearg(func) {\n      func.call(that, value);\n    }\n\n    function moreargs(func) {\n      func.apply(that, args);\n    }\n  }\n\n  /**\n   * @ignore\n   */\n\n  function getListeners(that, type, readonly) {\n    if (readonly && !that[LISTENERS]) return;\n    var listeners = that[LISTENERS] || (that[LISTENERS] = {});\n    return listeners[type] || (listeners[type] = []);\n  }\n\n})(EventLite);\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/event-lite/event-lite.js?");

/***/ }),

/***/ "./node_modules/execa/index.js":
/*!*************************************!*\
  !*** ./node_modules/execa/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst path = __webpack_require__(/*! path */ \"path\");\nconst childProcess = __webpack_require__(/*! child_process */ \"child_process\");\nconst crossSpawn = __webpack_require__(/*! cross-spawn */ \"./node_modules/execa/node_modules/cross-spawn/index.js\");\nconst stripEof = __webpack_require__(/*! strip-eof */ \"./node_modules/strip-eof/index.js\");\nconst npmRunPath = __webpack_require__(/*! npm-run-path */ \"./node_modules/execa/node_modules/npm-run-path/index.js\");\nconst isStream = __webpack_require__(/*! is-stream */ \"./node_modules/execa/node_modules/is-stream/index.js\");\nconst _getStream = __webpack_require__(/*! get-stream */ \"./node_modules/execa/node_modules/get-stream/index.js\");\nconst pFinally = __webpack_require__(/*! p-finally */ \"./node_modules/p-finally/index.js\");\nconst onExit = __webpack_require__(/*! signal-exit */ \"./node_modules/signal-exit/index.js\");\nconst errname = __webpack_require__(/*! ./lib/errname */ \"./node_modules/execa/lib/errname.js\");\nconst stdio = __webpack_require__(/*! ./lib/stdio */ \"./node_modules/execa/lib/stdio.js\");\n\nconst TEN_MEGABYTES = 1000 * 1000 * 10;\n\nfunction handleArgs(cmd, args, opts) {\n\tlet parsed;\n\n\topts = Object.assign({\n\t\textendEnv: true,\n\t\tenv: {}\n\t}, opts);\n\n\tif (opts.extendEnv) {\n\t\topts.env = Object.assign({}, process.env, opts.env);\n\t}\n\n\tif (opts.__winShell === true) {\n\t\tdelete opts.__winShell;\n\t\tparsed = {\n\t\t\tcommand: cmd,\n\t\t\targs,\n\t\t\toptions: opts,\n\t\t\tfile: cmd,\n\t\t\toriginal: {\n\t\t\t\tcmd,\n\t\t\t\targs\n\t\t\t}\n\t\t};\n\t} else {\n\t\tparsed = crossSpawn._parse(cmd, args, opts);\n\t}\n\n\topts = Object.assign({\n\t\tmaxBuffer: TEN_MEGABYTES,\n\t\tbuffer: true,\n\t\tstripEof: true,\n\t\tpreferLocal: true,\n\t\tlocalDir: parsed.options.cwd || process.cwd(),\n\t\tencoding: 'utf8',\n\t\treject: true,\n\t\tcleanup: true\n\t}, parsed.options);\n\n\topts.stdio = stdio(opts);\n\n\tif (opts.preferLocal) {\n\t\topts.env = npmRunPath.env(Object.assign({}, opts, {cwd: opts.localDir}));\n\t}\n\n\tif (opts.detached) {\n\t\t// #115\n\t\topts.cleanup = false;\n\t}\n\n\tif (process.platform === 'win32' && path.basename(parsed.command) === 'cmd.exe') {\n\t\t// #116\n\t\tparsed.args.unshift('/q');\n\t}\n\n\treturn {\n\t\tcmd: parsed.command,\n\t\targs: parsed.args,\n\t\topts,\n\t\tparsed\n\t};\n}\n\nfunction handleInput(spawned, input) {\n\tif (input === null || input === undefined) {\n\t\treturn;\n\t}\n\n\tif (isStream(input)) {\n\t\tinput.pipe(spawned.stdin);\n\t} else {\n\t\tspawned.stdin.end(input);\n\t}\n}\n\nfunction handleOutput(opts, val) {\n\tif (val && opts.stripEof) {\n\t\tval = stripEof(val);\n\t}\n\n\treturn val;\n}\n\nfunction handleShell(fn, cmd, opts) {\n\tlet file = '/bin/sh';\n\tlet args = ['-c', cmd];\n\n\topts = Object.assign({}, opts);\n\n\tif (process.platform === 'win32') {\n\t\topts.__winShell = true;\n\t\tfile = process.env.comspec || 'cmd.exe';\n\t\targs = ['/s', '/c', `\"${cmd}\"`];\n\t\topts.windowsVerbatimArguments = true;\n\t}\n\n\tif (opts.shell) {\n\t\tfile = opts.shell;\n\t\tdelete opts.shell;\n\t}\n\n\treturn fn(file, args, opts);\n}\n\nfunction getStream(process, stream, {encoding, buffer, maxBuffer}) {\n\tif (!process[stream]) {\n\t\treturn null;\n\t}\n\n\tlet ret;\n\n\tif (!buffer) {\n\t\t// TODO: Use `ret = util.promisify(stream.finished)(process[stream]);` when targeting Node.js 10\n\t\tret = new Promise((resolve, reject) => {\n\t\t\tprocess[stream]\n\t\t\t\t.once('end', resolve)\n\t\t\t\t.once('error', reject);\n\t\t});\n\t} else if (encoding) {\n\t\tret = _getStream(process[stream], {\n\t\t\tencoding,\n\t\t\tmaxBuffer\n\t\t});\n\t} else {\n\t\tret = _getStream.buffer(process[stream], {maxBuffer});\n\t}\n\n\treturn ret.catch(err => {\n\t\terr.stream = stream;\n\t\terr.message = `${stream} ${err.message}`;\n\t\tthrow err;\n\t});\n}\n\nfunction makeError(result, options) {\n\tconst {stdout, stderr} = result;\n\n\tlet err = result.error;\n\tconst {code, signal} = result;\n\n\tconst {parsed, joinedCmd} = options;\n\tconst timedOut = options.timedOut || false;\n\n\tif (!err) {\n\t\tlet output = '';\n\n\t\tif (Array.isArray(parsed.opts.stdio)) {\n\t\t\tif (parsed.opts.stdio[2] !== 'inherit') {\n\t\t\t\toutput += output.length > 0 ? stderr : `\\n${stderr}`;\n\t\t\t}\n\n\t\t\tif (parsed.opts.stdio[1] !== 'inherit') {\n\t\t\t\toutput += `\\n${stdout}`;\n\t\t\t}\n\t\t} else if (parsed.opts.stdio !== 'inherit') {\n\t\t\toutput = `\\n${stderr}${stdout}`;\n\t\t}\n\n\t\terr = new Error(`Command failed: ${joinedCmd}${output}`);\n\t\terr.code = code < 0 ? errname(code) : code;\n\t}\n\n\terr.stdout = stdout;\n\terr.stderr = stderr;\n\terr.failed = true;\n\terr.signal = signal || null;\n\terr.cmd = joinedCmd;\n\terr.timedOut = timedOut;\n\n\treturn err;\n}\n\nfunction joinCmd(cmd, args) {\n\tlet joinedCmd = cmd;\n\n\tif (Array.isArray(args) && args.length > 0) {\n\t\tjoinedCmd += ' ' + args.join(' ');\n\t}\n\n\treturn joinedCmd;\n}\n\nmodule.exports = (cmd, args, opts) => {\n\tconst parsed = handleArgs(cmd, args, opts);\n\tconst {encoding, buffer, maxBuffer} = parsed.opts;\n\tconst joinedCmd = joinCmd(cmd, args);\n\n\tlet spawned;\n\ttry {\n\t\tspawned = childProcess.spawn(parsed.cmd, parsed.args, parsed.opts);\n\t} catch (err) {\n\t\treturn Promise.reject(err);\n\t}\n\n\tlet removeExitHandler;\n\tif (parsed.opts.cleanup) {\n\t\tremoveExitHandler = onExit(() => {\n\t\t\tspawned.kill();\n\t\t});\n\t}\n\n\tlet timeoutId = null;\n\tlet timedOut = false;\n\n\tconst cleanup = () => {\n\t\tif (timeoutId) {\n\t\t\tclearTimeout(timeoutId);\n\t\t\ttimeoutId = null;\n\t\t}\n\n\t\tif (removeExitHandler) {\n\t\t\tremoveExitHandler();\n\t\t}\n\t};\n\n\tif (parsed.opts.timeout > 0) {\n\t\ttimeoutId = setTimeout(() => {\n\t\t\ttimeoutId = null;\n\t\t\ttimedOut = true;\n\t\t\tspawned.kill(parsed.opts.killSignal);\n\t\t}, parsed.opts.timeout);\n\t}\n\n\tconst processDone = new Promise(resolve => {\n\t\tspawned.on('exit', (code, signal) => {\n\t\t\tcleanup();\n\t\t\tresolve({code, signal});\n\t\t});\n\n\t\tspawned.on('error', err => {\n\t\t\tcleanup();\n\t\t\tresolve({error: err});\n\t\t});\n\n\t\tif (spawned.stdin) {\n\t\t\tspawned.stdin.on('error', err => {\n\t\t\t\tcleanup();\n\t\t\t\tresolve({error: err});\n\t\t\t});\n\t\t}\n\t});\n\n\tfunction destroy() {\n\t\tif (spawned.stdout) {\n\t\t\tspawned.stdout.destroy();\n\t\t}\n\n\t\tif (spawned.stderr) {\n\t\t\tspawned.stderr.destroy();\n\t\t}\n\t}\n\n\tconst handlePromise = () => pFinally(Promise.all([\n\t\tprocessDone,\n\t\tgetStream(spawned, 'stdout', {encoding, buffer, maxBuffer}),\n\t\tgetStream(spawned, 'stderr', {encoding, buffer, maxBuffer})\n\t]).then(arr => {\n\t\tconst result = arr[0];\n\t\tresult.stdout = arr[1];\n\t\tresult.stderr = arr[2];\n\n\t\tif (result.error || result.code !== 0 || result.signal !== null) {\n\t\t\tconst err = makeError(result, {\n\t\t\t\tjoinedCmd,\n\t\t\t\tparsed,\n\t\t\t\ttimedOut\n\t\t\t});\n\n\t\t\t// TODO: missing some timeout logic for killed\n\t\t\t// https://github.com/nodejs/node/blob/master/lib/child_process.js#L203\n\t\t\t// err.killed = spawned.killed || killed;\n\t\t\terr.killed = err.killed || spawned.killed;\n\n\t\t\tif (!parsed.opts.reject) {\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t}\n\n\t\treturn {\n\t\t\tstdout: handleOutput(parsed.opts, result.stdout),\n\t\t\tstderr: handleOutput(parsed.opts, result.stderr),\n\t\t\tcode: 0,\n\t\t\tfailed: false,\n\t\t\tkilled: false,\n\t\t\tsignal: null,\n\t\t\tcmd: joinedCmd,\n\t\t\ttimedOut: false\n\t\t};\n\t}), destroy);\n\n\tcrossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);\n\n\thandleInput(spawned, parsed.opts.input);\n\n\tspawned.then = (onfulfilled, onrejected) => handlePromise().then(onfulfilled, onrejected);\n\tspawned.catch = onrejected => handlePromise().catch(onrejected);\n\n\treturn spawned;\n};\n\n// TODO: set `stderr: 'ignore'` when that option is implemented\nmodule.exports.stdout = (...args) => module.exports(...args).then(x => x.stdout);\n\n// TODO: set `stdout: 'ignore'` when that option is implemented\nmodule.exports.stderr = (...args) => module.exports(...args).then(x => x.stderr);\n\nmodule.exports.shell = (cmd, opts) => handleShell(module.exports, cmd, opts);\n\nmodule.exports.sync = (cmd, args, opts) => {\n\tconst parsed = handleArgs(cmd, args, opts);\n\tconst joinedCmd = joinCmd(cmd, args);\n\n\tif (isStream(parsed.opts.input)) {\n\t\tthrow new TypeError('The `input` option cannot be a stream in sync mode');\n\t}\n\n\tconst result = childProcess.spawnSync(parsed.cmd, parsed.args, parsed.opts);\n\tresult.code = result.status;\n\n\tif (result.error || result.status !== 0 || result.signal !== null) {\n\t\tconst err = makeError(result, {\n\t\t\tjoinedCmd,\n\t\t\tparsed\n\t\t});\n\n\t\tif (!parsed.opts.reject) {\n\t\t\treturn err;\n\t\t}\n\n\t\tthrow err;\n\t}\n\n\treturn {\n\t\tstdout: handleOutput(parsed.opts, result.stdout),\n\t\tstderr: handleOutput(parsed.opts, result.stderr),\n\t\tcode: 0,\n\t\tfailed: false,\n\t\tsignal: null,\n\t\tcmd: joinedCmd,\n\t\ttimedOut: false\n\t};\n};\n\nmodule.exports.shellSync = (cmd, opts) => handleShell(module.exports.sync, cmd, opts);\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/execa/index.js?");

/***/ }),

/***/ "./node_modules/execa/lib/errname.js":
/*!*******************************************!*\
  !*** ./node_modules/execa/lib/errname.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// Older verions of Node.js might not have `util.getSystemErrorName()`.\n// In that case, fall back to a deprecated internal.\nconst util = __webpack_require__(/*! util */ \"util\");\n\nlet uv;\n\nif (typeof util.getSystemErrorName === 'function') {\n\tmodule.exports = util.getSystemErrorName;\n} else {\n\ttry {\n\t\tuv = process.binding('uv');\n\n\t\tif (typeof uv.errname !== 'function') {\n\t\t\tthrow new TypeError('uv.errname is not a function');\n\t\t}\n\t} catch (err) {\n\t\tconsole.error('execa/lib/errname: unable to establish process.binding(\\'uv\\')', err);\n\t\tuv = null;\n\t}\n\n\tmodule.exports = code => errname(uv, code);\n}\n\n// Used for testing the fallback behavior\nmodule.exports.__test__ = errname;\n\nfunction errname(uv, code) {\n\tif (uv) {\n\t\treturn uv.errname(code);\n\t}\n\n\tif (!(code < 0)) {\n\t\tthrow new Error('err >= 0');\n\t}\n\n\treturn `Unknown system error ${code}`;\n}\n\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/execa/lib/errname.js?");

/***/ }),

/***/ "./node_modules/execa/lib/stdio.js":
/*!*****************************************!*\
  !*** ./node_modules/execa/lib/stdio.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
eval("\nconst alias = ['stdin', 'stdout', 'stderr'];\n\nconst hasAlias = opts => alias.some(x => Boolean(opts[x]));\n\nmodule.exports = opts => {\n\tif (!opts) {\n\t\treturn null;\n\t}\n\n\tif (opts.stdio && hasAlias(opts)) {\n\t\tthrow new Error(`It's not possible to provide \\`stdio\\` in combination with one of ${alias.map(x => `\\`${x}\\``).join(', ')}`);\n\t}\n\n\tif (typeof opts.stdio === 'string') {\n\t\treturn opts.stdio;\n\t}\n\n\tconst stdio = opts.stdio || [];\n\n\tif (!Array.isArray(stdio)) {\n\t\tthrow new TypeError(`Expected \\`stdio\\` to be of type \\`string\\` or \\`Array\\`, got \\`${typeof stdio}\\``);\n\t}\n\n\tconst result = [];\n\tconst len = Math.max(stdio.length, alias.length);\n\n\tfor (let i = 0; i < len; i++) {\n\t\tlet value = null;\n\n\t\tif (stdio[i] !== undefined) {\n\t\t\tvalue = stdio[i];\n\t\t} else if (opts[alias[i]] !== undefined) {\n\t\t\tvalue = opts[alias[i]];\n\t\t}\n\n\t\tresult[i] = value;\n\t}\n\n\treturn result;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/execa/lib/stdio.js?");

/***/ }),

/***/ "./node_modules/execa/node_modules/cross-spawn/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/execa/node_modules/cross-spawn/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst cp = __webpack_require__(/*! child_process */ \"child_process\");\nconst parse = __webpack_require__(/*! ./lib/parse */ \"./node_modules/execa/node_modules/cross-spawn/lib/parse.js\");\nconst enoent = __webpack_require__(/*! ./lib/enoent */ \"./node_modules/execa/node_modules/cross-spawn/lib/enoent.js\");\n\nfunction spawn(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);\n\n    // Hook into child process \"exit\" event to emit an error if the command\n    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    enoent.hookChildProcess(spawned, parsed);\n\n    return spawned;\n}\n\nfunction spawnSync(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);\n\n    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);\n\n    return result;\n}\n\nmodule.exports = spawn;\nmodule.exports.spawn = spawn;\nmodule.exports.sync = spawnSync;\n\nmodule.exports._parse = parse;\nmodule.exports._enoent = enoent;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/execa/node_modules/cross-spawn/index.js?");

/***/ }),

/***/ "./node_modules/execa/node_modules/cross-spawn/lib/enoent.js":
/*!*******************************************************************!*\
  !*** ./node_modules/execa/node_modules/cross-spawn/lib/enoent.js ***!
  \*******************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst isWin = process.platform === 'win32';\n\nfunction notFoundError(original, syscall) {\n    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {\n        code: 'ENOENT',\n        errno: 'ENOENT',\n        syscall: `${syscall} ${original.command}`,\n        path: original.command,\n        spawnargs: original.args,\n    });\n}\n\nfunction hookChildProcess(cp, parsed) {\n    if (!isWin) {\n        return;\n    }\n\n    const originalEmit = cp.emit;\n\n    cp.emit = function (name, arg1) {\n        // If emitting \"exit\" event and exit code is 1, we need to check if\n        // the command exists and emit an \"error\" instead\n        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16\n        if (name === 'exit') {\n            const err = verifyENOENT(arg1, parsed, 'spawn');\n\n            if (err) {\n                return originalEmit.call(cp, 'error', err);\n            }\n        }\n\n        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params\n    };\n}\n\nfunction verifyENOENT(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawn');\n    }\n\n    return null;\n}\n\nfunction verifyENOENTSync(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawnSync');\n    }\n\n    return null;\n}\n\nmodule.exports = {\n    hookChildProcess,\n    verifyENOENT,\n    verifyENOENTSync,\n    notFoundError,\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/execa/node_modules/cross-spawn/lib/enoent.js?");

/***/ }),

/***/ "./node_modules/execa/node_modules/cross-spawn/lib/parse.js":
/*!******************************************************************!*\
  !*** ./node_modules/execa/node_modules/cross-spawn/lib/parse.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\");\nconst niceTry = __webpack_require__(/*! nice-try */ \"./node_modules/nice-try/src/index.js\");\nconst resolveCommand = __webpack_require__(/*! ./util/resolveCommand */ \"./node_modules/execa/node_modules/cross-spawn/lib/util/resolveCommand.js\");\nconst escape = __webpack_require__(/*! ./util/escape */ \"./node_modules/execa/node_modules/cross-spawn/lib/util/escape.js\");\nconst readShebang = __webpack_require__(/*! ./util/readShebang */ \"./node_modules/execa/node_modules/cross-spawn/lib/util/readShebang.js\");\nconst semver = __webpack_require__(/*! semver */ \"./node_modules/execa/node_modules/semver/semver.js\");\n\nconst isWin = process.platform === 'win32';\nconst isExecutableRegExp = /\\.(?:com|exe)$/i;\nconst isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;\n\n// `options.shell` is supported in Node ^4.8.0, ^5.7.0 and >= 6.0.0\nconst supportsShellOption = niceTry(() => semver.satisfies(process.version, '^4.8.0 || ^5.7.0 || >= 6.0.0', true)) || false;\n\nfunction detectShebang(parsed) {\n    parsed.file = resolveCommand(parsed);\n\n    const shebang = parsed.file && readShebang(parsed.file);\n\n    if (shebang) {\n        parsed.args.unshift(parsed.file);\n        parsed.command = shebang;\n\n        return resolveCommand(parsed);\n    }\n\n    return parsed.file;\n}\n\nfunction parseNonShell(parsed) {\n    if (!isWin) {\n        return parsed;\n    }\n\n    // Detect & add support for shebangs\n    const commandFile = detectShebang(parsed);\n\n    // We don't need a shell if the command filename is an executable\n    const needsShell = !isExecutableRegExp.test(commandFile);\n\n    // If a shell is required, use cmd.exe and take care of escaping everything correctly\n    // Note that `forceShell` is an hidden option used only in tests\n    if (parsed.options.forceShell || needsShell) {\n        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n        // we need to double escape them\n        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);\n\n        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n        // This is necessary otherwise it will always fail with ENOENT in those cases\n        parsed.command = path.normalize(parsed.command);\n\n        // Escape command & arguments\n        parsed.command = escape.command(parsed.command);\n        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));\n\n        const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n        parsed.args = ['/d', '/s', '/c', `\"${shellCommand}\"`];\n        parsed.command = process.env.comspec || 'cmd.exe';\n        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n    }\n\n    return parsed;\n}\n\nfunction parseShell(parsed) {\n    // If node supports the shell option, there's no need to mimic its behavior\n    if (supportsShellOption) {\n        return parsed;\n    }\n\n    // Mimic node shell option\n    // See https://github.com/nodejs/node/blob/b9f6a2dc059a1062776133f3d4fd848c4da7d150/lib/child_process.js#L335\n    const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n    if (isWin) {\n        parsed.command = typeof parsed.options.shell === 'string' ? parsed.options.shell : process.env.comspec || 'cmd.exe';\n        parsed.args = ['/d', '/s', '/c', `\"${shellCommand}\"`];\n        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n    } else {\n        if (typeof parsed.options.shell === 'string') {\n            parsed.command = parsed.options.shell;\n        } else if (process.platform === 'android') {\n            parsed.command = '/system/bin/sh';\n        } else {\n            parsed.command = '/bin/sh';\n        }\n\n        parsed.args = ['-c', shellCommand];\n    }\n\n    return parsed;\n}\n\nfunction parse(command, args, options) {\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n\n    args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n    options = Object.assign({}, options); // Clone object to avoid changing the original\n\n    // Build our parsed object\n    const parsed = {\n        command,\n        args,\n        options,\n        file: undefined,\n        original: {\n            command,\n            args,\n        },\n    };\n\n    // Delegate further parsing to shell or non-shell\n    return options.shell ? parseShell(parsed) : parseNonShell(parsed);\n}\n\nmodule.exports = parse;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/execa/node_modules/cross-spawn/lib/parse.js?");

/***/ }),

/***/ "./node_modules/execa/node_modules/cross-spawn/lib/util/escape.js":
/*!************************************************************************!*\
  !*** ./node_modules/execa/node_modules/cross-spawn/lib/util/escape.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// See http://www.robvanderwoude.com/escapechars.php\nconst metaCharsRegExp = /([()\\][%!^\"`<>&|;, *?])/g;\n\nfunction escapeCommand(arg) {\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    return arg;\n}\n\nfunction escapeArgument(arg, doubleEscapeMetaChars) {\n    // Convert to string\n    arg = `${arg}`;\n\n    // Algorithm below is based on https://qntm.org/cmd\n\n    // Sequence of backslashes followed by a double quote:\n    // double up all the backslashes and escape the double quote\n    arg = arg.replace(/(\\\\*)\"/g, '$1$1\\\\\"');\n\n    // Sequence of backslashes followed by the end of the string\n    // (which will become a double quote later):\n    // double up all the backslashes\n    arg = arg.replace(/(\\\\*)$/, '$1$1');\n\n    // All other backslashes occur literally\n\n    // Quote the whole thing:\n    arg = `\"${arg}\"`;\n\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    // Double escape meta chars if necessary\n    if (doubleEscapeMetaChars) {\n        arg = arg.replace(metaCharsRegExp, '^$1');\n    }\n\n    return arg;\n}\n\nmodule.exports.command = escapeCommand;\nmodule.exports.argument = escapeArgument;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/execa/node_modules/cross-spawn/lib/util/escape.js?");

/***/ }),

/***/ "./node_modules/execa/node_modules/cross-spawn/lib/util/readShebang.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/execa/node_modules/cross-spawn/lib/util/readShebang.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst shebangCommand = __webpack_require__(/*! shebang-command */ \"./node_modules/execa/node_modules/shebang-command/index.js\");\n\nfunction readShebang(command) {\n    // Read the first 150 bytes from the file\n    const size = 150;\n    let buffer;\n\n    if (Buffer.alloc) {\n        // Node.js v4.5+ / v5.10+\n        buffer = Buffer.alloc(size);\n    } else {\n        // Old Node.js API\n        buffer = new Buffer(size);\n        buffer.fill(0); // zero-fill\n    }\n\n    let fd;\n\n    try {\n        fd = fs.openSync(command, 'r');\n        fs.readSync(fd, buffer, 0, size, 0);\n        fs.closeSync(fd);\n    } catch (e) { /* Empty */ }\n\n    // Attempt to extract shebang (null is returned if not a shebang)\n    return shebangCommand(buffer.toString());\n}\n\nmodule.exports = readShebang;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/execa/node_modules/cross-spawn/lib/util/readShebang.js?");

/***/ }),

/***/ "./node_modules/execa/node_modules/cross-spawn/lib/util/resolveCommand.js":
/*!********************************************************************************!*\
  !*** ./node_modules/execa/node_modules/cross-spawn/lib/util/resolveCommand.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\");\nconst which = __webpack_require__(/*! which */ \"./node_modules/execa/node_modules/which/which.js\");\nconst pathKey = __webpack_require__(/*! path-key */ \"./node_modules/path-key/index.js\")();\n\nfunction resolveCommandAttempt(parsed, withoutPathExt) {\n    const cwd = process.cwd();\n    const hasCustomCwd = parsed.options.cwd != null;\n\n    // If a custom `cwd` was specified, we need to change the process cwd\n    // because `which` will do stat calls but does not support a custom cwd\n    if (hasCustomCwd) {\n        try {\n            process.chdir(parsed.options.cwd);\n        } catch (err) {\n            /* Empty */\n        }\n    }\n\n    let resolved;\n\n    try {\n        resolved = which.sync(parsed.command, {\n            path: (parsed.options.env || process.env)[pathKey],\n            pathExt: withoutPathExt ? path.delimiter : undefined,\n        });\n    } catch (e) {\n        /* Empty */\n    } finally {\n        process.chdir(cwd);\n    }\n\n    // If we successfully resolved, ensure that an absolute path is returned\n    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it\n    if (resolved) {\n        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);\n    }\n\n    return resolved;\n}\n\nfunction resolveCommand(parsed) {\n    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);\n}\n\nmodule.exports = resolveCommand;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/execa/node_modules/cross-spawn/lib/util/resolveCommand.js?");

/***/ }),

/***/ "./node_modules/execa/node_modules/get-stream/buffer-stream.js":
/*!*********************************************************************!*\
  !*** ./node_modules/execa/node_modules/get-stream/buffer-stream.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst {PassThrough} = __webpack_require__(/*! stream */ \"stream\");\n\nmodule.exports = options => {\n\toptions = Object.assign({}, options);\n\n\tconst {array} = options;\n\tlet {encoding} = options;\n\tconst buffer = encoding === 'buffer';\n\tlet objectMode = false;\n\n\tif (array) {\n\t\tobjectMode = !(encoding || buffer);\n\t} else {\n\t\tencoding = encoding || 'utf8';\n\t}\n\n\tif (buffer) {\n\t\tencoding = null;\n\t}\n\n\tlet len = 0;\n\tconst ret = [];\n\tconst stream = new PassThrough({objectMode});\n\n\tif (encoding) {\n\t\tstream.setEncoding(encoding);\n\t}\n\n\tstream.on('data', chunk => {\n\t\tret.push(chunk);\n\n\t\tif (objectMode) {\n\t\t\tlen = ret.length;\n\t\t} else {\n\t\t\tlen += chunk.length;\n\t\t}\n\t});\n\n\tstream.getBufferedValue = () => {\n\t\tif (array) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn buffer ? Buffer.concat(ret, len) : ret.join('');\n\t};\n\n\tstream.getBufferedLength = () => len;\n\n\treturn stream;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/execa/node_modules/get-stream/buffer-stream.js?");

/***/ }),

/***/ "./node_modules/execa/node_modules/get-stream/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/execa/node_modules/get-stream/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst pump = __webpack_require__(/*! pump */ \"./node_modules/pump/index.js\");\nconst bufferStream = __webpack_require__(/*! ./buffer-stream */ \"./node_modules/execa/node_modules/get-stream/buffer-stream.js\");\n\nclass MaxBufferError extends Error {\n\tconstructor() {\n\t\tsuper('maxBuffer exceeded');\n\t\tthis.name = 'MaxBufferError';\n\t}\n}\n\nfunction getStream(inputStream, options) {\n\tif (!inputStream) {\n\t\treturn Promise.reject(new Error('Expected a stream'));\n\t}\n\n\toptions = Object.assign({maxBuffer: Infinity}, options);\n\n\tconst {maxBuffer} = options;\n\n\tlet stream;\n\treturn new Promise((resolve, reject) => {\n\t\tconst rejectPromise = error => {\n\t\t\tif (error) { // A null check\n\t\t\t\terror.bufferedData = stream.getBufferedValue();\n\t\t\t}\n\t\t\treject(error);\n\t\t};\n\n\t\tstream = pump(inputStream, bufferStream(options), error => {\n\t\t\tif (error) {\n\t\t\t\trejectPromise(error);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolve();\n\t\t});\n\n\t\tstream.on('data', () => {\n\t\t\tif (stream.getBufferedLength() > maxBuffer) {\n\t\t\t\trejectPromise(new MaxBufferError());\n\t\t\t}\n\t\t});\n\t}).then(() => stream.getBufferedValue());\n}\n\nmodule.exports = getStream;\nmodule.exports.buffer = (stream, options) => getStream(stream, Object.assign({}, options, {encoding: 'buffer'}));\nmodule.exports.array = (stream, options) => getStream(stream, Object.assign({}, options, {array: true}));\nmodule.exports.MaxBufferError = MaxBufferError;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/execa/node_modules/get-stream/index.js?");

/***/ }),

/***/ "./node_modules/execa/node_modules/is-stream/index.js":
/*!************************************************************!*\
  !*** ./node_modules/execa/node_modules/is-stream/index.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar isStream = module.exports = function (stream) {\n\treturn stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function';\n};\n\nisStream.writable = function (stream) {\n\treturn isStream(stream) && stream.writable !== false && typeof stream._write === 'function' && typeof stream._writableState === 'object';\n};\n\nisStream.readable = function (stream) {\n\treturn isStream(stream) && stream.readable !== false && typeof stream._read === 'function' && typeof stream._readableState === 'object';\n};\n\nisStream.duplex = function (stream) {\n\treturn isStream.writable(stream) && isStream.readable(stream);\n};\n\nisStream.transform = function (stream) {\n\treturn isStream.duplex(stream) && typeof stream._transform === 'function' && typeof stream._transformState === 'object';\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/execa/node_modules/is-stream/index.js?");

/***/ }),

/***/ "./node_modules/execa/node_modules/npm-run-path/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/execa/node_modules/npm-run-path/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst path = __webpack_require__(/*! path */ \"path\");\nconst pathKey = __webpack_require__(/*! path-key */ \"./node_modules/path-key/index.js\");\n\nmodule.exports = opts => {\n\topts = Object.assign({\n\t\tcwd: process.cwd(),\n\t\tpath: process.env[pathKey()]\n\t}, opts);\n\n\tlet prev;\n\tlet pth = path.resolve(opts.cwd);\n\tconst ret = [];\n\n\twhile (prev !== pth) {\n\t\tret.push(path.join(pth, 'node_modules/.bin'));\n\t\tprev = pth;\n\t\tpth = path.resolve(pth, '..');\n\t}\n\n\t// ensure the running `node` binary is used\n\tret.push(path.dirname(process.execPath));\n\n\treturn ret.concat(opts.path).join(path.delimiter);\n};\n\nmodule.exports.env = opts => {\n\topts = Object.assign({\n\t\tenv: process.env\n\t}, opts);\n\n\tconst env = Object.assign({}, opts.env);\n\tconst path = pathKey({env});\n\n\topts.path = env[path];\n\tenv[path] = module.exports(opts);\n\n\treturn env;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/execa/node_modules/npm-run-path/index.js?");

/***/ }),

/***/ "./node_modules/execa/node_modules/semver/semver.js":
/*!**********************************************************!*\
  !*** ./node_modules/execa/node_modules/semver/semver.js ***!
  \**********************************************************/
/***/ ((module, exports) => {

eval("exports = module.exports = SemVer\n\nvar debug\n/* istanbul ignore next */\nif (typeof process === 'object' &&\n    process.env &&\n    process.env.NODE_DEBUG &&\n    /\\bsemver\\b/i.test(process.env.NODE_DEBUG)) {\n  debug = function () {\n    var args = Array.prototype.slice.call(arguments, 0)\n    args.unshift('SEMVER')\n    console.log.apply(console, args)\n  }\n} else {\n  debug = function () {}\n}\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0'\n\nvar MAX_LENGTH = 256\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n  /* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nvar MAX_SAFE_COMPONENT_LENGTH = 16\n\n// The actual regexps go on exports.re\nvar re = exports.re = []\nvar src = exports.src = []\nvar R = 0\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*'\nvar NUMERICIDENTIFIERLOOSE = R++\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+'\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*'\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')'\n\nvar MAINVERSIONLOOSE = R++\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n                            '|' + src[NONNUMERICIDENTIFIER] + ')'\n\nvar PRERELEASEIDENTIFIERLOOSE = R++\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')'\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))'\n\nvar PRERELEASELOOSE = R++\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))'\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n                src[PRERELEASE] + '?' +\n                src[BUILD] + '?'\n\nsrc[FULL] = '^' + FULLPLAIN + '$'\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n                 src[PRERELEASELOOSE] + '?' +\n                 src[BUILD] + '?'\n\nvar LOOSE = R++\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$'\n\nvar GTLT = R++\nsrc[GTLT] = '((?:<|>)?=?)'\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*'\nvar XRANGEIDENTIFIER = R++\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*'\n\nvar XRANGEPLAIN = R++\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[PRERELEASE] + ')?' +\n                   src[BUILD] + '?' +\n                   ')?)?'\n\nvar XRANGEPLAINLOOSE = R++\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[PRERELEASELOOSE] + ')?' +\n                        src[BUILD] + '?' +\n                        ')?)?'\n\nvar XRANGE = R++\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$'\nvar XRANGELOOSE = R++\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$'\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\nvar COERCE = R++\nsrc[COERCE] = '(?:^|[^\\\\d])' +\n              '(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +\n              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n              '(?:$|[^\\\\d])'\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++\nsrc[LONETILDE] = '(?:~>?)'\n\nvar TILDETRIM = R++\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+'\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')\nvar tildeTrimReplace = '$1~'\n\nvar TILDE = R++\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'\nvar TILDELOOSE = R++\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++\nsrc[LONECARET] = '(?:\\\\^)'\n\nvar CARETTRIM = R++\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+'\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')\nvar caretTrimReplace = '$1^'\n\nvar CARET = R++\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'\nvar CARETLOOSE = R++\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$'\nvar COMPARATOR = R++\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$'\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')\nvar comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s*$'\n\nvar HYPHENRANGELOOSE = R++\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$'\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*'\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i])\n  if (!re[i]) {\n    re[i] = new RegExp(src[i])\n  }\n}\n\nexports.parse = parse\nfunction parse (version, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null\n  }\n\n  var r = options.loose ? re[LOOSE] : re[FULL]\n  if (!r.test(version)) {\n    return null\n  }\n\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    return null\n  }\n}\n\nexports.valid = valid\nfunction valid (version, options) {\n  var v = parse(version, options)\n  return v ? v.version : null\n}\n\nexports.clean = clean\nfunction clean (version, options) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\n\nexports.SemVer = SemVer\n\nfunction SemVer (version, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n  if (version instanceof SemVer) {\n    if (version.loose === options.loose) {\n      return version\n    } else {\n      version = version.version\n    }\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version)\n  }\n\n  if (version.length > MAX_LENGTH) {\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')\n  }\n\n  if (!(this instanceof SemVer)) {\n    return new SemVer(version, options)\n  }\n\n  debug('SemVer', version, options)\n  this.options = options\n  this.loose = !!options.loose\n\n  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])\n\n  if (!m) {\n    throw new TypeError('Invalid Version: ' + version)\n  }\n\n  this.raw = version\n\n  // these are actually numbers\n  this.major = +m[1]\n  this.minor = +m[2]\n  this.patch = +m[3]\n\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n    throw new TypeError('Invalid major version')\n  }\n\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n    throw new TypeError('Invalid minor version')\n  }\n\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n    throw new TypeError('Invalid patch version')\n  }\n\n  // numberify any prerelease numeric ids\n  if (!m[4]) {\n    this.prerelease = []\n  } else {\n    this.prerelease = m[4].split('.').map(function (id) {\n      if (/^[0-9]+$/.test(id)) {\n        var num = +id\n        if (num >= 0 && num < MAX_SAFE_INTEGER) {\n          return num\n        }\n      }\n      return id\n    })\n  }\n\n  this.build = m[5] ? m[5].split('.') : []\n  this.format()\n}\n\nSemVer.prototype.format = function () {\n  this.version = this.major + '.' + this.minor + '.' + this.patch\n  if (this.prerelease.length) {\n    this.version += '-' + this.prerelease.join('.')\n  }\n  return this.version\n}\n\nSemVer.prototype.toString = function () {\n  return this.version\n}\n\nSemVer.prototype.compare = function (other) {\n  debug('SemVer.compare', this.version, this.options, other)\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  return this.compareMain(other) || this.comparePre(other)\n}\n\nSemVer.prototype.compareMain = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch)\n}\n\nSemVer.prototype.comparePre = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length) {\n    return -1\n  } else if (!this.prerelease.length && other.prerelease.length) {\n    return 1\n  } else if (!this.prerelease.length && !other.prerelease.length) {\n    return 0\n  }\n\n  var i = 0\n  do {\n    var a = this.prerelease[i]\n    var b = other.prerelease[i]\n    debug('prerelease compare', i, a, b)\n    if (a === undefined && b === undefined) {\n      return 0\n    } else if (b === undefined) {\n      return 1\n    } else if (a === undefined) {\n      return -1\n    } else if (a === b) {\n      continue\n    } else {\n      return compareIdentifiers(a, b)\n    }\n  } while (++i)\n}\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function (release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0\n      this.patch = 0\n      this.minor = 0\n      this.major++\n      this.inc('pre', identifier)\n      break\n    case 'preminor':\n      this.prerelease.length = 0\n      this.patch = 0\n      this.minor++\n      this.inc('pre', identifier)\n      break\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0\n      this.inc('patch', identifier)\n      this.inc('pre', identifier)\n      break\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0) {\n        this.inc('patch', identifier)\n      }\n      this.inc('pre', identifier)\n      break\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0) {\n        this.major++\n      }\n      this.minor = 0\n      this.patch = 0\n      this.prerelease = []\n      break\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0) {\n        this.minor++\n      }\n      this.patch = 0\n      this.prerelease = []\n      break\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0) {\n        this.patch++\n      }\n      this.prerelease = []\n      break\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0) {\n        this.prerelease = [0]\n      } else {\n        var i = this.prerelease.length\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++\n            i = -2\n          }\n        }\n        if (i === -1) {\n          // didn't increment anything\n          this.prerelease.push(0)\n        }\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1])) {\n            this.prerelease = [identifier, 0]\n          }\n        } else {\n          this.prerelease = [identifier, 0]\n        }\n      }\n      break\n\n    default:\n      throw new Error('invalid increment argument: ' + release)\n  }\n  this.format()\n  this.raw = this.version\n  return this\n}\n\nexports.inc = inc\nfunction inc (version, release, loose, identifier) {\n  if (typeof (loose) === 'string') {\n    identifier = loose\n    loose = undefined\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version\n  } catch (er) {\n    return null\n  }\n}\n\nexports.diff = diff\nfunction diff (version1, version2) {\n  if (eq(version1, version2)) {\n    return null\n  } else {\n    var v1 = parse(version1)\n    var v2 = parse(version2)\n    var prefix = ''\n    if (v1.prerelease.length || v2.prerelease.length) {\n      prefix = 'pre'\n      var defaultResult = 'prerelease'\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key\n        }\n      }\n    }\n    return defaultResult // may be undefined\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers\n\nvar numeric = /^[0-9]+$/\nfunction compareIdentifiers (a, b) {\n  var anum = numeric.test(a)\n  var bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers\nfunction rcompareIdentifiers (a, b) {\n  return compareIdentifiers(b, a)\n}\n\nexports.major = major\nfunction major (a, loose) {\n  return new SemVer(a, loose).major\n}\n\nexports.minor = minor\nfunction minor (a, loose) {\n  return new SemVer(a, loose).minor\n}\n\nexports.patch = patch\nfunction patch (a, loose) {\n  return new SemVer(a, loose).patch\n}\n\nexports.compare = compare\nfunction compare (a, b, loose) {\n  return new SemVer(a, loose).compare(new SemVer(b, loose))\n}\n\nexports.compareLoose = compareLoose\nfunction compareLoose (a, b) {\n  return compare(a, b, true)\n}\n\nexports.rcompare = rcompare\nfunction rcompare (a, b, loose) {\n  return compare(b, a, loose)\n}\n\nexports.sort = sort\nfunction sort (list, loose) {\n  return list.sort(function (a, b) {\n    return exports.compare(a, b, loose)\n  })\n}\n\nexports.rsort = rsort\nfunction rsort (list, loose) {\n  return list.sort(function (a, b) {\n    return exports.rcompare(a, b, loose)\n  })\n}\n\nexports.gt = gt\nfunction gt (a, b, loose) {\n  return compare(a, b, loose) > 0\n}\n\nexports.lt = lt\nfunction lt (a, b, loose) {\n  return compare(a, b, loose) < 0\n}\n\nexports.eq = eq\nfunction eq (a, b, loose) {\n  return compare(a, b, loose) === 0\n}\n\nexports.neq = neq\nfunction neq (a, b, loose) {\n  return compare(a, b, loose) !== 0\n}\n\nexports.gte = gte\nfunction gte (a, b, loose) {\n  return compare(a, b, loose) >= 0\n}\n\nexports.lte = lte\nfunction lte (a, b, loose) {\n  return compare(a, b, loose) <= 0\n}\n\nexports.cmp = cmp\nfunction cmp (a, op, b, loose) {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError('Invalid operator: ' + op)\n  }\n}\n\nexports.Comparator = Comparator\nfunction Comparator (comp, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (comp instanceof Comparator) {\n    if (comp.loose === !!options.loose) {\n      return comp\n    } else {\n      comp = comp.value\n    }\n  }\n\n  if (!(this instanceof Comparator)) {\n    return new Comparator(comp, options)\n  }\n\n  debug('comparator', comp, options)\n  this.options = options\n  this.loose = !!options.loose\n  this.parse(comp)\n\n  if (this.semver === ANY) {\n    this.value = ''\n  } else {\n    this.value = this.operator + this.semver.version\n  }\n\n  debug('comp', this)\n}\n\nvar ANY = {}\nComparator.prototype.parse = function (comp) {\n  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]\n  var m = comp.match(r)\n\n  if (!m) {\n    throw new TypeError('Invalid comparator: ' + comp)\n  }\n\n  this.operator = m[1]\n  if (this.operator === '=') {\n    this.operator = ''\n  }\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2]) {\n    this.semver = ANY\n  } else {\n    this.semver = new SemVer(m[2], this.options.loose)\n  }\n}\n\nComparator.prototype.toString = function () {\n  return this.value\n}\n\nComparator.prototype.test = function (version) {\n  debug('Comparator.test', version, this.options.loose)\n\n  if (this.semver === ANY) {\n    return true\n  }\n\n  if (typeof version === 'string') {\n    version = new SemVer(version, this.options)\n  }\n\n  return cmp(version, this.operator, this.semver, this.options)\n}\n\nComparator.prototype.intersects = function (comp, options) {\n  if (!(comp instanceof Comparator)) {\n    throw new TypeError('a Comparator is required')\n  }\n\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  var rangeTmp\n\n  if (this.operator === '') {\n    rangeTmp = new Range(comp.value, options)\n    return satisfies(this.value, rangeTmp, options)\n  } else if (comp.operator === '') {\n    rangeTmp = new Range(this.value, options)\n    return satisfies(comp.semver, rangeTmp, options)\n  }\n\n  var sameDirectionIncreasing =\n    (this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '>=' || comp.operator === '>')\n  var sameDirectionDecreasing =\n    (this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '<=' || comp.operator === '<')\n  var sameSemVer = this.semver.version === comp.semver.version\n  var differentDirectionsInclusive =\n    (this.operator === '>=' || this.operator === '<=') &&\n    (comp.operator === '>=' || comp.operator === '<=')\n  var oppositeDirectionsLessThan =\n    cmp(this.semver, '<', comp.semver, options) &&\n    ((this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '<=' || comp.operator === '<'))\n  var oppositeDirectionsGreaterThan =\n    cmp(this.semver, '>', comp.semver, options) &&\n    ((this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '>=' || comp.operator === '>'))\n\n  return sameDirectionIncreasing || sameDirectionDecreasing ||\n    (sameSemVer && differentDirectionsInclusive) ||\n    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan\n}\n\nexports.Range = Range\nfunction Range (range, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (range instanceof Range) {\n    if (range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease) {\n      return range\n    } else {\n      return new Range(range.raw, options)\n    }\n  }\n\n  if (range instanceof Comparator) {\n    return new Range(range.value, options)\n  }\n\n  if (!(this instanceof Range)) {\n    return new Range(range, options)\n  }\n\n  this.options = options\n  this.loose = !!options.loose\n  this.includePrerelease = !!options.includePrerelease\n\n  // First, split based on boolean or ||\n  this.raw = range\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function (range) {\n    return this.parseRange(range.trim())\n  }, this).filter(function (c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length\n  })\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range)\n  }\n\n  this.format()\n}\n\nRange.prototype.format = function () {\n  this.range = this.set.map(function (comps) {\n    return comps.join(' ').trim()\n  }).join('||').trim()\n  return this.range\n}\n\nRange.prototype.toString = function () {\n  return this.range\n}\n\nRange.prototype.parseRange = function (range) {\n  var loose = this.options.loose\n  range = range.trim()\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]\n  range = range.replace(hr, hyphenReplace)\n  debug('hyphen replace', range)\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)\n  debug('comparator trim', range, re[COMPARATORTRIM])\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[TILDETRIM], tildeTrimReplace)\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[CARETTRIM], caretTrimReplace)\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ')\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]\n  var set = range.split(' ').map(function (comp) {\n    return parseComparator(comp, this.options)\n  }, this).join(' ').split(/\\s+/)\n  if (this.options.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function (comp) {\n      return !!comp.match(compRe)\n    })\n  }\n  set = set.map(function (comp) {\n    return new Comparator(comp, this.options)\n  }, this)\n\n  return set\n}\n\nRange.prototype.intersects = function (range, options) {\n  if (!(range instanceof Range)) {\n    throw new TypeError('a Range is required')\n  }\n\n  return this.set.some(function (thisComparators) {\n    return thisComparators.every(function (thisComparator) {\n      return range.set.some(function (rangeComparators) {\n        return rangeComparators.every(function (rangeComparator) {\n          return thisComparator.intersects(rangeComparator, options)\n        })\n      })\n    })\n  })\n}\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators\nfunction toComparators (range, options) {\n  return new Range(range, options).set.map(function (comp) {\n    return comp.map(function (c) {\n      return c.value\n    }).join(' ').trim().split(' ')\n  })\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator (comp, options) {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nfunction isX (id) {\n  return !id || id.toLowerCase() === 'x' || id === '*'\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes (comp, options) {\n  return comp.trim().split(/\\s+/).map(function (comp) {\n    return replaceTilde(comp, options)\n  }).join(' ')\n}\n\nfunction replaceTilde (comp, options) {\n  var r = options.loose ? re[TILDELOOSE] : re[TILDE]\n  return comp.replace(r, function (_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr)\n    var ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n            ' <' + M + '.' + (+m + 1) + '.0'\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0'\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets (comp, options) {\n  return comp.trim().split(/\\s+/).map(function (comp) {\n    return replaceCaret(comp, options)\n  }).join(' ')\n}\n\nfunction replaceCaret (comp, options) {\n  debug('caret', comp, options)\n  var r = options.loose ? re[CARETLOOSE] : re[CARET]\n  return comp.replace(r, function (_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr)\n    var ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'\n      } else {\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1)\n        } else {\n          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n                ' <' + M + '.' + (+m + 1) + '.0'\n        }\n      } else {\n        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n              ' <' + (+M + 1) + '.0.0'\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1)\n        } else {\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0'\n        }\n      } else {\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0'\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nfunction replaceXRanges (comp, options) {\n  debug('replaceXRanges', comp, options)\n  return comp.split(/\\s+/).map(function (comp) {\n    return replaceXRange(comp, options)\n  }).join(' ')\n}\n\nfunction replaceXRange (comp, options) {\n  comp = comp.trim()\n  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]\n  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    var xM = isX(M)\n    var xm = xM || isX(m)\n    var xp = xm || isX(p)\n    var anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p\n    } else if (xm) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars (comp, options) {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[STAR], '')\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr, tb) {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = '>=' + fM + '.0.0'\n  } else if (isX(fp)) {\n    from = '>=' + fM + '.' + fm + '.0'\n  } else {\n    from = '>=' + from\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = '<' + (+tM + 1) + '.0.0'\n  } else if (isX(tp)) {\n    to = '<' + tM + '.' + (+tm + 1) + '.0'\n  } else if (tpr) {\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr\n  } else {\n    to = '<=' + to\n  }\n\n  return (from + ' ' + to).trim()\n}\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function (version) {\n  if (!version) {\n    return false\n  }\n\n  if (typeof version === 'string') {\n    version = new SemVer(version, this.options)\n  }\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version, this.options)) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction testSet (set, version, options) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n\nexports.satisfies = satisfies\nfunction satisfies (version, range, options) {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\n\nexports.maxSatisfying = maxSatisfying\nfunction maxSatisfying (versions, range, options) {\n  var max = null\n  var maxSV = null\n  try {\n    var rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\n\nexports.minSatisfying = minSatisfying\nfunction minSatisfying (versions, range, options) {\n  var min = null\n  var minSV = null\n  try {\n    var rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\n\nexports.minVersion = minVersion\nfunction minVersion (range, loose) {\n  range = new Range(range, loose)\n\n  var minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i]\n\n    comparators.forEach(function (comparator) {\n      // Clone to avoid manipulating the comparator's semver object.\n      var compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!minver || gt(minver, compver)) {\n            minver = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error('Unexpected operation: ' + comparator.operator)\n      }\n    })\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\n\nexports.validRange = validRange\nfunction validRange (range, options) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr\nfunction ltr (version, range, options) {\n  return outside(version, range, '<', options)\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr\nfunction gtr (version, range, options) {\n  return outside(version, range, '>', options)\n}\n\nexports.outside = outside\nfunction outside (version, range, hilo, options) {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  var gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i]\n\n    var high = null\n    var low = null\n\n    comparators.forEach(function (comparator) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nexports.prerelease = prerelease\nfunction prerelease (version, options) {\n  var parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\n\nexports.intersects = intersects\nfunction intersects (r1, r2, options) {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2)\n}\n\nexports.coerce = coerce\nfunction coerce (version) {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  var match = version.match(re[COERCE])\n\n  if (match == null) {\n    return null\n  }\n\n  return parse(match[1] +\n    '.' + (match[2] || '0') +\n    '.' + (match[3] || '0'))\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/execa/node_modules/semver/semver.js?");

/***/ }),

/***/ "./node_modules/execa/node_modules/shebang-command/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/execa/node_modules/shebang-command/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar shebangRegex = __webpack_require__(/*! shebang-regex */ \"./node_modules/execa/node_modules/shebang-regex/index.js\");\n\nmodule.exports = function (str) {\n\tvar match = str.match(shebangRegex);\n\n\tif (!match) {\n\t\treturn null;\n\t}\n\n\tvar arr = match[0].replace(/#! ?/, '').split(' ');\n\tvar bin = arr[0].split('/').pop();\n\tvar arg = arr[1];\n\n\treturn (bin === 'env' ?\n\t\targ :\n\t\tbin + (arg ? ' ' + arg : '')\n\t);\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/execa/node_modules/shebang-command/index.js?");

/***/ }),

/***/ "./node_modules/execa/node_modules/shebang-regex/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/execa/node_modules/shebang-regex/index.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = /^#!.*/;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/execa/node_modules/shebang-regex/index.js?");

/***/ }),

/***/ "./node_modules/execa/node_modules/which/which.js":
/*!********************************************************!*\
  !*** ./node_modules/execa/node_modules/which/which.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = which\nwhich.sync = whichSync\n\nvar isWindows = process.platform === 'win32' ||\n    process.env.OSTYPE === 'cygwin' ||\n    process.env.OSTYPE === 'msys'\n\nvar path = __webpack_require__(/*! path */ \"path\")\nvar COLON = isWindows ? ';' : ':'\nvar isexe = __webpack_require__(/*! isexe */ \"./node_modules/isexe/index.js\")\n\nfunction getNotFoundError (cmd) {\n  var er = new Error('not found: ' + cmd)\n  er.code = 'ENOENT'\n\n  return er\n}\n\nfunction getPathInfo (cmd, opt) {\n  var colon = opt.colon || COLON\n  var pathEnv = opt.path || process.env.PATH || ''\n  var pathExt = ['']\n\n  pathEnv = pathEnv.split(colon)\n\n  var pathExtExe = ''\n  if (isWindows) {\n    pathEnv.unshift(process.cwd())\n    pathExtExe = (opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM')\n    pathExt = pathExtExe.split(colon)\n\n\n    // Always test the cmd itself first.  isexe will check to make sure\n    // it's found in the pathExt set.\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')\n      pathExt.unshift('')\n  }\n\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  if (cmd.match(/\\//) || isWindows && cmd.match(/\\\\/))\n    pathEnv = ['']\n\n  return {\n    env: pathEnv,\n    ext: pathExt,\n    extExe: pathExtExe\n  }\n}\n\nfunction which (cmd, opt, cb) {\n  if (typeof opt === 'function') {\n    cb = opt\n    opt = {}\n  }\n\n  var info = getPathInfo(cmd, opt)\n  var pathEnv = info.env\n  var pathExt = info.ext\n  var pathExtExe = info.extExe\n  var found = []\n\n  ;(function F (i, l) {\n    if (i === l) {\n      if (opt.all && found.length)\n        return cb(null, found)\n      else\n        return cb(getNotFoundError(cmd))\n    }\n\n    var pathPart = pathEnv[i]\n    if (pathPart.charAt(0) === '\"' && pathPart.slice(-1) === '\"')\n      pathPart = pathPart.slice(1, -1)\n\n    var p = path.join(pathPart, cmd)\n    if (!pathPart && (/^\\.[\\\\\\/]/).test(cmd)) {\n      p = cmd.slice(0, 2) + p\n    }\n    ;(function E (ii, ll) {\n      if (ii === ll) return F(i + 1, l)\n      var ext = pathExt[ii]\n      isexe(p + ext, { pathExt: pathExtExe }, function (er, is) {\n        if (!er && is) {\n          if (opt.all)\n            found.push(p + ext)\n          else\n            return cb(null, p + ext)\n        }\n        return E(ii + 1, ll)\n      })\n    })(0, pathExt.length)\n  })(0, pathEnv.length)\n}\n\nfunction whichSync (cmd, opt) {\n  opt = opt || {}\n\n  var info = getPathInfo(cmd, opt)\n  var pathEnv = info.env\n  var pathExt = info.ext\n  var pathExtExe = info.extExe\n  var found = []\n\n  for (var i = 0, l = pathEnv.length; i < l; i ++) {\n    var pathPart = pathEnv[i]\n    if (pathPart.charAt(0) === '\"' && pathPart.slice(-1) === '\"')\n      pathPart = pathPart.slice(1, -1)\n\n    var p = path.join(pathPart, cmd)\n    if (!pathPart && /^\\.[\\\\\\/]/.test(cmd)) {\n      p = cmd.slice(0, 2) + p\n    }\n    for (var j = 0, ll = pathExt.length; j < ll; j ++) {\n      var cur = p + pathExt[j]\n      var is\n      try {\n        is = isexe.sync(cur, { pathExt: pathExtExe })\n        if (is) {\n          if (opt.all)\n            found.push(cur)\n          else\n            return cur\n        }\n      } catch (ex) {}\n    }\n  }\n\n  if (opt.all && found.length)\n    return found\n\n  if (opt.nothrow)\n    return null\n\n  throw getNotFoundError(cmd)\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/execa/node_modules/which/which.js?");

/***/ }),

/***/ "./node_modules/fast-diff/diff.js":
/*!****************************************!*\
  !*** ./node_modules/fast-diff/diff.js ***!
  \****************************************/
/***/ ((module) => {

eval("/**\n * This library modifies the diff-patch-match library by Neil Fraser\n * by removing the patch and match functionality and certain advanced\n * options in the diff function. The original license is as follows:\n *\n * ===\n *\n * Diff Match and Patch\n *\n * Copyright 2006 Google Inc.\n * http://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {Int|Object} [cursor_pos] Edit position in text1 or object with more info\n * @return {Array} Array of diff tuples.\n */\nfunction diff_main(text1, text2, cursor_pos, _fix_unicode) {\n  // Check for equality\n  if (text1 === text2) {\n    if (text1) {\n      return [[DIFF_EQUAL, text1]];\n    }\n    return [];\n  }\n\n  if (cursor_pos != null) {\n    var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);\n    if (editdiff) {\n      return editdiff;\n    }\n  }\n\n  // Trim off common prefix (speedup).\n  var commonlength = diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = diff_compute_(text1, text2);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\n  }\n  if (commonsuffix) {\n    diffs.push([DIFF_EQUAL, commonsuffix]);\n  }\n  diff_cleanupMerge(diffs, _fix_unicode);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @return {Array} Array of diff tuples.\n */\nfunction diff_compute_(text1, text2) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [[DIFF_INSERT, text2]];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [[DIFF_DELETE, text1]];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i !== -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [\n      [DIFF_INSERT, longtext.substring(0, i)],\n      [DIFF_EQUAL, shorttext],\n      [DIFF_INSERT, longtext.substring(i + shorttext.length)]\n    ];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length === 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = diff_main(text1_a, text2_a);\n    var diffs_b = diff_main(text1_b, text2_b);\n    // Merge the results.\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\n  }\n\n  return diff_bisect_(text1, text2);\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @return {Array} Array of diff tuples.\n * @private\n */\nfunction diff_bisect_(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 !== 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 === -d || (k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (\n        x1 < text1_length && y1 < text2_length &&\n        text1.charAt(x1) === text2.charAt(y1)\n      ) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return diff_bisectSplit_(text1, text2, x1, y1);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 === -d || (k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (\n        x2 < text1_length && y2 < text2_length &&\n        text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)\n      ) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return diff_bisectSplit_(text1, text2, x1, y1);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @return {Array} Array of diff tuples.\n */\nfunction diff_bisectSplit_(text1, text2, x, y) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = diff_main(text1a, text2a);\n  var diffsb = diff_main(text1b, text2b);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\nfunction diff_commonPrefix(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (\n      text1.substring(pointerstart, pointermid) ==\n      text2.substring(pointerstart, pointermid)\n    ) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n\n  if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {\n    pointermid--;\n  }\n\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\nfunction diff_commonSuffix(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (\n      text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n      text2.substring(text2.length - pointermid, text2.length - pointerend)\n    ) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n\n  if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {\n    pointermid--;\n  }\n\n  return pointermid;\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n */\nfunction diff_halfMatch_(text1, text2) {\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {\n      var prefixLength = diff_commonPrefix(\n        longtext.substring(i), shorttext.substring(j));\n      var suffixLength = diff_commonSuffix(\n        longtext.substring(0, i), shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(\n          j - suffixLength, j) + shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [\n        best_longtext_a, best_longtext_b,\n        best_shorttext_a, best_shorttext_b, best_common\n      ];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {Array} diffs Array of diff tuples.\n * @param {boolean} fix_unicode Whether to normalize to a unicode-correct diff\n */\nfunction diff_cleanupMerge(diffs, fix_unicode) {\n  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    if (pointer < diffs.length - 1 && !diffs[pointer][1]) {\n      diffs.splice(pointer, 1);\n      continue;\n    }\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        var previous_equality = pointer - count_insert - count_delete - 1;\n        if (fix_unicode) {\n          // prevent splitting of unicode surrogate pairs.  when fix_unicode is true,\n          // we assume that the old and new text in the diff are complete and correct\n          // unicode-encoded JS strings, but the tuple boundaries may fall between\n          // surrogate pairs.  we fix this by shaving off stray surrogates from the end\n          // of the previous equality and the beginning of this equality.  this may create\n          // empty equalities or a common prefix or suffix.  for example, if AB and AC are\n          // emojis, `[[0, 'A'], [-1, 'BA'], [0, 'C']]` would turn into deleting 'ABAC' and\n          // inserting 'AC', and then the common suffix 'AC' will be eliminated.  in this\n          // particular case, both equalities go away, we absorb any previous inequalities,\n          // and we keep scanning for the next equality before rewriting the tuples.\n          if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {\n            var stray = diffs[previous_equality][1].slice(-1);\n            diffs[previous_equality][1] = diffs[previous_equality][1].slice(0, -1);\n            text_delete = stray + text_delete;\n            text_insert = stray + text_insert;\n            if (!diffs[previous_equality][1]) {\n              // emptied out previous equality, so delete it and include previous delete/insert\n              diffs.splice(previous_equality, 1);\n              pointer--;\n              var k = previous_equality - 1;\n              if (diffs[k] && diffs[k][0] === DIFF_INSERT) {\n                count_insert++;\n                text_insert = diffs[k][1] + text_insert;\n                k--;\n              }\n              if (diffs[k] && diffs[k][0] === DIFF_DELETE) {\n                count_delete++;\n                text_delete = diffs[k][1] + text_delete;\n                k--;\n              }\n              previous_equality = k;\n            }\n          }\n          if (starts_with_pair_end(diffs[pointer][1])) {\n            var stray = diffs[pointer][1].charAt(0);\n            diffs[pointer][1] = diffs[pointer][1].slice(1);\n            text_delete += stray;\n            text_insert += stray;\n          }\n        }\n        if (pointer < diffs.length - 1 && !diffs[pointer][1]) {\n          // for empty equality not at end, wait for next equality\n          diffs.splice(pointer, 1);\n          break;\n        }\n        if (text_delete.length > 0 || text_insert.length > 0) {\n          // note that diff_commonPrefix and diff_commonSuffix are unicode-aware\n          if (text_delete.length > 0 && text_insert.length > 0) {\n            // Factor out any common prefixes.\n            commonlength = diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if (previous_equality >= 0) {\n                diffs[previous_equality][1] += text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixes.\n            commonlength = diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] =\n                text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length - commonlength);\n              text_delete = text_delete.substring(0, text_delete.length - commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          var n = count_insert + count_delete;\n          if (text_delete.length === 0 && text_insert.length === 0) {\n            diffs.splice(pointer - n, n);\n            pointer = pointer - n;\n          } else if (text_delete.length === 0) {\n            diffs.splice(pointer - n, n, [DIFF_INSERT, text_insert]);\n            pointer = pointer - n + 1;\n          } else if (text_insert.length === 0) {\n            diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete]);\n            pointer = pointer - n + 1;\n          } else {\n            diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);\n            pointer = pointer - n + 2;\n          }\n        }\n        if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL &&\n      diffs[pointer + 1][0] === DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n        diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n          diffs[pointer][1].substring(0, diffs[pointer][1].length -\n            diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n        diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n          diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n          diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    diff_cleanupMerge(diffs, fix_unicode);\n  }\n};\n\nfunction is_surrogate_pair_start(charCode) {\n  return charCode >= 0xD800 && charCode <= 0xDBFF;\n}\n\nfunction is_surrogate_pair_end(charCode) {\n  return charCode >= 0xDC00 && charCode <= 0xDFFF;\n}\n\nfunction starts_with_pair_end(str) {\n  return is_surrogate_pair_end(str.charCodeAt(0));\n}\n\nfunction ends_with_pair_start(str) {\n  return is_surrogate_pair_start(str.charCodeAt(str.length - 1));\n}\n\nfunction remove_empty_tuples(tuples) {\n  var ret = [];\n  for (var i = 0; i < tuples.length; i++) {\n    if (tuples[i][1].length > 0) {\n      ret.push(tuples[i]);\n    }\n  }\n  return ret;\n}\n\nfunction make_edit_splice(before, oldMiddle, newMiddle, after) {\n  if (ends_with_pair_start(before) || starts_with_pair_end(after)) {\n    return null;\n  }\n  return remove_empty_tuples([\n    [DIFF_EQUAL, before],\n    [DIFF_DELETE, oldMiddle],\n    [DIFF_INSERT, newMiddle],\n    [DIFF_EQUAL, after]\n  ]);\n}\n\nfunction find_cursor_edit_diff(oldText, newText, cursor_pos) {\n  // note: this runs after equality check has ruled out exact equality\n  var oldRange = typeof cursor_pos === 'number' ?\n    { index: cursor_pos, length: 0 } : cursor_pos.oldRange;\n  var newRange = typeof cursor_pos === 'number' ?\n    null : cursor_pos.newRange;\n  // take into account the old and new selection to generate the best diff\n  // possible for a text edit.  for example, a text change from \"xxx\" to \"xx\"\n  // could be a delete or forwards-delete of any one of the x's, or the\n  // result of selecting two of the x's and typing \"x\".\n  var oldLength = oldText.length;\n  var newLength = newText.length;\n  if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {\n    // see if we have an insert or delete before or after cursor\n    var oldCursor = oldRange.index;\n    var oldBefore = oldText.slice(0, oldCursor);\n    var oldAfter = oldText.slice(oldCursor);\n    var maybeNewCursor = newRange ? newRange.index : null;\n    editBefore: {\n      // is this an insert or delete right before oldCursor?\n      var newCursor = oldCursor + newLength - oldLength;\n      if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {\n        break editBefore;\n      }\n      if (newCursor < 0 || newCursor > newLength) {\n        break editBefore;\n      }\n      var newBefore = newText.slice(0, newCursor);\n      var newAfter = newText.slice(newCursor);\n      if (newAfter !== oldAfter) {\n        break editBefore;\n      }\n      var prefixLength = Math.min(oldCursor, newCursor);\n      var oldPrefix = oldBefore.slice(0, prefixLength);\n      var newPrefix = newBefore.slice(0, prefixLength);\n      if (oldPrefix !== newPrefix) {\n        break editBefore;\n      }\n      var oldMiddle = oldBefore.slice(prefixLength);\n      var newMiddle = newBefore.slice(prefixLength);\n      return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);\n    }\n    editAfter: {\n      // is this an insert or delete right after oldCursor?\n      if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {\n        break editAfter;\n      }\n      var cursor = oldCursor;\n      var newBefore = newText.slice(0, cursor);\n      var newAfter = newText.slice(cursor);\n      if (newBefore !== oldBefore) {\n        break editAfter;\n      }\n      var suffixLength = Math.min(oldLength - cursor, newLength - cursor);\n      var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);\n      var newSuffix = newAfter.slice(newAfter.length - suffixLength);\n      if (oldSuffix !== newSuffix) {\n        break editAfter;\n      }\n      var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);\n      var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);\n      return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);\n    }\n  }\n  if (oldRange.length > 0 && newRange && newRange.length === 0) {\n    replaceRange: {\n      // see if diff could be a splice of the old selection range\n      var oldPrefix = oldText.slice(0, oldRange.index);\n      var oldSuffix = oldText.slice(oldRange.index + oldRange.length);\n      var prefixLength = oldPrefix.length;\n      var suffixLength = oldSuffix.length;\n      if (newLength < prefixLength + suffixLength) {\n        break replaceRange;\n      }\n      var newPrefix = newText.slice(0, prefixLength);\n      var newSuffix = newText.slice(newLength - suffixLength);\n      if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {\n        break replaceRange;\n      }\n      var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);\n      var newMiddle = newText.slice(prefixLength, newLength - suffixLength);\n      return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);\n    }\n  }\n\n  return null;\n}\n\nfunction diff(text1, text2, cursor_pos) {\n  // only pass fix_unicode=true at the top level, not when diff_main is\n  // recursively invoked\n  return diff_main(text1, text2, cursor_pos, true);\n}\n\ndiff.INSERT = DIFF_INSERT;\ndiff.DELETE = DIFF_DELETE;\ndiff.EQUAL = DIFF_EQUAL;\n\nmodule.exports = diff;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fast-diff/diff.js?");

/***/ }),

/***/ "./node_modules/fb-watchman/index.js":
/*!*******************************************!*\
  !*** ./node_modules/fb-watchman/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* Copyright 2014-present Facebook, Inc.\n * Licensed under the Apache License, Version 2.0 */\n\n\n\nvar net = __webpack_require__(/*! net */ \"net\");\nvar EE = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar util = __webpack_require__(/*! util */ \"util\");\nvar childProcess = __webpack_require__(/*! child_process */ \"child_process\");\nvar bser = __webpack_require__(/*! bser */ \"./node_modules/bser/index.js\");\n\n// We'll emit the responses to these when they get sent down to us\nvar unilateralTags = ['subscription', 'log'];\n\n/**\n * @param options An object with the following optional keys:\n *   * 'watchmanBinaryPath' (string) Absolute path to the watchman binary.\n *     If not provided, the Client locates the binary using the PATH specified\n *     by the node child_process's default env.\n */\nfunction Client(options) {\n  var self = this;\n  EE.call(this);\n\n  this.watchmanBinaryPath = 'watchman';\n  if (options && options.watchmanBinaryPath) {\n    this.watchmanBinaryPath = options.watchmanBinaryPath.trim();\n  };\n  this.commands = [];\n}\nutil.inherits(Client, EE);\n\nmodule.exports.Client = Client;\n\n// Try to send the next queued command, if any\nClient.prototype.sendNextCommand = function() {\n  if (this.currentCommand) {\n    // There's a command pending response, don't send this new one yet\n    return;\n  }\n\n  this.currentCommand = this.commands.shift();\n  if (!this.currentCommand) {\n    // No further commands are queued\n    return;\n  }\n\n  this.socket.write(bser.dumpToBuffer(this.currentCommand.cmd));\n}\n\nClient.prototype.cancelCommands = function(why) {\n  var error = new Error(why);\n\n  // Steal all pending commands before we start cancellation, in\n  // case something decides to schedule more commands\n  var cmds = this.commands;\n  this.commands = [];\n\n  if (this.currentCommand) {\n    cmds.unshift(this.currentCommand);\n    this.currentCommand = null;\n  }\n\n  // Synthesize an error condition for any commands that were queued\n  cmds.forEach(function(cmd) {\n    cmd.cb(error);\n  });\n}\n\nClient.prototype.connect = function() {\n  var self = this;\n\n  function makeSock(sockname) {\n    // bunser will decode the watchman BSER protocol for us\n    self.bunser = new bser.BunserBuf();\n    // For each decoded line:\n    self.bunser.on('value', function(obj) {\n      // Figure out if this is a unliteral response or if it is the\n      // response portion of a request-response sequence.  At the time\n      // of writing, there are only two possible unilateral responses.\n      var unilateral = false;\n      for (var i = 0; i < unilateralTags.length; i++) {\n        var tag = unilateralTags[i];\n        if (tag in obj) {\n          unilateral = tag;\n        }\n      }\n\n      if (unilateral) {\n        self.emit(unilateral, obj);\n      } else if (self.currentCommand) {\n        var cmd = self.currentCommand;\n        self.currentCommand = null;\n        if ('error' in obj) {\n          var error = new Error(obj.error);\n          error.watchmanResponse = obj;\n          cmd.cb(error);\n        } else {\n          cmd.cb(null, obj);\n        }\n      }\n\n      // See if we can dispatch the next queued command, if any\n      self.sendNextCommand();\n    });\n    self.bunser.on('error', function(err) {\n      self.emit('error', err);\n    });\n\n    self.socket = net.createConnection(sockname);\n    self.socket.on('connect', function() {\n      self.connecting = false;\n      self.emit('connect');\n      self.sendNextCommand();\n    });\n    self.socket.on('error', function(err) {\n      self.connecting = false;\n      self.emit('error', err);\n    });\n    self.socket.on('data', function(buf) {\n      if (self.bunser) {\n        self.bunser.append(buf);\n      }\n    });\n    self.socket.on('end', function() {\n      self.socket = null;\n      self.bunser = null;\n      self.cancelCommands('The watchman connection was closed');\n      self.emit('end');\n    });\n  }\n\n  // triggers will export the sock path to the environment.\n  // If we're invoked in such a way, we can simply pick up the\n  // definition from the environment and avoid having to fork off\n  // a process to figure it out\n  if (process.env.WATCHMAN_SOCK) {\n    makeSock(process.env.WATCHMAN_SOCK);\n    return;\n  }\n\n  // We need to ask the client binary where to find it.\n  // This will cause the service to start for us if it isn't\n  // already running.\n  var args = ['--no-pretty', 'get-sockname'];\n\n  // We use the more elaborate spawn rather than exec because there\n  // are some error cases on Windows where process spawning can hang.\n  // It is desirable to pipe stderr directly to stderr live so that\n  // we can discover the problem.\n  var proc = null;\n  var spawnFailed = false;\n\n  function spawnError(error) {\n    if (spawnFailed) {\n      // For ENOENT, proc 'close' will also trigger with a negative code,\n      // let's suppress that second error.\n      return;\n    }\n    spawnFailed = true;\n    if (error.errno === 'EACCES') {\n      error.message = 'The Watchman CLI is installed but cannot ' +\n                      'be spawned because of a permission problem';\n    } else if (error.errno === 'ENOENT') {\n      error.message = 'Watchman was not found in PATH.  See ' +\n          'https://facebook.github.io/watchman/docs/install.html ' +\n          'for installation instructions';\n    }\n    console.error('Watchman: ', error.message);\n    self.emit('error', error);\n  }\n\n  try {\n    proc = childProcess.spawn(this.watchmanBinaryPath, args, {\n      stdio: ['ignore', 'pipe', 'pipe']\n    });\n  } catch (error) {\n    spawnError(error);\n    return;\n  }\n\n  var stdout = [];\n  var stderr = [];\n  proc.stdout.on('data', function(data) {\n    stdout.push(data);\n  });\n  proc.stderr.on('data', function(data) {\n    data = data.toString('utf8');\n    stderr.push(data);\n    console.error(data);\n  });\n  proc.on('error', function(error) {\n    spawnError(error);\n  });\n\n  proc.on('close', function (code, signal) {\n    if (code !== 0) {\n      spawnError(new Error(\n          self.watchmanBinaryPath + ' ' + args.join(' ') +\n          ' returned with exit code=' + code + ', signal=' +\n          signal + ', stderr= ' + stderr.join('')));\n      return;\n    }\n    try {\n      var obj = JSON.parse(stdout.join(''));\n      if ('error' in obj) {\n        var error = new Error(obj.error);\n        error.watchmanResponse = obj;\n        self.emit('error', error);\n        return;\n      }\n      makeSock(obj.sockname);\n    } catch (e) {\n      self.emit('error', e);\n    }\n  });\n}\n\nClient.prototype.command = function(args, done) {\n  done = done || function() {};\n\n  // Queue up the command\n  this.commands.push({cmd: args, cb: done});\n\n  // Establish a connection if we don't already have one\n  if (!this.socket) {\n    if (!this.connecting) {\n      this.connecting = true;\n      this.connect();\n      return;\n    }\n    return;\n  }\n\n  // If we're already connected and idle, try sending the command immediately\n  this.sendNextCommand();\n}\n\nvar cap_versions = {\n    \"cmd-watch-del-all\": \"3.1.1\",\n    \"cmd-watch-project\": \"3.1\",\n    \"relative_root\": \"3.3\",\n    \"term-dirname\": \"3.1\",\n    \"term-idirname\": \"3.1\",\n    \"wildmatch\": \"3.7\",\n}\n\n// Compares a vs b, returns < 0 if a < b, > 0 if b > b, 0 if a == b\nfunction vers_compare(a, b) {\n  a = a.split('.');\n  b = b.split('.');\n  for (var i = 0; i < 3; i++) {\n    var d = parseInt(a[i] || '0') - parseInt(b[i] || '0');\n    if (d != 0) {\n      return d;\n    }\n  }\n  return 0; // Equal\n}\n\nfunction have_cap(vers, name) {\n  if (name in cap_versions) {\n    return vers_compare(vers, cap_versions[name]) >= 0;\n  }\n  return false;\n}\n\n// This is a helper that we expose for testing purposes\nClient.prototype._synthesizeCapabilityCheck = function(\n    resp, optional, required) {\n  resp.capabilities = {}\n  var version = resp.version;\n  optional.forEach(function (name) {\n    resp.capabilities[name] = have_cap(version, name);\n  });\n  required.forEach(function (name) {\n    var have = have_cap(version, name);\n    resp.capabilities[name] = have;\n    if (!have) {\n      resp.error = 'client required capability `' + name +\n                   '` is not supported by this server';\n    }\n  });\n  return resp;\n}\n\nClient.prototype.capabilityCheck = function(caps, done) {\n  var optional = caps.optional || [];\n  var required = caps.required || [];\n  var self = this;\n  this.command(['version', {\n      optional: optional,\n      required: required\n  }], function (error, resp) {\n    if (error) {\n      done(error);\n      return;\n    }\n    if (!('capabilities' in resp)) {\n      // Server doesn't support capabilities, so we need to\n      // synthesize the results based on the version\n      resp = self._synthesizeCapabilityCheck(resp, optional, required);\n      if (resp.error) {\n        error = new Error(resp.error);\n        error.watchmanResponse = resp;\n        done(error);\n        return;\n      }\n    }\n    done(null, resp);\n  });\n}\n\n// Close the connection to the service\nClient.prototype.end = function() {\n  this.cancelCommands('The client was ended');\n  if (this.socket) {\n    this.socket.end();\n    this.socket = null;\n  }\n  this.bunser = null;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fb-watchman/index.js?");

/***/ }),

/***/ "./node_modules/flatted/esm/index.js":
/*!*******************************************!*\
  !*** ./node_modules/flatted/esm/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__,\n/* harmony export */   \"parse\": () => /* binding */ parse,\n/* harmony export */   \"stringify\": () => /* binding */ stringify\n/* harmony export */ });\nvar Flatted = (function (Primitive, primitive) {\n\n  /*!\n   * ISC License\n   *\n   * Copyright (c) 2018, Andrea Giammarchi, @WebReflection\n   *\n   * Permission to use, copy, modify, and/or distribute this software for any\n   * purpose with or without fee is hereby granted, provided that the above\n   * copyright notice and this permission notice appear in all copies.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n   * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n   * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n   * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n   * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n   * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n   * PERFORMANCE OF THIS SOFTWARE.\n   */\n\n  var Flatted = {\n\n    parse: function parse(text, reviver) {\n      var input = JSON.parse(text, Primitives).map(primitives);\n      var value = input[0];\n      var $ = reviver || noop;\n      var tmp = typeof value === 'object' && value ?\n                  revive(input, new Set, value, $) :\n                  value;\n      return $.call({'': tmp}, '', tmp);\n    },\n\n    stringify: function stringify(value, replacer, space) {\n      for (var\n        firstRun,\n        known = new Map,\n        input = [],\n        output = [],\n        $ = replacer && typeof replacer === typeof input ?\n              function (k, v) {\n                if (k === '' || -1 < replacer.indexOf(k)) return v;\n              } :\n              (replacer || noop),\n        i = +set(known, input, $.call({'': value}, '', value)),\n        replace = function (key, value) {\n          if (firstRun) {\n            firstRun = !firstRun;\n            return value;\n          }\n          var after = $.call(this, key, value);\n          switch (typeof after) {\n            case 'object':\n              if (after === null) return after;\n            case primitive:\n              return known.get(after) || set(known, input, after);\n          }\n          return after;\n        };\n        i < input.length; i++\n      ) {\n        firstRun = true;\n        output[i] = JSON.stringify(input[i], replace, space);\n      }\n      return '[' + output.join(',') + ']';\n    }\n\n  };\n\n  return Flatted;\n\n  function noop(key, value) {\n    return value;\n  }\n\n  function revive(input, parsed, output, $) {\n    return Object.keys(output).reduce(\n      function (output, key) {\n        var value = output[key];\n        if (value instanceof Primitive) {\n          var tmp = input[value];\n          if (typeof tmp === 'object' && !parsed.has(tmp)) {\n            parsed.add(tmp);\n            output[key] = $.call(output, key, revive(input, parsed, tmp, $));\n          } else {\n            output[key] = $.call(output, key, tmp);\n          }\n        } else\n          output[key] = $.call(output, key, value);\n        return output;\n      },\n      output\n    );\n  }\n\n  function set(known, input, value) {\n    var index = Primitive(input.push(value) - 1);\n    known.set(value, index);\n    return index;\n  }\n\n  // the two kinds of primitives\n  //  1. the real one\n  //  2. the wrapped one\n\n  function primitives(value) {\n    return value instanceof Primitive ? Primitive(value) : value;\n  }\n\n  function Primitives(key, value) {\n    return typeof value === primitive ? new Primitive(value) : value;\n  }\n\n}(String, 'string'));\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Flatted);\nvar parse = Flatted.parse;\nvar stringify = Flatted.stringify;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/flatted/esm/index.js?");

/***/ }),

/***/ "./node_modules/follow-redirects/debug.js":
/*!************************************************!*\
  !*** ./node_modules/follow-redirects/debug.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var debug;\ntry {\n  /* eslint global-require: off */\n  debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")(\"follow-redirects\");\n}\ncatch (error) {\n  debug = function () { /* */ };\n}\nmodule.exports = debug;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/follow-redirects/debug.js?");

/***/ }),

/***/ "./node_modules/follow-redirects/index.js":
/*!************************************************!*\
  !*** ./node_modules/follow-redirects/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var url = __webpack_require__(/*! url */ \"url\");\nvar URL = url.URL;\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar Writable = __webpack_require__(/*! stream */ \"stream\").Writable;\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar debug = __webpack_require__(/*! ./debug */ \"./node_modules/follow-redirects/debug.js\");\n\n// Create handlers that pass events from native requests\nvar eventHandlers = Object.create(null);\n[\"abort\", \"aborted\", \"connect\", \"error\", \"socket\", \"timeout\"].forEach(function (event) {\n  eventHandlers[event] = function (arg1, arg2, arg3) {\n    this._redirectable.emit(event, arg1, arg2, arg3);\n  };\n});\n\n// Error types with codes\nvar RedirectionError = createErrorType(\n  \"ERR_FR_REDIRECTION_FAILURE\",\n  \"\"\n);\nvar TooManyRedirectsError = createErrorType(\n  \"ERR_FR_TOO_MANY_REDIRECTS\",\n  \"Maximum number of redirects exceeded\"\n);\nvar MaxBodyLengthExceededError = createErrorType(\n  \"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\",\n  \"Request body larger than maxBodyLength limit\"\n);\nvar WriteAfterEndError = createErrorType(\n  \"ERR_STREAM_WRITE_AFTER_END\",\n  \"write after end\"\n);\n\n// An HTTP(S) request that can be redirected\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n  this._sanitizeOptions(options);\n  this._options = options;\n  this._ended = false;\n  this._ending = false;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = [];\n\n  // Attach a callback if passed\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  }\n\n  // React to responses of native requests\n  var self = this;\n  this._onNativeResponse = function (response) {\n    self._processResponse(response);\n  };\n\n  // Perform the first request\n  this._performRequest();\n}\nRedirectableRequest.prototype = Object.create(Writable.prototype);\n\n// Writes buffered data to the current native request\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Writing is not allowed if end has been called\n  if (this._ending) {\n    throw new WriteAfterEndError();\n  }\n\n  // Validate input and shift parameters if necessary\n  if (!(typeof data === \"string\" || typeof data === \"object\" && (\"length\" in data))) {\n    throw new TypeError(\"data should be a string, Buffer or Uint8Array\");\n  }\n  if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Ignore empty buffers, since writing them doesn't invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n    return;\n  }\n  // Only write when we don't exceed the maximum body length\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\n    this._currentRequest.write(data, encoding, callback);\n  }\n  // Error when we exceed the maximum body length\n  else {\n    this.emit(\"error\", new MaxBodyLengthExceededError());\n    this.abort();\n  }\n};\n\n// Ends the current native request\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (typeof data === \"function\") {\n    callback = data;\n    data = encoding = null;\n  }\n  else if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Write data if needed and end\n  if (!data) {\n    this._ended = this._ending = true;\n    this._currentRequest.end(null, null, callback);\n  }\n  else {\n    var self = this;\n    var currentRequest = this._currentRequest;\n    this.write(data, encoding, function () {\n      self._ended = true;\n      currentRequest.end(null, null, callback);\n    });\n    this._ending = true;\n  }\n};\n\n// Sets a header value on the current native request\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n  this._currentRequest.setHeader(name, value);\n};\n\n// Clears a header value on the current native request\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n  this._currentRequest.removeHeader(name);\n};\n\n// Global timeout for all underlying requests\nRedirectableRequest.prototype.setTimeout = function (msecs, callback) {\n  if (callback) {\n    this.once(\"timeout\", callback);\n  }\n\n  if (this.socket) {\n    startTimer(this, msecs);\n  }\n  else {\n    var self = this;\n    this._currentRequest.once(\"socket\", function () {\n      startTimer(self, msecs);\n    });\n  }\n\n  this.once(\"response\", clearTimer);\n  this.once(\"error\", clearTimer);\n\n  return this;\n};\n\nfunction startTimer(request, msecs) {\n  clearTimeout(request._timeout);\n  request._timeout = setTimeout(function () {\n    request.emit(\"timeout\");\n  }, msecs);\n}\n\nfunction clearTimer() {\n  clearTimeout(this._timeout);\n}\n\n// Proxy all other public ClientRequest methods\n[\n  \"abort\", \"flushHeaders\", \"getHeader\",\n  \"setNoDelay\", \"setSocketKeepAlive\",\n].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n});\n\n// Proxy all public ClientRequest properties\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () { return this._currentRequest[property]; },\n  });\n});\n\nRedirectableRequest.prototype._sanitizeOptions = function (options) {\n  // Ensure headers are always present\n  if (!options.headers) {\n    options.headers = {};\n  }\n\n  // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n    delete options.host;\n  }\n\n  // Complete the URL object when necessary\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    }\n    else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  }\n};\n\n\n// Executes the next native request (initial or redirect)\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n  if (!nativeProtocol) {\n    this.emit(\"error\", new TypeError(\"Unsupported protocol \" + protocol));\n    return;\n  }\n\n  // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n  if (this._options.agents) {\n    var scheme = protocol.substr(0, protocol.length - 1);\n    this._options.agent = this._options.agents[scheme];\n  }\n\n  // Create the native request\n  var request = this._currentRequest =\n        nativeProtocol.request(this._options, this._onNativeResponse);\n  this._currentUrl = url.format(this._options);\n\n  // Set up event handlers\n  request._redirectable = this;\n  for (var event in eventHandlers) {\n    /* istanbul ignore else */\n    if (event) {\n      request.on(event, eventHandlers[event]);\n    }\n  }\n\n  // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n  if (this._isRedirect) {\n    // Write the request entity and end.\n    var i = 0;\n    var self = this;\n    var buffers = this._requestBodyBuffers;\n    (function writeNext(error) {\n      // Only write if this request has not been redirected yet\n      /* istanbul ignore else */\n      if (request === self._currentRequest) {\n        // Report any write errors\n        /* istanbul ignore if */\n        if (error) {\n          self.emit(\"error\", error);\n        }\n        // Write the next buffer if there are still left\n        else if (i < buffers.length) {\n          var buffer = buffers[i++];\n          /* istanbul ignore else */\n          if (!request.finished) {\n            request.write(buffer.data, buffer.encoding, writeNext);\n          }\n        }\n        // End the request if `end` has been called on us\n        else if (self._ended) {\n          request.end();\n        }\n      }\n    }());\n  }\n};\n\n// Processes a response from the current native request\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  var statusCode = response.statusCode;\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: statusCode,\n    });\n  }\n\n  // RFC72316.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n  var location = response.headers.location;\n  if (location && this._options.followRedirects !== false &&\n      statusCode >= 300 && statusCode < 400) {\n    // Abort the current request\n    this._currentRequest.removeAllListeners();\n    this._currentRequest.on(\"error\", noop);\n    this._currentRequest.abort();\n    // Discard the remainder of the response to avoid waiting for data\n    response.destroy();\n\n    // RFC72316.4: A client SHOULD detect and intervene\n    // in cyclical redirections (i.e., \"infinite\" redirection loops).\n    if (++this._redirectCount > this._options.maxRedirects) {\n      this.emit(\"error\", new TooManyRedirectsError());\n      return;\n    }\n\n    // RFC72316.4: Automatic redirection needs to done with\n    // care for methods not known to be safe, []\n    // RFC72316.4.23: For historical reasons, a user agent MAY change\n    // the request method from POST to GET for the subsequent request.\n    if ((statusCode === 301 || statusCode === 302) && this._options.method === \"POST\" ||\n        // RFC72316.4.4: The 303 (See Other) status code indicates that\n        // the server is redirecting the user agent to a different resource []\n        // A user agent can perform a retrieval request targeting that URI\n        // (a GET or HEAD request if using HTTP) []\n        (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {\n      this._options.method = \"GET\";\n      // Drop a possible entity and headers related to it\n      this._requestBodyBuffers = [];\n      removeMatchingHeaders(/^content-/i, this._options.headers);\n    }\n\n    // Drop the Host header, as the redirect might lead to a different host\n    var previousHostName = removeMatchingHeaders(/^host$/i, this._options.headers) ||\n      url.parse(this._currentUrl).hostname;\n\n    // Create the redirected request\n    var redirectUrl = url.resolve(this._currentUrl, location);\n    debug(\"redirecting to\", redirectUrl);\n    this._isRedirect = true;\n    var redirectUrlParts = url.parse(redirectUrl);\n    Object.assign(this._options, redirectUrlParts);\n\n    // Drop the Authorization header if redirecting to another host\n    if (redirectUrlParts.hostname !== previousHostName) {\n      removeMatchingHeaders(/^authorization$/i, this._options.headers);\n    }\n\n    // Evaluate the beforeRedirect callback\n    if (typeof this._options.beforeRedirect === \"function\") {\n      var responseDetails = { headers: response.headers };\n      try {\n        this._options.beforeRedirect.call(null, this._options, responseDetails);\n      }\n      catch (err) {\n        this.emit(\"error\", err);\n        return;\n      }\n      this._sanitizeOptions(this._options);\n    }\n\n    // Perform the redirected request\n    try {\n      this._performRequest();\n    }\n    catch (cause) {\n      var error = new RedirectionError(\"Redirected request failed: \" + cause.message);\n      error.cause = cause;\n      this.emit(\"error\", error);\n    }\n  }\n  else {\n    // The response is not a redirect; return it as-is\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response);\n\n    // Clean up\n    this._requestBodyBuffers = [];\n  }\n};\n\n// Wraps the key/value object of protocols with redirect functionality\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024,\n  };\n\n  // Wrap each protocol\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\n\n    // Executes a request, following redirects\n    wrappedProtocol.request = function (input, options, callback) {\n      // Parse parameters\n      if (typeof input === \"string\") {\n        var urlStr = input;\n        try {\n          input = urlToOptions(new URL(urlStr));\n        }\n        catch (err) {\n          /* istanbul ignore next */\n          input = url.parse(urlStr);\n        }\n      }\n      else if (URL && (input instanceof URL)) {\n        input = urlToOptions(input);\n      }\n      else {\n        callback = options;\n        options = input;\n        input = { protocol: protocol };\n      }\n      if (typeof options === \"function\") {\n        callback = options;\n        options = null;\n      }\n\n      // Set defaults\n      options = Object.assign({\n        maxRedirects: exports.maxRedirects,\n        maxBodyLength: exports.maxBodyLength,\n      }, input, options);\n      options.nativeProtocols = nativeProtocols;\n\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    };\n\n    // Executes a GET request, following redirects\n    wrappedProtocol.get = function (input, options, callback) {\n      var request = wrappedProtocol.request(input, options, callback);\n      request.end();\n      return request;\n    };\n  });\n  return exports;\n}\n\n/* istanbul ignore next */\nfunction noop() { /* empty */ }\n\n// from https://github.com/nodejs/node/blob/master/lib/internal/url.js\nfunction urlToOptions(urlObject) {\n  var options = {\n    protocol: urlObject.protocol,\n    hostname: urlObject.hostname.startsWith(\"[\") ?\n      /* istanbul ignore next */\n      urlObject.hostname.slice(1, -1) :\n      urlObject.hostname,\n    hash: urlObject.hash,\n    search: urlObject.search,\n    pathname: urlObject.pathname,\n    path: urlObject.pathname + urlObject.search,\n    href: urlObject.href,\n  };\n  if (urlObject.port !== \"\") {\n    options.port = Number(urlObject.port);\n  }\n  return options;\n}\n\nfunction removeMatchingHeaders(regex, headers) {\n  var lastValue;\n  for (var header in headers) {\n    if (regex.test(header)) {\n      lastValue = headers[header];\n      delete headers[header];\n    }\n  }\n  return lastValue;\n}\n\nfunction createErrorType(code, defaultMessage) {\n  function CustomError(message) {\n    Error.captureStackTrace(this, this.constructor);\n    this.message = message || defaultMessage;\n  }\n  CustomError.prototype = new Error();\n  CustomError.prototype.constructor = CustomError;\n  CustomError.prototype.name = \"Error [\" + code + \"]\";\n  CustomError.prototype.code = code;\n  return CustomError;\n}\n\n// Exports\nmodule.exports = wrap({ http: http, https: https });\nmodule.exports.wrap = wrap;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/follow-redirects/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/copy-sync/copy-sync.js":
/*!**********************************************************!*\
  !*** ./node_modules/fs-extra/lib/copy-sync/copy-sync.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdirsSync = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\").mkdirsSync\nconst utimesMillisSync = __webpack_require__(/*! ../util/utimes */ \"./node_modules/fs-extra/lib/util/utimes.js\").utimesMillisSync\nconst stat = __webpack_require__(/*! ../util/stat */ \"./node_modules/fs-extra/lib/util/stat.js\")\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy')\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy')\n  return handleFilterAndCopy(destStat, src, dest, opts)\n}\n\nfunction handleFilterAndCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirsSync(destParent)\n  return startCopy(destStat, src, dest, opts)\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  fs.copyFileSync(src, dest)\n  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest)\n  return setDestMode(dest, srcStat.mode)\n}\n\nfunction handleTimestamps (srcMode, src, dest) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode)\n  return setDestTimestamps(src, dest)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200)\n}\n\nfunction setDestMode (dest, srcMode) {\n  return fs.chmodSync(dest, srcMode)\n}\n\nfunction setDestTimestamps (src, dest) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  const updatedSrcStat = fs.statSync(src)\n  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts)\n  if (destStat && !destStat.isDirectory()) {\n    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n  }\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcMode, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return setDestMode(dest, srcMode)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy')\n  return startCopy(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\nmodule.exports = copySync\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/copy-sync/copy-sync.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/copy-sync/index.js":
/*!******************************************************!*\
  !*** ./node_modules/fs-extra/lib/copy-sync/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = {\n  copySync: __webpack_require__(/*! ./copy-sync */ \"./node_modules/fs-extra/lib/copy-sync/copy-sync.js\")\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/copy-sync/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/copy/copy.js":
/*!************************************************!*\
  !*** ./node_modules/fs-extra/lib/copy/copy.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdirs = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\").mkdirs\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists\nconst utimesMillis = __webpack_require__(/*! ../util/utimes */ \"./node_modules/fs-extra/lib/util/utimes.js\").utimesMillis\nconst stat = __webpack_require__(/*! ../util/stat */ \"./node_modules/fs-extra/lib/util/stat.js\")\n\nfunction copy (src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts\n    opts = {}\n  } else if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  cb = cb || function () {}\n  opts = opts || {}\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  stat.checkPaths(src, dest, 'copy', (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'copy', err => {\n      if (err) return cb(err)\n      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)\n      return checkParentDir(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction checkParentDir (destStat, src, dest, opts, cb) {\n  const destParent = path.dirname(dest)\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err)\n    if (dirExists) return startCopy(destStat, src, dest, opts, cb)\n    mkdirs(destParent, err => {\n      if (err) return cb(err)\n      return startCopy(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction handleFilter (onInclude, destStat, src, dest, opts, cb) {\n  Promise.resolve(opts.filter(src, dest)).then(include => {\n    if (include) return onInclude(destStat, src, dest, opts, cb)\n    return cb()\n  }, error => cb(error))\n}\n\nfunction startCopy (destStat, src, dest, opts, cb) {\n  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)\n  return getStats(destStat, src, dest, opts, cb)\n}\n\nfunction getStats (destStat, src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat\n  stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isFile() ||\n             srcStat.isCharacterDevice() ||\n             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)\n  })\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)\n  return mayCopyFile(srcStat, src, dest, opts, cb)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err)\n      return copyFile(srcStat, src, dest, opts, cb)\n    })\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`))\n  } else return cb()\n}\n\nfunction copyFile (srcStat, src, dest, opts, cb) {\n  fs.copyFile(src, dest, err => {\n    if (err) return cb(err)\n    if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src, dest, cb)\n    return setDestMode(dest, srcStat.mode, cb)\n  })\n}\n\nfunction handleTimestampsAndMode (srcMode, src, dest, cb) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) {\n    return makeFileWritable(dest, srcMode, err => {\n      if (err) return cb(err)\n      return setDestTimestampsAndMode(srcMode, src, dest, cb)\n    })\n  }\n  return setDestTimestampsAndMode(srcMode, src, dest, cb)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode, cb) {\n  return setDestMode(dest, srcMode | 0o200, cb)\n}\n\nfunction setDestTimestampsAndMode (srcMode, src, dest, cb) {\n  setDestTimestamps(src, dest, err => {\n    if (err) return cb(err)\n    return setDestMode(dest, srcMode, cb)\n  })\n}\n\nfunction setDestMode (dest, srcMode, cb) {\n  return fs.chmod(dest, srcMode, cb)\n}\n\nfunction setDestTimestamps (src, dest, cb) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  fs.stat(src, (err, updatedSrcStat) => {\n    if (err) return cb(err)\n    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb)\n  })\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts, cb)\n  if (destStat && !destStat.isDirectory()) {\n    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n  }\n  return copyDir(src, dest, opts, cb)\n}\n\nfunction mkDirAndCopy (srcMode, src, dest, opts, cb) {\n  fs.mkdir(dest, err => {\n    if (err) return cb(err)\n    copyDir(src, dest, opts, err => {\n      if (err) return cb(err)\n      return setDestMode(dest, srcMode, cb)\n    })\n  })\n}\n\nfunction copyDir (src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err)\n    return copyDirItems(items, src, dest, opts, cb)\n  })\n}\n\nfunction copyDirItems (items, src, dest, opts, cb) {\n  const item = items.pop()\n  if (!item) return cb()\n  return copyDirItem(items, item, src, dest, opts, cb)\n}\n\nfunction copyDirItem (items, item, src, dest, opts, cb) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  stat.checkPaths(srcItem, destItem, 'copy', (err, stats) => {\n    if (err) return cb(err)\n    const { destStat } = stats\n    startCopy(destStat, srcItem, destItem, opts, err => {\n      if (err) return cb(err)\n      return copyDirItems(items, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction onLink (destStat, src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrc) => {\n    if (err) return cb(err)\n    if (opts.dereference) {\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n    }\n\n    if (!destStat) {\n      return fs.symlink(resolvedSrc, dest, cb)\n    } else {\n      fs.readlink(dest, (err, resolvedDest) => {\n        if (err) {\n          // dest exists and is a regular file or directory,\n          // Windows may throw UNKNOWN error. If dest already exists,\n          // fs throws error anyway, so no need to guard against it here.\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)\n          return cb(err)\n        }\n        if (opts.dereference) {\n          resolvedDest = path.resolve(process.cwd(), resolvedDest)\n        }\n        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))\n        }\n\n        // do not copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n        if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))\n        }\n        return copyLink(resolvedSrc, dest, cb)\n      })\n    }\n  })\n}\n\nfunction copyLink (resolvedSrc, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err)\n    return fs.symlink(resolvedSrc, dest, cb)\n  })\n}\n\nmodule.exports = copy\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/copy/copy.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/copy/index.js":
/*!*************************************************!*\
  !*** ./node_modules/fs-extra/lib/copy/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nmodule.exports = {\n  copy: u(__webpack_require__(/*! ./copy */ \"./node_modules/fs-extra/lib/copy/copy.js\"))\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/copy/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/empty/index.js":
/*!**************************************************!*\
  !*** ./node_modules/fs-extra/lib/empty/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\")\nconst remove = __webpack_require__(/*! ../remove */ \"./node_modules/fs-extra/lib/remove/index.js\")\n\nconst emptyDir = u(function emptyDir (dir, callback) {\n  callback = callback || function () {}\n  fs.readdir(dir, (err, items) => {\n    if (err) return mkdir.mkdirs(dir, callback)\n\n    items = items.map(item => path.join(dir, item))\n\n    deleteItem()\n\n    function deleteItem () {\n      const item = items.pop()\n      if (!item) return callback()\n      remove.remove(item, err => {\n        if (err) return callback(err)\n        deleteItem()\n      })\n    }\n  })\n})\n\nfunction emptyDirSync (dir) {\n  let items\n  try {\n    items = fs.readdirSync(dir)\n  } catch {\n    return mkdir.mkdirsSync(dir)\n  }\n\n  items.forEach(item => {\n    item = path.join(dir, item)\n    remove.removeSync(item)\n  })\n}\n\nmodule.exports = {\n  emptyDirSync,\n  emptydirSync: emptyDirSync,\n  emptyDir,\n  emptydir: emptyDir\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/empty/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/file.js":
/*!**************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/file.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\")\n\nfunction createFile (file, callback) {\n  function makeFile () {\n    fs.writeFile(file, '', err => {\n      if (err) return callback(err)\n      callback()\n    })\n  }\n\n  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err\n    if (!err && stats.isFile()) return callback()\n    const dir = path.dirname(file)\n    fs.stat(dir, (err, stats) => {\n      if (err) {\n        // if the directory doesn't exist, make it\n        if (err.code === 'ENOENT') {\n          return mkdir.mkdirs(dir, err => {\n            if (err) return callback(err)\n            makeFile()\n          })\n        }\n        return callback(err)\n      }\n\n      if (stats.isDirectory()) makeFile()\n      else {\n        // parent is not a directory\n        // This is just to cause an internal ENOTDIR error to be thrown\n        fs.readdir(dir, err => {\n          if (err) return callback(err)\n        })\n      }\n    })\n  })\n}\n\nfunction createFileSync (file) {\n  let stats\n  try {\n    stats = fs.statSync(file)\n  } catch {}\n  if (stats && stats.isFile()) return\n\n  const dir = path.dirname(file)\n  try {\n    if (!fs.statSync(dir).isDirectory()) {\n      // parent is not a directory\n      // This is just to cause an internal ENOTDIR error to be thrown\n      fs.readdirSync(dir)\n    }\n  } catch (err) {\n    // If the stat call above failed because the directory doesn't exist, create it\n    if (err && err.code === 'ENOENT') mkdir.mkdirsSync(dir)\n    else throw err\n  }\n\n  fs.writeFileSync(file, '')\n}\n\nmodule.exports = {\n  createFile: u(createFile),\n  createFileSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/ensure/file.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst file = __webpack_require__(/*! ./file */ \"./node_modules/fs-extra/lib/ensure/file.js\")\nconst link = __webpack_require__(/*! ./link */ \"./node_modules/fs-extra/lib/ensure/link.js\")\nconst symlink = __webpack_require__(/*! ./symlink */ \"./node_modules/fs-extra/lib/ensure/symlink.js\")\n\nmodule.exports = {\n  // file\n  createFile: file.createFile,\n  createFileSync: file.createFileSync,\n  ensureFile: file.createFile,\n  ensureFileSync: file.createFileSync,\n  // link\n  createLink: link.createLink,\n  createLinkSync: link.createLinkSync,\n  ensureLink: link.createLink,\n  ensureLinkSync: link.createLinkSync,\n  // symlink\n  createSymlink: symlink.createSymlink,\n  createSymlinkSync: symlink.createSymlinkSync,\n  ensureSymlink: symlink.createSymlink,\n  ensureSymlinkSync: symlink.createSymlinkSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/ensure/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/link.js":
/*!**************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/link.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\nfunction createLink (srcpath, dstpath, callback) {\n  function makeLink (srcpath, dstpath) {\n    fs.link(srcpath, dstpath, err => {\n      if (err) return callback(err)\n      callback(null)\n    })\n  }\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureLink')\n        return callback(err)\n      }\n\n      const dir = path.dirname(dstpath)\n      pathExists(dir, (err, dirExists) => {\n        if (err) return callback(err)\n        if (dirExists) return makeLink(srcpath, dstpath)\n        mkdir.mkdirs(dir, err => {\n          if (err) return callback(err)\n          makeLink(srcpath, dstpath)\n        })\n      })\n    })\n  })\n}\n\nfunction createLinkSync (srcpath, dstpath) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  try {\n    fs.lstatSync(srcpath)\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  const dir = path.dirname(dstpath)\n  const dirExists = fs.existsSync(dir)\n  if (dirExists) return fs.linkSync(srcpath, dstpath)\n  mkdir.mkdirsSync(dir)\n\n  return fs.linkSync(srcpath, dstpath)\n}\n\nmodule.exports = {\n  createLink: u(createLink),\n  createLinkSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/ensure/link.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/symlink-paths.js":
/*!***********************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/symlink-paths.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nfunction symlinkPaths (srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink')\n        return callback(err)\n      }\n      return callback(null, {\n        toCwd: srcpath,\n        toDst: srcpath\n      })\n    })\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    return pathExists(relativeToDst, (err, exists) => {\n      if (err) return callback(err)\n      if (exists) {\n        return callback(null, {\n          toCwd: relativeToDst,\n          toDst: srcpath\n        })\n      } else {\n        return fs.lstat(srcpath, (err) => {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink')\n            return callback(err)\n          }\n          return callback(null, {\n            toCwd: srcpath,\n            toDst: path.relative(dstdir, srcpath)\n          })\n        })\n      }\n    })\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  let exists\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      toCwd: srcpath,\n      toDst: srcpath\n    }\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    exists = fs.existsSync(relativeToDst)\n    if (exists) {\n      return {\n        toCwd: relativeToDst,\n        toDst: srcpath\n      }\n    } else {\n      exists = fs.existsSync(srcpath)\n      if (!exists) throw new Error('relative srcpath does not exist')\n      return {\n        toCwd: srcpath,\n        toDst: path.relative(dstdir, srcpath)\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  symlinkPaths,\n  symlinkPathsSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/ensure/symlink-paths.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/symlink-type.js":
/*!**********************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/symlink-type.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\n\nfunction symlinkType (srcpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n  if (type) return callback(null, type)\n  fs.lstat(srcpath, (err, stats) => {\n    if (err) return callback(null, 'file')\n    type = (stats && stats.isDirectory()) ? 'dir' : 'file'\n    callback(null, type)\n  })\n}\n\nfunction symlinkTypeSync (srcpath, type) {\n  let stats\n\n  if (type) return type\n  try {\n    stats = fs.lstatSync(srcpath)\n  } catch {\n    return 'file'\n  }\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nmodule.exports = {\n  symlinkType,\n  symlinkTypeSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/ensure/symlink-type.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/symlink.js":
/*!*****************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/symlink.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst _mkdirs = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\")\nconst mkdirs = _mkdirs.mkdirs\nconst mkdirsSync = _mkdirs.mkdirsSync\n\nconst _symlinkPaths = __webpack_require__(/*! ./symlink-paths */ \"./node_modules/fs-extra/lib/ensure/symlink-paths.js\")\nconst symlinkPaths = _symlinkPaths.symlinkPaths\nconst symlinkPathsSync = _symlinkPaths.symlinkPathsSync\n\nconst _symlinkType = __webpack_require__(/*! ./symlink-type */ \"./node_modules/fs-extra/lib/ensure/symlink-type.js\")\nconst symlinkType = _symlinkType.symlinkType\nconst symlinkTypeSync = _symlinkType.symlinkTypeSync\n\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\nfunction createSymlink (srcpath, dstpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    symlinkPaths(srcpath, dstpath, (err, relative) => {\n      if (err) return callback(err)\n      srcpath = relative.toDst\n      symlinkType(relative.toCwd, type, (err, type) => {\n        if (err) return callback(err)\n        const dir = path.dirname(dstpath)\n        pathExists(dir, (err, dirExists) => {\n          if (err) return callback(err)\n          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)\n          mkdirs(dir, err => {\n            if (err) return callback(err)\n            fs.symlink(srcpath, dstpath, type, callback)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction createSymlinkSync (srcpath, dstpath, type) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  const relative = symlinkPathsSync(srcpath, dstpath)\n  srcpath = relative.toDst\n  type = symlinkTypeSync(relative.toCwd, type)\n  const dir = path.dirname(dstpath)\n  const exists = fs.existsSync(dir)\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type)\n  mkdirsSync(dir)\n  return fs.symlinkSync(srcpath, dstpath, type)\n}\n\nmodule.exports = {\n  createSymlink: u(createSymlink),\n  createSymlinkSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/ensure/symlink.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/fs/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fs-extra/lib/fs/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// This is adapted from https://github.com/normalize/mz\n// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\n\nconst api = [\n  'access',\n  'appendFile',\n  'chmod',\n  'chown',\n  'close',\n  'copyFile',\n  'fchmod',\n  'fchown',\n  'fdatasync',\n  'fstat',\n  'fsync',\n  'ftruncate',\n  'futimes',\n  'lchmod',\n  'lchown',\n  'link',\n  'lstat',\n  'mkdir',\n  'mkdtemp',\n  'open',\n  'opendir',\n  'readdir',\n  'readFile',\n  'readlink',\n  'realpath',\n  'rename',\n  'rmdir',\n  'stat',\n  'symlink',\n  'truncate',\n  'unlink',\n  'utimes',\n  'writeFile'\n].filter(key => {\n  // Some commands are not available on some systems. Ex:\n  // fs.opendir was added in Node.js v12.12.0\n  // fs.lchown is not available on at least some Linux\n  return typeof fs[key] === 'function'\n})\n\n// Export all keys:\nObject.keys(fs).forEach(key => {\n  if (key === 'promises') {\n    // fs.promises is a getter property that triggers ExperimentalWarning\n    // Don't re-export it here, the getter is defined in \"lib/index.js\"\n    return\n  }\n  exports[key] = fs[key]\n})\n\n// Universalify async methods:\napi.forEach(method => {\n  exports[method] = u(fs[method])\n})\n\n// We differ from mz/fs in that we still ship the old, broken, fs.exists()\n// since we are a drop-in replacement for the native module\nexports.exists = function (filename, callback) {\n  if (typeof callback === 'function') {\n    return fs.exists(filename, callback)\n  }\n  return new Promise(resolve => {\n    return fs.exists(filename, resolve)\n  })\n}\n\n// fs.read(), fs.write(), & fs.writev() need special treatment due to multiple callback args\n\nexports.read = function (fd, buffer, offset, length, position, callback) {\n  if (typeof callback === 'function') {\n    return fs.read(fd, buffer, offset, length, position, callback)\n  }\n  return new Promise((resolve, reject) => {\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffer })\n    })\n  })\n}\n\n// Function signature can be\n// fs.write(fd, buffer[, offset[, length[, position]]], callback)\n// OR\n// fs.write(fd, string[, position[, encoding]], callback)\n// We need to handle both cases, so we use ...args\nexports.write = function (fd, buffer, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.write(fd, buffer, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffer })\n    })\n  })\n}\n\n// fs.writev only available in Node v12.9.0+\nif (typeof fs.writev === 'function') {\n  // Function signature is\n  // s.writev(fd, buffers[, position], callback)\n  // We need to handle the optional arg, so we use ...args\n  exports.writev = function (fd, buffers, ...args) {\n    if (typeof args[args.length - 1] === 'function') {\n      return fs.writev(fd, buffers, ...args)\n    }\n\n    return new Promise((resolve, reject) => {\n      fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {\n        if (err) return reject(err)\n        resolve({ bytesWritten, buffers })\n      })\n    })\n  }\n}\n\n// fs.realpath.native only available in Node v9.2+\nif (typeof fs.realpath.native === 'function') {\n  exports.realpath.native = u(fs.realpath.native)\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/fs/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/fs-extra/lib/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = {\n  // Export promiseified graceful-fs:\n  ...__webpack_require__(/*! ./fs */ \"./node_modules/fs-extra/lib/fs/index.js\"),\n  // Export extra methods:\n  ...__webpack_require__(/*! ./copy-sync */ \"./node_modules/fs-extra/lib/copy-sync/index.js\"),\n  ...__webpack_require__(/*! ./copy */ \"./node_modules/fs-extra/lib/copy/index.js\"),\n  ...__webpack_require__(/*! ./empty */ \"./node_modules/fs-extra/lib/empty/index.js\"),\n  ...__webpack_require__(/*! ./ensure */ \"./node_modules/fs-extra/lib/ensure/index.js\"),\n  ...__webpack_require__(/*! ./json */ \"./node_modules/fs-extra/lib/json/index.js\"),\n  ...__webpack_require__(/*! ./mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\"),\n  ...__webpack_require__(/*! ./move-sync */ \"./node_modules/fs-extra/lib/move-sync/index.js\"),\n  ...__webpack_require__(/*! ./move */ \"./node_modules/fs-extra/lib/move/index.js\"),\n  ...__webpack_require__(/*! ./output */ \"./node_modules/fs-extra/lib/output/index.js\"),\n  ...__webpack_require__(/*! ./path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\"),\n  ...__webpack_require__(/*! ./remove */ \"./node_modules/fs-extra/lib/remove/index.js\")\n}\n\n// Export fs.promises as a getter property so that we don't trigger\n// ExperimentalWarning before fs.promises is actually accessed.\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nif (Object.getOwnPropertyDescriptor(fs, 'promises')) {\n  Object.defineProperty(module.exports, \"promises\", ({\n    get () { return fs.promises }\n  }))\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/json/index.js":
/*!*************************************************!*\
  !*** ./node_modules/fs-extra/lib/json/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromPromise\nconst jsonFile = __webpack_require__(/*! ./jsonfile */ \"./node_modules/fs-extra/lib/json/jsonfile.js\")\n\njsonFile.outputJson = u(__webpack_require__(/*! ./output-json */ \"./node_modules/fs-extra/lib/json/output-json.js\"))\njsonFile.outputJsonSync = __webpack_require__(/*! ./output-json-sync */ \"./node_modules/fs-extra/lib/json/output-json-sync.js\")\n// aliases\njsonFile.outputJSON = jsonFile.outputJson\njsonFile.outputJSONSync = jsonFile.outputJsonSync\njsonFile.writeJSON = jsonFile.writeJson\njsonFile.writeJSONSync = jsonFile.writeJsonSync\njsonFile.readJSON = jsonFile.readJson\njsonFile.readJSONSync = jsonFile.readJsonSync\n\nmodule.exports = jsonFile\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/json/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/json/jsonfile.js":
/*!****************************************************!*\
  !*** ./node_modules/fs-extra/lib/json/jsonfile.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst jsonFile = __webpack_require__(/*! jsonfile */ \"./node_modules/jsonfile/index.js\")\n\nmodule.exports = {\n  // jsonfile exports\n  readJson: jsonFile.readFile,\n  readJsonSync: jsonFile.readFileSync,\n  writeJson: jsonFile.writeFile,\n  writeJsonSync: jsonFile.writeFileSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/json/jsonfile.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/json/output-json-sync.js":
/*!************************************************************!*\
  !*** ./node_modules/fs-extra/lib/json/output-json-sync.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { stringify } = __webpack_require__(/*! jsonfile/utils */ \"./node_modules/jsonfile/utils.js\")\nconst { outputFileSync } = __webpack_require__(/*! ../output */ \"./node_modules/fs-extra/lib/output/index.js\")\n\nfunction outputJsonSync (file, data, options) {\n  const str = stringify(data, options)\n\n  outputFileSync(file, str, options)\n}\n\nmodule.exports = outputJsonSync\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/json/output-json-sync.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/json/output-json.js":
/*!*******************************************************!*\
  !*** ./node_modules/fs-extra/lib/json/output-json.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { stringify } = __webpack_require__(/*! jsonfile/utils */ \"./node_modules/jsonfile/utils.js\")\nconst { outputFile } = __webpack_require__(/*! ../output */ \"./node_modules/fs-extra/lib/output/index.js\")\n\nasync function outputJson (file, data, options = {}) {\n  const str = stringify(data, options)\n\n  await outputFile(file, str, options)\n}\n\nmodule.exports = outputJson\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/json/output-json.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/mkdirs/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fs-extra/lib/mkdirs/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromPromise\nconst { makeDir: _makeDir, makeDirSync } = __webpack_require__(/*! ./make-dir */ \"./node_modules/fs-extra/lib/mkdirs/make-dir.js\")\nconst makeDir = u(_makeDir)\n\nmodule.exports = {\n  mkdirs: makeDir,\n  mkdirsSync: makeDirSync,\n  // alias\n  mkdirp: makeDir,\n  mkdirpSync: makeDirSync,\n  ensureDir: makeDir,\n  ensureDirSync: makeDirSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/mkdirs/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/mkdirs/make-dir.js":
/*!******************************************************!*\
  !*** ./node_modules/fs-extra/lib/mkdirs/make-dir.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Adapted from https://github.com/sindresorhus/make-dir\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nconst fs = __webpack_require__(/*! ../fs */ \"./node_modules/fs-extra/lib/fs/index.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst atLeastNode = __webpack_require__(/*! at-least-node */ \"./node_modules/at-least-node/index.js\")\n\nconst useNativeRecursiveOption = atLeastNode('10.12.0')\n\n// https://github.com/nodejs/node/issues/8987\n// https://github.com/libuv/libuv/pull/1088\nconst checkPath = pth => {\n  if (process.platform === 'win32') {\n    const pathHasInvalidWinCharacters = /[<>:\"|?*]/.test(pth.replace(path.parse(pth).root, ''))\n\n    if (pathHasInvalidWinCharacters) {\n      const error = new Error(`Path contains invalid characters: ${pth}`)\n      error.code = 'EINVAL'\n      throw error\n    }\n  }\n}\n\nconst processOptions = options => {\n  const defaults = { mode: 0o777 }\n  if (typeof options === 'number') options = { mode: options }\n  return { ...defaults, ...options }\n}\n\nconst permissionError = pth => {\n  // This replicates the exception of `fs.mkdir` with native the\n  // `recusive` option when run on an invalid drive under Windows.\n  const error = new Error(`operation not permitted, mkdir '${pth}'`)\n  error.code = 'EPERM'\n  error.errno = -4048\n  error.path = pth\n  error.syscall = 'mkdir'\n  return error\n}\n\nmodule.exports.makeDir = async (input, options) => {\n  checkPath(input)\n  options = processOptions(options)\n\n  if (useNativeRecursiveOption) {\n    const pth = path.resolve(input)\n\n    return fs.mkdir(pth, {\n      mode: options.mode,\n      recursive: true\n    })\n  }\n\n  const make = async pth => {\n    try {\n      await fs.mkdir(pth, options.mode)\n    } catch (error) {\n      if (error.code === 'EPERM') {\n        throw error\n      }\n\n      if (error.code === 'ENOENT') {\n        if (path.dirname(pth) === pth) {\n          throw permissionError(pth)\n        }\n\n        if (error.message.includes('null bytes')) {\n          throw error\n        }\n\n        await make(path.dirname(pth))\n        return make(pth)\n      }\n\n      try {\n        const stats = await fs.stat(pth)\n        if (!stats.isDirectory()) {\n          // This error is never exposed to the user\n          // it is caught below, and the original error is thrown\n          throw new Error('The path is not a directory')\n        }\n      } catch {\n        throw error\n      }\n    }\n  }\n\n  return make(path.resolve(input))\n}\n\nmodule.exports.makeDirSync = (input, options) => {\n  checkPath(input)\n  options = processOptions(options)\n\n  if (useNativeRecursiveOption) {\n    const pth = path.resolve(input)\n\n    return fs.mkdirSync(pth, {\n      mode: options.mode,\n      recursive: true\n    })\n  }\n\n  const make = pth => {\n    try {\n      fs.mkdirSync(pth, options.mode)\n    } catch (error) {\n      if (error.code === 'EPERM') {\n        throw error\n      }\n\n      if (error.code === 'ENOENT') {\n        if (path.dirname(pth) === pth) {\n          throw permissionError(pth)\n        }\n\n        if (error.message.includes('null bytes')) {\n          throw error\n        }\n\n        make(path.dirname(pth))\n        return make(pth)\n      }\n\n      try {\n        if (!fs.statSync(pth).isDirectory()) {\n          // This error is never exposed to the user\n          // it is caught below, and the original error is thrown\n          throw new Error('The path is not a directory')\n        }\n      } catch {\n        throw error\n      }\n    }\n  }\n\n  return make(path.resolve(input))\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/mkdirs/make-dir.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/move-sync/index.js":
/*!******************************************************!*\
  !*** ./node_modules/fs-extra/lib/move-sync/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = {\n  moveSync: __webpack_require__(/*! ./move-sync */ \"./node_modules/fs-extra/lib/move-sync/move-sync.js\")\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/move-sync/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/move-sync/move-sync.js":
/*!**********************************************************!*\
  !*** ./node_modules/fs-extra/lib/move-sync/move-sync.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst copySync = __webpack_require__(/*! ../copy-sync */ \"./node_modules/fs-extra/lib/copy-sync/index.js\").copySync\nconst removeSync = __webpack_require__(/*! ../remove */ \"./node_modules/fs-extra/lib/remove/index.js\").removeSync\nconst mkdirpSync = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\").mkdirpSync\nconst stat = __webpack_require__(/*! ../util/stat */ \"./node_modules/fs-extra/lib/util/stat.js\")\n\nfunction moveSync (src, dest, opts) {\n  opts = opts || {}\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  const { srcStat } = stat.checkPathsSync(src, dest, 'move')\n  stat.checkParentPathsSync(src, srcStat, dest, 'move')\n  mkdirpSync(path.dirname(dest))\n  return doRename(src, dest, overwrite)\n}\n\nfunction doRename (src, dest, overwrite) {\n  if (overwrite) {\n    removeSync(dest)\n    return rename(src, dest, overwrite)\n  }\n  if (fs.existsSync(dest)) throw new Error('dest already exists.')\n  return rename(src, dest, overwrite)\n}\n\nfunction rename (src, dest, overwrite) {\n  try {\n    fs.renameSync(src, dest)\n  } catch (err) {\n    if (err.code !== 'EXDEV') throw err\n    return moveAcrossDevice(src, dest, overwrite)\n  }\n}\n\nfunction moveAcrossDevice (src, dest, overwrite) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copySync(src, dest, opts)\n  return removeSync(src)\n}\n\nmodule.exports = moveSync\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/move-sync/move-sync.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/move/index.js":
/*!*************************************************!*\
  !*** ./node_modules/fs-extra/lib/move/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nmodule.exports = {\n  move: u(__webpack_require__(/*! ./move */ \"./node_modules/fs-extra/lib/move/move.js\"))\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/move/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/move/move.js":
/*!************************************************!*\
  !*** ./node_modules/fs-extra/lib/move/move.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst copy = __webpack_require__(/*! ../copy */ \"./node_modules/fs-extra/lib/copy/index.js\").copy\nconst remove = __webpack_require__(/*! ../remove */ \"./node_modules/fs-extra/lib/remove/index.js\").remove\nconst mkdirp = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\").mkdirp\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists\nconst stat = __webpack_require__(/*! ../util/stat */ \"./node_modules/fs-extra/lib/util/stat.js\")\n\nfunction move (src, dest, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  stat.checkPaths(src, dest, 'move', (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'move', err => {\n      if (err) return cb(err)\n      mkdirp(path.dirname(dest), err => {\n        if (err) return cb(err)\n        return doRename(src, dest, overwrite, cb)\n      })\n    })\n  })\n}\n\nfunction doRename (src, dest, overwrite, cb) {\n  if (overwrite) {\n    return remove(dest, err => {\n      if (err) return cb(err)\n      return rename(src, dest, overwrite, cb)\n    })\n  }\n  pathExists(dest, (err, destExists) => {\n    if (err) return cb(err)\n    if (destExists) return cb(new Error('dest already exists.'))\n    return rename(src, dest, overwrite, cb)\n  })\n}\n\nfunction rename (src, dest, overwrite, cb) {\n  fs.rename(src, dest, err => {\n    if (!err) return cb()\n    if (err.code !== 'EXDEV') return cb(err)\n    return moveAcrossDevice(src, dest, overwrite, cb)\n  })\n}\n\nfunction moveAcrossDevice (src, dest, overwrite, cb) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copy(src, dest, opts, err => {\n    if (err) return cb(err)\n    return remove(src, cb)\n  })\n}\n\nmodule.exports = move\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/move/move.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/output/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fs-extra/lib/output/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  const dir = path.dirname(file)\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n\n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\nfunction outputFileSync (file, ...args) {\n  const dir = path.dirname(file)\n  if (fs.existsSync(dir)) {\n    return fs.writeFileSync(file, ...args)\n  }\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync(file, ...args)\n}\n\nmodule.exports = {\n  outputFile: u(outputFile),\n  outputFileSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/output/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/path-exists/index.js":
/*!********************************************************!*\
  !*** ./node_modules/fs-extra/lib/path-exists/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromPromise\nconst fs = __webpack_require__(/*! ../fs */ \"./node_modules/fs-extra/lib/fs/index.js\")\n\nfunction pathExists (path) {\n  return fs.access(path).then(() => true).catch(() => false)\n}\n\nmodule.exports = {\n  pathExists: u(pathExists),\n  pathExistsSync: fs.existsSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/path-exists/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/remove/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fs-extra/lib/remove/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/universalify/index.js\").fromCallback\nconst rimraf = __webpack_require__(/*! ./rimraf */ \"./node_modules/fs-extra/lib/remove/rimraf.js\")\n\nmodule.exports = {\n  remove: u(rimraf),\n  removeSync: rimraf.sync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/remove/index.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/remove/rimraf.js":
/*!****************************************************!*\
  !*** ./node_modules/fs-extra/lib/remove/rimraf.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\n\nconst isWindows = (process.platform === 'win32')\n\nfunction defaults (options) {\n  const methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(m => {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n}\n\nfunction rimraf (p, options, cb) {\n  let busyTries = 0\n\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  rimraf_(p, options, function CB (er) {\n    if (er) {\n      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&\n          busyTries < options.maxBusyTries) {\n        busyTries++\n        const time = busyTries * 100\n        // try again, with the same exact callback as this one.\n        return setTimeout(() => rimraf_(p, options, CB), time)\n      }\n\n      // already gone\n      if (er.code === 'ENOENT') er = null\n    }\n\n    cb(er)\n  })\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, (er, st) => {\n    if (er && er.code === 'ENOENT') {\n      return cb(null)\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === 'EPERM' && isWindows) {\n      return fixWinEPERM(p, options, er, cb)\n    }\n\n    if (st && st.isDirectory()) {\n      return rmdir(p, options, er, cb)\n    }\n\n    options.unlink(p, er => {\n      if (er) {\n        if (er.code === 'ENOENT') {\n          return cb(null)\n        }\n        if (er.code === 'EPERM') {\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        }\n        if (er.code === 'EISDIR') {\n          return rmdir(p, options, er, cb)\n        }\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.chmod(p, 0o666, er2 => {\n    if (er2) {\n      cb(er2.code === 'ENOENT' ? null : er)\n    } else {\n      options.stat(p, (er3, stats) => {\n        if (er3) {\n          cb(er3.code === 'ENOENT' ? null : er)\n        } else if (stats.isDirectory()) {\n          rmdir(p, options, er, cb)\n        } else {\n          options.unlink(p, cb)\n        }\n      })\n    }\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  let stats\n\n  assert(p)\n  assert(options)\n\n  try {\n    options.chmodSync(p, 0o666)\n  } catch (er2) {\n    if (er2.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  try {\n    stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  if (stats.isDirectory()) {\n    rmdirSync(p, options, er)\n  } else {\n    options.unlinkSync(p)\n  }\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, er => {\n    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {\n      rmkids(p, options, cb)\n    } else if (er && er.code === 'ENOTDIR') {\n      cb(originalEr)\n    } else {\n      cb(er)\n    }\n  })\n}\n\nfunction rmkids (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, (er, files) => {\n    if (er) return cb(er)\n\n    let n = files.length\n    let errState\n\n    if (n === 0) return options.rmdir(p, cb)\n\n    files.forEach(f => {\n      rimraf(path.join(p, f), options, er => {\n        if (errState) {\n          return\n        }\n        if (er) return cb(errState = er)\n        if (--n === 0) {\n          options.rmdir(p, cb)\n        }\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  let st\n\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  try {\n    st = options.lstatSync(p)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er.code === 'EPERM' && isWindows) {\n      fixWinEPERMSync(p, options, er)\n    }\n  }\n\n  try {\n    // sunos lets the root user unlink directories, which is... weird.\n    if (st && st.isDirectory()) {\n      rmdirSync(p, options, null)\n    } else {\n      options.unlinkSync(p)\n    }\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    } else if (er.code === 'EPERM') {\n      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n    } else if (er.code !== 'EISDIR') {\n      throw er\n    }\n    rmdirSync(p, options, er)\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === 'ENOTDIR') {\n      throw originalEr\n    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {\n      rmkidsSync(p, options)\n    } else if (er.code !== 'ENOENT') {\n      throw er\n    }\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))\n\n  if (isWindows) {\n    // We only end up here once we got ENOTEMPTY at least once, and\n    // at this point, we are guaranteed to have removed all the kids.\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n    // try really hard to delete stuff on windows, because it has a\n    // PROFOUNDLY annoying habit of not closing handles promptly when\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\n    const startTime = Date.now()\n    do {\n      try {\n        const ret = options.rmdirSync(p, options)\n        return ret\n      } catch {}\n    } while (Date.now() - startTime < 500) // give up after 500ms\n  } else {\n    const ret = options.rmdirSync(p, options)\n    return ret\n  }\n}\n\nmodule.exports = rimraf\nrimraf.sync = rimrafSync\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/remove/rimraf.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/util/stat.js":
/*!************************************************!*\
  !*** ./node_modules/fs-extra/lib/util/stat.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! ../fs */ \"./node_modules/fs-extra/lib/fs/index.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst util = __webpack_require__(/*! util */ \"util\")\nconst atLeastNode = __webpack_require__(/*! at-least-node */ \"./node_modules/at-least-node/index.js\")\n\nconst nodeSupportsBigInt = atLeastNode('10.5.0')\nconst stat = (file) => nodeSupportsBigInt ? fs.stat(file, { bigint: true }) : fs.stat(file)\nconst statSync = (file) => nodeSupportsBigInt ? fs.statSync(file, { bigint: true }) : fs.statSync(file)\n\nfunction getStats (src, dest) {\n  return Promise.all([\n    stat(src),\n    stat(dest).catch(err => {\n      if (err.code === 'ENOENT') return null\n      throw err\n    })\n  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))\n}\n\nfunction getStatsSync (src, dest) {\n  let destStat\n  const srcStat = statSync(src)\n  try {\n    destStat = statSync(dest)\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nfunction checkPaths (src, dest, funcName, cb) {\n  util.callbackify(getStats)(src, dest, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    if (destStat && areIdentical(srcStat, destStat)) {\n      return cb(new Error('Source and destination must not be the same.'))\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return cb(null, { srcStat, destStat })\n  })\n}\n\nfunction checkPathsSync (src, dest, funcName) {\n  const { srcStat, destStat } = getStatsSync(src, dest)\n  if (destStat && areIdentical(srcStat, destStat)) {\n    throw new Error('Source and destination must not be the same.')\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\n  const callback = (err, destStat) => {\n    if (err) {\n      if (err.code === 'ENOENT') return cb()\n      return cb(err)\n    }\n    if (areIdentical(srcStat, destStat)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return checkParentPaths(src, srcStat, destParent, funcName, cb)\n  }\n  if (nodeSupportsBigInt) fs.stat(destParent, { bigint: true }, callback)\n  else fs.stat(destParent, callback)\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    destStat = statSync(destParent)\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\nfunction areIdentical (srcStat, destStat) {\n  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    if (nodeSupportsBigInt || destStat.ino < Number.MAX_SAFE_INTEGER) {\n      // definitive answer\n      return true\n    }\n    // Use additional heuristics if we can't use 'bigint'.\n    // Different 'ino' could be represented the same if they are >= Number.MAX_SAFE_INTEGER\n    // See issue 657\n    if (destStat.size === srcStat.size &&\n        destStat.mode === srcStat.mode &&\n        destStat.nlink === srcStat.nlink &&\n        destStat.atimeMs === srcStat.atimeMs &&\n        destStat.mtimeMs === srcStat.mtimeMs &&\n        destStat.ctimeMs === srcStat.ctimeMs &&\n        destStat.birthtimeMs === srcStat.birthtimeMs) {\n      // heuristic answer\n      return true\n    }\n  }\n  return false\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/util/stat.js?");

/***/ }),

/***/ "./node_modules/fs-extra/lib/util/utimes.js":
/*!**************************************************!*\
  !*** ./node_modules/fs-extra/lib/util/utimes.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\n\nfunction utimesMillis (path, atime, mtime, callback) {\n  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)\n  fs.open(path, 'r+', (err, fd) => {\n    if (err) return callback(err)\n    fs.futimes(fd, atime, mtime, futimesErr => {\n      fs.close(fd, closeErr => {\n        if (callback) callback(futimesErr || closeErr)\n      })\n    })\n  })\n}\n\nfunction utimesMillisSync (path, atime, mtime) {\n  const fd = fs.openSync(path, 'r+')\n  fs.futimesSync(fd, atime, mtime)\n  return fs.closeSync(fd)\n}\n\nmodule.exports = {\n  utimesMillis,\n  utimesMillisSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-extra/lib/util/utimes.js?");

/***/ }),

/***/ "./node_modules/fs-minipass/index.js":
/*!*******************************************!*\
  !*** ./node_modules/fs-minipass/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst MiniPass = __webpack_require__(/*! minipass */ \"./node_modules/minipass/index.js\")\nconst EE = __webpack_require__(/*! events */ \"events\").EventEmitter\nconst fs = __webpack_require__(/*! fs */ \"fs\")\n\nlet writev = fs.writev\n/* istanbul ignore next */\nif (!writev) {\n  // This entire block can be removed if support for earlier than Node.js\n  // 12.9.0 is not needed.\n  const binding = process.binding('fs')\n  const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback\n\n  writev = (fd, iovec, pos, cb) => {\n    const done = (er, bw) => cb(er, bw, iovec)\n    const req = new FSReqWrap()\n    req.oncomplete = done\n    binding.writeBuffers(fd, iovec, pos, req)\n  }\n}\n\nconst _autoClose = Symbol('_autoClose')\nconst _close = Symbol('_close')\nconst _ended = Symbol('_ended')\nconst _fd = Symbol('_fd')\nconst _finished = Symbol('_finished')\nconst _flags = Symbol('_flags')\nconst _flush = Symbol('_flush')\nconst _handleChunk = Symbol('_handleChunk')\nconst _makeBuf = Symbol('_makeBuf')\nconst _mode = Symbol('_mode')\nconst _needDrain = Symbol('_needDrain')\nconst _onerror = Symbol('_onerror')\nconst _onopen = Symbol('_onopen')\nconst _onread = Symbol('_onread')\nconst _onwrite = Symbol('_onwrite')\nconst _open = Symbol('_open')\nconst _path = Symbol('_path')\nconst _pos = Symbol('_pos')\nconst _queue = Symbol('_queue')\nconst _read = Symbol('_read')\nconst _readSize = Symbol('_readSize')\nconst _reading = Symbol('_reading')\nconst _remain = Symbol('_remain')\nconst _size = Symbol('_size')\nconst _write = Symbol('_write')\nconst _writing = Symbol('_writing')\nconst _defaultFlag = Symbol('_defaultFlag')\nconst _errored = Symbol('_errored')\n\nclass ReadStream extends MiniPass {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.readable = true\n    this.writable = false\n\n    if (typeof path !== 'string')\n      throw new TypeError('path must be a string')\n\n    this[_errored] = false\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_path] = path\n    this[_readSize] = opt.readSize || 16*1024*1024\n    this[_reading] = false\n    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity\n    this[_remain] = this[_size]\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    if (typeof this[_fd] === 'number')\n      this[_read]()\n    else\n      this[_open]()\n  }\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  write () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  end () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  [_open] () {\n    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_read]()\n    }\n  }\n\n  [_makeBuf] () {\n    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]))\n  }\n\n  [_read] () {\n    if (!this[_reading]) {\n      this[_reading] = true\n      const buf = this[_makeBuf]()\n      /* istanbul ignore if */\n      if (buf.length === 0)\n        return process.nextTick(() => this[_onread](null, 0, buf))\n      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) =>\n        this[_onread](er, br, buf))\n    }\n  }\n\n  [_onread] (er, br, buf) {\n    this[_reading] = false\n    if (er)\n      this[_onerror](er)\n    else if (this[_handleChunk](br, buf))\n      this[_read]()\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))\n    }\n  }\n\n  [_onerror] (er) {\n    this[_reading] = true\n    this[_close]()\n    this.emit('error', er)\n  }\n\n  [_handleChunk] (br, buf) {\n    let ret = false\n    // no effect if infinite\n    this[_remain] -= br\n    if (br > 0)\n      ret = super.write(br < buf.length ? buf.slice(0, br) : buf)\n\n    if (br === 0 || this[_remain] <= 0) {\n      ret = false\n      this[_close]()\n      super.end()\n    }\n\n    return ret\n  }\n\n  emit (ev, data) {\n    switch (ev) {\n      case 'prefinish':\n      case 'finish':\n        break\n\n      case 'drain':\n        if (typeof this[_fd] === 'number')\n          this[_read]()\n        break\n\n      case 'error':\n        if (this[_errored])\n          return\n        this[_errored] = true\n        return super.emit(ev, data)\n\n      default:\n        return super.emit(ev, data)\n    }\n  }\n}\n\nclass ReadStreamSync extends ReadStream {\n  [_open] () {\n    let threw = true\n    try {\n      this[_onopen](null, fs.openSync(this[_path], 'r'))\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_read] () {\n    let threw = true\n    try {\n      if (!this[_reading]) {\n        this[_reading] = true\n        do {\n          const buf = this[_makeBuf]()\n          /* istanbul ignore next */\n          const br = buf.length === 0 ? 0\n            : fs.readSync(this[_fd], buf, 0, buf.length, null)\n          if (!this[_handleChunk](br, buf))\n            break\n        } while (true)\n        this[_reading] = false\n      }\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.closeSync(fd)\n      this.emit('close')\n    }\n  }\n}\n\nclass WriteStream extends EE {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n    this.readable = false\n    this.writable = true\n    this[_errored] = false\n    this[_writing] = false\n    this[_ended] = false\n    this[_needDrain] = false\n    this[_queue] = []\n    this[_path] = path\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode\n    this[_pos] = typeof opt.start === 'number' ? opt.start : null\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    // truncating makes no sense when writing into the middle\n    const defaultFlag = this[_pos] !== null ? 'r+' : 'w'\n    this[_defaultFlag] = opt.flags === undefined\n    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags\n\n    if (this[_fd] === null)\n      this[_open]()\n  }\n\n  emit (ev, data) {\n    if (ev === 'error') {\n      if (this[_errored])\n        return\n      this[_errored] = true\n    }\n    return super.emit(ev, data)\n  }\n\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  [_onerror] (er) {\n    this[_close]()\n    this[_writing] = true\n    this.emit('error', er)\n  }\n\n  [_open] () {\n    fs.open(this[_path], this[_flags], this[_mode],\n      (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (this[_defaultFlag] &&\n        this[_flags] === 'r+' &&\n        er && er.code === 'ENOENT') {\n      this[_flags] = 'w'\n      this[_open]()\n    } else if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_flush]()\n    }\n  }\n\n  end (buf, enc) {\n    if (buf)\n      this.write(buf, enc)\n\n    this[_ended] = true\n\n    // synthetic after-write logic, where drain/finish live\n    if (!this[_writing] && !this[_queue].length &&\n        typeof this[_fd] === 'number')\n      this[_onwrite](null, 0)\n    return this\n  }\n\n  write (buf, enc) {\n    if (typeof buf === 'string')\n      buf = Buffer.from(buf, enc)\n\n    if (this[_ended]) {\n      this.emit('error', new Error('write() after end()'))\n      return false\n    }\n\n    if (this[_fd] === null || this[_writing] || this[_queue].length) {\n      this[_queue].push(buf)\n      this[_needDrain] = true\n      return false\n    }\n\n    this[_writing] = true\n    this[_write](buf)\n    return true\n  }\n\n  [_write] (buf) {\n    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) =>\n      this[_onwrite](er, bw))\n  }\n\n  [_onwrite] (er, bw) {\n    if (er)\n      this[_onerror](er)\n    else {\n      if (this[_pos] !== null)\n        this[_pos] += bw\n      if (this[_queue].length)\n        this[_flush]()\n      else {\n        this[_writing] = false\n\n        if (this[_ended] && !this[_finished]) {\n          this[_finished] = true\n          this[_close]()\n          this.emit('finish')\n        } else if (this[_needDrain]) {\n          this[_needDrain] = false\n          this.emit('drain')\n        }\n      }\n    }\n  }\n\n  [_flush] () {\n    if (this[_queue].length === 0) {\n      if (this[_ended])\n        this[_onwrite](null, 0)\n    } else if (this[_queue].length === 1)\n      this[_write](this[_queue].pop())\n    else {\n      const iovec = this[_queue]\n      this[_queue] = []\n      writev(this[_fd], iovec, this[_pos],\n        (er, bw) => this[_onwrite](er, bw))\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))\n    }\n  }\n}\n\nclass WriteStreamSync extends WriteStream {\n  [_open] () {\n    let fd\n    // only wrap in a try{} block if we know we'll retry, to avoid\n    // the rethrow obscuring the error's source frame in most cases.\n    if (this[_defaultFlag] && this[_flags] === 'r+') {\n      try {\n        fd = fs.openSync(this[_path], this[_flags], this[_mode])\n      } catch (er) {\n        if (er.code === 'ENOENT') {\n          this[_flags] = 'w'\n          return this[_open]()\n        } else\n          throw er\n      }\n    } else\n      fd = fs.openSync(this[_path], this[_flags], this[_mode])\n\n    this[_onopen](null, fd)\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.closeSync(fd)\n      this.emit('close')\n    }\n  }\n\n  [_write] (buf) {\n    // throw the original, but try to close if it fails\n    let threw = true\n    try {\n      this[_onwrite](null,\n        fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]))\n      threw = false\n    } finally {\n      if (threw)\n        try { this[_close]() } catch (_) {}\n    }\n  }\n}\n\nexports.ReadStream = ReadStream\nexports.ReadStreamSync = ReadStreamSync\n\nexports.WriteStream = WriteStream\nexports.WriteStreamSync = WriteStreamSync\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs-minipass/index.js?");

/***/ }),

/***/ "./node_modules/fs.realpath/index.js":
/*!*******************************************!*\
  !*** ./node_modules/fs.realpath/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = realpath\nrealpath.realpath = realpath\nrealpath.sync = realpathSync\nrealpath.realpathSync = realpathSync\nrealpath.monkeypatch = monkeypatch\nrealpath.unmonkeypatch = unmonkeypatch\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar origRealpath = fs.realpath\nvar origRealpathSync = fs.realpathSync\n\nvar version = process.version\nvar ok = /^v[0-5]\\./.test(version)\nvar old = __webpack_require__(/*! ./old.js */ \"./node_modules/fs.realpath/old.js\")\n\nfunction newError (er) {\n  return er && er.syscall === 'realpath' && (\n    er.code === 'ELOOP' ||\n    er.code === 'ENOMEM' ||\n    er.code === 'ENAMETOOLONG'\n  )\n}\n\nfunction realpath (p, cache, cb) {\n  if (ok) {\n    return origRealpath(p, cache, cb)\n  }\n\n  if (typeof cache === 'function') {\n    cb = cache\n    cache = null\n  }\n  origRealpath(p, cache, function (er, result) {\n    if (newError(er)) {\n      old.realpath(p, cache, cb)\n    } else {\n      cb(er, result)\n    }\n  })\n}\n\nfunction realpathSync (p, cache) {\n  if (ok) {\n    return origRealpathSync(p, cache)\n  }\n\n  try {\n    return origRealpathSync(p, cache)\n  } catch (er) {\n    if (newError(er)) {\n      return old.realpathSync(p, cache)\n    } else {\n      throw er\n    }\n  }\n}\n\nfunction monkeypatch () {\n  fs.realpath = realpath\n  fs.realpathSync = realpathSync\n}\n\nfunction unmonkeypatch () {\n  fs.realpath = origRealpath\n  fs.realpathSync = origRealpathSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs.realpath/index.js?");

/***/ }),

/***/ "./node_modules/fs.realpath/old.js":
/*!*****************************************!*\
  !*** ./node_modules/fs.realpath/old.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar pathModule = __webpack_require__(/*! path */ \"path\");\nvar isWindows = process.platform === 'win32';\nvar fs = __webpack_require__(/*! fs */ \"fs\");\n\n// JavaScript implementation of realpath, ported from node pre-v6\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\n\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  var callback;\n  if (DEBUG) {\n    var backtrace = new Error;\n    callback = debugCallback;\n  } else\n    callback = missingCallback;\n\n  return callback;\n\n  function debugCallback(err) {\n    if (err) {\n      backtrace.message = err.message;\n      err = backtrace;\n      missingCallback(err);\n    }\n  }\n\n  function missingCallback(err) {\n    if (err) {\n      if (process.throwDeprecation)\n        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n      else if (!process.noDeprecation) {\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\n        if (process.traceDeprecation)\n          console.trace(msg);\n        else\n          console.error(msg);\n      }\n    }\n  }\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\nvar normalize = pathModule.normalize;\n\n// Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n}\n\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\n\nexports.realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      continue;\n    }\n\n    var resolvedLink;\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n      // track this, if given a cache.\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n\n  return p;\n};\n\n\nexports.realpath = function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  }\n\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    }\n\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err);\n\n    // if not a symlink, skip to the next path part\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return cb(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fs.realpath/old.js?");

/***/ }),

/***/ "./node_modules/fstream/fstream.js":
/*!*****************************************!*\
  !*** ./node_modules/fstream/fstream.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("exports.Abstract = __webpack_require__(/*! ./lib/abstract.js */ \"./node_modules/fstream/lib/abstract.js\")\nexports.Reader = __webpack_require__(/*! ./lib/reader.js */ \"./node_modules/fstream/lib/reader.js\")\nexports.Writer = __webpack_require__(/*! ./lib/writer.js */ \"./node_modules/fstream/lib/writer.js\")\n\nexports.File = {\n  Reader: __webpack_require__(/*! ./lib/file-reader.js */ \"./node_modules/fstream/lib/file-reader.js\"),\n  Writer: __webpack_require__(/*! ./lib/file-writer.js */ \"./node_modules/fstream/lib/file-writer.js\")\n}\n\nexports.Dir = {\n  Reader: __webpack_require__(/*! ./lib/dir-reader.js */ \"./node_modules/fstream/lib/dir-reader.js\"),\n  Writer: __webpack_require__(/*! ./lib/dir-writer.js */ \"./node_modules/fstream/lib/dir-writer.js\")\n}\n\nexports.Link = {\n  Reader: __webpack_require__(/*! ./lib/link-reader.js */ \"./node_modules/fstream/lib/link-reader.js\"),\n  Writer: __webpack_require__(/*! ./lib/link-writer.js */ \"./node_modules/fstream/lib/link-writer.js\")\n}\n\nexports.Proxy = {\n  Reader: __webpack_require__(/*! ./lib/proxy-reader.js */ \"./node_modules/fstream/lib/proxy-reader.js\"),\n  Writer: __webpack_require__(/*! ./lib/proxy-writer.js */ \"./node_modules/fstream/lib/proxy-writer.js\")\n}\n\nexports.Reader.Dir = exports.DirReader = exports.Dir.Reader\nexports.Reader.File = exports.FileReader = exports.File.Reader\nexports.Reader.Link = exports.LinkReader = exports.Link.Reader\nexports.Reader.Proxy = exports.ProxyReader = exports.Proxy.Reader\n\nexports.Writer.Dir = exports.DirWriter = exports.Dir.Writer\nexports.Writer.File = exports.FileWriter = exports.File.Writer\nexports.Writer.Link = exports.LinkWriter = exports.Link.Writer\nexports.Writer.Proxy = exports.ProxyWriter = exports.Proxy.Writer\n\nexports.collect = __webpack_require__(/*! ./lib/collect.js */ \"./node_modules/fstream/lib/collect.js\")\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fstream/fstream.js?");

/***/ }),

/***/ "./node_modules/fstream/lib/abstract.js":
/*!**********************************************!*\
  !*** ./node_modules/fstream/lib/abstract.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// the parent class for all fstreams.\n\nmodule.exports = Abstract\n\nvar Stream = __webpack_require__(/*! stream */ \"stream\").Stream\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\")\n\nfunction Abstract () {\n  Stream.call(this)\n}\n\ninherits(Abstract, Stream)\n\nAbstract.prototype.on = function (ev, fn) {\n  if (ev === 'ready' && this.ready) {\n    process.nextTick(fn.bind(this))\n  } else {\n    Stream.prototype.on.call(this, ev, fn)\n  }\n  return this\n}\n\nAbstract.prototype.abort = function () {\n  this._aborted = true\n  this.emit('abort')\n}\n\nAbstract.prototype.destroy = function () {}\n\nAbstract.prototype.warn = function (msg, code) {\n  var self = this\n  var er = decorate(msg, code, self)\n  if (!self.listeners('warn')) {\n    console.error('%s %s\\n' +\n    'path = %s\\n' +\n    'syscall = %s\\n' +\n    'fstream_type = %s\\n' +\n    'fstream_path = %s\\n' +\n    'fstream_unc_path = %s\\n' +\n    'fstream_class = %s\\n' +\n    'fstream_stack =\\n%s\\n',\n      code || 'UNKNOWN',\n      er.stack,\n      er.path,\n      er.syscall,\n      er.fstream_type,\n      er.fstream_path,\n      er.fstream_unc_path,\n      er.fstream_class,\n      er.fstream_stack.join('\\n'))\n  } else {\n    self.emit('warn', er)\n  }\n}\n\nAbstract.prototype.info = function (msg, code) {\n  this.emit('info', msg, code)\n}\n\nAbstract.prototype.error = function (msg, code, th) {\n  var er = decorate(msg, code, this)\n  if (th) throw er\n  else this.emit('error', er)\n}\n\nfunction decorate (er, code, self) {\n  if (!(er instanceof Error)) er = new Error(er)\n  er.code = er.code || code\n  er.path = er.path || self.path\n  er.fstream_type = er.fstream_type || self.type\n  er.fstream_path = er.fstream_path || self.path\n  if (self._path !== self.path) {\n    er.fstream_unc_path = er.fstream_unc_path || self._path\n  }\n  if (self.linkpath) {\n    er.fstream_linkpath = er.fstream_linkpath || self.linkpath\n  }\n  er.fstream_class = er.fstream_class || self.constructor.name\n  er.fstream_stack = er.fstream_stack ||\n    new Error().stack.split(/\\n/).slice(3).map(function (s) {\n      return s.replace(/^ {4}at /, '')\n    })\n\n  return er\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fstream/lib/abstract.js?");

/***/ }),

/***/ "./node_modules/fstream/lib/collect.js":
/*!*********************************************!*\
  !*** ./node_modules/fstream/lib/collect.js ***!
  \*********************************************/
/***/ ((module) => {

eval("module.exports = collect\n\nfunction collect (stream) {\n  if (stream._collected) return\n\n  if (stream._paused) return stream.on('resume', collect.bind(null, stream))\n\n  stream._collected = true\n  stream.pause()\n\n  stream.on('data', save)\n  stream.on('end', save)\n  var buf = []\n  function save (b) {\n    if (typeof b === 'string') b = new Buffer(b)\n    if (Buffer.isBuffer(b) && !b.length) return\n    buf.push(b)\n  }\n\n  stream.on('entry', saveEntry)\n  var entryBuffer = []\n  function saveEntry (e) {\n    collect(e)\n    entryBuffer.push(e)\n  }\n\n  stream.on('proxy', proxyPause)\n  function proxyPause (p) {\n    p.pause()\n  }\n\n  // replace the pipe method with a new version that will\n  // unlock the buffered stuff.  if you just call .pipe()\n  // without a destination, then it'll re-play the events.\n  stream.pipe = (function (orig) {\n    return function (dest) {\n      // console.error(' === open the pipes', dest && dest.path)\n\n      // let the entries flow through one at a time.\n      // Once they're all done, then we can resume completely.\n      var e = 0\n      ;(function unblockEntry () {\n        var entry = entryBuffer[e++]\n        // console.error(\" ==== unblock entry\", entry && entry.path)\n        if (!entry) return resume()\n        entry.on('end', unblockEntry)\n        if (dest) dest.add(entry)\n        else stream.emit('entry', entry)\n      })()\n\n      function resume () {\n        stream.removeListener('entry', saveEntry)\n        stream.removeListener('data', save)\n        stream.removeListener('end', save)\n\n        stream.pipe = orig\n        if (dest) stream.pipe(dest)\n\n        buf.forEach(function (b) {\n          if (b) stream.emit('data', b)\n          else stream.emit('end')\n        })\n\n        stream.resume()\n      }\n\n      return dest\n    }\n  })(stream.pipe)\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fstream/lib/collect.js?");

/***/ }),

/***/ "./node_modules/fstream/lib/dir-reader.js":
/*!************************************************!*\
  !*** ./node_modules/fstream/lib/dir-reader.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// A thing that emits \"entry\" events with Reader objects\n// Pausing it causes it to stop emitting entry events, and also\n// pauses the current entry if there is one.\n\nmodule.exports = DirReader\n\nvar fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar Reader = __webpack_require__(/*! ./reader.js */ \"./node_modules/fstream/lib/reader.js\")\nvar assert = __webpack_require__(/*! assert */ \"assert\").ok\n\ninherits(DirReader, Reader)\n\nfunction DirReader (props) {\n  var self = this\n  if (!(self instanceof DirReader)) {\n    throw new Error('DirReader must be called as constructor.')\n  }\n\n  // should already be established as a Directory type\n  if (props.type !== 'Directory' || !props.Directory) {\n    throw new Error('Non-directory type ' + props.type)\n  }\n\n  self.entries = null\n  self._index = -1\n  self._paused = false\n  self._length = -1\n\n  if (props.sort) {\n    this.sort = props.sort\n  }\n\n  Reader.call(this, props)\n}\n\nDirReader.prototype._getEntries = function () {\n  var self = this\n\n  // race condition.  might pause() before calling _getEntries,\n  // and then resume, and try to get them a second time.\n  if (self._gotEntries) return\n  self._gotEntries = true\n\n  fs.readdir(self._path, function (er, entries) {\n    if (er) return self.error(er)\n\n    self.entries = entries\n\n    self.emit('entries', entries)\n    if (self._paused) self.once('resume', processEntries)\n    else processEntries()\n\n    function processEntries () {\n      self._length = self.entries.length\n      if (typeof self.sort === 'function') {\n        self.entries = self.entries.sort(self.sort.bind(self))\n      }\n      self._read()\n    }\n  })\n}\n\n// start walking the dir, and emit an \"entry\" event for each one.\nDirReader.prototype._read = function () {\n  var self = this\n\n  if (!self.entries) return self._getEntries()\n\n  if (self._paused || self._currentEntry || self._aborted) {\n    // console.error('DR paused=%j, current=%j, aborted=%j', self._paused, !!self._currentEntry, self._aborted)\n    return\n  }\n\n  self._index++\n  if (self._index >= self.entries.length) {\n    if (!self._ended) {\n      self._ended = true\n      self.emit('end')\n      self.emit('close')\n    }\n    return\n  }\n\n  // ok, handle this one, then.\n\n  // save creating a proxy, by stat'ing the thing now.\n  var p = path.resolve(self._path, self.entries[self._index])\n  assert(p !== self._path)\n  assert(self.entries[self._index])\n\n  // set this to prevent trying to _read() again in the stat time.\n  self._currentEntry = p\n  fs[ self.props.follow ? 'stat' : 'lstat' ](p, function (er, stat) {\n    if (er) return self.error(er)\n\n    var who = self._proxy || self\n\n    stat.path = p\n    stat.basename = path.basename(p)\n    stat.dirname = path.dirname(p)\n    var childProps = self.getChildProps.call(who, stat)\n    childProps.path = p\n    childProps.basename = path.basename(p)\n    childProps.dirname = path.dirname(p)\n\n    var entry = Reader(childProps, stat)\n\n    // console.error(\"DR Entry\", p, stat.size)\n\n    self._currentEntry = entry\n\n    // \"entry\" events are for direct entries in a specific dir.\n    // \"child\" events are for any and all children at all levels.\n    // This nomenclature is not completely final.\n\n    entry.on('pause', function (who) {\n      if (!self._paused && !entry._disowned) {\n        self.pause(who)\n      }\n    })\n\n    entry.on('resume', function (who) {\n      if (self._paused && !entry._disowned) {\n        self.resume(who)\n      }\n    })\n\n    entry.on('stat', function (props) {\n      self.emit('_entryStat', entry, props)\n      if (entry._aborted) return\n      if (entry._paused) {\n        entry.once('resume', function () {\n          self.emit('entryStat', entry, props)\n        })\n      } else self.emit('entryStat', entry, props)\n    })\n\n    entry.on('ready', function EMITCHILD () {\n      // console.error(\"DR emit child\", entry._path)\n      if (self._paused) {\n        // console.error(\"  DR emit child - try again later\")\n        // pause the child, and emit the \"entry\" event once we drain.\n        // console.error(\"DR pausing child entry\")\n        entry.pause(self)\n        return self.once('resume', EMITCHILD)\n      }\n\n      // skip over sockets.  they can't be piped around properly,\n      // so there's really no sense even acknowledging them.\n      // if someone really wants to see them, they can listen to\n      // the \"socket\" events.\n      if (entry.type === 'Socket') {\n        self.emit('socket', entry)\n      } else {\n        self.emitEntry(entry)\n      }\n    })\n\n    var ended = false\n    entry.on('close', onend)\n    entry.on('disown', onend)\n    function onend () {\n      if (ended) return\n      ended = true\n      self.emit('childEnd', entry)\n      self.emit('entryEnd', entry)\n      self._currentEntry = null\n      if (!self._paused) {\n        self._read()\n      }\n    }\n\n    // XXX Remove this.  Works in node as of 0.6.2 or so.\n    // Long filenames should not break stuff.\n    entry.on('error', function (er) {\n      if (entry._swallowErrors) {\n        self.warn(er)\n        entry.emit('end')\n        entry.emit('close')\n      } else {\n        self.emit('error', er)\n      }\n    })\n\n    // proxy up some events.\n    ;[\n      'child',\n      'childEnd',\n      'warn'\n    ].forEach(function (ev) {\n      entry.on(ev, self.emit.bind(self, ev))\n    })\n  })\n}\n\nDirReader.prototype.disown = function (entry) {\n  entry.emit('beforeDisown')\n  entry._disowned = true\n  entry.parent = entry.root = null\n  if (entry === this._currentEntry) {\n    this._currentEntry = null\n  }\n  entry.emit('disown')\n}\n\nDirReader.prototype.getChildProps = function () {\n  return {\n    depth: this.depth + 1,\n    root: this.root || this,\n    parent: this,\n    follow: this.follow,\n    filter: this.filter,\n    sort: this.props.sort,\n    hardlinks: this.props.hardlinks\n  }\n}\n\nDirReader.prototype.pause = function (who) {\n  var self = this\n  if (self._paused) return\n  who = who || self\n  self._paused = true\n  if (self._currentEntry && self._currentEntry.pause) {\n    self._currentEntry.pause(who)\n  }\n  self.emit('pause', who)\n}\n\nDirReader.prototype.resume = function (who) {\n  var self = this\n  if (!self._paused) return\n  who = who || self\n\n  self._paused = false\n  // console.error('DR Emit Resume', self._path)\n  self.emit('resume', who)\n  if (self._paused) {\n    // console.error('DR Re-paused', self._path)\n    return\n  }\n\n  if (self._currentEntry) {\n    if (self._currentEntry.resume) self._currentEntry.resume(who)\n  } else self._read()\n}\n\nDirReader.prototype.emitEntry = function (entry) {\n  this.emit('entry', entry)\n  this.emit('child', entry)\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fstream/lib/dir-reader.js?");

/***/ }),

/***/ "./node_modules/fstream/lib/dir-writer.js":
/*!************************************************!*\
  !*** ./node_modules/fstream/lib/dir-writer.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// It is expected that, when .add() returns false, the consumer\n// of the DirWriter will pause until a \"drain\" event occurs. Note\n// that this is *almost always going to be the case*, unless the\n// thing being written is some sort of unsupported type, and thus\n// skipped over.\n\nmodule.exports = DirWriter\n\nvar Writer = __webpack_require__(/*! ./writer.js */ \"./node_modules/fstream/lib/writer.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\")\nvar mkdir = __webpack_require__(/*! mkdirp */ \"./node_modules/fstream/node_modules/mkdirp/index.js\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar collect = __webpack_require__(/*! ./collect.js */ \"./node_modules/fstream/lib/collect.js\")\n\ninherits(DirWriter, Writer)\n\nfunction DirWriter (props) {\n  var self = this\n  if (!(self instanceof DirWriter)) {\n    self.error('DirWriter must be called as constructor.', null, true)\n  }\n\n  // should already be established as a Directory type\n  if (props.type !== 'Directory' || !props.Directory) {\n    self.error('Non-directory type ' + props.type + ' ' +\n      JSON.stringify(props), null, true)\n  }\n\n  Writer.call(this, props)\n}\n\nDirWriter.prototype._create = function () {\n  var self = this\n  mkdir(self._path, Writer.dirmode, function (er) {\n    if (er) return self.error(er)\n    // ready to start getting entries!\n    self.ready = true\n    self.emit('ready')\n    self._process()\n  })\n}\n\n// a DirWriter has an add(entry) method, but its .write() doesn't\n// do anything.  Why a no-op rather than a throw?  Because this\n// leaves open the door for writing directory metadata for\n// gnu/solaris style dumpdirs.\nDirWriter.prototype.write = function () {\n  return true\n}\n\nDirWriter.prototype.end = function () {\n  this._ended = true\n  this._process()\n}\n\nDirWriter.prototype.add = function (entry) {\n  var self = this\n\n  // console.error('\\tadd', entry._path, '->', self._path)\n  collect(entry)\n  if (!self.ready || self._currentEntry) {\n    self._buffer.push(entry)\n    return false\n  }\n\n  // create a new writer, and pipe the incoming entry into it.\n  if (self._ended) {\n    return self.error('add after end')\n  }\n\n  self._buffer.push(entry)\n  self._process()\n\n  return this._buffer.length === 0\n}\n\nDirWriter.prototype._process = function () {\n  var self = this\n\n  // console.error('DW Process p=%j', self._processing, self.basename)\n\n  if (self._processing) return\n\n  var entry = self._buffer.shift()\n  if (!entry) {\n    // console.error(\"DW Drain\")\n    self.emit('drain')\n    if (self._ended) self._finish()\n    return\n  }\n\n  self._processing = true\n  // console.error(\"DW Entry\", entry._path)\n\n  self.emit('entry', entry)\n\n  // ok, add this entry\n  //\n  // don't allow recursive copying\n  var p = entry\n  var pp\n  do {\n    pp = p._path || p.path\n    if (pp === self.root._path || pp === self._path ||\n      (pp && pp.indexOf(self._path) === 0)) {\n      // console.error('DW Exit (recursive)', entry.basename, self._path)\n      self._processing = false\n      if (entry._collected) entry.pipe()\n      return self._process()\n    }\n    p = p.parent\n  } while (p)\n\n  // console.error(\"DW not recursive\")\n\n  // chop off the entry's root dir, replace with ours\n  var props = {\n    parent: self,\n    root: self.root || self,\n    type: entry.type,\n    depth: self.depth + 1\n  }\n\n  pp = entry._path || entry.path || entry.props.path\n  if (entry.parent) {\n    pp = pp.substr(entry.parent._path.length + 1)\n  }\n  // get rid of any ../../ shenanigans\n  props.path = path.join(self.path, path.join('/', pp))\n\n  // if i have a filter, the child should inherit it.\n  props.filter = self.filter\n\n  // all the rest of the stuff, copy over from the source.\n  Object.keys(entry.props).forEach(function (k) {\n    if (!props.hasOwnProperty(k)) {\n      props[k] = entry.props[k]\n    }\n  })\n\n  // not sure at this point what kind of writer this is.\n  var child = self._currentChild = new Writer(props)\n  child.on('ready', function () {\n    // console.error(\"DW Child Ready\", child.type, child._path)\n    // console.error(\"  resuming\", entry._path)\n    entry.pipe(child)\n    entry.resume()\n  })\n\n  // XXX Make this work in node.\n  // Long filenames should not break stuff.\n  child.on('error', function (er) {\n    if (child._swallowErrors) {\n      self.warn(er)\n      child.emit('end')\n      child.emit('close')\n    } else {\n      self.emit('error', er)\n    }\n  })\n\n  // we fire _end internally *after* end, so that we don't move on\n  // until any \"end\" listeners have had their chance to do stuff.\n  child.on('close', onend)\n  var ended = false\n  function onend () {\n    if (ended) return\n    ended = true\n    // console.error(\"* DW Child end\", child.basename)\n    self._currentChild = null\n    self._processing = false\n    self._process()\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fstream/lib/dir-writer.js?");

/***/ }),

/***/ "./node_modules/fstream/lib/file-reader.js":
/*!*************************************************!*\
  !*** ./node_modules/fstream/lib/file-reader.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Basically just a wrapper around an fs.ReadStream\n\nmodule.exports = FileReader\n\nvar fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\")\nvar Reader = __webpack_require__(/*! ./reader.js */ \"./node_modules/fstream/lib/reader.js\")\nvar EOF = {EOF: true}\nvar CLOSE = {CLOSE: true}\n\ninherits(FileReader, Reader)\n\nfunction FileReader (props) {\n  // console.error(\"    FR create\", props.path, props.size, new Error().stack)\n  var self = this\n  if (!(self instanceof FileReader)) {\n    throw new Error('FileReader must be called as constructor.')\n  }\n\n  // should already be established as a File type\n  // XXX Todo: preserve hardlinks by tracking dev+inode+nlink,\n  // with a HardLinkReader class.\n  if (!((props.type === 'Link' && props.Link) ||\n    (props.type === 'File' && props.File))) {\n    throw new Error('Non-file type ' + props.type)\n  }\n\n  self._buffer = []\n  self._bytesEmitted = 0\n  Reader.call(self, props)\n}\n\nFileReader.prototype._getStream = function () {\n  var self = this\n  var stream = self._stream = fs.createReadStream(self._path, self.props)\n\n  if (self.props.blksize) {\n    stream.bufferSize = self.props.blksize\n  }\n\n  stream.on('open', self.emit.bind(self, 'open'))\n\n  stream.on('data', function (c) {\n    // console.error('\\t\\t%d %s', c.length, self.basename)\n    self._bytesEmitted += c.length\n    // no point saving empty chunks\n    if (!c.length) {\n      return\n    } else if (self._paused || self._buffer.length) {\n      self._buffer.push(c)\n      self._read()\n    } else self.emit('data', c)\n  })\n\n  stream.on('end', function () {\n    if (self._paused || self._buffer.length) {\n      // console.error('FR Buffering End', self._path)\n      self._buffer.push(EOF)\n      self._read()\n    } else {\n      self.emit('end')\n    }\n\n    if (self._bytesEmitted !== self.props.size) {\n      self.error(\"Didn't get expected byte count\\n\" +\n        'expect: ' + self.props.size + '\\n' +\n        'actual: ' + self._bytesEmitted)\n    }\n  })\n\n  stream.on('close', function () {\n    if (self._paused || self._buffer.length) {\n      // console.error('FR Buffering Close', self._path)\n      self._buffer.push(CLOSE)\n      self._read()\n    } else {\n      // console.error('FR close 1', self._path)\n      self.emit('close')\n    }\n  })\n\n  stream.on('error', function (e) {\n    self.emit('error', e)\n  })\n\n  self._read()\n}\n\nFileReader.prototype._read = function () {\n  var self = this\n  // console.error('FR _read', self._path)\n  if (self._paused) {\n    // console.error('FR _read paused', self._path)\n    return\n  }\n\n  if (!self._stream) {\n    // console.error('FR _getStream calling', self._path)\n    return self._getStream()\n  }\n\n  // clear out the buffer, if there is one.\n  if (self._buffer.length) {\n    // console.error('FR _read has buffer', self._buffer.length, self._path)\n    var buf = self._buffer\n    for (var i = 0, l = buf.length; i < l; i++) {\n      var c = buf[i]\n      if (c === EOF) {\n        // console.error('FR Read emitting buffered end', self._path)\n        self.emit('end')\n      } else if (c === CLOSE) {\n        // console.error('FR Read emitting buffered close', self._path)\n        self.emit('close')\n      } else {\n        // console.error('FR Read emitting buffered data', self._path)\n        self.emit('data', c)\n      }\n\n      if (self._paused) {\n        // console.error('FR Read Re-pausing at '+i, self._path)\n        self._buffer = buf.slice(i)\n        return\n      }\n    }\n    self._buffer.length = 0\n  }\n// console.error(\"FR _read done\")\n// that's about all there is to it.\n}\n\nFileReader.prototype.pause = function (who) {\n  var self = this\n  // console.error('FR Pause', self._path)\n  if (self._paused) return\n  who = who || self\n  self._paused = true\n  if (self._stream) self._stream.pause()\n  self.emit('pause', who)\n}\n\nFileReader.prototype.resume = function (who) {\n  var self = this\n  // console.error('FR Resume', self._path)\n  if (!self._paused) return\n  who = who || self\n  self.emit('resume', who)\n  self._paused = false\n  if (self._stream) self._stream.resume()\n  self._read()\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fstream/lib/file-reader.js?");

/***/ }),

/***/ "./node_modules/fstream/lib/file-writer.js":
/*!*************************************************!*\
  !*** ./node_modules/fstream/lib/file-writer.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = FileWriter\n\nvar fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nvar Writer = __webpack_require__(/*! ./writer.js */ \"./node_modules/fstream/lib/writer.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\")\nvar EOF = {}\n\ninherits(FileWriter, Writer)\n\nfunction FileWriter (props) {\n  var self = this\n  if (!(self instanceof FileWriter)) {\n    throw new Error('FileWriter must be called as constructor.')\n  }\n\n  // should already be established as a File type\n  if (props.type !== 'File' || !props.File) {\n    throw new Error('Non-file type ' + props.type)\n  }\n\n  self._buffer = []\n  self._bytesWritten = 0\n\n  Writer.call(this, props)\n}\n\nFileWriter.prototype._create = function () {\n  var self = this\n  if (self._stream) return\n\n  var so = {}\n  if (self.props.flags) so.flags = self.props.flags\n  so.mode = Writer.filemode\n  if (self._old && self._old.blksize) so.bufferSize = self._old.blksize\n\n  self._stream = fs.createWriteStream(self._path, so)\n\n  self._stream.on('open', function () {\n    // console.error(\"FW open\", self._buffer, self._path)\n    self.ready = true\n    self._buffer.forEach(function (c) {\n      if (c === EOF) self._stream.end()\n      else self._stream.write(c)\n    })\n    self.emit('ready')\n    // give this a kick just in case it needs it.\n    self.emit('drain')\n  })\n\n  self._stream.on('error', function (er) { self.emit('error', er) })\n\n  self._stream.on('drain', function () { self.emit('drain') })\n\n  self._stream.on('close', function () {\n    // console.error('\\n\\nFW Stream Close', self._path, self.size)\n    self._finish()\n  })\n}\n\nFileWriter.prototype.write = function (c) {\n  var self = this\n\n  self._bytesWritten += c.length\n\n  if (!self.ready) {\n    if (!Buffer.isBuffer(c) && typeof c !== 'string') {\n      throw new Error('invalid write data')\n    }\n    self._buffer.push(c)\n    return false\n  }\n\n  var ret = self._stream.write(c)\n  // console.error('\\t-- fw wrote, _stream says', ret, self._stream._queue.length)\n\n  // allow 2 buffered writes, because otherwise there's just too\n  // much stop and go bs.\n  if (ret === false && self._stream._queue) {\n    return self._stream._queue.length <= 2\n  } else {\n    return ret\n  }\n}\n\nFileWriter.prototype.end = function (c) {\n  var self = this\n\n  if (c) self.write(c)\n\n  if (!self.ready) {\n    self._buffer.push(EOF)\n    return false\n  }\n\n  return self._stream.end()\n}\n\nFileWriter.prototype._finish = function () {\n  var self = this\n  if (typeof self.size === 'number' && self._bytesWritten !== self.size) {\n    self.error(\n      'Did not get expected byte count.\\n' +\n      'expect: ' + self.size + '\\n' +\n      'actual: ' + self._bytesWritten)\n  }\n  Writer.prototype._finish.call(self)\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fstream/lib/file-writer.js?");

/***/ }),

/***/ "./node_modules/fstream/lib/get-type.js":
/*!**********************************************!*\
  !*** ./node_modules/fstream/lib/get-type.js ***!
  \**********************************************/
/***/ ((module) => {

eval("module.exports = getType\n\nfunction getType (st) {\n  var types = [\n    'Directory',\n    'File',\n    'SymbolicLink',\n    'Link', // special for hardlinks from tarballs\n    'BlockDevice',\n    'CharacterDevice',\n    'FIFO',\n    'Socket'\n  ]\n  var type\n\n  if (st.type && types.indexOf(st.type) !== -1) {\n    st[st.type] = true\n    return st.type\n  }\n\n  for (var i = 0, l = types.length; i < l; i++) {\n    type = types[i]\n    var is = st[type] || st['is' + type]\n    if (typeof is === 'function') is = is.call(st)\n    if (is) {\n      st[type] = true\n      st.type = type\n      return type\n    }\n  }\n\n  return null\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fstream/lib/get-type.js?");

/***/ }),

/***/ "./node_modules/fstream/lib/link-reader.js":
/*!*************************************************!*\
  !*** ./node_modules/fstream/lib/link-reader.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Basically just a wrapper around an fs.readlink\n//\n// XXX: Enhance this to support the Link type, by keeping\n// a lookup table of {<dev+inode>:<path>}, so that hardlinks\n// can be preserved in tarballs.\n\nmodule.exports = LinkReader\n\nvar fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\")\nvar Reader = __webpack_require__(/*! ./reader.js */ \"./node_modules/fstream/lib/reader.js\")\n\ninherits(LinkReader, Reader)\n\nfunction LinkReader (props) {\n  var self = this\n  if (!(self instanceof LinkReader)) {\n    throw new Error('LinkReader must be called as constructor.')\n  }\n\n  if (!((props.type === 'Link' && props.Link) ||\n    (props.type === 'SymbolicLink' && props.SymbolicLink))) {\n    throw new Error('Non-link type ' + props.type)\n  }\n\n  Reader.call(self, props)\n}\n\n// When piping a LinkReader into a LinkWriter, we have to\n// already have the linkpath property set, so that has to\n// happen *before* the \"ready\" event, which means we need to\n// override the _stat method.\nLinkReader.prototype._stat = function (currentStat) {\n  var self = this\n  fs.readlink(self._path, function (er, linkpath) {\n    if (er) return self.error(er)\n    self.linkpath = self.props.linkpath = linkpath\n    self.emit('linkpath', linkpath)\n    Reader.prototype._stat.call(self, currentStat)\n  })\n}\n\nLinkReader.prototype._read = function () {\n  var self = this\n  if (self._paused) return\n  // basically just a no-op, since we got all the info we need\n  // from the _stat method\n  if (!self._ended) {\n    self.emit('end')\n    self.emit('close')\n    self._ended = true\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fstream/lib/link-reader.js?");

/***/ }),

/***/ "./node_modules/fstream/lib/link-writer.js":
/*!*************************************************!*\
  !*** ./node_modules/fstream/lib/link-writer.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = LinkWriter\n\nvar fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nvar Writer = __webpack_require__(/*! ./writer.js */ \"./node_modules/fstream/lib/writer.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar rimraf = __webpack_require__(/*! rimraf */ \"./node_modules/fstream/node_modules/rimraf/rimraf.js\")\n\ninherits(LinkWriter, Writer)\n\nfunction LinkWriter (props) {\n  var self = this\n  if (!(self instanceof LinkWriter)) {\n    throw new Error('LinkWriter must be called as constructor.')\n  }\n\n  // should already be established as a Link type\n  if (!((props.type === 'Link' && props.Link) ||\n    (props.type === 'SymbolicLink' && props.SymbolicLink))) {\n    throw new Error('Non-link type ' + props.type)\n  }\n\n  if (props.linkpath === '') props.linkpath = '.'\n  if (!props.linkpath) {\n    self.error('Need linkpath property to create ' + props.type)\n  }\n\n  Writer.call(this, props)\n}\n\nLinkWriter.prototype._create = function () {\n  // console.error(\" LW _create\")\n  var self = this\n  var hard = self.type === 'Link' || process.platform === 'win32'\n  var link = hard ? 'link' : 'symlink'\n  var lp = hard ? path.resolve(self.dirname, self.linkpath) : self.linkpath\n\n  // can only change the link path by clobbering\n  // For hard links, let's just assume that's always the case, since\n  // there's no good way to read them if we don't already know.\n  if (hard) return clobber(self, lp, link)\n\n  fs.readlink(self._path, function (er, p) {\n    // only skip creation if it's exactly the same link\n    if (p && p === lp) return finish(self)\n    clobber(self, lp, link)\n  })\n}\n\nfunction clobber (self, lp, link) {\n  rimraf(self._path, function (er) {\n    if (er) return self.error(er)\n    create(self, lp, link)\n  })\n}\n\nfunction create (self, lp, link) {\n  fs[link](lp, self._path, function (er) {\n    // if this is a hard link, and we're in the process of writing out a\n    // directory, it's very possible that the thing we're linking to\n    // doesn't exist yet (especially if it was intended as a symlink),\n    // so swallow ENOENT errors here and just soldier in.\n    // Additionally, an EPERM or EACCES can happen on win32 if it's trying\n    // to make a link to a directory.  Again, just skip it.\n    // A better solution would be to have fs.symlink be supported on\n    // windows in some nice fashion.\n    if (er) {\n      if ((er.code === 'ENOENT' ||\n        er.code === 'EACCES' ||\n        er.code === 'EPERM') && process.platform === 'win32') {\n        self.ready = true\n        self.emit('ready')\n        self.emit('end')\n        self.emit('close')\n        self.end = self._finish = function () {}\n      } else return self.error(er)\n    }\n    finish(self)\n  })\n}\n\nfunction finish (self) {\n  self.ready = true\n  self.emit('ready')\n  if (self._ended && !self._finished) self._finish()\n}\n\nLinkWriter.prototype.end = function () {\n  // console.error(\"LW finish in end\")\n  this._ended = true\n  if (this.ready) {\n    this._finished = true\n    this._finish()\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fstream/lib/link-writer.js?");

/***/ }),

/***/ "./node_modules/fstream/lib/proxy-reader.js":
/*!**************************************************!*\
  !*** ./node_modules/fstream/lib/proxy-reader.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// A reader for when we don't yet know what kind of thing\n// the thing is.\n\nmodule.exports = ProxyReader\n\nvar Reader = __webpack_require__(/*! ./reader.js */ \"./node_modules/fstream/lib/reader.js\")\nvar getType = __webpack_require__(/*! ./get-type.js */ \"./node_modules/fstream/lib/get-type.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\")\nvar fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\n\ninherits(ProxyReader, Reader)\n\nfunction ProxyReader (props) {\n  var self = this\n  if (!(self instanceof ProxyReader)) {\n    throw new Error('ProxyReader must be called as constructor.')\n  }\n\n  self.props = props\n  self._buffer = []\n  self.ready = false\n\n  Reader.call(self, props)\n}\n\nProxyReader.prototype._stat = function () {\n  var self = this\n  var props = self.props\n  // stat the thing to see what the proxy should be.\n  var stat = props.follow ? 'stat' : 'lstat'\n\n  fs[stat](props.path, function (er, current) {\n    var type\n    if (er || !current) {\n      type = 'File'\n    } else {\n      type = getType(current)\n    }\n\n    props[type] = true\n    props.type = self.type = type\n\n    self._old = current\n    self._addProxy(Reader(props, current))\n  })\n}\n\nProxyReader.prototype._addProxy = function (proxy) {\n  var self = this\n  if (self._proxyTarget) {\n    return self.error('proxy already set')\n  }\n\n  self._proxyTarget = proxy\n  proxy._proxy = self\n\n  ;[\n    'error',\n    'data',\n    'end',\n    'close',\n    'linkpath',\n    'entry',\n    'entryEnd',\n    'child',\n    'childEnd',\n    'warn',\n    'stat'\n  ].forEach(function (ev) {\n    // console.error('~~ proxy event', ev, self.path)\n    proxy.on(ev, self.emit.bind(self, ev))\n  })\n\n  self.emit('proxy', proxy)\n\n  proxy.on('ready', function () {\n    // console.error(\"~~ proxy is ready!\", self.path)\n    self.ready = true\n    self.emit('ready')\n  })\n\n  var calls = self._buffer\n  self._buffer.length = 0\n  calls.forEach(function (c) {\n    proxy[c[0]].apply(proxy, c[1])\n  })\n}\n\nProxyReader.prototype.pause = function () {\n  return this._proxyTarget ? this._proxyTarget.pause() : false\n}\n\nProxyReader.prototype.resume = function () {\n  return this._proxyTarget ? this._proxyTarget.resume() : false\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fstream/lib/proxy-reader.js?");

/***/ }),

/***/ "./node_modules/fstream/lib/proxy-writer.js":
/*!**************************************************!*\
  !*** ./node_modules/fstream/lib/proxy-writer.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// A writer for when we don't know what kind of thing\n// the thing is.  That is, it's not explicitly set,\n// so we're going to make it whatever the thing already\n// is, or \"File\"\n//\n// Until then, collect all events.\n\nmodule.exports = ProxyWriter\n\nvar Writer = __webpack_require__(/*! ./writer.js */ \"./node_modules/fstream/lib/writer.js\")\nvar getType = __webpack_require__(/*! ./get-type.js */ \"./node_modules/fstream/lib/get-type.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\")\nvar collect = __webpack_require__(/*! ./collect.js */ \"./node_modules/fstream/lib/collect.js\")\nvar fs = __webpack_require__(/*! fs */ \"fs\")\n\ninherits(ProxyWriter, Writer)\n\nfunction ProxyWriter (props) {\n  var self = this\n  if (!(self instanceof ProxyWriter)) {\n    throw new Error('ProxyWriter must be called as constructor.')\n  }\n\n  self.props = props\n  self._needDrain = false\n\n  Writer.call(self, props)\n}\n\nProxyWriter.prototype._stat = function () {\n  var self = this\n  var props = self.props\n  // stat the thing to see what the proxy should be.\n  var stat = props.follow ? 'stat' : 'lstat'\n\n  fs[stat](props.path, function (er, current) {\n    var type\n    if (er || !current) {\n      type = 'File'\n    } else {\n      type = getType(current)\n    }\n\n    props[type] = true\n    props.type = self.type = type\n\n    self._old = current\n    self._addProxy(Writer(props, current))\n  })\n}\n\nProxyWriter.prototype._addProxy = function (proxy) {\n  // console.error(\"~~ set proxy\", this.path)\n  var self = this\n  if (self._proxy) {\n    return self.error('proxy already set')\n  }\n\n  self._proxy = proxy\n  ;[\n    'ready',\n    'error',\n    'close',\n    'pipe',\n    'drain',\n    'warn'\n  ].forEach(function (ev) {\n    proxy.on(ev, self.emit.bind(self, ev))\n  })\n\n  self.emit('proxy', proxy)\n\n  var calls = self._buffer\n  calls.forEach(function (c) {\n    // console.error(\"~~ ~~ proxy buffered call\", c[0], c[1])\n    proxy[c[0]].apply(proxy, c[1])\n  })\n  self._buffer.length = 0\n  if (self._needsDrain) self.emit('drain')\n}\n\nProxyWriter.prototype.add = function (entry) {\n  // console.error(\"~~ proxy add\")\n  collect(entry)\n\n  if (!this._proxy) {\n    this._buffer.push(['add', [entry]])\n    this._needDrain = true\n    return false\n  }\n  return this._proxy.add(entry)\n}\n\nProxyWriter.prototype.write = function (c) {\n  // console.error('~~ proxy write')\n  if (!this._proxy) {\n    this._buffer.push(['write', [c]])\n    this._needDrain = true\n    return false\n  }\n  return this._proxy.write(c)\n}\n\nProxyWriter.prototype.end = function (c) {\n  // console.error('~~ proxy end')\n  if (!this._proxy) {\n    this._buffer.push(['end', [c]])\n    return false\n  }\n  return this._proxy.end(c)\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fstream/lib/proxy-writer.js?");

/***/ }),

/***/ "./node_modules/fstream/lib/reader.js":
/*!********************************************!*\
  !*** ./node_modules/fstream/lib/reader.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = Reader\n\nvar fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nvar Stream = __webpack_require__(/*! stream */ \"stream\").Stream\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar getType = __webpack_require__(/*! ./get-type.js */ \"./node_modules/fstream/lib/get-type.js\")\nvar hardLinks = Reader.hardLinks = {}\nvar Abstract = __webpack_require__(/*! ./abstract.js */ \"./node_modules/fstream/lib/abstract.js\")\n\n// Must do this *before* loading the child classes\ninherits(Reader, Abstract)\n\nvar LinkReader = __webpack_require__(/*! ./link-reader.js */ \"./node_modules/fstream/lib/link-reader.js\")\n\nfunction Reader (props, currentStat) {\n  var self = this\n  if (!(self instanceof Reader)) return new Reader(props, currentStat)\n\n  if (typeof props === 'string') {\n    props = { path: props }\n  }\n\n  // polymorphism.\n  // call fstream.Reader(dir) to get a DirReader object, etc.\n  // Note that, unlike in the Writer case, ProxyReader is going\n  // to be the *normal* state of affairs, since we rarely know\n  // the type of a file prior to reading it.\n\n  var type\n  var ClassType\n\n  if (props.type && typeof props.type === 'function') {\n    type = props.type\n    ClassType = type\n  } else {\n    type = getType(props)\n    ClassType = Reader\n  }\n\n  if (currentStat && !type) {\n    type = getType(currentStat)\n    props[type] = true\n    props.type = type\n  }\n\n  switch (type) {\n    case 'Directory':\n      ClassType = __webpack_require__(/*! ./dir-reader.js */ \"./node_modules/fstream/lib/dir-reader.js\")\n      break\n\n    case 'Link':\n    // XXX hard links are just files.\n    // However, it would be good to keep track of files' dev+inode\n    // and nlink values, and create a HardLinkReader that emits\n    // a linkpath value of the original copy, so that the tar\n    // writer can preserve them.\n    // ClassType = HardLinkReader\n    // break\n\n    case 'File':\n      ClassType = __webpack_require__(/*! ./file-reader.js */ \"./node_modules/fstream/lib/file-reader.js\")\n      break\n\n    case 'SymbolicLink':\n      ClassType = LinkReader\n      break\n\n    case 'Socket':\n      ClassType = __webpack_require__(/*! ./socket-reader.js */ \"./node_modules/fstream/lib/socket-reader.js\")\n      break\n\n    case null:\n      ClassType = __webpack_require__(/*! ./proxy-reader.js */ \"./node_modules/fstream/lib/proxy-reader.js\")\n      break\n  }\n\n  if (!(self instanceof ClassType)) {\n    return new ClassType(props)\n  }\n\n  Abstract.call(self)\n\n  if (!props.path) {\n    self.error('Must provide a path', null, true)\n  }\n\n  self.readable = true\n  self.writable = false\n\n  self.type = type\n  self.props = props\n  self.depth = props.depth = props.depth || 0\n  self.parent = props.parent || null\n  self.root = props.root || (props.parent && props.parent.root) || self\n\n  self._path = self.path = path.resolve(props.path)\n  if (process.platform === 'win32') {\n    self.path = self._path = self.path.replace(/\\?/g, '_')\n    if (self._path.length >= 260) {\n      // how DOES one create files on the moon?\n      // if the path has spaces in it, then UNC will fail.\n      self._swallowErrors = true\n      // if (self._path.indexOf(\" \") === -1) {\n      self._path = '\\\\\\\\?\\\\' + self.path.replace(/\\//g, '\\\\')\n    // }\n    }\n  }\n  self.basename = props.basename = path.basename(self.path)\n  self.dirname = props.dirname = path.dirname(self.path)\n\n  // these have served their purpose, and are now just noisy clutter\n  props.parent = props.root = null\n\n  // console.error(\"\\n\\n\\n%s setting size to\", props.path, props.size)\n  self.size = props.size\n  self.filter = typeof props.filter === 'function' ? props.filter : null\n  if (props.sort === 'alpha') props.sort = alphasort\n\n  // start the ball rolling.\n  // this will stat the thing, and then call self._read()\n  // to start reading whatever it is.\n  // console.error(\"calling stat\", props.path, currentStat)\n  self._stat(currentStat)\n}\n\nfunction alphasort (a, b) {\n  return a === b ? 0\n    : a.toLowerCase() > b.toLowerCase() ? 1\n      : a.toLowerCase() < b.toLowerCase() ? -1\n        : a > b ? 1\n          : -1\n}\n\nReader.prototype._stat = function (currentStat) {\n  var self = this\n  var props = self.props\n  var stat = props.follow ? 'stat' : 'lstat'\n  // console.error(\"Reader._stat\", self._path, currentStat)\n  if (currentStat) process.nextTick(statCb.bind(null, null, currentStat))\n  else fs[stat](self._path, statCb)\n\n  function statCb (er, props_) {\n    // console.error(\"Reader._stat, statCb\", self._path, props_, props_.nlink)\n    if (er) return self.error(er)\n\n    Object.keys(props_).forEach(function (k) {\n      props[k] = props_[k]\n    })\n\n    // if it's not the expected size, then abort here.\n    if (undefined !== self.size && props.size !== self.size) {\n      return self.error('incorrect size')\n    }\n    self.size = props.size\n\n    var type = getType(props)\n    var handleHardlinks = props.hardlinks !== false\n\n    // special little thing for handling hardlinks.\n    if (handleHardlinks && type !== 'Directory' && props.nlink && props.nlink > 1) {\n      var k = props.dev + ':' + props.ino\n      // console.error(\"Reader has nlink\", self._path, k)\n      if (hardLinks[k] === self._path || !hardLinks[k]) {\n        hardLinks[k] = self._path\n      } else {\n        // switch into hardlink mode.\n        type = self.type = self.props.type = 'Link'\n        self.Link = self.props.Link = true\n        self.linkpath = self.props.linkpath = hardLinks[k]\n        // console.error(\"Hardlink detected, switching mode\", self._path, self.linkpath)\n        // Setting __proto__ would arguably be the \"correct\"\n        // approach here, but that just seems too wrong.\n        self._stat = self._read = LinkReader.prototype._read\n      }\n    }\n\n    if (self.type && self.type !== type) {\n      self.error('Unexpected type: ' + type)\n    }\n\n    // if the filter doesn't pass, then just skip over this one.\n    // still have to emit end so that dir-walking can move on.\n    if (self.filter) {\n      var who = self._proxy || self\n      // special handling for ProxyReaders\n      if (!self.filter.call(who, who, props)) {\n        if (!self._disowned) {\n          self.abort()\n          self.emit('end')\n          self.emit('close')\n        }\n        return\n      }\n    }\n\n    // last chance to abort or disown before the flow starts!\n    var events = ['_stat', 'stat', 'ready']\n    var e = 0\n    ;(function go () {\n      if (self._aborted) {\n        self.emit('end')\n        self.emit('close')\n        return\n      }\n\n      if (self._paused && self.type !== 'Directory') {\n        self.once('resume', go)\n        return\n      }\n\n      var ev = events[e++]\n      if (!ev) {\n        return self._read()\n      }\n      self.emit(ev, props)\n      go()\n    })()\n  }\n}\n\nReader.prototype.pipe = function (dest) {\n  var self = this\n  if (typeof dest.add === 'function') {\n    // piping to a multi-compatible, and we've got directory entries.\n    self.on('entry', function (entry) {\n      var ret = dest.add(entry)\n      if (ret === false) {\n        self.pause()\n      }\n    })\n  }\n\n  // console.error(\"R Pipe apply Stream Pipe\")\n  return Stream.prototype.pipe.apply(this, arguments)\n}\n\nReader.prototype.pause = function (who) {\n  this._paused = true\n  who = who || this\n  this.emit('pause', who)\n  if (this._stream) this._stream.pause(who)\n}\n\nReader.prototype.resume = function (who) {\n  this._paused = false\n  who = who || this\n  this.emit('resume', who)\n  if (this._stream) this._stream.resume(who)\n  this._read()\n}\n\nReader.prototype._read = function () {\n  this.error('Cannot read unknown type: ' + this.type)\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fstream/lib/reader.js?");

/***/ }),

/***/ "./node_modules/fstream/lib/socket-reader.js":
/*!***************************************************!*\
  !*** ./node_modules/fstream/lib/socket-reader.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Just get the stats, and then don't do anything.\n// You can't really \"read\" from a socket.  You \"connect\" to it.\n// Mostly, this is here so that reading a dir with a socket in it\n// doesn't blow up.\n\nmodule.exports = SocketReader\n\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\")\nvar Reader = __webpack_require__(/*! ./reader.js */ \"./node_modules/fstream/lib/reader.js\")\n\ninherits(SocketReader, Reader)\n\nfunction SocketReader (props) {\n  var self = this\n  if (!(self instanceof SocketReader)) {\n    throw new Error('SocketReader must be called as constructor.')\n  }\n\n  if (!(props.type === 'Socket' && props.Socket)) {\n    throw new Error('Non-socket type ' + props.type)\n  }\n\n  Reader.call(self, props)\n}\n\nSocketReader.prototype._read = function () {\n  var self = this\n  if (self._paused) return\n  // basically just a no-op, since we got all the info we have\n  // from the _stat method\n  if (!self._ended) {\n    self.emit('end')\n    self.emit('close')\n    self._ended = true\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fstream/lib/socket-reader.js?");

/***/ }),

/***/ "./node_modules/fstream/lib/writer.js":
/*!********************************************!*\
  !*** ./node_modules/fstream/lib/writer.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = Writer\n\nvar fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\")\nvar rimraf = __webpack_require__(/*! rimraf */ \"./node_modules/fstream/node_modules/rimraf/rimraf.js\")\nvar mkdir = __webpack_require__(/*! mkdirp */ \"./node_modules/fstream/node_modules/mkdirp/index.js\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar umask = process.platform === 'win32' ? 0 : process.umask()\nvar getType = __webpack_require__(/*! ./get-type.js */ \"./node_modules/fstream/lib/get-type.js\")\nvar Abstract = __webpack_require__(/*! ./abstract.js */ \"./node_modules/fstream/lib/abstract.js\")\n\n// Must do this *before* loading the child classes\ninherits(Writer, Abstract)\n\nWriter.dirmode = parseInt('0777', 8) & (~umask)\nWriter.filemode = parseInt('0666', 8) & (~umask)\n\nvar DirWriter = __webpack_require__(/*! ./dir-writer.js */ \"./node_modules/fstream/lib/dir-writer.js\")\nvar LinkWriter = __webpack_require__(/*! ./link-writer.js */ \"./node_modules/fstream/lib/link-writer.js\")\nvar FileWriter = __webpack_require__(/*! ./file-writer.js */ \"./node_modules/fstream/lib/file-writer.js\")\nvar ProxyWriter = __webpack_require__(/*! ./proxy-writer.js */ \"./node_modules/fstream/lib/proxy-writer.js\")\n\n// props is the desired state.  current is optionally the current stat,\n// provided here so that subclasses can avoid statting the target\n// more than necessary.\nfunction Writer (props, current) {\n  var self = this\n\n  if (typeof props === 'string') {\n    props = { path: props }\n  }\n\n  // polymorphism.\n  // call fstream.Writer(dir) to get a DirWriter object, etc.\n  var type = getType(props)\n  var ClassType = Writer\n\n  switch (type) {\n    case 'Directory':\n      ClassType = DirWriter\n      break\n    case 'File':\n      ClassType = FileWriter\n      break\n    case 'Link':\n    case 'SymbolicLink':\n      ClassType = LinkWriter\n      break\n    case null:\n    default:\n      // Don't know yet what type to create, so we wrap in a proxy.\n      ClassType = ProxyWriter\n      break\n  }\n\n  if (!(self instanceof ClassType)) return new ClassType(props)\n\n  // now get down to business.\n\n  Abstract.call(self)\n\n  if (!props.path) self.error('Must provide a path', null, true)\n\n  // props is what we want to set.\n  // set some convenience properties as well.\n  self.type = props.type\n  self.props = props\n  self.depth = props.depth || 0\n  self.clobber = props.clobber === false ? props.clobber : true\n  self.parent = props.parent || null\n  self.root = props.root || (props.parent && props.parent.root) || self\n\n  self._path = self.path = path.resolve(props.path)\n  if (process.platform === 'win32') {\n    self.path = self._path = self.path.replace(/\\?/g, '_')\n    if (self._path.length >= 260) {\n      self._swallowErrors = true\n      self._path = '\\\\\\\\?\\\\' + self.path.replace(/\\//g, '\\\\')\n    }\n  }\n  self.basename = path.basename(props.path)\n  self.dirname = path.dirname(props.path)\n  self.linkpath = props.linkpath || null\n\n  props.parent = props.root = null\n\n  // console.error(\"\\n\\n\\n%s setting size to\", props.path, props.size)\n  self.size = props.size\n\n  if (typeof props.mode === 'string') {\n    props.mode = parseInt(props.mode, 8)\n  }\n\n  self.readable = false\n  self.writable = true\n\n  // buffer until ready, or while handling another entry\n  self._buffer = []\n  self.ready = false\n\n  self.filter = typeof props.filter === 'function' ? props.filter : null\n\n  // start the ball rolling.\n  // this checks what's there already, and then calls\n  // self._create() to call the impl-specific creation stuff.\n  self._stat(current)\n}\n\n// Calling this means that it's something we can't create.\n// Just assert that it's already there, otherwise raise a warning.\nWriter.prototype._create = function () {\n  var self = this\n  fs[self.props.follow ? 'stat' : 'lstat'](self._path, function (er) {\n    if (er) {\n      return self.warn('Cannot create ' + self._path + '\\n' +\n        'Unsupported type: ' + self.type, 'ENOTSUP')\n    }\n    self._finish()\n  })\n}\n\nWriter.prototype._stat = function (current) {\n  var self = this\n  var props = self.props\n  var stat = props.follow ? 'stat' : 'lstat'\n  var who = self._proxy || self\n\n  if (current) statCb(null, current)\n  else fs[stat](self._path, statCb)\n\n  function statCb (er, current) {\n    if (self.filter && !self.filter.call(who, who, current)) {\n      self._aborted = true\n      self.emit('end')\n      self.emit('close')\n      return\n    }\n\n    // if it's not there, great.  We'll just create it.\n    // if it is there, then we'll need to change whatever differs\n    if (er || !current) {\n      return create(self)\n    }\n\n    self._old = current\n    var currentType = getType(current)\n\n    // if it's a type change, then we need to clobber or error.\n    // if it's not a type change, then let the impl take care of it.\n    if (currentType !== self.type || self.type === 'File' && current.nlink > 1) {\n      return rimraf(self._path, function (er) {\n        if (er) return self.error(er)\n        self._old = null\n        create(self)\n      })\n    }\n\n    // otherwise, just handle in the app-specific way\n    // this creates a fs.WriteStream, or mkdir's, or whatever\n    create(self)\n  }\n}\n\nfunction create (self) {\n  // console.error(\"W create\", self._path, Writer.dirmode)\n\n  // XXX Need to clobber non-dirs that are in the way,\n  // unless { clobber: false } in the props.\n  mkdir(path.dirname(self._path), Writer.dirmode, function (er, made) {\n    // console.error(\"W created\", path.dirname(self._path), er)\n    if (er) return self.error(er)\n\n    // later on, we have to set the mode and owner for these\n    self._madeDir = made\n    return self._create()\n  })\n}\n\nfunction endChmod (self, want, current, path, cb) {\n  var wantMode = want.mode\n  var chmod = want.follow || self.type !== 'SymbolicLink'\n    ? 'chmod' : 'lchmod'\n\n  if (!fs[chmod]) return cb()\n  if (typeof wantMode !== 'number') return cb()\n\n  var curMode = current.mode & parseInt('0777', 8)\n  wantMode = wantMode & parseInt('0777', 8)\n  if (wantMode === curMode) return cb()\n\n  fs[chmod](path, wantMode, cb)\n}\n\nfunction endChown (self, want, current, path, cb) {\n  // Don't even try it unless root.  Too easy to EPERM.\n  if (process.platform === 'win32') return cb()\n  if (!process.getuid || process.getuid() !== 0) return cb()\n  if (typeof want.uid !== 'number' &&\n    typeof want.gid !== 'number') return cb()\n\n  if (current.uid === want.uid &&\n    current.gid === want.gid) return cb()\n\n  var chown = (self.props.follow || self.type !== 'SymbolicLink')\n    ? 'chown' : 'lchown'\n  if (!fs[chown]) return cb()\n\n  if (typeof want.uid !== 'number') want.uid = current.uid\n  if (typeof want.gid !== 'number') want.gid = current.gid\n\n  fs[chown](path, want.uid, want.gid, cb)\n}\n\nfunction endUtimes (self, want, current, path, cb) {\n  if (!fs.utimes || process.platform === 'win32') return cb()\n\n  var utimes = (want.follow || self.type !== 'SymbolicLink')\n    ? 'utimes' : 'lutimes'\n\n  if (utimes === 'lutimes' && !fs[utimes]) {\n    utimes = 'utimes'\n  }\n\n  if (!fs[utimes]) return cb()\n\n  var curA = current.atime\n  var curM = current.mtime\n  var meA = want.atime\n  var meM = want.mtime\n\n  if (meA === undefined) meA = curA\n  if (meM === undefined) meM = curM\n\n  if (!isDate(meA)) meA = new Date(meA)\n  if (!isDate(meM)) meA = new Date(meM)\n\n  if (meA.getTime() === curA.getTime() &&\n    meM.getTime() === curM.getTime()) return cb()\n\n  fs[utimes](path, meA, meM, cb)\n}\n\n// XXX This function is beastly.  Break it up!\nWriter.prototype._finish = function () {\n  var self = this\n\n  if (self._finishing) return\n  self._finishing = true\n\n  // console.error(\" W Finish\", self._path, self.size)\n\n  // set up all the things.\n  // At this point, we're already done writing whatever we've gotta write,\n  // adding files to the dir, etc.\n  var todo = 0\n  var errState = null\n  var done = false\n\n  if (self._old) {\n    // the times will almost *certainly* have changed.\n    // adds the utimes syscall, but remove another stat.\n    self._old.atime = new Date(0)\n    self._old.mtime = new Date(0)\n    // console.error(\" W Finish Stale Stat\", self._path, self.size)\n    setProps(self._old)\n  } else {\n    var stat = self.props.follow ? 'stat' : 'lstat'\n    // console.error(\" W Finish Stating\", self._path, self.size)\n    fs[stat](self._path, function (er, current) {\n      // console.error(\" W Finish Stated\", self._path, self.size, current)\n      if (er) {\n        // if we're in the process of writing out a\n        // directory, it's very possible that the thing we're linking to\n        // doesn't exist yet (especially if it was intended as a symlink),\n        // so swallow ENOENT errors here and just soldier on.\n        if (er.code === 'ENOENT' &&\n          (self.type === 'Link' || self.type === 'SymbolicLink') &&\n          process.platform === 'win32') {\n          self.ready = true\n          self.emit('ready')\n          self.emit('end')\n          self.emit('close')\n          self.end = self._finish = function () {}\n          return\n        } else return self.error(er)\n      }\n      setProps(self._old = current)\n    })\n  }\n\n  return\n\n  function setProps (current) {\n    todo += 3\n    endChmod(self, self.props, current, self._path, next('chmod'))\n    endChown(self, self.props, current, self._path, next('chown'))\n    endUtimes(self, self.props, current, self._path, next('utimes'))\n  }\n\n  function next (what) {\n    return function (er) {\n      // console.error(\"   W Finish\", what, todo)\n      if (errState) return\n      if (er) {\n        er.fstream_finish_call = what\n        return self.error(errState = er)\n      }\n      if (--todo > 0) return\n      if (done) return\n      done = true\n\n      // we may still need to set the mode/etc. on some parent dirs\n      // that were created previously.  delay end/close until then.\n      if (!self._madeDir) return end()\n      else endMadeDir(self, self._path, end)\n\n      function end (er) {\n        if (er) {\n          er.fstream_finish_call = 'setupMadeDir'\n          return self.error(er)\n        }\n        // all the props have been set, so we're completely done.\n        self.emit('end')\n        self.emit('close')\n      }\n    }\n  }\n}\n\nfunction endMadeDir (self, p, cb) {\n  var made = self._madeDir\n  // everything *between* made and path.dirname(self._path)\n  // needs to be set up.  Note that this may just be one dir.\n  var d = path.dirname(p)\n\n  endMadeDir_(self, d, function (er) {\n    if (er) return cb(er)\n    if (d === made) {\n      return cb()\n    }\n    endMadeDir(self, d, cb)\n  })\n}\n\nfunction endMadeDir_ (self, p, cb) {\n  var dirProps = {}\n  Object.keys(self.props).forEach(function (k) {\n    dirProps[k] = self.props[k]\n\n    // only make non-readable dirs if explicitly requested.\n    if (k === 'mode' && self.type !== 'Directory') {\n      dirProps[k] = dirProps[k] | parseInt('0111', 8)\n    }\n  })\n\n  var todo = 3\n  var errState = null\n  fs.stat(p, function (er, current) {\n    if (er) return cb(errState = er)\n    endChmod(self, dirProps, current, p, next)\n    endChown(self, dirProps, current, p, next)\n    endUtimes(self, dirProps, current, p, next)\n  })\n\n  function next (er) {\n    if (errState) return\n    if (er) return cb(errState = er)\n    if (--todo === 0) return cb()\n  }\n}\n\nWriter.prototype.pipe = function () {\n  this.error(\"Can't pipe from writable stream\")\n}\n\nWriter.prototype.add = function () {\n  this.error(\"Can't add to non-Directory type\")\n}\n\nWriter.prototype.write = function () {\n  return true\n}\n\nfunction objectToString (d) {\n  return Object.prototype.toString.call(d)\n}\n\nfunction isDate (d) {\n  return typeof d === 'object' && objectToString(d) === '[object Date]'\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fstream/lib/writer.js?");

/***/ }),

/***/ "./node_modules/fstream/node_modules/mkdirp/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/fstream/node_modules/mkdirp/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var path = __webpack_require__(/*! path */ \"path\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                if (path.dirname(p) === p) return cb(er);\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fstream/node_modules/mkdirp/index.js?");

/***/ }),

/***/ "./node_modules/fstream/node_modules/rimraf/rimraf.js":
/*!************************************************************!*\
  !*** ./node_modules/fstream/node_modules/rimraf/rimraf.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = rimraf\nrimraf.sync = rimrafSync\n\nvar assert = __webpack_require__(/*! assert */ \"assert\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar glob = undefined\ntry {\n  glob = __webpack_require__(/*! glob */ \"./node_modules/glob/glob.js\")\n} catch (_err) {\n  // treat glob as optional.\n}\nvar _0666 = parseInt('666', 8)\n\nvar defaultGlobOpts = {\n  nosort: true,\n  silent: true\n}\n\n// for EMFILE handling\nvar timeout = 0\n\nvar isWindows = (process.platform === \"win32\")\n\nfunction defaults (options) {\n  var methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(function(m) {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n  options.emfileWait = options.emfileWait || 1000\n  if (options.glob === false) {\n    options.disableGlob = true\n  }\n  if (options.disableGlob !== true && glob === undefined) {\n    throw Error('glob dependency not found, set `options.disableGlob = true` if intentional')\n  }\n  options.disableGlob = options.disableGlob || false\n  options.glob = options.glob || defaultGlobOpts\n}\n\nfunction rimraf (p, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert.equal(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  var busyTries = 0\n  var errState = null\n  var n = 0\n\n  if (options.disableGlob || !glob.hasMagic(p))\n    return afterGlob(null, [p])\n\n  options.lstat(p, function (er, stat) {\n    if (!er)\n      return afterGlob(null, [p])\n\n    glob(p, options.glob, afterGlob)\n  })\n\n  function next (er) {\n    errState = errState || er\n    if (--n === 0)\n      cb(errState)\n  }\n\n  function afterGlob (er, results) {\n    if (er)\n      return cb(er)\n\n    n = results.length\n    if (n === 0)\n      return cb()\n\n    results.forEach(function (p) {\n      rimraf_(p, options, function CB (er) {\n        if (er) {\n          if ((er.code === \"EBUSY\" || er.code === \"ENOTEMPTY\" || er.code === \"EPERM\") &&\n              busyTries < options.maxBusyTries) {\n            busyTries ++\n            var time = busyTries * 100\n            // try again, with the same exact callback as this one.\n            return setTimeout(function () {\n              rimraf_(p, options, CB)\n            }, time)\n          }\n\n          // this one won't happen if graceful-fs is used.\n          if (er.code === \"EMFILE\" && timeout < options.emfileWait) {\n            return setTimeout(function () {\n              rimraf_(p, options, CB)\n            }, timeout ++)\n          }\n\n          // already gone\n          if (er.code === \"ENOENT\") er = null\n        }\n\n        timeout = 0\n        next(er)\n      })\n    })\n  }\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, function (er, st) {\n    if (er && er.code === \"ENOENT\")\n      return cb(null)\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === \"EPERM\" && isWindows)\n      fixWinEPERM(p, options, er, cb)\n\n    if (st && st.isDirectory())\n      return rmdir(p, options, er, cb)\n\n    options.unlink(p, function (er) {\n      if (er) {\n        if (er.code === \"ENOENT\")\n          return cb(null)\n        if (er.code === \"EPERM\")\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        if (er.code === \"EISDIR\")\n          return rmdir(p, options, er, cb)\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n  if (er)\n    assert(er instanceof Error)\n\n  options.chmod(p, _0666, function (er2) {\n    if (er2)\n      cb(er2.code === \"ENOENT\" ? null : er)\n    else\n      options.stat(p, function(er3, stats) {\n        if (er3)\n          cb(er3.code === \"ENOENT\" ? null : er)\n        else if (stats.isDirectory())\n          rmdir(p, options, er, cb)\n        else\n          options.unlink(p, cb)\n      })\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  assert(p)\n  assert(options)\n  if (er)\n    assert(er instanceof Error)\n\n  try {\n    options.chmodSync(p, _0666)\n  } catch (er2) {\n    if (er2.code === \"ENOENT\")\n      return\n    else\n      throw er\n  }\n\n  try {\n    var stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === \"ENOENT\")\n      return\n    else\n      throw er\n  }\n\n  if (stats.isDirectory())\n    rmdirSync(p, options, er)\n  else\n    options.unlinkSync(p)\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  if (originalEr)\n    assert(originalEr instanceof Error)\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, function (er) {\n    if (er && (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\"))\n      rmkids(p, options, cb)\n    else if (er && er.code === \"ENOTDIR\")\n      cb(originalEr)\n    else\n      cb(er)\n  })\n}\n\nfunction rmkids(p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, function (er, files) {\n    if (er)\n      return cb(er)\n    var n = files.length\n    if (n === 0)\n      return options.rmdir(p, cb)\n    var errState\n    files.forEach(function (f) {\n      rimraf(path.join(p, f), options, function (er) {\n        if (errState)\n          return\n        if (er)\n          return cb(errState = er)\n        if (--n === 0)\n          options.rmdir(p, cb)\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  var results\n\n  if (options.disableGlob || !glob.hasMagic(p)) {\n    results = [p]\n  } else {\n    try {\n      options.lstatSync(p)\n      results = [p]\n    } catch (er) {\n      results = glob.sync(p, options.glob)\n    }\n  }\n\n  if (!results.length)\n    return\n\n  for (var i = 0; i < results.length; i++) {\n    var p = results[i]\n\n    try {\n      var st = options.lstatSync(p)\n    } catch (er) {\n      if (er.code === \"ENOENT\")\n        return\n\n      // Windows can EPERM on stat.  Life is suffering.\n      if (er.code === \"EPERM\" && isWindows)\n        fixWinEPERMSync(p, options, er)\n    }\n\n    try {\n      // sunos lets the root user unlink directories, which is... weird.\n      if (st && st.isDirectory())\n        rmdirSync(p, options, null)\n      else\n        options.unlinkSync(p)\n    } catch (er) {\n      if (er.code === \"ENOENT\")\n        return\n      if (er.code === \"EPERM\")\n        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n      if (er.code !== \"EISDIR\")\n        throw er\n\n      rmdirSync(p, options, er)\n    }\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n  if (originalEr)\n    assert(originalEr instanceof Error)\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === \"ENOENT\")\n      return\n    if (er.code === \"ENOTDIR\")\n      throw originalEr\n    if (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\")\n      rmkidsSync(p, options)\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(function (f) {\n    rimrafSync(path.join(p, f), options)\n  })\n\n  // We only end up here once we got ENOTEMPTY at least once, and\n  // at this point, we are guaranteed to have removed all the kids.\n  // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n  // try really hard to delete stuff on windows, because it has a\n  // PROFOUNDLY annoying habit of not closing handles promptly when\n  // files are deleted, resulting in spurious ENOTEMPTY errors.\n  var retries = isWindows ? 100 : 1\n  var i = 0\n  do {\n    var threw = true\n    try {\n      var ret = options.rmdirSync(p, options)\n      threw = false\n      return ret\n    } finally {\n      if (++i < retries && threw)\n        continue\n    }\n  } while (true)\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/fstream/node_modules/rimraf/rimraf.js?");

/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/function-bind/implementation.js?");

/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/function-bind/implementation.js\");\n\nmodule.exports = Function.prototype.bind || implementation;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/function-bind/index.js?");

/***/ }),

/***/ "./node_modules/glob/common.js":
/*!*************************************!*\
  !*** ./node_modules/glob/common.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("exports.alphasort = alphasort\nexports.alphasorti = alphasorti\nexports.setopts = setopts\nexports.ownProp = ownProp\nexports.makeAbs = makeAbs\nexports.finish = finish\nexports.mark = mark\nexports.isIgnored = isIgnored\nexports.childrenIgnored = childrenIgnored\n\nfunction ownProp (obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field)\n}\n\nvar path = __webpack_require__(/*! path */ \"path\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"./node_modules/minimatch/minimatch.js\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"./node_modules/path-is-absolute/index.js\")\nvar Minimatch = minimatch.Minimatch\n\nfunction alphasorti (a, b) {\n  return a.toLowerCase().localeCompare(b.toLowerCase())\n}\n\nfunction alphasort (a, b) {\n  return a.localeCompare(b)\n}\n\nfunction setupIgnores (self, options) {\n  self.ignore = options.ignore || []\n\n  if (!Array.isArray(self.ignore))\n    self.ignore = [self.ignore]\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap)\n  }\n}\n\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap (pattern) {\n  var gmatcher = null\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '')\n    gmatcher = new Minimatch(gpattern, { dot: true })\n  }\n\n  return {\n    matcher: new Minimatch(pattern, { dot: true }),\n    gmatcher: gmatcher\n  }\n}\n\nfunction setopts (self, pattern, options) {\n  if (!options)\n    options = {}\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  self.silent = !!options.silent\n  self.pattern = pattern\n  self.strict = options.strict !== false\n  self.realpath = !!options.realpath\n  self.realpathCache = options.realpathCache || Object.create(null)\n  self.follow = !!options.follow\n  self.dot = !!options.dot\n  self.mark = !!options.mark\n  self.nodir = !!options.nodir\n  if (self.nodir)\n    self.mark = true\n  self.sync = !!options.sync\n  self.nounique = !!options.nounique\n  self.nonull = !!options.nonull\n  self.nosort = !!options.nosort\n  self.nocase = !!options.nocase\n  self.stat = !!options.stat\n  self.noprocess = !!options.noprocess\n  self.absolute = !!options.absolute\n\n  self.maxLength = options.maxLength || Infinity\n  self.cache = options.cache || Object.create(null)\n  self.statCache = options.statCache || Object.create(null)\n  self.symlinks = options.symlinks || Object.create(null)\n\n  setupIgnores(self, options)\n\n  self.changedCwd = false\n  var cwd = process.cwd()\n  if (!ownProp(options, \"cwd\"))\n    self.cwd = cwd\n  else {\n    self.cwd = path.resolve(options.cwd)\n    self.changedCwd = self.cwd !== cwd\n  }\n\n  self.root = options.root || path.resolve(self.cwd, \"/\")\n  self.root = path.resolve(self.root)\n  if (process.platform === \"win32\")\n    self.root = self.root.replace(/\\\\/g, \"/\")\n\n  // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)\n  if (process.platform === \"win32\")\n    self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\")\n  self.nomount = !!options.nomount\n\n  // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n  options.nonegate = true\n  options.nocomment = true\n\n  self.minimatch = new Minimatch(pattern, options)\n  self.options = self.minimatch.options\n}\n\nfunction finish (self) {\n  var nou = self.nounique\n  var all = nou ? [] : Object.create(null)\n\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\n    var matches = self.matches[i]\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i]\n        if (nou)\n          all.push(literal)\n        else\n          all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou)\n        all.push.apply(all, m)\n      else\n        m.forEach(function (m) {\n          all[m] = true\n        })\n    }\n  }\n\n  if (!nou)\n    all = Object.keys(all)\n\n  if (!self.nosort)\n    all = all.sort(self.nocase ? alphasorti : alphasort)\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i])\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        var notDir = !(/\\/$/.test(e))\n        var c = self.cache[e] || self.cache[makeAbs(self, e)]\n        if (notDir && c)\n          notDir = c !== 'DIR' && !Array.isArray(c)\n        return notDir\n      })\n    }\n  }\n\n  if (self.ignore.length)\n    all = all.filter(function(m) {\n      return !isIgnored(self, m)\n    })\n\n  self.found = all\n}\n\nfunction mark (self, p) {\n  var abs = makeAbs(self, p)\n  var c = self.cache[abs]\n  var m = p\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c)\n    var slash = p.slice(-1) === '/'\n\n    if (isDir && !slash)\n      m += '/'\n    else if (!isDir && slash)\n      m = m.slice(0, -1)\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m)\n      self.statCache[mabs] = self.statCache[abs]\n      self.cache[mabs] = self.cache[abs]\n    }\n  }\n\n  return m\n}\n\n// lotta situps...\nfunction makeAbs (self, f) {\n  var abs = f\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f)\n  } else if (isAbsolute(f) || f === '') {\n    abs = f\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f)\n  } else {\n    abs = path.resolve(f)\n  }\n\n  if (process.platform === 'win32')\n    abs = abs.replace(/\\\\/g, '/')\n\n  return abs\n}\n\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\nfunction childrenIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/glob/common.js?");

/***/ }),

/***/ "./node_modules/glob/glob.js":
/*!***********************************!*\
  !*** ./node_modules/glob/glob.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar rp = __webpack_require__(/*! fs.realpath */ \"./node_modules/fs.realpath/index.js\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"./node_modules/minimatch/minimatch.js\")\nvar Minimatch = minimatch.Minimatch\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\")\nvar EE = __webpack_require__(/*! events */ \"events\").EventEmitter\nvar path = __webpack_require__(/*! path */ \"path\")\nvar assert = __webpack_require__(/*! assert */ \"assert\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"./node_modules/path-is-absolute/index.js\")\nvar globSync = __webpack_require__(/*! ./sync.js */ \"./node_modules/glob/sync.js\")\nvar common = __webpack_require__(/*! ./common.js */ \"./node_modules/glob/common.js\")\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar inflight = __webpack_require__(/*! inflight */ \"./node_modules/inflight/inflight.js\")\nvar util = __webpack_require__(/*! util */ \"util\")\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nvar once = __webpack_require__(/*! once */ \"./node_modules/once/once.js\")\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {}\n  if (!options) options = {}\n\n  if (options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return globSync(pattern, options)\n  }\n\n  return new Glob(pattern, options, cb)\n}\n\nglob.sync = globSync\nvar GlobSync = glob.GlobSync = globSync.GlobSync\n\n// old api surface\nglob.glob = glob\n\nfunction extend (origin, add) {\n  if (add === null || typeof add !== 'object') {\n    return origin\n  }\n\n  var keys = Object.keys(add)\n  var i = keys.length\n  while (i--) {\n    origin[keys[i]] = add[keys[i]]\n  }\n  return origin\n}\n\nglob.hasMagic = function (pattern, options_) {\n  var options = extend({}, options_)\n  options.noprocess = true\n\n  var g = new Glob(pattern, options)\n  var set = g.minimatch.set\n\n  if (!pattern)\n    return false\n\n  if (set.length > 1)\n    return true\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string')\n      return true\n  }\n\n  return false\n}\n\nglob.Glob = Glob\ninherits(Glob, EE)\nfunction Glob (pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = null\n  }\n\n  if (options && options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return new GlobSync(pattern, options)\n  }\n\n  if (!(this instanceof Glob))\n    return new Glob(pattern, options, cb)\n\n  setopts(this, pattern, options)\n  this._didRealPath = false\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n)\n\n  if (typeof cb === 'function') {\n    cb = once(cb)\n    this.on('error', cb)\n    this.on('end', function (matches) {\n      cb(null, matches)\n    })\n  }\n\n  var self = this\n  this._processing = 0\n\n  this._emitQueue = []\n  this._processQueue = []\n  this.paused = false\n\n  if (this.noprocess)\n    return this\n\n  if (n === 0)\n    return done()\n\n  var sync = true\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false, done)\n  }\n  sync = false\n\n  function done () {\n    --self._processing\n    if (self._processing <= 0) {\n      if (sync) {\n        process.nextTick(function () {\n          self._finish()\n        })\n      } else {\n        self._finish()\n      }\n    }\n  }\n}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob)\n  if (this.aborted)\n    return\n\n  if (this.realpath && !this._didRealpath)\n    return this._realpath()\n\n  common.finish(this)\n  this.emit('end', this.found)\n}\n\nGlob.prototype._realpath = function () {\n  if (this._didRealpath)\n    return\n\n  this._didRealpath = true\n\n  var n = this.matches.length\n  if (n === 0)\n    return this._finish()\n\n  var self = this\n  for (var i = 0; i < this.matches.length; i++)\n    this._realpathSet(i, next)\n\n  function next () {\n    if (--n === 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index]\n  if (!matchset)\n    return cb()\n\n  var found = Object.keys(matchset)\n  var self = this\n  var n = found.length\n\n  if (n === 0)\n    return cb()\n\n  var set = this.matches[index] = Object.create(null)\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p)\n    rp.realpath(p, self.realpathCache, function (er, real) {\n      if (!er)\n        set[real] = true\n      else if (er.syscall === 'stat')\n        set[p] = true\n      else\n        self.emit('error', er) // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set\n        cb()\n      }\n    })\n  })\n}\n\nGlob.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlob.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\nGlob.prototype.abort = function () {\n  this.aborted = true\n  this.emit('abort')\n}\n\nGlob.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true\n    this.emit('pause')\n  }\n}\n\nGlob.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume')\n    this.paused = false\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0)\n      this._emitQueue.length = 0\n      for (var i = 0; i < eq.length; i ++) {\n        var e = eq[i]\n        this._emitMatch(e[0], e[1])\n      }\n    }\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0)\n      this._processQueue.length = 0\n      for (var i = 0; i < pq.length; i ++) {\n        var p = pq[i]\n        this._processing--\n        this._process(p[0], p[1], p[2], p[3])\n      }\n    }\n  }\n}\n\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert(this instanceof Glob)\n  assert(typeof cb === 'function')\n\n  if (this.aborted)\n    return\n\n  this._processing++\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb])\n    return\n  }\n\n  //console.error('PROCESS %d', this._processing, pattern)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip _processing\n  if (childrenIgnored(this, read))\n    return cb()\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)\n}\n\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return cb()\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return cb()\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return cb()\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix) {\n      if (prefix !== '/')\n        e = prefix + '/' + e\n      else\n        e = prefix + e\n    }\n    this._process([e].concat(remain), index, inGlobStar, cb)\n  }\n  cb()\n}\n\nGlob.prototype._emitMatch = function (index, e) {\n  if (this.aborted)\n    return\n\n  if (isIgnored(this, e))\n    return\n\n  if (this.paused) {\n    this._emitQueue.push([index, e])\n    return\n  }\n\n  var abs = isAbsolute(e) ? e : this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute)\n    e = abs\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  var st = this.statCache[abs]\n  if (st)\n    this.emit('stat', e, st)\n\n  this.emit('match', e)\n}\n\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted)\n    return\n\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false, cb)\n\n  var lstatkey = 'lstat\\0' + abs\n  var self = this\n  var lstatcb = inflight(lstatkey, lstatcb_)\n\n  if (lstatcb)\n    fs.lstat(abs, lstatcb)\n\n  function lstatcb_ (er, lstat) {\n    if (er && er.code === 'ENOENT')\n      return cb()\n\n    var isSym = lstat && lstat.isSymbolicLink()\n    self.symlinks[abs] = isSym\n\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && lstat && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE'\n      cb()\n    } else\n      self._readdir(abs, false, cb)\n  }\n}\n\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted)\n    return\n\n  cb = inflight('readdir\\0'+abs+'\\0'+inGlobStar, cb)\n  if (!cb)\n    return\n\n  //console.error('RD %j %j', +inGlobStar, abs)\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs, cb)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return cb()\n\n    if (Array.isArray(c))\n      return cb(null, c)\n  }\n\n  var self = this\n  fs.readdir(abs, readdirCb(this, abs, cb))\n}\n\nfunction readdirCb (self, abs, cb) {\n  return function (er, entries) {\n    if (er)\n      self._readdirError(abs, er, cb)\n    else\n      self._readdirEntries(abs, entries, cb)\n  }\n}\n\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted)\n    return\n\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n  return cb(null, entries)\n}\n\nGlob.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted)\n    return\n\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        this.emit('error', error)\n        this.abort()\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict) {\n        this.emit('error', er)\n        // If the error is handled, then we abort\n        // if not, we threw out of here\n        this.abort()\n      }\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n\n  return cb()\n}\n\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\n\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return cb()\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false, cb)\n\n  var isSym = this.symlinks[abs]\n  var len = entries.length\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return cb()\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true, cb)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true, cb)\n  }\n\n  cb()\n}\n\nGlob.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb)\n  })\n}\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n\n  //console.error('ps2', prefix, exists)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return cb()\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n  cb()\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return cb()\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return cb(null, c)\n\n    if (needDir && c === 'FILE')\n      return cb()\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (stat !== undefined) {\n    if (stat === false)\n      return cb(null, stat)\n    else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE'\n      if (needDir && type === 'FILE')\n        return cb()\n      else\n        return cb(null, type, stat)\n    }\n  }\n\n  var self = this\n  var statcb = inflight('stat\\0' + abs, lstatcb_)\n  if (statcb)\n    fs.lstat(abs, statcb)\n\n  function lstatcb_ (er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return fs.stat(abs, function (er, stat) {\n        if (er)\n          self._stat2(f, abs, null, lstat, cb)\n        else\n          self._stat2(f, abs, er, stat, cb)\n      })\n    } else {\n      self._stat2(f, abs, er, lstat, cb)\n    }\n  }\n}\n\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n    this.statCache[abs] = false\n    return cb()\n  }\n\n  var needDir = f.slice(-1) === '/'\n  this.statCache[abs] = stat\n\n  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())\n    return cb(null, false, stat)\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return cb()\n\n  return cb(null, c, stat)\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/glob/glob.js?");

/***/ }),

/***/ "./node_modules/glob/sync.js":
/*!***********************************!*\
  !*** ./node_modules/glob/sync.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = globSync\nglobSync.GlobSync = GlobSync\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar rp = __webpack_require__(/*! fs.realpath */ \"./node_modules/fs.realpath/index.js\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"./node_modules/minimatch/minimatch.js\")\nvar Minimatch = minimatch.Minimatch\nvar Glob = __webpack_require__(/*! ./glob.js */ \"./node_modules/glob/glob.js\").Glob\nvar util = __webpack_require__(/*! util */ \"util\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar assert = __webpack_require__(/*! assert */ \"assert\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"./node_modules/path-is-absolute/index.js\")\nvar common = __webpack_require__(/*! ./common.js */ \"./node_modules/glob/common.js\")\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nfunction globSync (pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  return new GlobSync(pattern, options).found\n}\n\nfunction GlobSync (pattern, options) {\n  if (!pattern)\n    throw new Error('must provide pattern')\n\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  if (!(this instanceof GlobSync))\n    return new GlobSync(pattern, options)\n\n  setopts(this, pattern, options)\n\n  if (this.noprocess)\n    return this\n\n  var n = this.minimatch.set.length\n  this.matches = new Array(n)\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false)\n  }\n  this._finish()\n}\n\nGlobSync.prototype._finish = function () {\n  assert(this instanceof GlobSync)\n  if (this.realpath) {\n    var self = this\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null)\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p)\n          var real = rp.realpathSync(p, self.realpathCache)\n          set[real] = true\n        } catch (er) {\n          if (er.syscall === 'stat')\n            set[self._makeAbs(p)] = true\n          else\n            throw er\n        }\n      }\n    })\n  }\n  common.finish(this)\n}\n\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert(this instanceof GlobSync)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip processing\n  if (childrenIgnored(this, read))\n    return\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)\n}\n\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar)\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix.slice(-1) !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix)\n      newPattern = [prefix, e]\n    else\n      newPattern = [e]\n    this._process(newPattern.concat(remain), index, inGlobStar)\n  }\n}\n\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  if (isIgnored(this, e))\n    return\n\n  var abs = this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute) {\n    e = abs\n  }\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  if (this.stat)\n    this._stat(e)\n}\n\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false)\n\n  var entries\n  var lstat\n  var stat\n  try {\n    lstat = fs.lstatSync(abs)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      // lstat failed, doesn't exist\n      return null\n    }\n  }\n\n  var isSym = lstat && lstat.isSymbolicLink()\n  this.symlinks[abs] = isSym\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && lstat && !lstat.isDirectory())\n    this.cache[abs] = 'FILE'\n  else\n    entries = this._readdir(abs, false)\n\n  return entries\n}\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries\n\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return null\n\n    if (Array.isArray(c))\n      return c\n  }\n\n  try {\n    return this._readdirEntries(abs, fs.readdirSync(abs))\n  } catch (er) {\n    this._readdirError(abs, er)\n    return null\n  }\n}\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n\n  // mark and cache dir-ness\n  return entries\n}\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        throw error\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict)\n        throw er\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n}\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n\n  var entries = this._readdir(abs, inGlobStar)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false)\n\n  var len = entries.length\n  var isSym = this.symlinks[abs]\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true)\n  }\n}\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return false\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return c\n\n    if (needDir && c === 'FILE')\n      return false\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (!stat) {\n    var lstat\n    try {\n      lstat = fs.lstatSync(abs)\n    } catch (er) {\n      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n        this.statCache[abs] = false\n        return false\n      }\n    }\n\n    if (lstat && lstat.isSymbolicLink()) {\n      try {\n        stat = fs.statSync(abs)\n      } catch (er) {\n        stat = lstat\n      }\n    } else {\n      stat = lstat\n    }\n  }\n\n  this.statCache[abs] = stat\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return false\n\n  return c\n}\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/glob/sync.js?");

/***/ }),

/***/ "./node_modules/graceful-fs/clone.js":
/*!*******************************************!*\
  !*** ./node_modules/graceful-fs/clone.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = clone\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: obj.__proto__ }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/graceful-fs/clone.js?");

/***/ }),

/***/ "./node_modules/graceful-fs/graceful-fs.js":
/*!*************************************************!*\
  !*** ./node_modules/graceful-fs/graceful-fs.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var fs = __webpack_require__(/*! fs */ \"fs\")\nvar polyfills = __webpack_require__(/*! ./polyfills.js */ \"./node_modules/graceful-fs/polyfills.js\")\nvar legacy = __webpack_require__(/*! ./legacy-streams.js */ \"./node_modules/graceful-fs/legacy-streams.js\")\nvar clone = __webpack_require__(/*! ./clone.js */ \"./node_modules/graceful-fs/clone.js\")\n\nvar util = __webpack_require__(/*! util */ \"util\")\n\n/* istanbul ignore next - node 0.x polyfill */\nvar gracefulQueue\nvar previousSymbol\n\n/* istanbul ignore else - node 0.x polyfill */\nif (typeof Symbol === 'function' && typeof Symbol.for === 'function') {\n  gracefulQueue = Symbol.for('graceful-fs.queue')\n  // This is used in testing by future versions\n  previousSymbol = Symbol.for('graceful-fs.previous')\n} else {\n  gracefulQueue = '___graceful-fs.queue'\n  previousSymbol = '___graceful-fs.previous'\n}\n\nfunction noop () {}\n\nfunction publishQueue(context, queue) {\n  Object.defineProperty(context, gracefulQueue, {\n    get: function() {\n      return queue\n    }\n  })\n}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\n// Once time initialization\nif (!fs[gracefulQueue]) {\n  // This queue can be shared by multiple loaded instances\n  var queue = global[gracefulQueue] || []\n  publishQueue(fs, queue)\n\n  // Patch fs.close/closeSync to shared queue version, because we need\n  // to retry() whenever a close happens *anywhere* in the program.\n  // This is essential when multiple graceful-fs instances are\n  // in play at the same time.\n  fs.close = (function (fs$close) {\n    function close (fd, cb) {\n      return fs$close.call(fs, fd, function (err) {\n        // This function uses the graceful-fs shared queue\n        if (!err) {\n          retry()\n        }\n\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n      })\n    }\n\n    Object.defineProperty(close, previousSymbol, {\n      value: fs$close\n    })\n    return close\n  })(fs.close)\n\n  fs.closeSync = (function (fs$closeSync) {\n    function closeSync (fd) {\n      // This function uses the graceful-fs shared queue\n      fs$closeSync.apply(fs, arguments)\n      retry()\n    }\n\n    Object.defineProperty(closeSync, previousSymbol, {\n      value: fs$closeSync\n    })\n    return closeSync\n  })(fs.closeSync)\n\n  if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n    process.on('exit', function() {\n      debug(fs[gracefulQueue])\n      __webpack_require__(/*! assert */ \"assert\").equal(fs[gracefulQueue].length, 0)\n    })\n  }\n}\n\nif (!global[gracefulQueue]) {\n  publishQueue(global, fs[gracefulQueue]);\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    var args = [path]\n    if (typeof options !== 'function') {\n      args.push(options)\n    } else {\n      cb = options\n    }\n    args.push(go$readdir$cb)\n\n    return go$readdir(args)\n\n    function go$readdir$cb (err, files) {\n      if (files && files.sort)\n        files.sort()\n\n      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n        enqueue([go$readdir, [args]])\n\n      else {\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n        retry()\n      }\n    }\n  }\n\n  function go$readdir (args) {\n    return fs$readdir.apply(fs, args)\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  Object.defineProperty(fs, 'ReadStream', {\n    get: function () {\n      return ReadStream\n    },\n    set: function (val) {\n      ReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  Object.defineProperty(fs, 'WriteStream', {\n    get: function () {\n      return WriteStream\n    },\n    set: function (val) {\n      WriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  // legacy names\n  var FileReadStream = ReadStream\n  Object.defineProperty(fs, 'FileReadStream', {\n    get: function () {\n      return FileReadStream\n    },\n    set: function (val) {\n      FileReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  var FileWriteStream = WriteStream\n  Object.defineProperty(fs, 'FileWriteStream', {\n    get: function () {\n      return FileWriteStream\n    },\n    set: function (val) {\n      FileWriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new fs.ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new fs.WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  fs[gracefulQueue].push(elem)\n}\n\nfunction retry () {\n  var elem = fs[gracefulQueue].shift()\n  if (elem) {\n    debug('RETRY', elem[0].name, elem[1])\n    elem[0].apply(null, elem[1])\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/graceful-fs/graceful-fs.js?");

/***/ }),

/***/ "./node_modules/graceful-fs/legacy-streams.js":
/*!****************************************************!*\
  !*** ./node_modules/graceful-fs/legacy-streams.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Stream = __webpack_require__(/*! stream */ \"stream\").Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/graceful-fs/legacy-streams.js?");

/***/ }),

/***/ "./node_modules/graceful-fs/polyfills.js":
/*!***********************************************!*\
  !*** ./node_modules/graceful-fs/polyfills.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var constants = __webpack_require__(/*! constants */ \"constants\")\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\nvar chdir = process.chdir\nprocess.chdir = function(d) {\n  cwd = null\n  chdir.call(process, d)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n            && Date.now() - start < 60000) {\n          setTimeout(function() {\n            fs.stat(to, function (stater, st) {\n              if (stater && stater.code === \"ENOENT\")\n                fs$rename(from, to, CB);\n              else\n                cb(er)\n            })\n          }, backoff)\n          if (backoff < 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) {\n    function read (fd, buffer, offset, length, position, callback_) {\n      var callback\n      if (callback_ && typeof callback_ === 'function') {\n        var eagCounter = 0\n        callback = function (er, _, __) {\n          if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n            eagCounter ++\n            return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n          }\n          callback_.apply(this, arguments)\n        }\n      }\n      return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n    }\n\n    // This ensures `util.promisify` works as it does for native `fs.read`.\n    read.__proto__ = fs$read\n    return read\n  })(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options, cb) {\n      if (typeof options === 'function') {\n        cb = options\n        options = null\n      }\n      function callback (er, stats) {\n        if (stats) {\n          if (stats.uid < 0) stats.uid += 0x100000000\n          if (stats.gid < 0) stats.gid += 0x100000000\n        }\n        if (cb) cb.apply(this, arguments)\n      }\n      return options ? orig.call(fs, target, options, callback)\n        : orig.call(fs, target, callback)\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options) {\n      var stats = options ? orig.call(fs, target, options)\n        : orig.call(fs, target)\n      if (stats.uid < 0) stats.uid += 0x100000000\n      if (stats.gid < 0) stats.gid += 0x100000000\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn't support the op. Just ignore\n  // that, because it doesn't matter.\n  //\n  // if there's no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it's strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \"ENOSYS\")\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n        return true\n    }\n\n    return false\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/graceful-fs/polyfills.js?");

/***/ }),

/***/ "./node_modules/has-flag/index.js":
/*!****************************************!*\
  !*** ./node_modules/has-flag/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = (flag, argv = process.argv) => {\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst position = argv.indexOf(prefix + flag);\n\tconst terminatorPosition = argv.indexOf('--');\n\treturn position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/has-flag/index.js?");

/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar origSymbol = global.Symbol;\nvar hasSymbolSham = __webpack_require__(/*! ./shams */ \"./node_modules/has-symbols/shams.js\");\n\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/has-symbols/index.js?");

/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/has-symbols/shams.js?");

/***/ }),

/***/ "./node_modules/http-proxy-agent/dist/agent.js":
/*!*****************************************************!*\
  !*** ./node_modules/http-proxy-agent/dist/agent.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst net_1 = __importDefault(__webpack_require__(/*! net */ \"net\"));\nconst tls_1 = __importDefault(__webpack_require__(/*! tls */ \"tls\"));\nconst url_1 = __importDefault(__webpack_require__(/*! url */ \"url\"));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\"));\nconst once_1 = __importDefault(__webpack_require__(/*! @tootallnate/once */ \"./node_modules/@tootallnate/once/dist/index.js\"));\nconst agent_base_1 = __webpack_require__(/*! agent-base */ \"./node_modules/agent-base/dist/src/index.js\");\nconst debug = debug_1.default('http-proxy-agent');\nfunction isHTTPS(protocol) {\n    return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;\n}\n/**\n * The `HttpProxyAgent` implements an HTTP Agent subclass that connects\n * to the specified \"HTTP proxy server\" in order to proxy HTTP requests.\n *\n * @api public\n */\nclass HttpProxyAgent extends agent_base_1.Agent {\n    constructor(_opts) {\n        let opts;\n        if (typeof _opts === 'string') {\n            opts = url_1.default.parse(_opts);\n        }\n        else {\n            opts = _opts;\n        }\n        if (!opts) {\n            throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');\n        }\n        debug('Creating new HttpProxyAgent instance: %o', opts);\n        super(opts);\n        const proxy = Object.assign({}, opts);\n        // If `true`, then connect to the proxy server over TLS.\n        // Defaults to `false`.\n        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);\n        // Prefer `hostname` over `host`, and set the `port` if needed.\n        proxy.host = proxy.hostname || proxy.host;\n        if (typeof proxy.port === 'string') {\n            proxy.port = parseInt(proxy.port, 10);\n        }\n        if (!proxy.port && proxy.host) {\n            proxy.port = this.secureProxy ? 443 : 80;\n        }\n        if (proxy.host && proxy.path) {\n            // If both a `host` and `path` are specified then it's most likely\n            // the result of a `url.parse()` call... we need to remove the\n            // `path` portion so that `net.connect()` doesn't attempt to open\n            // that as a Unix socket file.\n            delete proxy.path;\n            delete proxy.pathname;\n        }\n        this.proxy = proxy;\n    }\n    /**\n     * Called when the node-core HTTP client library is creating a\n     * new HTTP request.\n     *\n     * @api protected\n     */\n    callback(req, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { proxy, secureProxy } = this;\n            const parsed = url_1.default.parse(req.path);\n            if (!parsed.protocol) {\n                parsed.protocol = 'http:';\n            }\n            if (!parsed.hostname) {\n                parsed.hostname = opts.hostname || opts.host || null;\n            }\n            if (parsed.port == null && typeof opts.port) {\n                parsed.port = String(opts.port);\n            }\n            if (parsed.port === '80') {\n                // if port is 80, then we can remove the port so that the\n                // \":80\" portion is not on the produced URL\n                delete parsed.port;\n            }\n            // Change the `http.ClientRequest` instance's \"path\" field\n            // to the absolute path of the URL that will be requested.\n            req.path = url_1.default.format(parsed);\n            // Inject the `Proxy-Authorization` header if necessary.\n            if (proxy.auth) {\n                req.setHeader('Proxy-Authorization', `Basic ${Buffer.from(proxy.auth).toString('base64')}`);\n            }\n            // Create a socket connection to the proxy server.\n            let socket;\n            if (secureProxy) {\n                debug('Creating `tls.Socket`: %o', proxy);\n                socket = tls_1.default.connect(proxy);\n            }\n            else {\n                debug('Creating `net.Socket`: %o', proxy);\n                socket = net_1.default.connect(proxy);\n            }\n            // At this point, the http ClientRequest's internal `_header` field\n            // might have already been set. If this is the case then we'll need\n            // to re-generate the string since we just changed the `req.path`.\n            if (req._header) {\n                let first;\n                let endOfHeaders;\n                debug('Regenerating stored HTTP header string for request');\n                req._header = null;\n                req._implicitHeader();\n                if (req.output && req.output.length > 0) {\n                    // Node < 12\n                    debug('Patching connection write() output buffer with updated header');\n                    first = req.output[0];\n                    endOfHeaders = first.indexOf('\\r\\n\\r\\n') + 4;\n                    req.output[0] = req._header + first.substring(endOfHeaders);\n                    debug('Output buffer: %o', req.output);\n                }\n                else if (req.outputData && req.outputData.length > 0) {\n                    // Node >= 12\n                    debug('Patching connection write() output buffer with updated header');\n                    first = req.outputData[0].data;\n                    endOfHeaders = first.indexOf('\\r\\n\\r\\n') + 4;\n                    req.outputData[0].data =\n                        req._header + first.substring(endOfHeaders);\n                    debug('Output buffer: %o', req.outputData[0].data);\n                }\n            }\n            // Wait for the socket's `connect` event, so that this `callback()`\n            // function throws instead of the `http` request machinery. This is\n            // important for i.e. `PacProxyAgent` which determines a failed proxy\n            // connection via the `callback()` function throwing.\n            yield once_1.default(socket, 'connect');\n            return socket;\n        });\n    }\n}\nexports.default = HttpProxyAgent;\n//# sourceMappingURL=agent.js.map\n\n//# sourceURL=webpack://coc.nvim/./node_modules/http-proxy-agent/dist/agent.js?");

/***/ }),

/***/ "./node_modules/http-proxy-agent/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/http-proxy-agent/dist/index.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst agent_1 = __importDefault(__webpack_require__(/*! ./agent */ \"./node_modules/http-proxy-agent/dist/agent.js\"));\nfunction createHttpProxyAgent(opts) {\n    return new agent_1.default(opts);\n}\n(function (createHttpProxyAgent) {\n    createHttpProxyAgent.HttpProxyAgent = agent_1.default;\n    createHttpProxyAgent.prototype = agent_1.default.prototype;\n})(createHttpProxyAgent || (createHttpProxyAgent = {}));\nmodule.exports = createHttpProxyAgent;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://coc.nvim/./node_modules/http-proxy-agent/dist/index.js?");

/***/ }),

/***/ "./node_modules/https-proxy-agent/dist/agent.js":
/*!******************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/agent.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst net_1 = __importDefault(__webpack_require__(/*! net */ \"net\"));\nconst tls_1 = __importDefault(__webpack_require__(/*! tls */ \"tls\"));\nconst url_1 = __importDefault(__webpack_require__(/*! url */ \"url\"));\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\"));\nconst agent_base_1 = __webpack_require__(/*! agent-base */ \"./node_modules/agent-base/dist/src/index.js\");\nconst parse_proxy_response_1 = __importDefault(__webpack_require__(/*! ./parse-proxy-response */ \"./node_modules/https-proxy-agent/dist/parse-proxy-response.js\"));\nconst debug = debug_1.default('https-proxy-agent:agent');\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * Outgoing HTTP requests are first tunneled through the proxy server using the\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\n * and then the proxy server connects to the destination target and issues the\n * HTTP request from the proxy server.\n *\n * `https:` requests have their socket connection upgraded to TLS once\n * the connection to the proxy server has been established.\n *\n * @api public\n */\nclass HttpsProxyAgent extends agent_base_1.Agent {\n    constructor(_opts) {\n        let opts;\n        if (typeof _opts === 'string') {\n            opts = url_1.default.parse(_opts);\n        }\n        else {\n            opts = _opts;\n        }\n        if (!opts) {\n            throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');\n        }\n        debug('creating new HttpsProxyAgent instance: %o', opts);\n        super(opts);\n        const proxy = Object.assign({}, opts);\n        // If `true`, then connect to the proxy server over TLS.\n        // Defaults to `false`.\n        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);\n        // Prefer `hostname` over `host`, and set the `port` if needed.\n        proxy.host = proxy.hostname || proxy.host;\n        if (typeof proxy.port === 'string') {\n            proxy.port = parseInt(proxy.port, 10);\n        }\n        if (!proxy.port && proxy.host) {\n            proxy.port = this.secureProxy ? 443 : 80;\n        }\n        // ALPN is supported by Node.js >= v5.\n        // attempt to negotiate http/1.1 for proxy servers that support http/2\n        if (this.secureProxy && !('ALPNProtocols' in proxy)) {\n            proxy.ALPNProtocols = ['http 1.1'];\n        }\n        if (proxy.host && proxy.path) {\n            // If both a `host` and `path` are specified then it's most likely\n            // the result of a `url.parse()` call... we need to remove the\n            // `path` portion so that `net.connect()` doesn't attempt to open\n            // that as a Unix socket file.\n            delete proxy.path;\n            delete proxy.pathname;\n        }\n        this.proxy = proxy;\n    }\n    /**\n     * Called when the node-core HTTP client library is creating a\n     * new HTTP request.\n     *\n     * @api protected\n     */\n    callback(req, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { proxy, secureProxy } = this;\n            // Create a socket connection to the proxy server.\n            let socket;\n            if (secureProxy) {\n                debug('Creating `tls.Socket`: %o', proxy);\n                socket = tls_1.default.connect(proxy);\n            }\n            else {\n                debug('Creating `net.Socket`: %o', proxy);\n                socket = net_1.default.connect(proxy);\n            }\n            const headers = Object.assign({}, proxy.headers);\n            const hostname = `${opts.host}:${opts.port}`;\n            let payload = `CONNECT ${hostname} HTTP/1.1\\r\\n`;\n            // Inject the `Proxy-Authorization` header if necessary.\n            if (proxy.auth) {\n                headers['Proxy-Authorization'] = `Basic ${Buffer.from(proxy.auth).toString('base64')}`;\n            }\n            // The `Host` header should only include the port\n            // number when it is not the default port.\n            let { host, port, secureEndpoint } = opts;\n            if (!isDefaultPort(port, secureEndpoint)) {\n                host += `:${port}`;\n            }\n            headers.Host = host;\n            headers.Connection = 'close';\n            for (const name of Object.keys(headers)) {\n                payload += `${name}: ${headers[name]}\\r\\n`;\n            }\n            const proxyResponsePromise = parse_proxy_response_1.default(socket);\n            socket.write(`${payload}\\r\\n`);\n            const { statusCode, buffered } = yield proxyResponsePromise;\n            if (statusCode === 200) {\n                req.once('socket', resume);\n                if (opts.secureEndpoint) {\n                    const servername = opts.servername || opts.host;\n                    if (!servername) {\n                        throw new Error('Could not determine \"servername\"');\n                    }\n                    // The proxy is connecting to a TLS server, so upgrade\n                    // this socket connection to a TLS connection.\n                    debug('Upgrading socket connection to TLS');\n                    return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, 'host', 'hostname', 'path', 'port')), { socket,\n                        servername }));\n                }\n                return socket;\n            }\n            // Some other status code that's not 200... need to re-play the HTTP\n            // header \"data\" events onto the socket once the HTTP machinery is\n            // attached so that the node core `http` can parse and handle the\n            // error status code.\n            // Close the original socket, and a new \"fake\" socket is returned\n            // instead, so that the proxy doesn't get the HTTP request\n            // written to it (which may contain `Authorization` headers or other\n            // sensitive data).\n            //\n            // See: https://hackerone.com/reports/541502\n            socket.destroy();\n            const fakeSocket = new net_1.default.Socket();\n            fakeSocket.readable = true;\n            // Need to wait for the \"socket\" event to re-play the \"data\" events.\n            req.once('socket', (s) => {\n                debug('replaying proxy buffer for failed request');\n                assert_1.default(s.listenerCount('data') > 0);\n                // Replay the \"buffered\" Buffer onto the fake `socket`, since at\n                // this point the HTTP module machinery has been hooked up for\n                // the user.\n                s.push(buffered);\n                s.push(null);\n            });\n            return fakeSocket;\n        });\n    }\n}\nexports.default = HttpsProxyAgent;\nfunction resume(socket) {\n    socket.resume();\n}\nfunction isDefaultPort(port, secure) {\n    return Boolean((!secure && port === 80) || (secure && port === 443));\n}\nfunction isHTTPS(protocol) {\n    return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;\n}\nfunction omit(obj, ...keys) {\n    const ret = {};\n    let key;\n    for (key in obj) {\n        if (!keys.includes(key)) {\n            ret[key] = obj[key];\n        }\n    }\n    return ret;\n}\n//# sourceMappingURL=agent.js.map\n\n//# sourceURL=webpack://coc.nvim/./node_modules/https-proxy-agent/dist/agent.js?");

/***/ }),

/***/ "./node_modules/https-proxy-agent/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/index.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst agent_1 = __importDefault(__webpack_require__(/*! ./agent */ \"./node_modules/https-proxy-agent/dist/agent.js\"));\nfunction createHttpsProxyAgent(opts) {\n    return new agent_1.default(opts);\n}\n(function (createHttpsProxyAgent) {\n    createHttpsProxyAgent.HttpsProxyAgent = agent_1.default;\n    createHttpsProxyAgent.prototype = agent_1.default.prototype;\n})(createHttpsProxyAgent || (createHttpsProxyAgent = {}));\nmodule.exports = createHttpsProxyAgent;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://coc.nvim/./node_modules/https-proxy-agent/dist/index.js?");

/***/ }),

/***/ "./node_modules/https-proxy-agent/dist/parse-proxy-response.js":
/*!*********************************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/parse-proxy-response.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\"));\nconst debug = debug_1.default('https-proxy-agent:parse-proxy-response');\nfunction parseProxyResponse(socket) {\n    return new Promise((resolve, reject) => {\n        // we need to buffer any HTTP traffic that happens with the proxy before we get\n        // the CONNECT response, so that if the response is anything other than an \"200\"\n        // response code, then we can re-play the \"data\" events on the socket once the\n        // HTTP parser is hooked up...\n        let buffersLength = 0;\n        const buffers = [];\n        function read() {\n            const b = socket.read();\n            if (b)\n                ondata(b);\n            else\n                socket.once('readable', read);\n        }\n        function cleanup() {\n            socket.removeListener('end', onend);\n            socket.removeListener('error', onerror);\n            socket.removeListener('close', onclose);\n            socket.removeListener('readable', read);\n        }\n        function onclose(err) {\n            debug('onclose had error %o', err);\n        }\n        function onend() {\n            debug('onend');\n        }\n        function onerror(err) {\n            cleanup();\n            debug('onerror %o', err);\n            reject(err);\n        }\n        function ondata(b) {\n            buffers.push(b);\n            buffersLength += b.length;\n            const buffered = Buffer.concat(buffers, buffersLength);\n            const endOfHeaders = buffered.indexOf('\\r\\n\\r\\n');\n            if (endOfHeaders === -1) {\n                // keep buffering\n                debug('have not received end of HTTP headers yet...');\n                read();\n                return;\n            }\n            const firstLine = buffered.toString('ascii', 0, buffered.indexOf('\\r\\n'));\n            const statusCode = +firstLine.split(' ')[1];\n            debug('got proxy server response: %o', firstLine);\n            resolve({\n                statusCode,\n                buffered\n            });\n        }\n        socket.on('error', onerror);\n        socket.on('close', onclose);\n        socket.on('end', onend);\n        read();\n    });\n}\nexports.default = parseProxyResponse;\n//# sourceMappingURL=parse-proxy-response.js.map\n\n//# sourceURL=webpack://coc.nvim/./node_modules/https-proxy-agent/dist/parse-proxy-response.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/inflight/inflight.js":
/*!*******************************************!*\
  !*** ./node_modules/inflight/inflight.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var wrappy = __webpack_require__(/*! wrappy */ \"./node_modules/wrappy/wrappy.js\")\nvar reqs = Object.create(null)\nvar once = __webpack_require__(/*! once */ \"./node_modules/once/once.js\")\n\nmodule.exports = wrappy(inflight)\n\nfunction inflight (key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb)\n    return null\n  } else {\n    reqs[key] = [cb]\n    return makeres(key)\n  }\n}\n\nfunction makeres (key) {\n  return once(function RES () {\n    var cbs = reqs[key]\n    var len = cbs.length\n    var args = slice(arguments)\n\n    // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args)\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len)\n        process.nextTick(function () {\n          RES.apply(null, args)\n        })\n      } else {\n        delete reqs[key]\n      }\n    }\n  })\n}\n\nfunction slice (args) {\n  var length = args.length\n  var array = []\n\n  for (var i = 0; i < length; i++) array[i] = args[i]\n  return array\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/inflight/inflight.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits.js":
/*!*******************************************!*\
  !*** ./node_modules/inherits/inherits.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("try {\n  var util = __webpack_require__(/*! util */ \"util\");\n  /* istanbul ignore next */\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  /* istanbul ignore next */\n  module.exports = __webpack_require__(/*! ./inherits_browser.js */ \"./node_modules/inherits/inherits_browser.js\");\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/inherits/inherits.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/ini/ini.js":
/*!*********************************!*\
  !*** ./node_modules/ini/ini.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("exports.parse = exports.decode = decode\n\nexports.stringify = exports.encode = encode\n\nexports.safe = safe\nexports.unsafe = unsafe\n\nvar eol = typeof process !== 'undefined' &&\n  process.platform === 'win32' ? '\\r\\n' : '\\n'\n\nfunction encode (obj, opt) {\n  var children = []\n  var out = ''\n\n  if (typeof opt === 'string') {\n    opt = {\n      section: opt,\n      whitespace: false\n    }\n  } else {\n    opt = opt || {}\n    opt.whitespace = opt.whitespace === true\n  }\n\n  var separator = opt.whitespace ? ' = ' : '='\n\n  Object.keys(obj).forEach(function (k, _, __) {\n    var val = obj[k]\n    if (val && Array.isArray(val)) {\n      val.forEach(function (item) {\n        out += safe(k + '[]') + separator + safe(item) + '\\n'\n      })\n    } else if (val && typeof val === 'object') {\n      children.push(k)\n    } else {\n      out += safe(k) + separator + safe(val) + eol\n    }\n  })\n\n  if (opt.section && out.length) {\n    out = '[' + safe(opt.section) + ']' + eol + out\n  }\n\n  children.forEach(function (k, _, __) {\n    var nk = dotSplit(k).join('\\\\.')\n    var section = (opt.section ? opt.section + '.' : '') + nk\n    var child = encode(obj[k], {\n      section: section,\n      whitespace: opt.whitespace\n    })\n    if (out.length && child.length) {\n      out += eol\n    }\n    out += child\n  })\n\n  return out\n}\n\nfunction dotSplit (str) {\n  return str.replace(/\\1/g, '\\u0002LITERAL\\\\1LITERAL\\u0002')\n    .replace(/\\\\\\./g, '\\u0001')\n    .split(/\\./).map(function (part) {\n      return part.replace(/\\1/g, '\\\\.')\n      .replace(/\\2LITERAL\\\\1LITERAL\\2/g, '\\u0001')\n    })\n}\n\nfunction decode (str) {\n  var out = {}\n  var p = out\n  var section = null\n  //          section     |key      = value\n  var re = /^\\[([^\\]]*)\\]$|^([^=]+)(=(.*))?$/i\n  var lines = str.split(/[\\r\\n]+/g)\n\n  lines.forEach(function (line, _, __) {\n    if (!line || line.match(/^\\s*[;#]/)) return\n    var match = line.match(re)\n    if (!match) return\n    if (match[1] !== undefined) {\n      section = unsafe(match[1])\n      p = out[section] = out[section] || {}\n      return\n    }\n    var key = unsafe(match[2])\n    var value = match[3] ? unsafe(match[4]) : true\n    switch (value) {\n      case 'true':\n      case 'false':\n      case 'null': value = JSON.parse(value)\n    }\n\n    // Convert keys with '[]' suffix to an array\n    if (key.length > 2 && key.slice(-2) === '[]') {\n      key = key.substring(0, key.length - 2)\n      if (!p[key]) {\n        p[key] = []\n      } else if (!Array.isArray(p[key])) {\n        p[key] = [p[key]]\n      }\n    }\n\n    // safeguard against resetting a previously defined\n    // array by accidentally forgetting the brackets\n    if (Array.isArray(p[key])) {\n      p[key].push(value)\n    } else {\n      p[key] = value\n    }\n  })\n\n  // {a:{y:1},\"a.b\":{x:2}} --> {a:{y:1,b:{x:2}}}\n  // use a filter to return the keys that have to be deleted.\n  Object.keys(out).filter(function (k, _, __) {\n    if (!out[k] ||\n      typeof out[k] !== 'object' ||\n      Array.isArray(out[k])) {\n      return false\n    }\n    // see if the parent section is also an object.\n    // if so, add it to that, and mark this one for deletion\n    var parts = dotSplit(k)\n    var p = out\n    var l = parts.pop()\n    var nl = l.replace(/\\\\\\./g, '.')\n    parts.forEach(function (part, _, __) {\n      if (!p[part] || typeof p[part] !== 'object') p[part] = {}\n      p = p[part]\n    })\n    if (p === out && nl === l) {\n      return false\n    }\n    p[nl] = out[k]\n    return true\n  }).forEach(function (del, _, __) {\n    delete out[del]\n  })\n\n  return out\n}\n\nfunction isQuoted (val) {\n  return (val.charAt(0) === '\"' && val.slice(-1) === '\"') ||\n    (val.charAt(0) === \"'\" && val.slice(-1) === \"'\")\n}\n\nfunction safe (val) {\n  return (typeof val !== 'string' ||\n    val.match(/[=\\r\\n]/) ||\n    val.match(/^\\[/) ||\n    (val.length > 1 &&\n     isQuoted(val)) ||\n    val !== val.trim())\n      ? JSON.stringify(val)\n      : val.replace(/;/g, '\\\\;').replace(/#/g, '\\\\#')\n}\n\nfunction unsafe (val, doUnesc) {\n  val = (val || '').trim()\n  if (isQuoted(val)) {\n    // remove the single quotes before calling JSON.parse\n    if (val.charAt(0) === \"'\") {\n      val = val.substr(1, val.length - 2)\n    }\n    try { val = JSON.parse(val) } catch (_) {}\n  } else {\n    // walk the val to find the first not-escaped ; character\n    var esc = false\n    var unesc = ''\n    for (var i = 0, l = val.length; i < l; i++) {\n      var c = val.charAt(i)\n      if (esc) {\n        if ('\\\\;#'.indexOf(c) !== -1) {\n          unesc += c\n        } else {\n          unesc += '\\\\' + c\n        }\n        esc = false\n      } else if (';#'.indexOf(c) !== -1) {\n        break\n      } else if (c === '\\\\') {\n        esc = true\n      } else {\n        unesc += c\n      }\n    }\n    if (esc) {\n      unesc += '\\\\'\n    }\n    return unesc.trim()\n  }\n  return val\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/ini/ini.js?");

/***/ }),

/***/ "./node_modules/int64-buffer/int64-buffer.js":
/*!***************************************************!*\
  !*** ./node_modules/int64-buffer/int64-buffer.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("// int64-buffer.js\n\n/*jshint -W018 */ // Confusing use of '!'.\n/*jshint -W030 */ // Expected an assignment or function call and instead saw an expression.\n/*jshint -W093 */ // Did you mean to return a conditional instead of an assignment?\n\nvar Uint64BE, Int64BE, Uint64LE, Int64LE;\n\n!function(exports) {\n  // constants\n\n  var UNDEFINED = \"undefined\";\n  var BUFFER = (UNDEFINED !== typeof Buffer) && Buffer;\n  var UINT8ARRAY = (UNDEFINED !== typeof Uint8Array) && Uint8Array;\n  var ARRAYBUFFER = (UNDEFINED !== typeof ArrayBuffer) && ArrayBuffer;\n  var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];\n  var isArray = Array.isArray || _isArray;\n  var BIT32 = 4294967296;\n  var BIT24 = 16777216;\n\n  // storage class\n\n  var storage; // Array;\n\n  // generate classes\n\n  Uint64BE = factory(\"Uint64BE\", true, true);\n  Int64BE = factory(\"Int64BE\", true, false);\n  Uint64LE = factory(\"Uint64LE\", false, true);\n  Int64LE = factory(\"Int64LE\", false, false);\n\n  // class factory\n\n  function factory(name, bigendian, unsigned) {\n    var posH = bigendian ? 0 : 4;\n    var posL = bigendian ? 4 : 0;\n    var pos0 = bigendian ? 0 : 3;\n    var pos1 = bigendian ? 1 : 2;\n    var pos2 = bigendian ? 2 : 1;\n    var pos3 = bigendian ? 3 : 0;\n    var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;\n    var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;\n    var proto = Int64.prototype;\n    var isName = \"is\" + name;\n    var _isInt64 = \"_\" + isName;\n\n    // properties\n    proto.buffer = void 0;\n    proto.offset = 0;\n    proto[_isInt64] = true;\n\n    // methods\n    proto.toNumber = toNumber;\n    proto.toString = toString;\n    proto.toJSON = toNumber;\n    proto.toArray = toArray;\n\n    // add .toBuffer() method only when Buffer available\n    if (BUFFER) proto.toBuffer = toBuffer;\n\n    // add .toArrayBuffer() method only when Uint8Array available\n    if (UINT8ARRAY) proto.toArrayBuffer = toArrayBuffer;\n\n    // isUint64BE, isInt64BE\n    Int64[isName] = isInt64;\n\n    // CommonJS\n    exports[name] = Int64;\n\n    return Int64;\n\n    // constructor\n    function Int64(buffer, offset, value, raddix) {\n      if (!(this instanceof Int64)) return new Int64(buffer, offset, value, raddix);\n      return init(this, buffer, offset, value, raddix);\n    }\n\n    // isUint64BE, isInt64BE\n    function isInt64(b) {\n      return !!(b && b[_isInt64]);\n    }\n\n    // initializer\n    function init(that, buffer, offset, value, raddix) {\n      if (UINT8ARRAY && ARRAYBUFFER) {\n        if (buffer instanceof ARRAYBUFFER) buffer = new UINT8ARRAY(buffer);\n        if (value instanceof ARRAYBUFFER) value = new UINT8ARRAY(value);\n      }\n\n      // Int64BE() style\n      if (!buffer && !offset && !value && !storage) {\n        // shortcut to initialize with zero\n        that.buffer = newArray(ZERO, 0);\n        return;\n      }\n\n      // Int64BE(value, raddix) style\n      if (!isValidBuffer(buffer, offset)) {\n        var _storage = storage || Array;\n        raddix = offset;\n        value = buffer;\n        offset = 0;\n        buffer = new _storage(8);\n      }\n\n      that.buffer = buffer;\n      that.offset = offset |= 0;\n\n      // Int64BE(buffer, offset) style\n      if (UNDEFINED === typeof value) return;\n\n      // Int64BE(buffer, offset, value, raddix) style\n      if (\"string\" === typeof value) {\n        fromString(buffer, offset, value, raddix || 10);\n      } else if (isValidBuffer(value, raddix)) {\n        fromArray(buffer, offset, value, raddix);\n      } else if (\"number\" === typeof raddix) {\n        writeInt32(buffer, offset + posH, value); // high\n        writeInt32(buffer, offset + posL, raddix); // low\n      } else if (value > 0) {\n        fromPositive(buffer, offset, value); // positive\n      } else if (value < 0) {\n        fromNegative(buffer, offset, value); // negative\n      } else {\n        fromArray(buffer, offset, ZERO, 0); // zero, NaN and others\n      }\n    }\n\n    function fromString(buffer, offset, str, raddix) {\n      var pos = 0;\n      var len = str.length;\n      var high = 0;\n      var low = 0;\n      if (str[0] === \"-\") pos++;\n      var sign = pos;\n      while (pos < len) {\n        var chr = parseInt(str[pos++], raddix);\n        if (!(chr >= 0)) break; // NaN\n        low = low * raddix + chr;\n        high = high * raddix + Math.floor(low / BIT32);\n        low %= BIT32;\n      }\n      if (sign) {\n        high = ~high;\n        if (low) {\n          low = BIT32 - low;\n        } else {\n          high++;\n        }\n      }\n      writeInt32(buffer, offset + posH, high);\n      writeInt32(buffer, offset + posL, low);\n    }\n\n    function toNumber() {\n      var buffer = this.buffer;\n      var offset = this.offset;\n      var high = readInt32(buffer, offset + posH);\n      var low = readInt32(buffer, offset + posL);\n      if (!unsigned) high |= 0; // a trick to get signed\n      return high ? (high * BIT32 + low) : low;\n    }\n\n    function toString(radix) {\n      var buffer = this.buffer;\n      var offset = this.offset;\n      var high = readInt32(buffer, offset + posH);\n      var low = readInt32(buffer, offset + posL);\n      var str = \"\";\n      var sign = !unsigned && (high & 0x80000000);\n      if (sign) {\n        high = ~high;\n        low = BIT32 - low;\n      }\n      radix = radix || 10;\n      while (1) {\n        var mod = (high % radix) * BIT32 + low;\n        high = Math.floor(high / radix);\n        low = Math.floor(mod / radix);\n        str = (mod % radix).toString(radix) + str;\n        if (!high && !low) break;\n      }\n      if (sign) {\n        str = \"-\" + str;\n      }\n      return str;\n    }\n\n    function writeInt32(buffer, offset, value) {\n      buffer[offset + pos3] = value & 255;\n      value = value >> 8;\n      buffer[offset + pos2] = value & 255;\n      value = value >> 8;\n      buffer[offset + pos1] = value & 255;\n      value = value >> 8;\n      buffer[offset + pos0] = value & 255;\n    }\n\n    function readInt32(buffer, offset) {\n      return (buffer[offset + pos0] * BIT24) +\n        (buffer[offset + pos1] << 16) +\n        (buffer[offset + pos2] << 8) +\n        buffer[offset + pos3];\n    }\n  }\n\n  function toArray(raw) {\n    var buffer = this.buffer;\n    var offset = this.offset;\n    storage = null; // Array\n    if (raw !== false && offset === 0 && buffer.length === 8 && isArray(buffer)) return buffer;\n    return newArray(buffer, offset);\n  }\n\n  function toBuffer(raw) {\n    var buffer = this.buffer;\n    var offset = this.offset;\n    storage = BUFFER;\n    if (raw !== false && offset === 0 && buffer.length === 8 && Buffer.isBuffer(buffer)) return buffer;\n    var dest = new BUFFER(8);\n    fromArray(dest, 0, buffer, offset);\n    return dest;\n  }\n\n  function toArrayBuffer(raw) {\n    var buffer = this.buffer;\n    var offset = this.offset;\n    var arrbuf = buffer.buffer;\n    storage = UINT8ARRAY;\n    if (raw !== false && offset === 0 && (arrbuf instanceof ARRAYBUFFER) && arrbuf.byteLength === 8) return arrbuf;\n    var dest = new UINT8ARRAY(8);\n    fromArray(dest, 0, buffer, offset);\n    return dest.buffer;\n  }\n\n  function isValidBuffer(buffer, offset) {\n    var len = buffer && buffer.length;\n    offset |= 0;\n    return len && (offset + 8 <= len) && (\"string\" !== typeof buffer[offset]);\n  }\n\n  function fromArray(destbuf, destoff, srcbuf, srcoff) {\n    destoff |= 0;\n    srcoff |= 0;\n    for (var i = 0; i < 8; i++) {\n      destbuf[destoff++] = srcbuf[srcoff++] & 255;\n    }\n  }\n\n  function newArray(buffer, offset) {\n    return Array.prototype.slice.call(buffer, offset, offset + 8);\n  }\n\n  function fromPositiveBE(buffer, offset, value) {\n    var pos = offset + 8;\n    while (pos > offset) {\n      buffer[--pos] = value & 255;\n      value /= 256;\n    }\n  }\n\n  function fromNegativeBE(buffer, offset, value) {\n    var pos = offset + 8;\n    value++;\n    while (pos > offset) {\n      buffer[--pos] = ((-value) & 255) ^ 255;\n      value /= 256;\n    }\n  }\n\n  function fromPositiveLE(buffer, offset, value) {\n    var end = offset + 8;\n    while (offset < end) {\n      buffer[offset++] = value & 255;\n      value /= 256;\n    }\n  }\n\n  function fromNegativeLE(buffer, offset, value) {\n    var end = offset + 8;\n    value++;\n    while (offset < end) {\n      buffer[offset++] = ((-value) & 255) ^ 255;\n      value /= 256;\n    }\n  }\n\n  // https://github.com/retrofox/is-array\n  function _isArray(val) {\n    return !!val && \"[object Array]\" == Object.prototype.toString.call(val);\n  }\n\n}( true && typeof exports.nodeName !== 'string' ? exports : (this || {}));\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/int64-buffer/int64-buffer.js?");

/***/ }),

/***/ "./node_modules/is-callable/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-callable/index.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar fnToStr = Function.prototype.toString;\n\nvar constructorRegex = /^\\s*class\\b/;\nvar isES6ClassFn = function isES6ClassFunction(value) {\n\ttry {\n\t\tvar fnStr = fnToStr.call(value);\n\t\treturn constructorRegex.test(fnStr);\n\t} catch (e) {\n\t\treturn false; // not a function\n\t}\n};\n\nvar tryFunctionObject = function tryFunctionToStr(value) {\n\ttry {\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tfnToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar fnClass = '[object Function]';\nvar genClass = '[object GeneratorFunction]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nmodule.exports = function isCallable(value) {\n\tif (!value) { return false; }\n\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\tif (typeof value === 'function' && !value.prototype) { return true; }\n\tif (hasToStringTag) { return tryFunctionObject(value); }\n\tif (isES6ClassFn(value)) { return false; }\n\tvar strClass = toStr.call(value);\n\treturn strClass === fnClass || strClass === genClass;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/is-callable/index.js?");

/***/ }),

/***/ "./node_modules/is-docker/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-docker/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\");\n\nlet isDocker;\n\nfunction hasDockerEnv() {\n\ttry {\n\t\tfs.statSync('/.dockerenv');\n\t\treturn true;\n\t} catch (_) {\n\t\treturn false;\n\t}\n}\n\nfunction hasDockerCGroup() {\n\ttry {\n\t\treturn fs.readFileSync('/proc/self/cgroup', 'utf8').includes('docker');\n\t} catch (_) {\n\t\treturn false;\n\t}\n}\n\nmodule.exports = () => {\n\tif (isDocker === undefined) {\n\t\tisDocker = hasDockerEnv() || hasDockerCGroup();\n\t}\n\n\treturn isDocker;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/is-docker/index.js?");

/***/ }),

/***/ "./node_modules/is-wsl/index.js":
/*!**************************************!*\
  !*** ./node_modules/is-wsl/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst os = __webpack_require__(/*! os */ \"os\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst isDocker = __webpack_require__(/*! is-docker */ \"./node_modules/is-docker/index.js\");\n\nconst isWsl = () => {\n\tif (process.platform !== 'linux') {\n\t\treturn false;\n\t}\n\n\tif (os.release().toLowerCase().includes('microsoft')) {\n\t\tif (isDocker()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\ttry {\n\t\treturn fs.readFileSync('/proc/version', 'utf8').toLowerCase().includes('microsoft') ?\n\t\t\t!isDocker() : false;\n\t} catch (_) {\n\t\treturn false;\n\t}\n};\n\nif (process.env.__IS_WSL_TEST__) {\n\tmodule.exports = isWsl;\n} else {\n\tmodule.exports = isWsl();\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/is-wsl/index.js?");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/***/ ((module) => {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/isexe/index.js":
/*!*************************************!*\
  !*** ./node_modules/isexe/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var fs = __webpack_require__(/*! fs */ \"fs\")\nvar core\nif (process.platform === 'win32' || global.TESTING_WINDOWS) {\n  core = __webpack_require__(/*! ./windows.js */ \"./node_modules/isexe/windows.js\")\n} else {\n  core = __webpack_require__(/*! ./mode.js */ \"./node_modules/isexe/mode.js\")\n}\n\nmodule.exports = isexe\nisexe.sync = sync\n\nfunction isexe (path, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  if (!cb) {\n    if (typeof Promise !== 'function') {\n      throw new TypeError('callback not provided')\n    }\n\n    return new Promise(function (resolve, reject) {\n      isexe(path, options || {}, function (er, is) {\n        if (er) {\n          reject(er)\n        } else {\n          resolve(is)\n        }\n      })\n    })\n  }\n\n  core(path, options || {}, function (er, is) {\n    // ignore EACCES because that just means we aren't allowed to run it\n    if (er) {\n      if (er.code === 'EACCES' || options && options.ignoreErrors) {\n        er = null\n        is = false\n      }\n    }\n    cb(er, is)\n  })\n}\n\nfunction sync (path, options) {\n  // my kingdom for a filtered catch\n  try {\n    return core.sync(path, options || {})\n  } catch (er) {\n    if (options && options.ignoreErrors || er.code === 'EACCES') {\n      return false\n    } else {\n      throw er\n    }\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/isexe/index.js?");

/***/ }),

/***/ "./node_modules/isexe/mode.js":
/*!************************************!*\
  !*** ./node_modules/isexe/mode.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = isexe\nisexe.sync = sync\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), options)\n}\n\nfunction checkStat (stat, options) {\n  return stat.isFile() && checkMode(stat, options)\n}\n\nfunction checkMode (stat, options) {\n  var mod = stat.mode\n  var uid = stat.uid\n  var gid = stat.gid\n\n  var myUid = options.uid !== undefined ?\n    options.uid : process.getuid && process.getuid()\n  var myGid = options.gid !== undefined ?\n    options.gid : process.getgid && process.getgid()\n\n  var u = parseInt('100', 8)\n  var g = parseInt('010', 8)\n  var o = parseInt('001', 8)\n  var ug = u | g\n\n  var ret = (mod & o) ||\n    (mod & g) && gid === myGid ||\n    (mod & u) && uid === myUid ||\n    (mod & ug) && myUid === 0\n\n  return ret\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/isexe/mode.js?");

/***/ }),

/***/ "./node_modules/isexe/windows.js":
/*!***************************************!*\
  !*** ./node_modules/isexe/windows.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = isexe\nisexe.sync = sync\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\n\nfunction checkPathExt (path, options) {\n  var pathext = options.pathExt !== undefined ?\n    options.pathExt : process.env.PATHEXT\n\n  if (!pathext) {\n    return true\n  }\n\n  pathext = pathext.split(';')\n  if (pathext.indexOf('') !== -1) {\n    return true\n  }\n  for (var i = 0; i < pathext.length; i++) {\n    var p = pathext[i].toLowerCase()\n    if (p && path.substr(-p.length).toLowerCase() === p) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction checkStat (stat, path, options) {\n  if (!stat.isSymbolicLink() && !stat.isFile()) {\n    return false\n  }\n  return checkPathExt(path, options)\n}\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, path, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), path, options)\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/isexe/windows.js?");

/***/ }),

/***/ "./node_modules/isuri/index.js":
/*!*************************************!*\
  !*** ./node_modules/isuri/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar rfc3986 = __webpack_require__(/*! rfc-3986 */ \"./node_modules/rfc-3986/index.js\");\n\n// See: https://github.com/hapijs/hoek/blob/f62961d3d07aca68ab11480893e6e80a421914b4/lib/index.js#L783-L787\nfunction escapeRegex(string) {\n    // Escape ^$.*+-?=!:|\\/()[]{},\n    return string.replace(/[\\^\\$\\.\\*\\+\\-\\?\\=\\!\\:\\|\\\\\\/\\(\\)\\[\\]\\{\\}\\,]/g, '\\\\$&');\n}\n\nvar internals = {\n    Uri: {\n        createUriRegex: function (options) {\n            options = options || {};\n\n            if (typeof options !== 'object' || Array.isArray(options)) {\n                throw new Error('options must be an object');\n            }\n\n            var customScheme = '';\n\n            // If we were passed a scheme, use it instead of the generic one\n            if (options.scheme) {\n                if (!Array.isArray(options.scheme)) {\n                    options.scheme = [options.scheme];\n                }\n\n                if (options.scheme.length <= 0) {\n                    throw new Error('scheme must have at least 1 scheme specified');\n                }\n\n                for (var i = 0; i < options.scheme.length; ++i) {\n                    var currentScheme = options.scheme[i];\n\n                    if (!(currentScheme instanceof RegExp || typeof currentScheme === 'string')) {\n                        throw new Error('scheme must only contain Regular Expressions or Strings');\n                    }\n\n                    // Add OR separators if a value already exists\n                    customScheme = customScheme + (customScheme ? '|' : '');\n\n                    // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.\n                    if (currentScheme instanceof RegExp) {\n                        customScheme = customScheme + currentScheme.source;\n                    } else {\n                        if (!/[a-zA-Z][a-zA-Z0-9+-\\.]*/.test(currentScheme)) {\n                            throw new Error('scheme at position ' + i + ' must be a valid scheme');\n                        }\n                        customScheme = customScheme + escapeRegex(currentScheme);\n                    }\n                }\n\n            }\n\n            // Have to put this in a non-capturing group to handle the OR statements\n            var scheme = '(?:' + (customScheme || rfc3986.scheme) + ')';\n\n            /**\n             * URI = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]\n             *\n             * OR\n             *\n             * relative-ref = relative-part [ \"?\" query ] [ \"#\" fragment ]\n             */\n            return new RegExp('^(?:' + scheme + ':' + rfc3986.hierPart + ')(?:\\\\?' + rfc3986.query + ')?(?:#' + rfc3986.fragment + ')?$');\n        },\n        uriRegex: new RegExp(rfc3986.uri)\n    }\n};\n\ninternals.Uri.isValid = function (val) {\n    return internals.Uri.uriRegex.test(val);\n};\n\nmodule.exports = {\n    createUriRegex: internals.Uri.createUriRegex,\n\n    uriRegex: internals.Uri.uriRegex,\n    isValid: internals.Uri.isValid\n};\n\n//# sourceURL=webpack://coc.nvim/./node_modules/isuri/index.js?");

/***/ }),

/***/ "./node_modules/jsonc-parser/lib/esm/impl/edit.js":
/*!********************************************************!*\
  !*** ./node_modules/jsonc-parser/lib/esm/impl/edit.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"removeProperty\": () => /* binding */ removeProperty,\n/* harmony export */   \"setProperty\": () => /* binding */ setProperty,\n/* harmony export */   \"applyEdit\": () => /* binding */ applyEdit,\n/* harmony export */   \"isWS\": () => /* binding */ isWS\n/* harmony export */ });\n/* harmony import */ var _format__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./format */ \"./node_modules/jsonc-parser/lib/esm/impl/format.js\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parser */ \"./node_modules/jsonc-parser/lib/esm/impl/parser.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\nfunction removeProperty(text, path, options) {\n    return setProperty(text, path, void 0, options);\n}\nfunction setProperty(text, originalPath, value, options) {\n    var _a;\n    var path = originalPath.slice();\n    var errors = [];\n    var root = (0,_parser__WEBPACK_IMPORTED_MODULE_1__.parseTree)(text, errors);\n    var parent = void 0;\n    var lastSegment = void 0;\n    while (path.length > 0) {\n        lastSegment = path.pop();\n        parent = (0,_parser__WEBPACK_IMPORTED_MODULE_1__.findNodeAtLocation)(root, path);\n        if (parent === void 0 && value !== void 0) {\n            if (typeof lastSegment === 'string') {\n                value = (_a = {}, _a[lastSegment] = value, _a);\n            }\n            else {\n                value = [value];\n            }\n        }\n        else {\n            break;\n        }\n    }\n    if (!parent) {\n        // empty document\n        if (value === void 0) { // delete\n            throw new Error('Can not delete in empty document');\n        }\n        return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, options);\n    }\n    else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {\n        var existing = (0,_parser__WEBPACK_IMPORTED_MODULE_1__.findNodeAtLocation)(parent, [lastSegment]);\n        if (existing !== void 0) {\n            if (value === void 0) { // delete\n                if (!existing.parent) {\n                    throw new Error('Malformed AST');\n                }\n                var propertyIndex = parent.children.indexOf(existing.parent);\n                var removeBegin = void 0;\n                var removeEnd = existing.parent.offset + existing.parent.length;\n                if (propertyIndex > 0) {\n                    // remove the comma of the previous node\n                    var previous = parent.children[propertyIndex - 1];\n                    removeBegin = previous.offset + previous.length;\n                }\n                else {\n                    removeBegin = parent.offset + 1;\n                    if (parent.children.length > 1) {\n                        // remove the comma of the next node\n                        var next = parent.children[1];\n                        removeEnd = next.offset;\n                    }\n                }\n                return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: '' }, options);\n            }\n            else {\n                // set value of existing property\n                return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, options);\n            }\n        }\n        else {\n            if (value === void 0) { // delete\n                return []; // property does not exist, nothing to do\n            }\n            var newProperty = JSON.stringify(lastSegment) + \": \" + JSON.stringify(value);\n            var index = options.getInsertionIndex ? options.getInsertionIndex(parent.children.map(function (p) { return p.children[0].value; })) : parent.children.length;\n            var edit = void 0;\n            if (index > 0) {\n                var previous = parent.children[index - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            else if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty + ',' };\n            }\n            return withFormatting(text, edit, options);\n        }\n    }\n    else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {\n        var insertIndex = lastSegment;\n        if (insertIndex === -1) {\n            // Insert\n            var newProperty = \"\" + JSON.stringify(value);\n            var edit = void 0;\n            if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                var previous = parent.children[parent.children.length - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else if (value === void 0 && parent.children.length >= 0) {\n            // Removal\n            var removalIndex = lastSegment;\n            var toRemove = parent.children[removalIndex];\n            var edit = void 0;\n            if (parent.children.length === 1) {\n                // only item\n                edit = { offset: parent.offset + 1, length: parent.length - 2, content: '' };\n            }\n            else if (parent.children.length - 1 === removalIndex) {\n                // last item\n                var previous = parent.children[removalIndex - 1];\n                var offset = previous.offset + previous.length;\n                var parentEndOffset = parent.offset + parent.length;\n                edit = { offset: offset, length: parentEndOffset - 2 - offset, content: '' };\n            }\n            else {\n                edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: '' };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else if (value !== void 0) {\n            var edit = void 0;\n            var newProperty = \"\" + JSON.stringify(value);\n            if (!options.isArrayInsertion && parent.children.length > lastSegment) {\n                var toModify = parent.children[lastSegment];\n                edit = { offset: toModify.offset, length: toModify.length, content: newProperty };\n            }\n            else if (parent.children.length === 0 || lastSegment === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: parent.children.length === 0 ? newProperty : newProperty + ',' };\n            }\n            else {\n                var index = lastSegment > parent.children.length ? parent.children.length : lastSegment;\n                var previous = parent.children[index - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else {\n            throw new Error(\"Can not \" + (value === void 0 ? 'remove' : (options.isArrayInsertion ? 'insert' : 'modify')) + \" Array index \" + insertIndex + \" as length is not sufficient\");\n        }\n    }\n    else {\n        throw new Error(\"Can not add \" + (typeof lastSegment !== 'number' ? 'index' : 'property') + \" to parent of type \" + parent.type);\n    }\n}\nfunction withFormatting(text, edit, options) {\n    if (!options.formattingOptions) {\n        return [edit];\n    }\n    // apply the edit\n    var newText = applyEdit(text, edit);\n    // format the new text\n    var begin = edit.offset;\n    var end = edit.offset + edit.content.length;\n    if (edit.length === 0 || edit.content.length === 0) { // insert or remove\n        while (begin > 0 && !(0,_format__WEBPACK_IMPORTED_MODULE_0__.isEOL)(newText, begin - 1)) {\n            begin--;\n        }\n        while (end < newText.length && !(0,_format__WEBPACK_IMPORTED_MODULE_0__.isEOL)(newText, end)) {\n            end++;\n        }\n    }\n    var edits = (0,_format__WEBPACK_IMPORTED_MODULE_0__.format)(newText, { offset: begin, length: end - begin }, options.formattingOptions);\n    // apply the formatting edits and track the begin and end offsets of the changes\n    for (var i = edits.length - 1; i >= 0; i--) {\n        var edit_1 = edits[i];\n        newText = applyEdit(newText, edit_1);\n        begin = Math.min(begin, edit_1.offset);\n        end = Math.max(end, edit_1.offset + edit_1.length);\n        end += edit_1.content.length - edit_1.length;\n    }\n    // create a single edit with all changes\n    var editLength = text.length - (newText.length - end) - begin;\n    return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];\n}\nfunction applyEdit(text, edit) {\n    return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);\n}\nfunction isWS(text, offset) {\n    return '\\r\\n \\t'.indexOf(text.charAt(offset)) !== -1;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/jsonc-parser/lib/esm/impl/edit.js?");

/***/ }),

/***/ "./node_modules/jsonc-parser/lib/esm/impl/format.js":
/*!**********************************************************!*\
  !*** ./node_modules/jsonc-parser/lib/esm/impl/format.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"format\": () => /* binding */ format,\n/* harmony export */   \"isEOL\": () => /* binding */ isEOL\n/* harmony export */ });\n/* harmony import */ var _scanner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scanner */ \"./node_modules/jsonc-parser/lib/esm/impl/scanner.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nfunction format(documentText, range, options) {\n    var initialIndentLevel;\n    var formatText;\n    var formatTextStart;\n    var rangeStart;\n    var rangeEnd;\n    if (range) {\n        rangeStart = range.offset;\n        rangeEnd = rangeStart + range.length;\n        formatTextStart = rangeStart;\n        while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {\n            formatTextStart--;\n        }\n        var endOffset = rangeEnd;\n        while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {\n            endOffset++;\n        }\n        formatText = documentText.substring(formatTextStart, endOffset);\n        initialIndentLevel = computeIndentLevel(formatText, options);\n    }\n    else {\n        formatText = documentText;\n        initialIndentLevel = 0;\n        formatTextStart = 0;\n        rangeStart = 0;\n        rangeEnd = documentText.length;\n    }\n    var eol = getEOL(options, documentText);\n    var lineBreak = false;\n    var indentLevel = 0;\n    var indentValue;\n    if (options.insertSpaces) {\n        indentValue = repeat(' ', options.tabSize || 4);\n    }\n    else {\n        indentValue = '\\t';\n    }\n    var scanner = (0,_scanner__WEBPACK_IMPORTED_MODULE_0__.createScanner)(formatText, false);\n    var hasError = false;\n    function newLineAndIndent() {\n        return eol + repeat(indentValue, initialIndentLevel + indentLevel);\n    }\n    function scanNext() {\n        var token = scanner.scan();\n        lineBreak = false;\n        while (token === 15 /* Trivia */ || token === 14 /* LineBreakTrivia */) {\n            lineBreak = lineBreak || (token === 14 /* LineBreakTrivia */);\n            token = scanner.scan();\n        }\n        hasError = token === 16 /* Unknown */ || scanner.getTokenError() !== 0 /* None */;\n        return token;\n    }\n    var editOperations = [];\n    function addEdit(text, startOffset, endOffset) {\n        if (!hasError && startOffset < rangeEnd && endOffset > rangeStart && documentText.substring(startOffset, endOffset) !== text) {\n            editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });\n        }\n    }\n    var firstToken = scanNext();\n    if (firstToken !== 17 /* EOF */) {\n        var firstTokenStart = scanner.getTokenOffset() + formatTextStart;\n        var initialIndent = repeat(indentValue, initialIndentLevel);\n        addEdit(initialIndent, formatTextStart, firstTokenStart);\n    }\n    while (firstToken !== 17 /* EOF */) {\n        var firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n        var secondToken = scanNext();\n        var replaceContent = '';\n        while (!lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {\n            // comments on the same line: keep them on the same line, but ignore them otherwise\n            var commentTokenStart = scanner.getTokenOffset() + formatTextStart;\n            addEdit(' ', firstTokenEnd, commentTokenStart);\n            firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n            replaceContent = secondToken === 12 /* LineCommentTrivia */ ? newLineAndIndent() : '';\n            secondToken = scanNext();\n        }\n        if (secondToken === 2 /* CloseBraceToken */) {\n            if (firstToken !== 1 /* OpenBraceToken */) {\n                indentLevel--;\n                replaceContent = newLineAndIndent();\n            }\n        }\n        else if (secondToken === 4 /* CloseBracketToken */) {\n            if (firstToken !== 3 /* OpenBracketToken */) {\n                indentLevel--;\n                replaceContent = newLineAndIndent();\n            }\n        }\n        else {\n            switch (firstToken) {\n                case 3 /* OpenBracketToken */:\n                case 1 /* OpenBraceToken */:\n                    indentLevel++;\n                    replaceContent = newLineAndIndent();\n                    break;\n                case 5 /* CommaToken */:\n                case 12 /* LineCommentTrivia */:\n                    replaceContent = newLineAndIndent();\n                    break;\n                case 13 /* BlockCommentTrivia */:\n                    if (lineBreak) {\n                        replaceContent = newLineAndIndent();\n                    }\n                    else {\n                        // symbol following comment on the same line: keep on same line, separate with ' '\n                        replaceContent = ' ';\n                    }\n                    break;\n                case 6 /* ColonToken */:\n                    replaceContent = ' ';\n                    break;\n                case 10 /* StringLiteral */:\n                    if (secondToken === 6 /* ColonToken */) {\n                        replaceContent = '';\n                        break;\n                    }\n                // fall through\n                case 7 /* NullKeyword */:\n                case 8 /* TrueKeyword */:\n                case 9 /* FalseKeyword */:\n                case 11 /* NumericLiteral */:\n                case 2 /* CloseBraceToken */:\n                case 4 /* CloseBracketToken */:\n                    if (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */) {\n                        replaceContent = ' ';\n                    }\n                    else if (secondToken !== 5 /* CommaToken */ && secondToken !== 17 /* EOF */) {\n                        hasError = true;\n                    }\n                    break;\n                case 16 /* Unknown */:\n                    hasError = true;\n                    break;\n            }\n            if (lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {\n                replaceContent = newLineAndIndent();\n            }\n        }\n        var secondTokenStart = scanner.getTokenOffset() + formatTextStart;\n        addEdit(replaceContent, firstTokenEnd, secondTokenStart);\n        firstToken = secondToken;\n    }\n    return editOperations;\n}\nfunction repeat(s, count) {\n    var result = '';\n    for (var i = 0; i < count; i++) {\n        result += s;\n    }\n    return result;\n}\nfunction computeIndentLevel(content, options) {\n    var i = 0;\n    var nChars = 0;\n    var tabSize = options.tabSize || 4;\n    while (i < content.length) {\n        var ch = content.charAt(i);\n        if (ch === ' ') {\n            nChars++;\n        }\n        else if (ch === '\\t') {\n            nChars += tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    return Math.floor(nChars / tabSize);\n}\nfunction getEOL(options, text) {\n    for (var i = 0; i < text.length; i++) {\n        var ch = text.charAt(i);\n        if (ch === '\\r') {\n            if (i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                return '\\r\\n';\n            }\n            return '\\r';\n        }\n        else if (ch === '\\n') {\n            return '\\n';\n        }\n    }\n    return (options && options.eol) || '\\n';\n}\nfunction isEOL(text, offset) {\n    return '\\r\\n'.indexOf(text.charAt(offset)) !== -1;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/jsonc-parser/lib/esm/impl/format.js?");

/***/ }),

/***/ "./node_modules/jsonc-parser/lib/esm/impl/parser.js":
/*!**********************************************************!*\
  !*** ./node_modules/jsonc-parser/lib/esm/impl/parser.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getLocation\": () => /* binding */ getLocation,\n/* harmony export */   \"parse\": () => /* binding */ parse,\n/* harmony export */   \"parseTree\": () => /* binding */ parseTree,\n/* harmony export */   \"findNodeAtLocation\": () => /* binding */ findNodeAtLocation,\n/* harmony export */   \"getNodePath\": () => /* binding */ getNodePath,\n/* harmony export */   \"getNodeValue\": () => /* binding */ getNodeValue,\n/* harmony export */   \"contains\": () => /* binding */ contains,\n/* harmony export */   \"findNodeAtOffset\": () => /* binding */ findNodeAtOffset,\n/* harmony export */   \"visit\": () => /* binding */ visit,\n/* harmony export */   \"stripComments\": () => /* binding */ stripComments,\n/* harmony export */   \"getNodeType\": () => /* binding */ getNodeType\n/* harmony export */ });\n/* harmony import */ var _scanner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scanner */ \"./node_modules/jsonc-parser/lib/esm/impl/scanner.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nvar ParseOptions;\n(function (ParseOptions) {\n    ParseOptions.DEFAULT = {\n        allowTrailingComma: false\n    };\n})(ParseOptions || (ParseOptions = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nfunction getLocation(text, position) {\n    var segments = []; // strings or numbers\n    var earlyReturnException = new Object();\n    var previousNode = undefined;\n    var previousNodeInst = {\n        value: {},\n        offset: 0,\n        length: 0,\n        type: 'object',\n        parent: undefined\n    };\n    var isAtPropertyKey = false;\n    function setPreviousNode(value, offset, length, type) {\n        previousNodeInst.value = value;\n        previousNodeInst.offset = offset;\n        previousNodeInst.length = length;\n        previousNodeInst.type = type;\n        previousNodeInst.colonOffset = undefined;\n        previousNode = previousNodeInst;\n    }\n    try {\n        visit(text, {\n            onObjectBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                isAtPropertyKey = position > offset;\n                segments.push(''); // push a placeholder (will be replaced)\n            },\n            onObjectProperty: function (name, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(name, offset, length, 'property');\n                segments[segments.length - 1] = name;\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onObjectEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onArrayBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.push(0);\n            },\n            onArrayEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onLiteralValue: function (value, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(value, offset, length, getNodeType(value));\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onSeparator: function (sep, offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                if (sep === ':' && previousNode && previousNode.type === 'property') {\n                    previousNode.colonOffset = offset;\n                    isAtPropertyKey = false;\n                    previousNode = undefined;\n                }\n                else if (sep === ',') {\n                    var last = segments[segments.length - 1];\n                    if (typeof last === 'number') {\n                        segments[segments.length - 1] = last + 1;\n                    }\n                    else {\n                        isAtPropertyKey = true;\n                        segments[segments.length - 1] = '';\n                    }\n                    previousNode = undefined;\n                }\n            }\n        });\n    }\n    catch (e) {\n        if (e !== earlyReturnException) {\n            throw e;\n        }\n    }\n    return {\n        path: segments,\n        previousNode: previousNode,\n        isAtPropertyKey: isAtPropertyKey,\n        matches: function (pattern) {\n            var k = 0;\n            for (var i = 0; k < pattern.length && i < segments.length; i++) {\n                if (pattern[k] === segments[i] || pattern[k] === '*') {\n                    k++;\n                }\n                else if (pattern[k] !== '**') {\n                    return false;\n                }\n            }\n            return k === pattern.length;\n        }\n    };\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nfunction parse(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var currentProperty = null;\n    var currentParent = [];\n    var previousParents = [];\n    function onValue(value) {\n        if (Array.isArray(currentParent)) {\n            currentParent.push(value);\n        }\n        else if (currentProperty !== null) {\n            currentParent[currentProperty] = value;\n        }\n    }\n    var visitor = {\n        onObjectBegin: function () {\n            var object = {};\n            onValue(object);\n            previousParents.push(currentParent);\n            currentParent = object;\n            currentProperty = null;\n        },\n        onObjectProperty: function (name) {\n            currentProperty = name;\n        },\n        onObjectEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onArrayBegin: function () {\n            var array = [];\n            onValue(array);\n            previousParents.push(currentParent);\n            currentParent = array;\n            currentProperty = null;\n        },\n        onArrayEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onLiteralValue: onValue,\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    return currentParent[0];\n}\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nfunction parseTree(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root\n    function ensurePropertyComplete(endOffset) {\n        if (currentParent.type === 'property') {\n            currentParent.length = endOffset - currentParent.offset;\n            currentParent = currentParent.parent;\n        }\n    }\n    function onValue(valueNode) {\n        currentParent.children.push(valueNode);\n        return valueNode;\n    }\n    var visitor = {\n        onObjectBegin: function (offset) {\n            currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onObjectProperty: function (name, offset, length) {\n            currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });\n            currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });\n        },\n        onObjectEnd: function (offset, length) {\n            ensurePropertyComplete(offset + length); // in case of a missing value for a property: make sure property is complete\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onArrayBegin: function (offset, length) {\n            currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onArrayEnd: function (offset, length) {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onLiteralValue: function (value, offset, length) {\n            onValue({ type: getNodeType(value), offset: offset, length: length, parent: currentParent, value: value });\n            ensurePropertyComplete(offset + length);\n        },\n        onSeparator: function (sep, offset, length) {\n            if (currentParent.type === 'property') {\n                if (sep === ':') {\n                    currentParent.colonOffset = offset;\n                }\n                else if (sep === ',') {\n                    ensurePropertyComplete(offset);\n                }\n            }\n        },\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    var result = currentParent.children[0];\n    if (result) {\n        delete result.parent;\n    }\n    return result;\n}\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nfunction findNodeAtLocation(root, path) {\n    if (!root) {\n        return undefined;\n    }\n    var node = root;\n    for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n        var segment = path_1[_i];\n        if (typeof segment === 'string') {\n            if (node.type !== 'object' || !Array.isArray(node.children)) {\n                return undefined;\n            }\n            var found = false;\n            for (var _a = 0, _b = node.children; _a < _b.length; _a++) {\n                var propertyNode = _b[_a];\n                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {\n                    node = propertyNode.children[1];\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return undefined;\n            }\n        }\n        else {\n            var index = segment;\n            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n                return undefined;\n            }\n            node = node.children[index];\n        }\n    }\n    return node;\n}\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nfunction getNodePath(node) {\n    if (!node.parent || !node.parent.children) {\n        return [];\n    }\n    var path = getNodePath(node.parent);\n    if (node.parent.type === 'property') {\n        var key = node.parent.children[0].value;\n        path.push(key);\n    }\n    else if (node.parent.type === 'array') {\n        var index = node.parent.children.indexOf(node);\n        if (index !== -1) {\n            path.push(index);\n        }\n    }\n    return path;\n}\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nfunction getNodeValue(node) {\n    switch (node.type) {\n        case 'array':\n            return node.children.map(getNodeValue);\n        case 'object':\n            var obj = Object.create(null);\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                var prop = _a[_i];\n                var valueNode = prop.children[1];\n                if (valueNode) {\n                    obj[prop.children[0].value] = getNodeValue(valueNode);\n                }\n            }\n            return obj;\n        case 'null':\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return node.value;\n        default:\n            return undefined;\n    }\n}\nfunction contains(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));\n}\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nfunction findNodeAtOffset(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    if (contains(node, offset, includeRightBound)) {\n        var children = node.children;\n        if (Array.isArray(children)) {\n            for (var i = 0; i < children.length && children[i].offset <= offset; i++) {\n                var item = findNodeAtOffset(children[i], offset, includeRightBound);\n                if (item) {\n                    return item;\n                }\n            }\n        }\n        return node;\n    }\n    return undefined;\n}\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nfunction visit(text, visitor, options) {\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var _scanner = (0,_scanner__WEBPACK_IMPORTED_MODULE_0__.createScanner)(text, false);\n    function toNoArgVisit(visitFunction) {\n        return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };\n    }\n    function toOneArgVisit(visitFunction) {\n        return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };\n    }\n    var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);\n    var disallowComments = options && options.disallowComments;\n    var allowTrailingComma = options && options.allowTrailingComma;\n    function scanNext() {\n        while (true) {\n            var token = _scanner.scan();\n            switch (_scanner.getTokenError()) {\n                case 4 /* InvalidUnicode */:\n                    handleError(14 /* InvalidUnicode */);\n                    break;\n                case 5 /* InvalidEscapeCharacter */:\n                    handleError(15 /* InvalidEscapeCharacter */);\n                    break;\n                case 3 /* UnexpectedEndOfNumber */:\n                    handleError(13 /* UnexpectedEndOfNumber */);\n                    break;\n                case 1 /* UnexpectedEndOfComment */:\n                    if (!disallowComments) {\n                        handleError(11 /* UnexpectedEndOfComment */);\n                    }\n                    break;\n                case 2 /* UnexpectedEndOfString */:\n                    handleError(12 /* UnexpectedEndOfString */);\n                    break;\n                case 6 /* InvalidCharacter */:\n                    handleError(16 /* InvalidCharacter */);\n                    break;\n            }\n            switch (token) {\n                case 12 /* LineCommentTrivia */:\n                case 13 /* BlockCommentTrivia */:\n                    if (disallowComments) {\n                        handleError(10 /* InvalidCommentToken */);\n                    }\n                    else {\n                        onComment();\n                    }\n                    break;\n                case 16 /* Unknown */:\n                    handleError(1 /* InvalidSymbol */);\n                    break;\n                case 15 /* Trivia */:\n                case 14 /* LineBreakTrivia */:\n                    break;\n                default:\n                    return token;\n            }\n        }\n    }\n    function handleError(error, skipUntilAfter, skipUntil) {\n        if (skipUntilAfter === void 0) { skipUntilAfter = []; }\n        if (skipUntil === void 0) { skipUntil = []; }\n        onError(error);\n        if (skipUntilAfter.length + skipUntil.length > 0) {\n            var token = _scanner.getToken();\n            while (token !== 17 /* EOF */) {\n                if (skipUntilAfter.indexOf(token) !== -1) {\n                    scanNext();\n                    break;\n                }\n                else if (skipUntil.indexOf(token) !== -1) {\n                    break;\n                }\n                token = scanNext();\n            }\n        }\n    }\n    function parseString(isValue) {\n        var value = _scanner.getTokenValue();\n        if (isValue) {\n            onLiteralValue(value);\n        }\n        else {\n            onObjectProperty(value);\n        }\n        scanNext();\n        return true;\n    }\n    function parseLiteral() {\n        switch (_scanner.getToken()) {\n            case 11 /* NumericLiteral */:\n                var tokenValue = _scanner.getTokenValue();\n                var value = Number(tokenValue);\n                if (isNaN(value)) {\n                    handleError(2 /* InvalidNumberFormat */);\n                    value = 0;\n                }\n                onLiteralValue(value);\n                break;\n            case 7 /* NullKeyword */:\n                onLiteralValue(null);\n                break;\n            case 8 /* TrueKeyword */:\n                onLiteralValue(true);\n                break;\n            case 9 /* FalseKeyword */:\n                onLiteralValue(false);\n                break;\n            default:\n                return false;\n        }\n        scanNext();\n        return true;\n    }\n    function parseProperty() {\n        if (_scanner.getToken() !== 10 /* StringLiteral */) {\n            handleError(3 /* PropertyNameExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            return false;\n        }\n        parseString(false);\n        if (_scanner.getToken() === 6 /* ColonToken */) {\n            onSeparator(':');\n            scanNext(); // consume colon\n            if (!parseValue()) {\n                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            }\n        }\n        else {\n            handleError(5 /* ColonExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n        }\n        return true;\n    }\n    function parseObject() {\n        onObjectBegin();\n        scanNext(); // consume open brace\n        var needsComma = false;\n        while (_scanner.getToken() !== 2 /* CloseBraceToken */ && _scanner.getToken() !== 17 /* EOF */) {\n            if (_scanner.getToken() === 5 /* CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 2 /* CloseBraceToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* CommaExpected */, [], []);\n            }\n            if (!parseProperty()) {\n                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onObjectEnd();\n        if (_scanner.getToken() !== 2 /* CloseBraceToken */) {\n            handleError(7 /* CloseBraceExpected */, [2 /* CloseBraceToken */], []);\n        }\n        else {\n            scanNext(); // consume close brace\n        }\n        return true;\n    }\n    function parseArray() {\n        onArrayBegin();\n        scanNext(); // consume open bracket\n        var needsComma = false;\n        while (_scanner.getToken() !== 4 /* CloseBracketToken */ && _scanner.getToken() !== 17 /* EOF */) {\n            if (_scanner.getToken() === 5 /* CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 4 /* CloseBracketToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* CommaExpected */, [], []);\n            }\n            if (!parseValue()) {\n                handleError(4 /* ValueExpected */, [], [4 /* CloseBracketToken */, 5 /* CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onArrayEnd();\n        if (_scanner.getToken() !== 4 /* CloseBracketToken */) {\n            handleError(8 /* CloseBracketExpected */, [4 /* CloseBracketToken */], []);\n        }\n        else {\n            scanNext(); // consume close bracket\n        }\n        return true;\n    }\n    function parseValue() {\n        switch (_scanner.getToken()) {\n            case 3 /* OpenBracketToken */:\n                return parseArray();\n            case 1 /* OpenBraceToken */:\n                return parseObject();\n            case 10 /* StringLiteral */:\n                return parseString(true);\n            default:\n                return parseLiteral();\n        }\n    }\n    scanNext();\n    if (_scanner.getToken() === 17 /* EOF */) {\n        if (options.allowEmptyContent) {\n            return true;\n        }\n        handleError(4 /* ValueExpected */, [], []);\n        return false;\n    }\n    if (!parseValue()) {\n        handleError(4 /* ValueExpected */, [], []);\n        return false;\n    }\n    if (_scanner.getToken() !== 17 /* EOF */) {\n        handleError(9 /* EndOfFileExpected */, [], []);\n    }\n    return true;\n}\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nfunction stripComments(text, replaceCh) {\n    var _scanner = (0,_scanner__WEBPACK_IMPORTED_MODULE_0__.createScanner)(text), parts = [], kind, offset = 0, pos;\n    do {\n        pos = _scanner.getPosition();\n        kind = _scanner.scan();\n        switch (kind) {\n            case 12 /* LineCommentTrivia */:\n            case 13 /* BlockCommentTrivia */:\n            case 17 /* EOF */:\n                if (offset !== pos) {\n                    parts.push(text.substring(offset, pos));\n                }\n                if (replaceCh !== undefined) {\n                    parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n                }\n                offset = _scanner.getPosition();\n                break;\n        }\n    } while (kind !== 17 /* EOF */);\n    return parts.join('');\n}\nfunction getNodeType(value) {\n    switch (typeof value) {\n        case 'boolean': return 'boolean';\n        case 'number': return 'number';\n        case 'string': return 'string';\n        case 'object': {\n            if (!value) {\n                return 'null';\n            }\n            else if (Array.isArray(value)) {\n                return 'array';\n            }\n            return 'object';\n        }\n        default: return 'null';\n    }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/jsonc-parser/lib/esm/impl/parser.js?");

/***/ }),

/***/ "./node_modules/jsonc-parser/lib/esm/impl/scanner.js":
/*!***********************************************************!*\
  !*** ./node_modules/jsonc-parser/lib/esm/impl/scanner.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createScanner\": () => /* binding */ createScanner\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nfunction createScanner(text, ignoreTrivia) {\n    if (ignoreTrivia === void 0) { ignoreTrivia = false; }\n    var len = text.length;\n    var pos = 0, value = '', tokenOffset = 0, token = 16 /* Unknown */, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0 /* None */;\n    function scanHexDigits(count, exact) {\n        var digits = 0;\n        var value = 0;\n        while (digits < count || !exact) {\n            var ch = text.charCodeAt(pos);\n            if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {\n                value = value * 16 + ch - 48 /* _0 */;\n            }\n            else if (ch >= 65 /* A */ && ch <= 70 /* F */) {\n                value = value * 16 + ch - 65 /* A */ + 10;\n            }\n            else if (ch >= 97 /* a */ && ch <= 102 /* f */) {\n                value = value * 16 + ch - 97 /* a */ + 10;\n            }\n            else {\n                break;\n            }\n            pos++;\n            digits++;\n        }\n        if (digits < count) {\n            value = -1;\n        }\n        return value;\n    }\n    function setPosition(newPosition) {\n        pos = newPosition;\n        value = '';\n        tokenOffset = 0;\n        token = 16 /* Unknown */;\n        scanError = 0 /* None */;\n    }\n    function scanNumber() {\n        var start = pos;\n        if (text.charCodeAt(pos) === 48 /* _0 */) {\n            pos++;\n        }\n        else {\n            pos++;\n            while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n            }\n        }\n        if (pos < text.length && text.charCodeAt(pos) === 46 /* dot */) {\n            pos++;\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n            }\n            else {\n                scanError = 3 /* UnexpectedEndOfNumber */;\n                return text.substring(start, pos);\n            }\n        }\n        var end = pos;\n        if (pos < text.length && (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */)) {\n            pos++;\n            if (pos < text.length && text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */) {\n                pos++;\n            }\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n                end = pos;\n            }\n            else {\n                scanError = 3 /* UnexpectedEndOfNumber */;\n            }\n        }\n        return text.substring(start, end);\n    }\n    function scanString() {\n        var result = '', start = pos;\n        while (true) {\n            if (pos >= len) {\n                result += text.substring(start, pos);\n                scanError = 2 /* UnexpectedEndOfString */;\n                break;\n            }\n            var ch = text.charCodeAt(pos);\n            if (ch === 34 /* doubleQuote */) {\n                result += text.substring(start, pos);\n                pos++;\n                break;\n            }\n            if (ch === 92 /* backslash */) {\n                result += text.substring(start, pos);\n                pos++;\n                if (pos >= len) {\n                    scanError = 2 /* UnexpectedEndOfString */;\n                    break;\n                }\n                var ch2 = text.charCodeAt(pos++);\n                switch (ch2) {\n                    case 34 /* doubleQuote */:\n                        result += '\\\"';\n                        break;\n                    case 92 /* backslash */:\n                        result += '\\\\';\n                        break;\n                    case 47 /* slash */:\n                        result += '/';\n                        break;\n                    case 98 /* b */:\n                        result += '\\b';\n                        break;\n                    case 102 /* f */:\n                        result += '\\f';\n                        break;\n                    case 110 /* n */:\n                        result += '\\n';\n                        break;\n                    case 114 /* r */:\n                        result += '\\r';\n                        break;\n                    case 116 /* t */:\n                        result += '\\t';\n                        break;\n                    case 117 /* u */:\n                        var ch3 = scanHexDigits(4, true);\n                        if (ch3 >= 0) {\n                            result += String.fromCharCode(ch3);\n                        }\n                        else {\n                            scanError = 4 /* InvalidUnicode */;\n                        }\n                        break;\n                    default:\n                        scanError = 5 /* InvalidEscapeCharacter */;\n                }\n                start = pos;\n                continue;\n            }\n            if (ch >= 0 && ch <= 0x1f) {\n                if (isLineBreak(ch)) {\n                    result += text.substring(start, pos);\n                    scanError = 2 /* UnexpectedEndOfString */;\n                    break;\n                }\n                else {\n                    scanError = 6 /* InvalidCharacter */;\n                    // mark as error but continue with string\n                }\n            }\n            pos++;\n        }\n        return result;\n    }\n    function scanNext() {\n        value = '';\n        scanError = 0 /* None */;\n        tokenOffset = pos;\n        lineStartOffset = lineNumber;\n        prevTokenLineStartOffset = tokenLineStartOffset;\n        if (pos >= len) {\n            // at the end\n            tokenOffset = len;\n            return token = 17 /* EOF */;\n        }\n        var code = text.charCodeAt(pos);\n        // trivia: whitespace\n        if (isWhiteSpace(code)) {\n            do {\n                pos++;\n                value += String.fromCharCode(code);\n                code = text.charCodeAt(pos);\n            } while (isWhiteSpace(code));\n            return token = 15 /* Trivia */;\n        }\n        // trivia: newlines\n        if (isLineBreak(code)) {\n            pos++;\n            value += String.fromCharCode(code);\n            if (code === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {\n                pos++;\n                value += '\\n';\n            }\n            lineNumber++;\n            tokenLineStartOffset = pos;\n            return token = 14 /* LineBreakTrivia */;\n        }\n        switch (code) {\n            // tokens: []{}:,\n            case 123 /* openBrace */:\n                pos++;\n                return token = 1 /* OpenBraceToken */;\n            case 125 /* closeBrace */:\n                pos++;\n                return token = 2 /* CloseBraceToken */;\n            case 91 /* openBracket */:\n                pos++;\n                return token = 3 /* OpenBracketToken */;\n            case 93 /* closeBracket */:\n                pos++;\n                return token = 4 /* CloseBracketToken */;\n            case 58 /* colon */:\n                pos++;\n                return token = 6 /* ColonToken */;\n            case 44 /* comma */:\n                pos++;\n                return token = 5 /* CommaToken */;\n            // strings\n            case 34 /* doubleQuote */:\n                pos++;\n                value = scanString();\n                return token = 10 /* StringLiteral */;\n            // comments\n            case 47 /* slash */:\n                var start = pos - 1;\n                // Single-line comment\n                if (text.charCodeAt(pos + 1) === 47 /* slash */) {\n                    pos += 2;\n                    while (pos < len) {\n                        if (isLineBreak(text.charCodeAt(pos))) {\n                            break;\n                        }\n                        pos++;\n                    }\n                    value = text.substring(start, pos);\n                    return token = 12 /* LineCommentTrivia */;\n                }\n                // Multi-line comment\n                if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {\n                    pos += 2;\n                    var safeLength = len - 1; // For lookahead.\n                    var commentClosed = false;\n                    while (pos < safeLength) {\n                        var ch = text.charCodeAt(pos);\n                        if (ch === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {\n                            pos += 2;\n                            commentClosed = true;\n                            break;\n                        }\n                        pos++;\n                        if (isLineBreak(ch)) {\n                            if (ch === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {\n                                pos++;\n                            }\n                            lineNumber++;\n                            tokenLineStartOffset = pos;\n                        }\n                    }\n                    if (!commentClosed) {\n                        pos++;\n                        scanError = 1 /* UnexpectedEndOfComment */;\n                    }\n                    value = text.substring(start, pos);\n                    return token = 13 /* BlockCommentTrivia */;\n                }\n                // just a single slash\n                value += String.fromCharCode(code);\n                pos++;\n                return token = 16 /* Unknown */;\n            // numbers\n            case 45 /* minus */:\n                value += String.fromCharCode(code);\n                pos++;\n                if (pos === len || !isDigit(text.charCodeAt(pos))) {\n                    return token = 16 /* Unknown */;\n                }\n            // found a minus, followed by a number so\n            // we fall through to proceed with scanning\n            // numbers\n            case 48 /* _0 */:\n            case 49 /* _1 */:\n            case 50 /* _2 */:\n            case 51 /* _3 */:\n            case 52 /* _4 */:\n            case 53 /* _5 */:\n            case 54 /* _6 */:\n            case 55 /* _7 */:\n            case 56 /* _8 */:\n            case 57 /* _9 */:\n                value += scanNumber();\n                return token = 11 /* NumericLiteral */;\n            // literals and unknown symbols\n            default:\n                // is a literal? Read the full word.\n                while (pos < len && isUnknownContentCharacter(code)) {\n                    pos++;\n                    code = text.charCodeAt(pos);\n                }\n                if (tokenOffset !== pos) {\n                    value = text.substring(tokenOffset, pos);\n                    // keywords: true, false, null\n                    switch (value) {\n                        case 'true': return token = 8 /* TrueKeyword */;\n                        case 'false': return token = 9 /* FalseKeyword */;\n                        case 'null': return token = 7 /* NullKeyword */;\n                    }\n                    return token = 16 /* Unknown */;\n                }\n                // some\n                value += String.fromCharCode(code);\n                pos++;\n                return token = 16 /* Unknown */;\n        }\n    }\n    function isUnknownContentCharacter(code) {\n        if (isWhiteSpace(code) || isLineBreak(code)) {\n            return false;\n        }\n        switch (code) {\n            case 125 /* closeBrace */:\n            case 93 /* closeBracket */:\n            case 123 /* openBrace */:\n            case 91 /* openBracket */:\n            case 34 /* doubleQuote */:\n            case 58 /* colon */:\n            case 44 /* comma */:\n            case 47 /* slash */:\n                return false;\n        }\n        return true;\n    }\n    function scanNextNonTrivia() {\n        var result;\n        do {\n            result = scanNext();\n        } while (result >= 12 /* LineCommentTrivia */ && result <= 15 /* Trivia */);\n        return result;\n    }\n    return {\n        setPosition: setPosition,\n        getPosition: function () { return pos; },\n        scan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n        getToken: function () { return token; },\n        getTokenValue: function () { return value; },\n        getTokenOffset: function () { return tokenOffset; },\n        getTokenLength: function () { return pos - tokenOffset; },\n        getTokenStartLine: function () { return lineStartOffset; },\n        getTokenStartCharacter: function () { return tokenOffset - prevTokenLineStartOffset; },\n        getTokenError: function () { return scanError; },\n    };\n}\nfunction isWhiteSpace(ch) {\n    return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ ||\n        ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ ||\n        ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;\n}\nfunction isLineBreak(ch) {\n    return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */;\n}\nfunction isDigit(ch) {\n    return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/jsonc-parser/lib/esm/impl/scanner.js?");

/***/ }),

/***/ "./node_modules/jsonc-parser/lib/esm/main.js":
/*!***************************************************!*\
  !*** ./node_modules/jsonc-parser/lib/esm/main.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createScanner\": () => /* binding */ createScanner,\n/* harmony export */   \"getLocation\": () => /* binding */ getLocation,\n/* harmony export */   \"parse\": () => /* binding */ parse,\n/* harmony export */   \"parseTree\": () => /* binding */ parseTree,\n/* harmony export */   \"findNodeAtLocation\": () => /* binding */ findNodeAtLocation,\n/* harmony export */   \"findNodeAtOffset\": () => /* binding */ findNodeAtOffset,\n/* harmony export */   \"getNodePath\": () => /* binding */ getNodePath,\n/* harmony export */   \"getNodeValue\": () => /* binding */ getNodeValue,\n/* harmony export */   \"visit\": () => /* binding */ visit,\n/* harmony export */   \"stripComments\": () => /* binding */ stripComments,\n/* harmony export */   \"printParseErrorCode\": () => /* binding */ printParseErrorCode,\n/* harmony export */   \"format\": () => /* binding */ format,\n/* harmony export */   \"modify\": () => /* binding */ modify,\n/* harmony export */   \"applyEdits\": () => /* binding */ applyEdits\n/* harmony export */ });\n/* harmony import */ var _impl_format__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./impl/format */ \"./node_modules/jsonc-parser/lib/esm/impl/format.js\");\n/* harmony import */ var _impl_edit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./impl/edit */ \"./node_modules/jsonc-parser/lib/esm/impl/edit.js\");\n/* harmony import */ var _impl_scanner__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impl/scanner */ \"./node_modules/jsonc-parser/lib/esm/impl/scanner.js\");\n/* harmony import */ var _impl_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./impl/parser */ \"./node_modules/jsonc-parser/lib/esm/impl/parser.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nvar createScanner = _impl_scanner__WEBPACK_IMPORTED_MODULE_2__.createScanner;\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nvar getLocation = _impl_parser__WEBPACK_IMPORTED_MODULE_3__.getLocation;\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore, always check the errors list to find out if the input was valid.\n */\nvar parse = _impl_parser__WEBPACK_IMPORTED_MODULE_3__.parse;\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nvar parseTree = _impl_parser__WEBPACK_IMPORTED_MODULE_3__.parseTree;\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nvar findNodeAtLocation = _impl_parser__WEBPACK_IMPORTED_MODULE_3__.findNodeAtLocation;\n/**\n * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nvar findNodeAtOffset = _impl_parser__WEBPACK_IMPORTED_MODULE_3__.findNodeAtOffset;\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nvar getNodePath = _impl_parser__WEBPACK_IMPORTED_MODULE_3__.getNodePath;\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nvar getNodeValue = _impl_parser__WEBPACK_IMPORTED_MODULE_3__.getNodeValue;\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nvar visit = _impl_parser__WEBPACK_IMPORTED_MODULE_3__.visit;\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nvar stripComments = _impl_parser__WEBPACK_IMPORTED_MODULE_3__.stripComments;\nfunction printParseErrorCode(code) {\n    switch (code) {\n        case 1 /* InvalidSymbol */: return 'InvalidSymbol';\n        case 2 /* InvalidNumberFormat */: return 'InvalidNumberFormat';\n        case 3 /* PropertyNameExpected */: return 'PropertyNameExpected';\n        case 4 /* ValueExpected */: return 'ValueExpected';\n        case 5 /* ColonExpected */: return 'ColonExpected';\n        case 6 /* CommaExpected */: return 'CommaExpected';\n        case 7 /* CloseBraceExpected */: return 'CloseBraceExpected';\n        case 8 /* CloseBracketExpected */: return 'CloseBracketExpected';\n        case 9 /* EndOfFileExpected */: return 'EndOfFileExpected';\n        case 10 /* InvalidCommentToken */: return 'InvalidCommentToken';\n        case 11 /* UnexpectedEndOfComment */: return 'UnexpectedEndOfComment';\n        case 12 /* UnexpectedEndOfString */: return 'UnexpectedEndOfString';\n        case 13 /* UnexpectedEndOfNumber */: return 'UnexpectedEndOfNumber';\n        case 14 /* InvalidUnicode */: return 'InvalidUnicode';\n        case 15 /* InvalidEscapeCharacter */: return 'InvalidEscapeCharacter';\n        case 16 /* InvalidCharacter */: return 'InvalidCharacter';\n    }\n    return '<unknown ParseErrorCode>';\n}\n/**\n * Computes the edits needed to format a JSON document.\n *\n * @param documentText The input text\n * @param range The range to format or `undefined` to format the full content\n * @param options The formatting options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`.\n */\nfunction format(documentText, range, options) {\n    return _impl_format__WEBPACK_IMPORTED_MODULE_0__.format(documentText, range, options);\n}\n/**\n * Computes the edits needed to modify a value in the JSON document.\n *\n * @param documentText The input text\n * @param path The path of the value to change. The path represents either to the document root, a property or an array item.\n * If the path points to an non-existing property or item, it will be created.\n * @param value The new value for the specified property or item. If the value is undefined,\n * the property or item will be removed.\n * @param options Options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`.\n */\nfunction modify(text, path, value, options) {\n    return _impl_edit__WEBPACK_IMPORTED_MODULE_1__.setProperty(text, path, value, options);\n}\n/**\n * Applies edits to a input string.\n */\nfunction applyEdits(text, edits) {\n    for (var i = edits.length - 1; i >= 0; i--) {\n        text = _impl_edit__WEBPACK_IMPORTED_MODULE_1__.applyEdit(text, edits[i]);\n    }\n    return text;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/jsonc-parser/lib/esm/main.js?");

/***/ }),

/***/ "./node_modules/jsonfile/index.js":
/*!****************************************!*\
  !*** ./node_modules/jsonfile/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("let _fs\ntry {\n  _fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\n} catch (_) {\n  _fs = __webpack_require__(/*! fs */ \"fs\")\n}\nconst universalify = __webpack_require__(/*! universalify */ \"./node_modules/jsonfile/node_modules/universalify/index.js\")\nconst { stringify, stripBom } = __webpack_require__(/*! ./utils */ \"./node_modules/jsonfile/utils.js\")\n\nasync function _readFile (file, options = {}) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  }\n\n  const fs = options.fs || _fs\n\n  const shouldThrow = 'throws' in options ? options.throws : true\n\n  let data = await universalify.fromCallback(fs.readFile)(file, options)\n\n  data = stripBom(data)\n\n  let obj\n  try {\n    obj = JSON.parse(data, options ? options.reviver : null)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = `${file}: ${err.message}`\n      throw err\n    } else {\n      return null\n    }\n  }\n\n  return obj\n}\n\nconst readFile = universalify.fromPromise(_readFile)\n\nfunction readFileSync (file, options = {}) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  }\n\n  const fs = options.fs || _fs\n\n  const shouldThrow = 'throws' in options ? options.throws : true\n\n  try {\n    let content = fs.readFileSync(file, options)\n    content = stripBom(content)\n    return JSON.parse(content, options.reviver)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = `${file}: ${err.message}`\n      throw err\n    } else {\n      return null\n    }\n  }\n}\n\nasync function _writeFile (file, obj, options = {}) {\n  const fs = options.fs || _fs\n\n  const str = stringify(obj, options)\n\n  await universalify.fromCallback(fs.writeFile)(file, str, options)\n}\n\nconst writeFile = universalify.fromPromise(_writeFile)\n\nfunction writeFileSync (file, obj, options = {}) {\n  const fs = options.fs || _fs\n\n  const str = stringify(obj, options)\n  // not sure if fs.writeFileSync returns anything, but just in case\n  return fs.writeFileSync(file, str, options)\n}\n\nconst jsonfile = {\n  readFile,\n  readFileSync,\n  writeFile,\n  writeFileSync\n}\n\nmodule.exports = jsonfile\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/jsonfile/index.js?");

/***/ }),

/***/ "./node_modules/jsonfile/node_modules/universalify/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/jsonfile/node_modules/universalify/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.fromCallback = function (fn) {\n  return Object.defineProperty(function (...args) {\n    if (typeof args[args.length - 1] === 'function') fn.apply(this, args)\n    else {\n      return new Promise((resolve, reject) => {\n        fn.call(\n          this,\n          ...args,\n          (err, res) => (err != null) ? reject(err) : resolve(res)\n        )\n      })\n    }\n  }, 'name', { value: fn.name })\n}\n\nexports.fromPromise = function (fn) {\n  return Object.defineProperty(function (...args) {\n    const cb = args[args.length - 1]\n    if (typeof cb !== 'function') return fn.apply(this, args)\n    else fn.apply(this, args.slice(0, -1)).then(r => cb(null, r), cb)\n  }, 'name', { value: fn.name })\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/jsonfile/node_modules/universalify/index.js?");

/***/ }),

/***/ "./node_modules/jsonfile/utils.js":
/*!****************************************!*\
  !*** ./node_modules/jsonfile/utils.js ***!
  \****************************************/
/***/ ((module) => {

eval("function stringify (obj, { EOL = '\\n', finalEOL = true, replacer = null, spaces } = {}) {\n  const EOF = finalEOL ? EOL : ''\n  const str = JSON.stringify(obj, replacer, spaces)\n\n  return str.replace(/\\n/g, EOL) + EOF\n}\n\nfunction stripBom (content) {\n  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified\n  if (Buffer.isBuffer(content)) content = content.toString('utf8')\n  return content.replace(/^\\uFEFF/, '')\n}\n\nmodule.exports = { stringify, stripBom }\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/jsonfile/utils.js?");

/***/ }),

/***/ "./node_modules/listenercount/index.js":
/*!*********************************************!*\
  !*** ./node_modules/listenercount/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar listenerCount = __webpack_require__(/*! events */ \"events\").listenerCount\n// listenerCount isn't in node 0.10, so here's a basic polyfill\nlistenerCount = listenerCount || function (ee, event) {\n  var listeners = ee && ee._events && ee._events[event]\n  if (Array.isArray(listeners)) {\n    return listeners.length\n  } else if (typeof listeners === 'function') {\n    return 1\n  } else {\n    return 0\n  }\n}\n\nmodule.exports = listenerCount\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/listenercount/index.js?");

/***/ }),

/***/ "./node_modules/log4js/lib/LoggingEvent.js":
/*!*************************************************!*\
  !*** ./node_modules/log4js/lib/LoggingEvent.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const flatted = __webpack_require__(/*! flatted */ \"./node_modules/flatted/esm/index.js\");\nconst levels = __webpack_require__(/*! ./levels */ \"./node_modules/log4js/lib/levels.js\");\n\n/**\n * @name LoggingEvent\n * @namespace Log4js\n */\nclass LoggingEvent {\n  /**\n   * Models a logging event.\n   * @constructor\n   * @param {string} categoryName name of category\n   * @param {Log4js.Level} level level of message\n   * @param {Array} data objects to log\n   * @author Seth Chisamore\n   */\n  constructor(categoryName, level, data, context, location) {\n    this.startTime = new Date();\n    this.categoryName = categoryName;\n    this.data = data;\n    this.level = level;\n    this.context = Object.assign({}, context);\n    this.pid = process.pid;\n\n    if (location) {\n      this.functionName = location.functionName;\n      this.fileName = location.fileName;\n      this.lineNumber = location.lineNumber;\n      this.columnNumber = location.columnNumber;\n      this.callStack = location.callStack;\n    }\n  }\n\n  serialise() {\n    const logData = this.data.map((e) => {\n      // JSON.stringify(new Error('test')) returns {}, which is not really useful for us.\n      // The following allows us to serialize errors correctly.\n      if (e && e.message && e.stack) {\n        e = Object.assign({ message: e.message, stack: e.stack }, e);\n      }\n      return e;\n    });\n    this.data = logData;\n    return flatted.stringify(this);\n  }\n\n  static deserialise(serialised) {\n    let event;\n    try {\n      const rehydratedEvent = flatted.parse(serialised);\n      rehydratedEvent.data = rehydratedEvent.data.map((e) => {\n        if (e && e.message && e.stack) {\n          const fakeError = new Error(e);\n          Object.keys(e).forEach((key) => { fakeError[key] = e[key]; });\n          e = fakeError;\n        }\n        return e;\n      });\n      event = new LoggingEvent(\n        rehydratedEvent.categoryName,\n        levels.getLevel(rehydratedEvent.level.levelStr),\n        rehydratedEvent.data,\n        rehydratedEvent.context\n      );\n      event.startTime = new Date(rehydratedEvent.startTime);\n      event.pid = rehydratedEvent.pid;\n      event.cluster = rehydratedEvent.cluster;\n    } catch (e) {\n      event = new LoggingEvent(\n        'log4js',\n        levels.ERROR,\n        ['Unable to parse log:', serialised, 'because: ', e]\n      );\n    }\n\n    return event;\n  }\n}\n\nmodule.exports = LoggingEvent;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/LoggingEvent.js?");

/***/ }),

/***/ "./node_modules/log4js/lib/appenders/adapters.js":
/*!*******************************************************!*\
  !*** ./node_modules/log4js/lib/appenders/adapters.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("function maxFileSizeUnitTransform(maxLogSize) {\n  if (typeof maxLogSize === 'number' && Number.isInteger(maxLogSize)) {\n    return maxLogSize;\n  }\n\n  const units = {\n    K: 1024,\n    M: 1024 * 1024,\n    G: 1024 * 1024 * 1024,\n  };\n  const validUnit = Object.keys(units);\n  const unit = maxLogSize.substr(maxLogSize.length - 1).toLocaleUpperCase();\n  const value = maxLogSize.substring(0, maxLogSize.length - 1).trim();\n\n  if (validUnit.indexOf(unit) < 0 || !Number.isInteger(Number(value))) {\n    throw Error(`maxLogSize: \"${maxLogSize}\" is invalid`);\n  } else {\n    return value * units[unit];\n  }\n}\n\nfunction adapter(configAdapter, config) {\n  const newConfig = Object.assign({}, config);\n  Object.keys(configAdapter).forEach((key) => {\n    if (newConfig[key]) {\n      newConfig[key] = configAdapter[key](config[key]);\n    }\n  });\n  return newConfig;\n}\n\nfunction fileAppenderAdapter(config) {\n  const configAdapter = {\n    maxLogSize: maxFileSizeUnitTransform\n  };\n  return adapter(configAdapter, config);\n}\n\nconst adapters = {\n  file: fileAppenderAdapter,\n  fileSync: fileAppenderAdapter\n};\n\nmodule.exports.modifyConfig = config => (adapters[config.type] ? adapters[config.type](config) : config);\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/appenders/adapters.js?");

/***/ }),

/***/ "./node_modules/log4js/lib/appenders/categoryFilter.js":
/*!*************************************************************!*\
  !*** ./node_modules/log4js/lib/appenders/categoryFilter.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('log4js:categoryFilter');\n\nfunction categoryFilter(excludes, appender) {\n  if (typeof excludes === 'string') excludes = [excludes];\n  return (logEvent) => {\n    debug(`Checking ${logEvent.categoryName} against ${excludes}`);\n    if (excludes.indexOf(logEvent.categoryName) === -1) {\n      debug('Not excluded, sending to appender');\n      appender(logEvent);\n    }\n  };\n}\n\nfunction configure(config, layouts, findAppender) {\n  const appender = findAppender(config.appender);\n  return categoryFilter(config.exclude, appender);\n}\n\nmodule.exports.configure = configure;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/appenders/categoryFilter.js?");

/***/ }),

/***/ "./node_modules/log4js/lib/appenders/console.js":
/*!******************************************************!*\
  !*** ./node_modules/log4js/lib/appenders/console.js ***!
  \******************************************************/
/***/ ((module) => {

eval("// eslint-disable-next-line no-console\nconst consoleLog = console.log.bind(console);\n\nfunction consoleAppender(layout, timezoneOffset) {\n  return (loggingEvent) => {\n    consoleLog(layout(loggingEvent, timezoneOffset));\n  };\n}\n\nfunction configure(config, layouts) {\n  let layout = layouts.colouredLayout;\n  if (config.layout) {\n    layout = layouts.layout(config.layout.type, config.layout);\n  }\n  return consoleAppender(layout, config.timezoneOffset);\n}\n\nmodule.exports.configure = configure;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/appenders/console.js?");

/***/ }),

/***/ "./node_modules/log4js/lib/appenders/dateFile.js":
/*!*******************************************************!*\
  !*** ./node_modules/log4js/lib/appenders/dateFile.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const streams = __webpack_require__(/*! streamroller */ \"./node_modules/streamroller/lib/index.js\");\nconst os = __webpack_require__(/*! os */ \"os\");\n\nconst eol = os.EOL;\n\n/**\n * File appender that rolls files according to a date pattern.\n * @filename base filename.\n * @pattern the format that will be added to the end of filename when rolling,\n *          also used to check when to roll files - defaults to '.yyyy-MM-dd'\n * @layout layout function for log messages - defaults to basicLayout\n * @timezoneOffset optional timezone offset in minutes - defaults to system local\n */\nfunction appender(\n  filename,\n  pattern,\n  layout,\n  options,\n  timezoneOffset\n) {\n  // the options for file appender use maxLogSize, but the docs say any file appender\n  // options should work for dateFile as well.\n  options.maxSize = options.maxLogSize;\n\n  const logFile = new streams.DateRollingFileStream(\n    filename,\n    pattern,\n    options\n  );\n\n  logFile.on(\"drain\", () => {\n    process.emit(\"log4js:pause\", false);\n  });\n\n  const app = function (logEvent) {\n    if (!logFile.write(layout(logEvent, timezoneOffset) + eol, \"utf8\")) {\n      process.emit(\"log4js:pause\", true);\n    }\n  };\n\n  app.shutdown = function (complete) {\n    logFile.write('', 'utf-8', () => {\n      logFile.end(complete);\n    });\n  };\n\n  return app;\n}\n\nfunction configure(config, layouts) {\n  let layout = layouts.basicLayout;\n\n  if (config.layout) {\n    layout = layouts.layout(config.layout.type, config.layout);\n  }\n\n  if (!config.alwaysIncludePattern) {\n    config.alwaysIncludePattern = false;\n  }\n\n  return appender(\n    config.filename,\n    config.pattern,\n    layout,\n    config,\n    config.timezoneOffset\n  );\n}\n\nmodule.exports.configure = configure;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/appenders/dateFile.js?");

/***/ }),

/***/ "./node_modules/log4js/lib/appenders/file.js":
/*!***************************************************!*\
  !*** ./node_modules/log4js/lib/appenders/file.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('log4js:file');\nconst path = __webpack_require__(/*! path */ \"path\");\nconst streams = __webpack_require__(/*! streamroller */ \"./node_modules/streamroller/lib/index.js\");\nconst os = __webpack_require__(/*! os */ \"os\");\n\nconst eol = os.EOL;\n\nfunction openTheStream(file, fileSize, numFiles, options) {\n  const stream = new streams.RollingFileStream(\n    file,\n    fileSize,\n    numFiles,\n    options\n  );\n  stream.on('error', (err) => {\n    console.error('log4js.fileAppender - Writing to file %s, error happened ', file, err); //eslint-disable-line\n  });\n  stream.on('drain', () => {\n    process.emit(\"log4js:pause\", false);\n  });\n  return stream;\n}\n\n\n/**\n * File Appender writing the logs to a text file. Supports rolling of logs by size.\n *\n * @param file file log messages will be written to\n * @param layout a function that takes a logEvent and returns a string\n *   (defaults to basicLayout).\n * @param logSize - the maximum size (in bytes) for a log file,\n *   if not provided then logs won't be rotated.\n * @param numBackups - the number of log files to keep after logSize\n *   has been reached (default 5)\n * @param options - options to be passed to the underlying stream\n * @param timezoneOffset - optional timezone offset in minutes (default system local)\n */\nfunction fileAppender(file, layout, logSize, numBackups, options, timezoneOffset) {\n  file = path.normalize(file);\n  numBackups = numBackups === undefined ? 5 : numBackups;\n  // there has to be at least one backup if logSize has been specified\n  numBackups = numBackups === 0 ? 1 : numBackups;\n\n  debug(\n    'Creating file appender (',\n    file, ', ',\n    logSize, ', ',\n    numBackups, ', ',\n    options, ', ',\n    timezoneOffset, ')'\n  );\n\n  let writer = openTheStream(file, logSize, numBackups, options);\n\n  const app = function (loggingEvent) {\n    if (options.removeColor === true) {\n      // eslint-disable-next-line no-control-regex\n      const regex = /\\x1b[[0-9;]*m/g;\n      loggingEvent.data = loggingEvent.data.map(d => {\n        if (typeof d === 'string') return d.replace(regex, '')\n        return d\n      })\n    }\n    if (!writer.write(layout(loggingEvent, timezoneOffset) + eol, \"utf8\")) {\n      process.emit('log4js:pause', true);\n    }\n  };\n\n  app.reopen = function () {\n    writer.end(() => { writer = openTheStream(file, logSize, numBackups, options); });\n  };\n\n  app.sighupHandler = function () {\n    debug('SIGHUP handler called.');\n    app.reopen();\n  };\n\n  app.shutdown = function (complete) {\n    process.removeListener('SIGHUP', app.sighupHandler);\n    writer.end('', 'utf-8', complete);\n  };\n\n  // On SIGHUP, close and reopen all files. This allows this appender to work with\n  // logrotate. Note that if you are using logrotate, you should not set\n  // `logSize`.\n  process.on('SIGHUP', app.sighupHandler);\n\n  return app;\n}\n\nfunction configure(config, layouts) {\n  let layout = layouts.basicLayout;\n  if (config.layout) {\n    layout = layouts.layout(config.layout.type, config.layout);\n  }\n\n  return fileAppender(\n    config.filename,\n    layout,\n    config.maxLogSize,\n    config.backups,\n    config,\n    config.timezoneOffset\n  );\n}\n\nmodule.exports.configure = configure;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/appenders/file.js?");

/***/ }),

/***/ "./node_modules/log4js/lib/appenders/fileSync.js":
/*!*******************************************************!*\
  !*** ./node_modules/log4js/lib/appenders/fileSync.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('log4js:fileSync');\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst os = __webpack_require__(/*! os */ \"os\");\n\nconst eol = os.EOL || '\\n';\n\nfunction touchFile(file, options) {\n  // if the file exists, nothing to do\n  if (fs.existsSync(file)) {\n    return;\n  }\n\n  // touch the file to apply flags (like w to truncate the file)\n  const id = fs.openSync(file, options.flags, options.mode);\n  fs.closeSync(id);\n}\n\nclass RollingFileSync {\n  constructor(filename, size, backups, options) {\n    debug('In RollingFileStream');\n\n    function throwErrorIfArgumentsAreNotValid() {\n      if (!filename || !size || size <= 0) {\n        throw new Error('You must specify a filename and file size');\n      }\n    }\n\n    throwErrorIfArgumentsAreNotValid();\n\n    this.filename = filename;\n    this.size = size;\n    this.backups = backups || 1;\n    this.options = options;\n    this.currentSize = 0;\n\n    function currentFileSize(file) {\n      let fileSize = 0;\n\n      try {\n        fileSize = fs.statSync(file).size;\n      } catch (e) {\n        // file does not exist\n        touchFile(file, options);\n      }\n      return fileSize;\n    }\n\n    this.currentSize = currentFileSize(this.filename);\n  }\n\n  shouldRoll() {\n    debug('should roll with current size %d, and max size %d', this.currentSize, this.size);\n    return this.currentSize >= this.size;\n  }\n\n  roll(filename) {\n    const that = this;\n    const nameMatcher = new RegExp(`^${path.basename(filename)}`);\n\n    function justTheseFiles(item) {\n      return nameMatcher.test(item);\n    }\n\n    function index(filename_) {\n      return parseInt(filename_.substring((`${path.basename(filename)}.`).length), 10) || 0;\n    }\n\n    function byIndex(a, b) {\n      if (index(a) > index(b)) {\n        return 1;\n      }\n      if (index(a) < index(b)) {\n        return -1;\n      }\n\n      return 0;\n    }\n\n    function increaseFileIndex(fileToRename) {\n      const idx = index(fileToRename);\n      debug(`Index of ${fileToRename} is ${idx}`);\n      if (idx < that.backups) {\n        // on windows, you can get a EEXIST error if you rename a file to an existing file\n        // so, we'll try to delete the file we're renaming to first\n        try {\n          fs.unlinkSync(`${filename}.${idx + 1}`);\n        } catch (e) {\n          // ignore err: if we could not delete, it's most likely that it doesn't exist\n        }\n\n        debug(`Renaming ${fileToRename} -> ${filename}.${idx + 1}`);\n        fs.renameSync(path.join(path.dirname(filename), fileToRename), `${filename}.${idx + 1}`);\n      }\n    }\n\n    function renameTheFiles() {\n      // roll the backups (rename file.n to file.n+1, where n <= numBackups)\n      debug('Renaming the old files');\n\n      const files = fs.readdirSync(path.dirname(filename));\n      files.filter(justTheseFiles).sort(byIndex).reverse().forEach(increaseFileIndex);\n    }\n\n    debug('Rolling, rolling, rolling');\n    renameTheFiles();\n  }\n\n  /* eslint no-unused-vars:0 */\n  write(chunk, encoding) {\n    const that = this;\n\n\n    function writeTheChunk() {\n      debug('writing the chunk to the file');\n      that.currentSize += chunk.length;\n      fs.appendFileSync(that.filename, chunk);\n    }\n\n    debug('in write');\n\n\n    if (this.shouldRoll()) {\n      this.currentSize = 0;\n      this.roll(this.filename);\n    }\n\n    writeTheChunk();\n  }\n}\n\n/**\n * File Appender writing the logs to a text file. Supports rolling of logs by size.\n *\n * @param file file log messages will be written to\n * @param layout a function that takes a logevent and returns a string\n *   (defaults to basicLayout).\n * @param logSize - the maximum size (in bytes) for a log file,\n *   if not provided then logs won't be rotated.\n * @param numBackups - the number of log files to keep after logSize\n *   has been reached (default 5)\n * @param timezoneOffset - optional timezone offset in minutes\n *   (default system local)\n * @param options - passed as is to fs options\n */\nfunction fileAppender(file, layout, logSize, numBackups, timezoneOffset, options) {\n  debug('fileSync appender created');\n  file = path.normalize(file);\n  numBackups = numBackups === undefined ? 5 : numBackups;\n  // there has to be at least one backup if logSize has been specified\n  numBackups = numBackups === 0 ? 1 : numBackups;\n\n  function openTheStream(filePath, fileSize, numFiles) {\n    let stream;\n\n    if (fileSize) {\n      stream = new RollingFileSync(\n        filePath,\n        fileSize,\n        numFiles,\n        options\n      );\n    } else {\n      stream = (((f) => {\n        // touch the file to apply flags (like w to truncate the file)\n        touchFile(f, options);\n\n        return {\n          write(data) {\n            fs.appendFileSync(f, data);\n          }\n        };\n      }))(filePath);\n    }\n\n    return stream;\n  }\n\n  const logFile = openTheStream(file, logSize, numBackups);\n\n  return (loggingEvent) => {\n    logFile.write(layout(loggingEvent, timezoneOffset) + eol);\n  };\n}\n\nfunction configure(config, layouts) {\n  let layout = layouts.basicLayout;\n  if (config.layout) {\n    layout = layouts.layout(config.layout.type, config.layout);\n  }\n\n  const options = {\n    flags: config.flags || 'a',\n    encoding: config.encoding || 'utf8',\n    mode: config.mode || 0o644\n  };\n\n  return fileAppender(\n    config.filename,\n    layout,\n    config.maxLogSize,\n    config.backups,\n    config.timezoneOffset,\n    options\n  );\n}\n\nmodule.exports.configure = configure;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/appenders/fileSync.js?");

/***/ }),

/***/ "./node_modules/log4js/lib/appenders/index.js":
/*!****************************************************!*\
  !*** ./node_modules/log4js/lib/appenders/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const path = __webpack_require__(/*! path */ \"path\");\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('log4js:appenders');\nconst configuration = __webpack_require__(/*! ../configuration */ \"./node_modules/log4js/lib/configuration.js\");\nconst clustering = __webpack_require__(/*! ../clustering */ \"./node_modules/log4js/lib/clustering.js\");\nconst levels = __webpack_require__(/*! ../levels */ \"./node_modules/log4js/lib/levels.js\");\nconst layouts = __webpack_require__(/*! ../layouts */ \"./node_modules/log4js/lib/layouts.js\");\nconst adapters = __webpack_require__(/*! ./adapters */ \"./node_modules/log4js/lib/appenders/adapters.js\");\n\n// pre-load the core appenders so that webpack can find them\nconst coreAppenders = new Map();\ncoreAppenders.set('console', __webpack_require__(/*! ./console */ \"./node_modules/log4js/lib/appenders/console.js\"));\ncoreAppenders.set('stdout', __webpack_require__(/*! ./stdout */ \"./node_modules/log4js/lib/appenders/stdout.js\"));\ncoreAppenders.set('stderr', __webpack_require__(/*! ./stderr */ \"./node_modules/log4js/lib/appenders/stderr.js\"));\ncoreAppenders.set('logLevelFilter', __webpack_require__(/*! ./logLevelFilter */ \"./node_modules/log4js/lib/appenders/logLevelFilter.js\"));\ncoreAppenders.set('categoryFilter', __webpack_require__(/*! ./categoryFilter */ \"./node_modules/log4js/lib/appenders/categoryFilter.js\"));\ncoreAppenders.set('noLogFilter', __webpack_require__(/*! ./noLogFilter */ \"./node_modules/log4js/lib/appenders/noLogFilter.js\"));\ncoreAppenders.set('file', __webpack_require__(/*! ./file */ \"./node_modules/log4js/lib/appenders/file.js\"));\ncoreAppenders.set('dateFile', __webpack_require__(/*! ./dateFile */ \"./node_modules/log4js/lib/appenders/dateFile.js\"));\ncoreAppenders.set('fileSync', __webpack_require__(/*! ./fileSync */ \"./node_modules/log4js/lib/appenders/fileSync.js\"));\n\nconst appenders = new Map();\n\nconst tryLoading = (modulePath, config) => {\n  debug('Loading module from ', modulePath);\n  try {\n    return __webpack_require__(\"./node_modules/log4js/lib/appenders sync recursive\")(modulePath); //eslint-disable-line\n  } catch (e) {\n    // if the module was found, and we still got an error, then raise it\n    configuration.throwExceptionIf(\n      config,\n      e.code !== 'MODULE_NOT_FOUND',\n      `appender \"${modulePath}\" could not be loaded (error was: ${e})`\n    );\n    return undefined;\n  }\n};\n\nconst loadAppenderModule = (type, config) => coreAppenders.get(type)\n  || tryLoading(`./${type}`, config)\n  || tryLoading(type, config)\n  || (__webpack_require__.c[__webpack_require__.s] && tryLoading(path.join(path.dirname(__webpack_require__.c[__webpack_require__.s].filename), type), config))\n  || tryLoading(path.join(process.cwd(), type), config);\n\nconst appendersLoading = new Set();\n\nconst getAppender = (name, config) => {\n  if (appenders.has(name)) return appenders.get(name);\n  if (!config.appenders[name]) return false;\n  if (appendersLoading.has(name)) throw new Error(`Dependency loop detected for appender ${name}.`);\n  appendersLoading.add(name);\n\n  debug(`Creating appender ${name}`);\n  // eslint-disable-next-line no-use-before-define\n  const appender = createAppender(name, config);\n  appendersLoading.delete(name);\n  appenders.set(name, appender);\n  return appender;\n};\n\nconst createAppender = (name, config) => {\n  const appenderConfig = config.appenders[name];\n  const appenderModule = appenderConfig.type.configure\n    ? appenderConfig.type : loadAppenderModule(appenderConfig.type, config);\n  configuration.throwExceptionIf(\n    config,\n    configuration.not(appenderModule),\n    `appender \"${name}\" is not valid (type \"${appenderConfig.type}\" could not be found)`\n  );\n  if (appenderModule.appender) {\n    debug(`DEPRECATION: Appender ${appenderConfig.type} exports an appender function.`);\n  }\n  if (appenderModule.shutdown) {\n    debug(`DEPRECATION: Appender ${appenderConfig.type} exports a shutdown function.`);\n  }\n\n  debug(`${name}: clustering.isMaster ? ${clustering.isMaster()}`);\n  debug(`${name}: appenderModule is ${__webpack_require__(/*! util */ \"util\").inspect(appenderModule)}`); // eslint-disable-line\n  return clustering.onlyOnMaster(() => {\n    debug(`calling appenderModule.configure for ${name} / ${appenderConfig.type}`);\n    return appenderModule.configure(\n      adapters.modifyConfig(appenderConfig),\n      layouts,\n      appender => getAppender(appender, config),\n      levels\n    );\n  }, () => { });\n};\n\nconst setup = (config) => {\n  appenders.clear();\n  appendersLoading.clear();\n  const usedAppenders = [];\n  Object.values(config.categories).forEach(category => {\n    usedAppenders.push(...category.appenders)\n  });\n  Object.keys(config.appenders).forEach((name) => {\n    // dodgy hard-coding of special case for tcp-server which may not have\n    // any categories associated with it, but needs to be started up anyway\n    if (usedAppenders.includes(name) || config.appenders[name].type === 'tcp-server') {\n      getAppender(name, config);\n    }\n  });\n};\n\nsetup({ appenders: { out: { type: 'stdout' } }, categories: { default: { appenders: ['out'], level: 'trace' } } });\n\nconfiguration.addListener((config) => {\n  configuration.throwExceptionIf(\n    config,\n    configuration.not(configuration.anObject(config.appenders)),\n    'must have a property \"appenders\" of type object.'\n  );\n  const appenderNames = Object.keys(config.appenders);\n  configuration.throwExceptionIf(\n    config,\n    configuration.not(appenderNames.length),\n    'must define at least one appender.'\n  );\n\n  appenderNames.forEach((name) => {\n    configuration.throwExceptionIf(\n      config,\n      configuration.not(config.appenders[name].type),\n      `appender \"${name}\" is not valid (must be an object with property \"type\")`\n    );\n  });\n});\n\nconfiguration.addListener(setup);\n\nmodule.exports = appenders;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/appenders/index.js?");

/***/ }),

/***/ "./node_modules/log4js/lib/appenders/logLevelFilter.js":
/*!*************************************************************!*\
  !*** ./node_modules/log4js/lib/appenders/logLevelFilter.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("function logLevelFilter(minLevelString, maxLevelString, appender, levels) {\n  const minLevel = levels.getLevel(minLevelString);\n  const maxLevel = levels.getLevel(maxLevelString, levels.FATAL);\n  return (logEvent) => {\n    const eventLevel = logEvent.level;\n    if (eventLevel.isGreaterThanOrEqualTo(minLevel) && eventLevel.isLessThanOrEqualTo(maxLevel)) {\n      appender(logEvent);\n    }\n  };\n}\n\nfunction configure(config, layouts, findAppender, levels) {\n  const appender = findAppender(config.appender);\n  return logLevelFilter(config.level, config.maxLevel, appender, levels);\n}\n\nmodule.exports.configure = configure;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/appenders/logLevelFilter.js?");

/***/ }),

/***/ "./node_modules/log4js/lib/appenders/noLogFilter.js":
/*!**********************************************************!*\
  !*** ./node_modules/log4js/lib/appenders/noLogFilter.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('log4js:noLogFilter');\n\n/**\n * The function removes empty or null regexp from the array\n * @param {string[]} regexp\n * @returns {string[]} a filtered string array with not empty or null regexp\n */\nfunction removeNullOrEmptyRegexp(regexp) {\n  const filtered = regexp.filter(el => ((el != null) && (el !== '')));\n  return filtered;\n}\n\n/**\n * Returns a function that will exclude the events in case they match\n * with the regular expressions provided\n * @param {(string|string[])} filters contains the regexp that will be used for the evaluation\n * @param {*} appender\n * @returns {function}\n */\nfunction noLogFilter(filters, appender) {\n  return (logEvent) => {\n    debug(`Checking data: ${logEvent.data} against filters: ${filters}`);\n    if (typeof filters === 'string') {\n      filters = [filters];\n    }\n    filters = removeNullOrEmptyRegexp(filters);\n    const regex = new RegExp(filters.join('|'), 'i');\n    if (filters.length === 0\n      || logEvent.data.findIndex(value => regex.test(value)) < 0) {\n      debug('Not excluded, sending to appender');\n      appender(logEvent);\n    }\n  };\n}\n\nfunction configure(config, layouts, findAppender) {\n  const appender = findAppender(config.appender);\n  return noLogFilter(config.exclude, appender);\n}\n\nmodule.exports.configure = configure;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/appenders/noLogFilter.js?");

/***/ }),

/***/ "./node_modules/log4js/lib/appenders/stderr.js":
/*!*****************************************************!*\
  !*** ./node_modules/log4js/lib/appenders/stderr.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\nfunction stderrAppender(layout, timezoneOffset) {\n  return (loggingEvent) => {\n    process.stderr.write(`${layout(loggingEvent, timezoneOffset)}\\n`);\n  };\n}\n\nfunction configure(config, layouts) {\n  let layout = layouts.colouredLayout;\n  if (config.layout) {\n    layout = layouts.layout(config.layout.type, config.layout);\n  }\n  return stderrAppender(layout, config.timezoneOffset);\n}\n\nmodule.exports.configure = configure;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/appenders/stderr.js?");

/***/ }),

/***/ "./node_modules/log4js/lib/appenders/stdout.js":
/*!*****************************************************!*\
  !*** ./node_modules/log4js/lib/appenders/stdout.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nfunction stdoutAppender(layout, timezoneOffset) {\n  return (loggingEvent) => {\n    process.stdout.write(`${layout(loggingEvent, timezoneOffset)}\\n`);\n  };\n}\n\nfunction configure(config, layouts) {\n  let layout = layouts.colouredLayout;\n  if (config.layout) {\n    layout = layouts.layout(config.layout.type, config.layout);\n  }\n  return stdoutAppender(layout, config.timezoneOffset);\n}\n\nexports.configure = configure;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/appenders/stdout.js?");

/***/ }),

/***/ "./node_modules/log4js/lib/appenders sync recursive":
/*!*************************************************!*\
  !*** ./node_modules/log4js/lib/appenders/ sync ***!
  \*************************************************/
/***/ ((module) => {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => [];\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = \"./node_modules/log4js/lib/appenders sync recursive\";\nmodule.exports = webpackEmptyContext;\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/appenders/_sync?");

/***/ }),

/***/ "./node_modules/log4js/lib/categories.js":
/*!***********************************************!*\
  !*** ./node_modules/log4js/lib/categories.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('log4js:categories');\nconst configuration = __webpack_require__(/*! ./configuration */ \"./node_modules/log4js/lib/configuration.js\");\nconst levels = __webpack_require__(/*! ./levels */ \"./node_modules/log4js/lib/levels.js\");\nconst appenders = __webpack_require__(/*! ./appenders */ \"./node_modules/log4js/lib/appenders/index.js\");\n\nconst categories = new Map();\n\n/**\n * Add inherited config to this category.  That includes extra appenders from parent,\n * and level, if none is set on this category.\n * This is recursive, so each parent also gets loaded with inherited appenders.\n * Inheritance is blocked if a category has inherit=false\n * @param  {*} config\n * @param  {*} category the child category\n * @param  {string} categoryName dotted path to category\n * @return {void}\n */\nfunction inheritFromParent(config, category, categoryName) {\n  if (category.inherit === false) return;\n  const lastDotIndex = categoryName.lastIndexOf('.');\n  if (lastDotIndex < 0) return; // category is not a child\n  const parentCategoryName = categoryName.substring(0, lastDotIndex);\n  let parentCategory = config.categories[parentCategoryName];\n\n\n  if (!parentCategory) {\n    // parent is missing, so implicitly create it, so that it can inherit from its parents\n    parentCategory = { inherit: true, appenders: [] };\n  }\n\n  // make sure parent has had its inheritance taken care of before pulling its properties to this child\n  inheritFromParent(config, parentCategory, parentCategoryName);\n\n  // if the parent is not in the config (because we just created it above),\n  // and it inherited a valid configuration, add it to config.categories\n  if (!config.categories[parentCategoryName]\n    && parentCategory.appenders\n    && parentCategory.appenders.length\n    && parentCategory.level) {\n    config.categories[parentCategoryName] = parentCategory;\n  }\n\n  category.appenders = category.appenders || [];\n  category.level = category.level || parentCategory.level;\n\n  // merge in appenders from parent (parent is already holding its inherited appenders)\n  parentCategory.appenders.forEach((ap) => {\n    if (!category.appenders.includes(ap)) {\n      category.appenders.push(ap);\n    }\n  });\n  category.parent = parentCategory;\n}\n\n\n/**\n * Walk all categories in the config, and pull down any configuration from parent to child.\n * This includes inherited appenders, and level, where level is not set.\n * Inheritance is skipped where a category has inherit=false.\n * @param  {*} config\n */\nfunction addCategoryInheritance(config) {\n  if (!config.categories) return;\n  const categoryNames = Object.keys(config.categories);\n  categoryNames.forEach((name) => {\n    const category = config.categories[name];\n    // add inherited appenders and level to this category\n    inheritFromParent(config, category, name);\n  });\n}\n\nconfiguration.addPreProcessingListener(config => addCategoryInheritance(config));\n\nconfiguration.addListener((config) => {\n  configuration.throwExceptionIf(\n    config,\n    configuration.not(configuration.anObject(config.categories)),\n    'must have a property \"categories\" of type object.'\n  );\n\n  const categoryNames = Object.keys(config.categories);\n  configuration.throwExceptionIf(\n    config,\n    configuration.not(categoryNames.length),\n    'must define at least one category.'\n  );\n\n  categoryNames.forEach((name) => {\n    const category = config.categories[name];\n    configuration.throwExceptionIf(\n      config,\n      [\n        configuration.not(category.appenders),\n        configuration.not(category.level)\n      ],\n      `category \"${name}\" is not valid (must be an object with properties \"appenders\" and \"level\")`\n    );\n\n    configuration.throwExceptionIf(\n      config,\n      configuration.not(Array.isArray(category.appenders)),\n      `category \"${name}\" is not valid (appenders must be an array of appender names)`\n    );\n\n    configuration.throwExceptionIf(\n      config,\n      configuration.not(category.appenders.length),\n      `category \"${name}\" is not valid (appenders must contain at least one appender name)`\n    );\n\n    if (Object.prototype.hasOwnProperty.call(category, 'enableCallStack')) {\n      configuration.throwExceptionIf(\n        config,\n        typeof category.enableCallStack !== 'boolean',\n        `category \"${name}\" is not valid (enableCallStack must be boolean type)`\n      );\n    }\n\n    category.appenders.forEach((appender) => {\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(appenders.get(appender)),\n        `category \"${name}\" is not valid (appender \"${appender}\" is not defined)`\n      );\n    });\n\n    configuration.throwExceptionIf(\n      config,\n      configuration.not(levels.getLevel(category.level)),\n      `category \"${name}\" is not valid (level \"${category.level}\" not recognised;`\n      + ` valid levels are ${levels.levels.join(', ')})`\n    );\n  });\n\n  configuration.throwExceptionIf(\n    config,\n    configuration.not(config.categories.default),\n    'must define a \"default\" category.'\n  );\n});\n\nconst setup = (config) => {\n  categories.clear();\n\n  const categoryNames = Object.keys(config.categories);\n  categoryNames.forEach((name) => {\n    const category = config.categories[name];\n    const categoryAppenders = [];\n    category.appenders.forEach((appender) => {\n      categoryAppenders.push(appenders.get(appender));\n      debug(`Creating category ${name}`);\n      categories.set(\n        name,\n        {\n          appenders: categoryAppenders,\n          level: levels.getLevel(category.level),\n          enableCallStack: category.enableCallStack || false\n        }\n      );\n    });\n  });\n};\n\nsetup({ categories: { default: { appenders: ['out'], level: 'OFF' } } });\nconfiguration.addListener(setup);\n\nconst configForCategory = (category) => {\n  debug(`configForCategory: searching for config for ${category}`);\n  if (categories.has(category)) {\n    debug(`configForCategory: ${category} exists in config, returning it`);\n    return categories.get(category);\n  }\n  if (category.indexOf('.') > 0) {\n    debug(`configForCategory: ${category} has hierarchy, searching for parents`);\n    return configForCategory(category.substring(0, category.lastIndexOf('.')));\n  }\n  debug('configForCategory: returning config for default category');\n  return configForCategory('default');\n};\n\nconst appendersForCategory = category => configForCategory(category).appenders;\nconst getLevelForCategory = category => configForCategory(category).level;\n\nconst setLevelForCategory = (category, level) => {\n  let categoryConfig = categories.get(category);\n  debug(`setLevelForCategory: found ${categoryConfig} for ${category}`);\n  if (!categoryConfig) {\n    const sourceCategoryConfig = configForCategory(category);\n    debug('setLevelForCategory: no config found for category, '\n      + `found ${sourceCategoryConfig} for parents of ${category}`);\n    categoryConfig = { appenders: sourceCategoryConfig.appenders };\n  }\n  categoryConfig.level = level;\n  categories.set(category, categoryConfig);\n};\n\nconst getEnableCallStackForCategory = category => configForCategory(category).enableCallStack === true;\nconst setEnableCallStackForCategory = (category, useCallStack) => {\n  configForCategory(category).enableCallStack = useCallStack;\n};\n\nmodule.exports = {\n  appendersForCategory,\n  getLevelForCategory,\n  setLevelForCategory,\n  getEnableCallStackForCategory,\n  setEnableCallStackForCategory,\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/categories.js?");

/***/ }),

/***/ "./node_modules/log4js/lib/clustering.js":
/*!***********************************************!*\
  !*** ./node_modules/log4js/lib/clustering.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")(\"log4js:clustering\");\nconst LoggingEvent = __webpack_require__(/*! ./LoggingEvent */ \"./node_modules/log4js/lib/LoggingEvent.js\");\nconst configuration = __webpack_require__(/*! ./configuration */ \"./node_modules/log4js/lib/configuration.js\");\n\nlet disabled = false;\nlet cluster = null;\ntry {\n  cluster = __webpack_require__(/*! cluster */ \"cluster\"); //eslint-disable-line\n} catch (e) {\n  debug(\"cluster module not present\");\n  disabled = true;\n}\n\nconst listeners = [];\n\nlet pm2 = false;\nlet pm2InstanceVar = \"NODE_APP_INSTANCE\";\n\nconst isPM2Master = () => pm2 && process.env[pm2InstanceVar] === \"0\";\nconst isMaster = () => disabled || cluster.isMaster || isPM2Master();\n\nconst sendToListeners = logEvent => {\n  listeners.forEach(l => l(logEvent));\n};\n\n// in a multi-process node environment, worker loggers will use\n// process.send\nconst receiver = (worker, message) => {\n  // prior to node v6, the worker parameter was not passed (args were message, handle)\n  debug(\"cluster message received from worker \", worker, \": \", message);\n  if (worker.topic && worker.data) {\n    message = worker;\n    worker = undefined;\n  }\n  if (message && message.topic && message.topic === \"log4js:message\") {\n    debug(\"received message: \", message.data);\n    const logEvent = LoggingEvent.deserialise(message.data);\n    sendToListeners(logEvent);\n  }\n};\n\nif (!disabled) {\n  configuration.addListener(config => {\n    // clear out the listeners, because configure has been called.\n    listeners.length = 0;\n\n    ({\n      pm2,\n      disableClustering: disabled,\n      pm2InstanceVar = \"NODE_APP_INSTANCE\"\n    } = config);\n\n    debug(`clustering disabled ? ${disabled}`);\n    debug(`cluster.isMaster ? ${cluster && cluster.isMaster}`);\n    debug(`pm2 enabled ? ${pm2}`);\n    debug(`pm2InstanceVar = ${pm2InstanceVar}`);\n    debug(`process.env[${pm2InstanceVar}] = ${process.env[pm2InstanceVar]}`);\n\n    // just in case configure is called after shutdown\n    if (pm2) {\n      process.removeListener(\"message\", receiver);\n    }\n    if (cluster && cluster.removeListener) {\n      cluster.removeListener(\"message\", receiver);\n    }\n\n    if (disabled || config.disableClustering) {\n      debug(\"Not listening for cluster messages, because clustering disabled.\");\n    } else if (isPM2Master()) {\n      // PM2 cluster support\n      // PM2 runs everything as workers - install pm2-intercom for this to work.\n      // we only want one of the app instances to write logs\n      debug(\"listening for PM2 broadcast messages\");\n      process.on(\"message\", receiver);\n    } else if (cluster.isMaster) {\n      debug(\"listening for cluster messages\");\n      cluster.on(\"message\", receiver);\n    } else {\n      debug(\"not listening for messages, because we are not a master process\");\n    }\n  });\n}\n\nmodule.exports = {\n  onlyOnMaster: (fn, notMaster) => (isMaster() ? fn() : notMaster),\n  isMaster,\n  send: msg => {\n    if (isMaster()) {\n      sendToListeners(msg);\n    } else {\n      if (!pm2) {\n        msg.cluster = {\n          workerId: cluster.worker.id,\n          worker: process.pid\n        };\n      }\n      process.send({ topic: \"log4js:message\", data: msg.serialise() });\n    }\n  },\n  onMessage: listener => {\n    listeners.push(listener);\n  }\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/clustering.js?");

/***/ }),

/***/ "./node_modules/log4js/lib/configuration.js":
/*!**************************************************!*\
  !*** ./node_modules/log4js/lib/configuration.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst util = __webpack_require__(/*! util */ \"util\");\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('log4js:configuration');\n\nconst preProcessingListeners = [];\nconst listeners = [];\n\nconst not = thing => !thing;\n\nconst anObject = thing => thing && typeof thing === 'object' && !Array.isArray(thing);\n\nconst validIdentifier = thing => /^[A-Za-z][A-Za-z0-9_]*$/g.test(thing);\n\nconst anInteger = thing => thing && typeof thing === 'number' && Number.isInteger(thing);\n\nconst addListener = (fn) => {\n  listeners.push(fn);\n  debug(`Added listener, now ${listeners.length} listeners`);\n};\n\nconst addPreProcessingListener = (fn) => {\n  preProcessingListeners.push(fn);\n  debug(`Added pre-processing listener, now ${preProcessingListeners.length} listeners`);\n};\n\nconst throwExceptionIf = (config, checks, message) => {\n  const tests = Array.isArray(checks) ? checks : [checks];\n  tests.forEach((test) => {\n    if (test) {\n      throw new Error(`Problem with log4js configuration: (${util.inspect(config, { depth: 5 })})`\n        + ` - ${message}`);\n    }\n  });\n};\n\nconst configure = (candidate) => {\n  debug('New configuration to be validated: ', candidate);\n  throwExceptionIf(candidate, not(anObject(candidate)), 'must be an object.');\n\n  debug(`Calling pre-processing listeners (${preProcessingListeners.length})`);\n  preProcessingListeners.forEach(listener => listener(candidate));\n  debug('Configuration pre-processing finished.');\n\n  debug(`Calling configuration listeners (${listeners.length})`);\n  listeners.forEach(listener => listener(candidate));\n  debug('Configuration finished.');\n};\n\nmodule.exports = {\n  configure,\n  addListener,\n  addPreProcessingListener,\n  throwExceptionIf,\n  anObject,\n  anInteger,\n  validIdentifier,\n  not\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/configuration.js?");

/***/ }),

/***/ "./node_modules/log4js/lib/connect-logger.js":
/*!***************************************************!*\
  !*** ./node_modules/log4js/lib/connect-logger.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable no-plusplus */\n\nconst levels = __webpack_require__(/*! ./levels */ \"./node_modules/log4js/lib/levels.js\");\n\nconst DEFAULT_FORMAT =\n  \":remote-addr - -\" +\n  ' \":method :url HTTP/:http-version\"' +\n  ' :status :content-length \":referrer\"' +\n  ' \":user-agent\"';\n\n/**\n * Return request url path,\n * adding this function prevents the Cyclomatic Complexity,\n * for the assemble_tokens function at low, to pass the tests.\n *\n * @param  {IncomingMessage} req\n * @return {string}\n * @api private\n */\nfunction getUrl(req) {\n  return req.originalUrl || req.url;\n}\n\n/**\n * Adds custom {token, replacement} objects to defaults,\n * overwriting the defaults if any tokens clash\n *\n * @param  {IncomingMessage} req\n * @param  {ServerResponse} res\n * @param  {Array} customTokens\n *    [{ token: string-or-regexp, replacement: string-or-replace-function }]\n * @return {Array}\n */\nfunction assembleTokens(req, res, customTokens) {\n  const arrayUniqueTokens = array => {\n    const a = array.concat();\n    for (let i = 0; i < a.length; ++i) {\n      for (let j = i + 1; j < a.length; ++j) {\n        // not === because token can be regexp object\n        /* eslint eqeqeq:0 */\n        if (a[i].token == a[j].token) {\n          a.splice(j--, 1);\n        }\n      }\n    }\n    return a;\n  };\n\n  const defaultTokens = [];\n  defaultTokens.push({ token: \":url\", replacement: getUrl(req) });\n  defaultTokens.push({ token: \":protocol\", replacement: req.protocol });\n  defaultTokens.push({ token: \":hostname\", replacement: req.hostname });\n  defaultTokens.push({ token: \":method\", replacement: req.method });\n  defaultTokens.push({\n    token: \":status\",\n    replacement: res.__statusCode || res.statusCode\n  });\n  defaultTokens.push({\n    token: \":response-time\",\n    replacement: res.responseTime\n  });\n  defaultTokens.push({ token: \":date\", replacement: new Date().toUTCString() });\n  defaultTokens.push({\n    token: \":referrer\",\n    replacement: req.headers.referer || req.headers.referrer || \"\"\n  });\n  defaultTokens.push({\n    token: \":http-version\",\n    replacement: `${req.httpVersionMajor}.${req.httpVersionMinor}`\n  });\n  defaultTokens.push({\n    token: \":remote-addr\",\n    replacement:\n      req.headers[\"x-forwarded-for\"] ||\n      req.ip ||\n      req._remoteAddress ||\n      (req.socket &&\n        (req.socket.remoteAddress ||\n          (req.socket.socket && req.socket.socket.remoteAddress)))\n  });\n  defaultTokens.push({\n    token: \":user-agent\",\n    replacement: req.headers[\"user-agent\"]\n  });\n  defaultTokens.push({\n    token: \":content-length\",\n    replacement:\n      res.getHeader(\"content-length\") ||\n      (res.__headers && res.__headers[\"Content-Length\"]) ||\n      \"-\"\n  });\n  defaultTokens.push({\n    token: /:req\\[([^\\]]+)]/g,\n    replacement(_, field) {\n      return req.headers[field.toLowerCase()];\n    }\n  });\n  defaultTokens.push({\n    token: /:res\\[([^\\]]+)]/g,\n    replacement(_, field) {\n      return (\n        res.getHeader(field.toLowerCase()) ||\n        (res.__headers && res.__headers[field])\n      );\n    }\n  });\n\n  return arrayUniqueTokens(customTokens.concat(defaultTokens));\n}\n\n/**\n * Return formatted log line.\n *\n * @param  {string} str\n * @param {Array} tokens\n * @return {string}\n * @api private\n */\nfunction format(str, tokens) {\n  for (let i = 0; i < tokens.length; i++) {\n    str = str.replace(tokens[i].token, tokens[i].replacement);\n  }\n  return str;\n}\n\n/**\n * Return RegExp Object about nolog\n *\n * @param  {(string|Array)} nolog\n * @return {RegExp}\n * @api private\n *\n * syntax\n *  1. String\n *   1.1 \"\\\\.gif\"\n *         NOT LOGGING http://example.com/hoge.gif and http://example.com/hoge.gif?fuga\n *         LOGGING http://example.com/hoge.agif\n *   1.2 in \"\\\\.gif|\\\\.jpg$\"\n *         NOT LOGGING http://example.com/hoge.gif and\n *           http://example.com/hoge.gif?fuga and http://example.com/hoge.jpg?fuga\n *         LOGGING http://example.com/hoge.agif,\n *           http://example.com/hoge.ajpg and http://example.com/hoge.jpg?hoge\n *   1.3 in \"\\\\.(gif|jpe?g|png)$\"\n *         NOT LOGGING http://example.com/hoge.gif and http://example.com/hoge.jpeg\n *         LOGGING http://example.com/hoge.gif?uid=2 and http://example.com/hoge.jpg?pid=3\n *  2. RegExp\n *   2.1 in /\\.(gif|jpe?g|png)$/\n *         SAME AS 1.3\n *  3. Array\n *   3.1 [\"\\\\.jpg$\", \"\\\\.png\", \"\\\\.gif\"]\n *         SAME AS \"\\\\.jpg|\\\\.png|\\\\.gif\"\n */\nfunction createNoLogCondition(nolog) {\n  let regexp = null;\n\n  if (nolog instanceof RegExp) {\n    regexp = nolog;\n  }\n\n  if (typeof nolog === \"string\") {\n    regexp = new RegExp(nolog);\n  }\n\n  if (Array.isArray(nolog)) {\n    // convert to strings\n    const regexpsAsStrings = nolog.map(reg => (reg.source ? reg.source : reg));\n    regexp = new RegExp(regexpsAsStrings.join(\"|\"));\n  }\n\n  return regexp;\n}\n\n/**\n * Allows users to define rules around status codes to assign them to a specific\n * logging level.\n * There are two types of rules:\n *   - RANGE: matches a code within a certain range\n *     E.g. { 'from': 200, 'to': 299, 'level': 'info' }\n *   - CONTAINS: matches a code to a set of expected codes\n *     E.g. { 'codes': [200, 203], 'level': 'debug' }\n * Note*: Rules are respected only in order of prescendence.\n *\n * @param {Number} statusCode\n * @param {Level} currentLevel\n * @param {Object} ruleSet\n * @return {Level}\n * @api private\n */\nfunction matchRules(statusCode, currentLevel, ruleSet) {\n  let level = currentLevel;\n\n  if (ruleSet) {\n    const matchedRule = ruleSet.find(rule => {\n      let ruleMatched = false;\n      if (rule.from && rule.to) {\n        ruleMatched = statusCode >= rule.from && statusCode <= rule.to;\n      } else {\n        ruleMatched = rule.codes.indexOf(statusCode) !== -1;\n      }\n      return ruleMatched;\n    });\n    if (matchedRule) {\n      level = levels.getLevel(matchedRule.level, level);\n    }\n  }\n  return level;\n}\n\n/**\n * Log requests with the given `options` or a `format` string.\n *\n * Options:\n *\n *   - `format`        Format string, see below for tokens\n *   - `level`         A log4js levels instance. Supports also 'auto'\n *   - `nolog`         A string or RegExp to exclude target logs\n *   - `statusRules`   A array of rules for setting specific logging levels base on status codes\n *   - `context`       Whether to add a response of express to the context\n *\n * Tokens:\n *\n *   - `:req[header]` ex: `:req[Accept]`\n *   - `:res[header]` ex: `:res[Content-Length]`\n *   - `:http-version`\n *   - `:response-time`\n *   - `:remote-addr`\n *   - `:date`\n *   - `:method`\n *   - `:url`\n *   - `:referrer`\n *   - `:user-agent`\n *   - `:status`\n *\n * @return {Function}\n * @param logger4js\n * @param options\n * @api public\n */\nmodule.exports = function getLogger(logger4js, options) {\n  /* eslint no-underscore-dangle:0 */\n  if (typeof options === \"string\" || typeof options === \"function\") {\n    options = { format: options };\n  } else {\n    options = options || {};\n  }\n\n  const thisLogger = logger4js;\n  let level = levels.getLevel(options.level, levels.INFO);\n  const fmt = options.format || DEFAULT_FORMAT;\n  const nolog = createNoLogCondition(options.nolog);\n\n  return (req, res, next) => {\n    // mount safety\n    if (req._logging) return next();\n\n    // nologs\n    if (nolog && nolog.test(req.originalUrl)) return next();\n\n    if (thisLogger.isLevelEnabled(level) || options.level === \"auto\") {\n      const start = new Date();\n      const { writeHead } = res;\n\n      // flag as logging\n      req._logging = true;\n\n      // proxy for statusCode.\n      res.writeHead = (code, headers) => {\n        res.writeHead = writeHead;\n        res.writeHead(code, headers);\n\n        res.__statusCode = code;\n        res.__headers = headers || {};\n      };\n\n      // hook on end request to emit the log entry of the HTTP request.\n      res.on(\"finish\", () => {\n        res.responseTime = new Date() - start;\n        // status code response level handling\n        if (res.statusCode && options.level === \"auto\") {\n          level = levels.INFO;\n          if (res.statusCode >= 300) level = levels.WARN;\n          if (res.statusCode >= 400) level = levels.ERROR;\n        }\n        level = matchRules(res.statusCode, level, options.statusRules);\n\n        const combinedTokens = assembleTokens(req, res, options.tokens || []);\n\n        if (options.context) thisLogger.addContext(\"res\", res);\n        if (typeof fmt === \"function\") {\n          const line = fmt(req, res, str => format(str, combinedTokens));\n          if (line) thisLogger.log(level, line);\n        } else {\n          thisLogger.log(level, format(fmt, combinedTokens));\n        }\n        if (options.context) thisLogger.removeContext(\"res\");\n      });\n    }\n\n    // ensure next gets always called\n    return next();\n  };\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/connect-logger.js?");

/***/ }),

/***/ "./node_modules/log4js/lib/layouts.js":
/*!********************************************!*\
  !*** ./node_modules/log4js/lib/layouts.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const dateFormat = __webpack_require__(/*! date-format */ \"./node_modules/date-format/lib/index.js\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst path = __webpack_require__(/*! path */ \"path\");\n\nconst styles = {\n  // styles\n  bold: [1, 22],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  // grayscale\n  white: [37, 39],\n  grey: [90, 39],\n  black: [90, 39],\n  // colors\n  blue: [34, 39],\n  cyan: [36, 39],\n  green: [32, 39],\n  magenta: [35, 39],\n  red: [91, 39],\n  yellow: [33, 39]\n};\n\nfunction colorizeStart(style) {\n  return style ? `\\x1B[${styles[style][0]}m` : '';\n}\n\nfunction colorizeEnd(style) {\n  return style ? `\\x1B[${styles[style][1]}m` : '';\n}\n\n/**\n * Taken from masylum's fork (https://github.com/masylum/log4js-node)\n */\nfunction colorize(str, style) {\n  return colorizeStart(style) + str + colorizeEnd(style);\n}\n\nfunction timestampLevelAndCategory(loggingEvent, colour) {\n  return colorize(\n    util.format(\n      '[%s] [%s] %s - ',\n      dateFormat.asString(loggingEvent.startTime),\n      loggingEvent.level.toString(),\n      loggingEvent.categoryName\n    ),\n    colour\n  );\n}\n\n/**\n * BasicLayout is a simple layout for storing the logs. The logs are stored\n * in following format:\n * <pre>\n * [startTime] [logLevel] categoryName - message\\n\n * </pre>\n *\n * @author Stephan Strittmatter\n */\nfunction basicLayout(loggingEvent) {\n  return timestampLevelAndCategory(loggingEvent) + util.format(...loggingEvent.data);\n}\n\n/**\n * colouredLayout - taken from masylum's fork.\n * same as basicLayout, but with colours.\n */\nfunction colouredLayout(loggingEvent) {\n  return timestampLevelAndCategory(loggingEvent, loggingEvent.level.colour) + util.format(...loggingEvent.data);\n}\n\nfunction messagePassThroughLayout(loggingEvent) {\n  return util.format(...loggingEvent.data);\n}\n\nfunction dummyLayout(loggingEvent) {\n  return loggingEvent.data[0];\n}\n\n/**\n * PatternLayout\n * Format for specifiers is %[padding].[truncation][field]{[format]}\n * e.g. %5.10p - left pad the log level by 5 characters, up to a max of 10\n * both padding and truncation can be negative.\n * Negative truncation = trunc from end of string\n * Positive truncation = trunc from start of string\n * Negative padding = pad right\n * Positive padding = pad left\n *\n * Fields can be any of:\n *  - %r time in toLocaleTimeString format\n *  - %p log level\n *  - %c log category\n *  - %h hostname\n *  - %m log data\n *  - %d date in constious formats\n *  - %% %\n *  - %n newline\n *  - %z pid\n *  - %f filename\n *  - %l line number\n *  - %o column postion\n *  - %s call stack\n *  - %x{<tokenname>} add dynamic tokens to your log. Tokens are specified in the tokens parameter\n *  - %X{<tokenname>} add dynamic tokens to your log. Tokens are specified in logger context\n * You can use %[ and %] to define a colored block.\n *\n * Tokens are specified as simple key:value objects.\n * The key represents the token name whereas the value can be a string or function\n * which is called to extract the value to put in the log message. If token is not\n * found, it doesn't replace the field.\n *\n * A sample token would be: { 'pid' : function() { return process.pid; } }\n *\n * Takes a pattern string, array of tokens and returns a layout function.\n * @return {Function}\n * @param pattern\n * @param tokens\n * @param timezoneOffset\n *\n * @authors ['Stephan Strittmatter', 'Jan Schmidle']\n */\nfunction patternLayout(pattern, tokens) {\n  const TTCC_CONVERSION_PATTERN = '%r %p %c - %m%n';\n  const regex = /%(-?[0-9]+)?(\\.?-?[0-9]+)?([[\\]cdhmnprzxXyflos%])(\\{([^}]+)\\})?|([^%]+)/;\n\n  pattern = pattern || TTCC_CONVERSION_PATTERN;\n\n  function categoryName(loggingEvent, specifier) {\n    let loggerName = loggingEvent.categoryName;\n    if (specifier) {\n      const precision = parseInt(specifier, 10);\n      const loggerNameBits = loggerName.split('.');\n      if (precision < loggerNameBits.length) {\n        loggerName = loggerNameBits.slice(loggerNameBits.length - precision).join('.');\n      }\n    }\n    return loggerName;\n  }\n\n  function formatAsDate(loggingEvent, specifier) {\n    let format = dateFormat.ISO8601_FORMAT;\n    if (specifier) {\n      format = specifier;\n      // Pick up special cases\n      if (format === 'ISO8601') {\n        format = dateFormat.ISO8601_FORMAT;\n      } else if (format === 'ISO8601_WITH_TZ_OFFSET') {\n        format = dateFormat.ISO8601_WITH_TZ_OFFSET_FORMAT;\n      } else if (format === 'ABSOLUTE') {\n        format = dateFormat.ABSOLUTETIME_FORMAT;\n      } else if (format === 'DATE') {\n        format = dateFormat.DATETIME_FORMAT;\n      }\n    }\n    // Format the date\n    return dateFormat.asString(format, loggingEvent.startTime);\n  }\n\n  function hostname() {\n    return os.hostname().toString();\n  }\n\n  function formatMessage(loggingEvent) {\n    return util.format(...loggingEvent.data);\n  }\n\n  function endOfLine() {\n    return os.EOL;\n  }\n\n  function logLevel(loggingEvent) {\n    return loggingEvent.level.toString();\n  }\n\n  function startTime(loggingEvent) {\n    return dateFormat.asString('hh:mm:ss', loggingEvent.startTime);\n  }\n\n  function startColour(loggingEvent) {\n    return colorizeStart(loggingEvent.level.colour);\n  }\n\n  function endColour(loggingEvent) {\n    return colorizeEnd(loggingEvent.level.colour);\n  }\n\n  function percent() {\n    return '%';\n  }\n\n  function pid(loggingEvent) {\n    return loggingEvent && loggingEvent.pid ? loggingEvent.pid.toString() : process.pid.toString();\n  }\n\n  function clusterInfo() {\n    // this used to try to return the master and worker pids,\n    // but it would never have worked because master pid is not available to workers\n    // leaving this here to maintain compatibility for patterns\n    return pid();\n  }\n\n  function userDefined(loggingEvent, specifier) {\n    if (typeof tokens[specifier] !== 'undefined') {\n      return typeof tokens[specifier] === 'function' ? tokens[specifier](loggingEvent) : tokens[specifier];\n    }\n\n    return null;\n  }\n\n  function contextDefined(loggingEvent, specifier) {\n    const resolver = loggingEvent.context[specifier];\n\n    if (typeof resolver !== 'undefined') {\n      return typeof resolver === 'function' ? resolver(loggingEvent) : resolver;\n    }\n\n    return null;\n  }\n\n  function fileName(loggingEvent, specifier) {\n    let filename = loggingEvent.fileName || '';\n    if (specifier) {\n      const fileDepth = parseInt(specifier, 10);\n      const fileList = filename.split(path.sep);\n      if (fileList.length > fileDepth) {\n        filename = fileList.slice(-fileDepth).join(path.sep);\n      }\n    }\n\n    return filename;\n  }\n\n  function lineNumber(loggingEvent) {\n    return loggingEvent.lineNumber ? `${loggingEvent.lineNumber}` : '';\n  }\n\n  function columnNumber(loggingEvent) {\n    return loggingEvent.columnNumber ? `${loggingEvent.columnNumber}` : '';\n  }\n\n  function callStack(loggingEvent) {\n    return loggingEvent.callStack || '';\n  }\n\n  /* eslint quote-props:0 */\n  const replacers = {\n    c: categoryName,\n    d: formatAsDate,\n    h: hostname,\n    m: formatMessage,\n    n: endOfLine,\n    p: logLevel,\n    r: startTime,\n    '[': startColour,\n    ']': endColour,\n    y: clusterInfo,\n    z: pid,\n    '%': percent,\n    x: userDefined,\n    X: contextDefined,\n    f: fileName,\n    l: lineNumber,\n    o: columnNumber,\n    s: callStack\n  };\n\n  function replaceToken(conversionCharacter, loggingEvent, specifier) {\n    return replacers[conversionCharacter](loggingEvent, specifier);\n  }\n\n  function truncate(truncation, toTruncate) {\n    let len;\n    if (truncation) {\n      len = parseInt(truncation.substr(1), 10);\n      // negative truncate length means truncate from end of string\n      return len > 0 ? toTruncate.slice(0, len) : toTruncate.slice(len);\n    }\n\n    return toTruncate;\n  }\n\n  function pad(padding, toPad) {\n    let len;\n    if (padding) {\n      if (padding.charAt(0) === '-') {\n        len = parseInt(padding.substr(1), 10);\n        // Right pad with spaces\n        while (toPad.length < len) {\n          toPad += ' ';\n        }\n      } else {\n        len = parseInt(padding, 10);\n        // Left pad with spaces\n        while (toPad.length < len) {\n          toPad = ` ${toPad}`;\n        }\n      }\n    }\n    return toPad;\n  }\n\n  function truncateAndPad(toTruncAndPad, truncation, padding) {\n    let replacement = toTruncAndPad;\n    replacement = truncate(truncation, replacement);\n    replacement = pad(padding, replacement);\n    return replacement;\n  }\n\n  return function (loggingEvent) {\n    let formattedString = '';\n    let result;\n    let searchString = pattern;\n\n    /* eslint no-cond-assign:0 */\n    while ((result = regex.exec(searchString)) !== null) {\n      // const matchedString = result[0];\n      const padding = result[1];\n      const truncation = result[2];\n      const conversionCharacter = result[3];\n      const specifier = result[5];\n      const text = result[6];\n\n      // Check if the pattern matched was just normal text\n      if (text) {\n        formattedString += text.toString();\n      } else {\n        // Create a raw replacement string based on the conversion\n        // character and specifier\n        const replacement = replaceToken(conversionCharacter, loggingEvent, specifier);\n        formattedString += truncateAndPad(replacement, truncation, padding);\n      }\n      searchString = searchString.substr(result.index + result[0].length);\n    }\n    return formattedString;\n  };\n}\n\nconst layoutMakers = {\n  messagePassThrough () {\n    return messagePassThroughLayout;\n  },\n  basic () {\n    return basicLayout;\n  },\n  colored () {\n    return colouredLayout;\n  },\n  coloured () {\n    return colouredLayout;\n  },\n  pattern (config) {\n    return patternLayout(config && config.pattern, config && config.tokens);\n  },\n  dummy () {\n    return dummyLayout;\n  }\n};\n\nmodule.exports = {\n  basicLayout,\n  messagePassThroughLayout,\n  patternLayout,\n  colouredLayout,\n  coloredLayout: colouredLayout,\n  dummyLayout,\n  addLayout (name, serializerGenerator) {\n    layoutMakers[name] = serializerGenerator;\n  },\n  layout (name, config) {\n    return layoutMakers[name] && layoutMakers[name](config);\n  }\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/layouts.js?");

/***/ }),

/***/ "./node_modules/log4js/lib/levels.js":
/*!*******************************************!*\
  !*** ./node_modules/log4js/lib/levels.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst configuration = __webpack_require__(/*! ./configuration */ \"./node_modules/log4js/lib/configuration.js\");\n\nconst validColours = [\n  'white', 'grey', 'black',\n  'blue', 'cyan', 'green',\n  'magenta', 'red', 'yellow'\n];\n\nclass Level {\n  constructor(level, levelStr, colour) {\n    this.level = level;\n    this.levelStr = levelStr;\n    this.colour = colour;\n  }\n\n  toString() {\n    return this.levelStr;\n  }\n\n  /**\n   * converts given String to corresponding Level\n   * @param {(Level|string)} sArg -- String value of Level OR Log4js.Level\n   * @param {Level} [defaultLevel] -- default Level, if no String representation\n   * @return {Level}\n   */\n  static getLevel(sArg, defaultLevel) {\n    if (!sArg) {\n      return defaultLevel;\n    }\n\n    if (sArg instanceof Level) {\n      return sArg;\n    }\n\n    // a json-serialised level won't be an instance of Level (see issue #768)\n    if (sArg instanceof Object && sArg.levelStr) {\n      sArg = sArg.levelStr;\n    }\n\n    return Level[sArg.toString().toUpperCase()] || defaultLevel;\n  }\n\n  static addLevels(customLevels) {\n    if (customLevels) {\n      const levels = Object.keys(customLevels);\n      levels.forEach((l) => {\n        const levelStr = l.toUpperCase();\n        Level[levelStr] = new Level(\n          customLevels[l].value,\n          levelStr,\n          customLevels[l].colour\n        );\n        const existingLevelIndex = Level.levels.findIndex(lvl => lvl.levelStr === levelStr);\n        if (existingLevelIndex > -1) {\n          Level.levels[existingLevelIndex] = Level[levelStr];\n        } else {\n          Level.levels.push(Level[levelStr]);\n        }\n      });\n      Level.levels.sort((a, b) => a.level - b.level);\n    }\n  }\n\n\n  isLessThanOrEqualTo(otherLevel) {\n    if (typeof otherLevel === 'string') {\n      otherLevel = Level.getLevel(otherLevel);\n    }\n    return this.level <= otherLevel.level;\n  }\n\n  isGreaterThanOrEqualTo(otherLevel) {\n    if (typeof otherLevel === 'string') {\n      otherLevel = Level.getLevel(otherLevel);\n    }\n    return this.level >= otherLevel.level;\n  }\n\n  isEqualTo(otherLevel) {\n    if (typeof otherLevel === 'string') {\n      otherLevel = Level.getLevel(otherLevel);\n    }\n    return this.level === otherLevel.level;\n  }\n}\n\nLevel.levels = [];\nLevel.addLevels({\n  ALL: { value: Number.MIN_VALUE, colour: 'grey' },\n  TRACE: { value: 5000, colour: 'blue' },\n  DEBUG: { value: 10000, colour: 'cyan' },\n  INFO: { value: 20000, colour: 'green' },\n  WARN: { value: 30000, colour: 'yellow' },\n  ERROR: { value: 40000, colour: 'red' },\n  FATAL: { value: 50000, colour: 'magenta' },\n  MARK: { value: 9007199254740992, colour: 'grey' }, // 2^53\n  OFF: { value: Number.MAX_VALUE, colour: 'grey' }\n});\n\nconfiguration.addListener((config) => {\n  const levelConfig = config.levels;\n  if (levelConfig) {\n    configuration.throwExceptionIf(\n      config,\n      configuration.not(configuration.anObject(levelConfig)),\n      'levels must be an object'\n    );\n    const newLevels = Object.keys(levelConfig);\n    newLevels.forEach((l) => {\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(configuration.validIdentifier(l)),\n        `level name \"${l}\" is not a valid identifier (must start with a letter, only contain A-Z,a-z,0-9,_)`\n      );\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(configuration.anObject(levelConfig[l])),\n        `level \"${l}\" must be an object`\n      );\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(levelConfig[l].value),\n        `level \"${l}\" must have a 'value' property`\n      );\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(configuration.anInteger(levelConfig[l].value)),\n        `level \"${l}\".value must have an integer value`\n      );\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(levelConfig[l].colour),\n        `level \"${l}\" must have a 'colour' property`\n      );\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(validColours.indexOf(levelConfig[l].colour) > -1),\n        `level \"${l}\".colour must be one of ${validColours.join(', ')}`\n      );\n    });\n  }\n});\n\nconfiguration.addListener((config) => {\n  Level.addLevels(config.levels);\n});\n\nmodule.exports = Level;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/levels.js?");

/***/ }),

/***/ "./node_modules/log4js/lib/log4js.js":
/*!*******************************************!*\
  !*** ./node_modules/log4js/lib/log4js.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview log4js is a library to log in JavaScript in similar manner\n * than in log4j for Java (but not really).\n *\n * <h3>Example:</h3>\n * <pre>\n *  const logging = require('log4js');\n *  const log = logging.getLogger('some-category');\n *\n *  //call the log\n *  log.trace('trace me' );\n * </pre>\n *\n * NOTE: the authors below are the original browser-based log4js authors\n * don't try to contact them about bugs in this version :)\n * @author Stephan Strittmatter - http://jroller.com/page/stritti\n * @author Seth Chisamore - http://www.chisamore.com\n * @since 2005-05-20\n * Website: http://log4js.berlios.de\n */\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")(\"log4js:main\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst deepClone = __webpack_require__(/*! rfdc */ \"./node_modules/rfdc/index.js\")({ proto: true });\nconst configuration = __webpack_require__(/*! ./configuration */ \"./node_modules/log4js/lib/configuration.js\");\nconst layouts = __webpack_require__(/*! ./layouts */ \"./node_modules/log4js/lib/layouts.js\");\nconst levels = __webpack_require__(/*! ./levels */ \"./node_modules/log4js/lib/levels.js\");\nconst appenders = __webpack_require__(/*! ./appenders */ \"./node_modules/log4js/lib/appenders/index.js\");\nconst categories = __webpack_require__(/*! ./categories */ \"./node_modules/log4js/lib/categories.js\");\nconst Logger = __webpack_require__(/*! ./logger */ \"./node_modules/log4js/lib/logger.js\");\nconst clustering = __webpack_require__(/*! ./clustering */ \"./node_modules/log4js/lib/clustering.js\");\nconst connectLogger = __webpack_require__(/*! ./connect-logger */ \"./node_modules/log4js/lib/connect-logger.js\");\n\nlet enabled = false;\n\nfunction sendLogEventToAppender(logEvent) {\n  if (!enabled) return;\n  debug(\"Received log event \", logEvent);\n  const categoryAppenders = categories.appendersForCategory(\n    logEvent.categoryName\n  );\n  categoryAppenders.forEach(appender => {\n    appender(logEvent);\n  });\n}\n\nfunction loadConfigurationFile(filename) {\n  debug(`Loading configuration from ${filename}`);\n  try {\n    return JSON.parse(fs.readFileSync(filename, \"utf8\"));\n  } catch (e) {\n    throw new Error(\n      `Problem reading config from file \"${filename}\". Error was ${e.message}`,\n      e\n    );\n  }\n}\n\nfunction configure(configurationFileOrObject) {\n  let configObject = configurationFileOrObject;\n\n  if (typeof configObject === \"string\") {\n    configObject = loadConfigurationFile(configurationFileOrObject);\n  }\n  debug(`Configuration is ${configObject}`);\n\n  configuration.configure(deepClone(configObject));\n\n  clustering.onMessage(sendLogEventToAppender);\n\n  enabled = true;\n\n  // eslint-disable-next-line no-use-before-define\n  return log4js;\n}\n\n/**\n * Shutdown all log appenders. This will first disable all writing to appenders\n * and then call the shutdown function each appender.\n *\n * @params {Function} cb - The callback to be invoked once all appenders have\n *  shutdown. If an error occurs, the callback will be given the error object\n *  as the first argument.\n */\nfunction shutdown(cb) {\n  debug(\"Shutdown called. Disabling all log writing.\");\n  // First, disable all writing to appenders. This prevents appenders from\n  // not being able to be drained because of run-away log writes.\n  enabled = false;\n\n  // Call each of the shutdown functions in parallel\n  const appendersToCheck = Array.from(appenders.values());\n  const shutdownFunctions = appendersToCheck.reduceRight(\n    (accum, next) => (next.shutdown ? accum + 1 : accum),\n    0\n  );\n  let completed = 0;\n  let error;\n\n  debug(`Found ${shutdownFunctions} appenders with shutdown functions.`);\n  function complete(err) {\n    error = error || err;\n    completed += 1;\n    debug(`Appender shutdowns complete: ${completed} / ${shutdownFunctions}`);\n    if (completed >= shutdownFunctions) {\n      debug(\"All shutdown functions completed.\");\n      if (cb) {\n        cb(error);\n      }\n    }\n  }\n\n  if (shutdownFunctions === 0) {\n    debug(\"No appenders with shutdown functions found.\");\n    return cb !== undefined && cb();\n  }\n\n  appendersToCheck.filter(a => a.shutdown).forEach(a => a.shutdown(complete));\n\n  return null;\n}\n\n/**\n * Get a logger instance.\n * @static\n * @param loggerCategoryName\n * @return {Logger} instance of logger for the category\n */\nfunction getLogger(category) {\n  if (!enabled) {\n    configure(\n      process.env.LOG4JS_CONFIG || {\n        appenders: { out: { type: \"stdout\" } },\n        categories: { default: { appenders: [\"out\"], level: \"OFF\" } }\n      }\n    );\n  }\n  return new Logger(category || \"default\");\n}\n\n/**\n * @name log4js\n * @namespace Log4js\n * @property getLogger\n * @property configure\n * @property shutdown\n */\nconst log4js = {\n  getLogger,\n  configure,\n  shutdown,\n  connectLogger,\n  levels,\n  addLayout: layouts.addLayout\n};\n\nmodule.exports = log4js;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/log4js.js?");

/***/ }),

/***/ "./node_modules/log4js/lib/logger.js":
/*!*******************************************!*\
  !*** ./node_modules/log4js/lib/logger.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-underscore-dangle:0 */\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")(\"log4js:logger\");\nconst LoggingEvent = __webpack_require__(/*! ./LoggingEvent */ \"./node_modules/log4js/lib/LoggingEvent.js\");\nconst levels = __webpack_require__(/*! ./levels */ \"./node_modules/log4js/lib/levels.js\");\nconst clustering = __webpack_require__(/*! ./clustering */ \"./node_modules/log4js/lib/clustering.js\");\nconst categories = __webpack_require__(/*! ./categories */ \"./node_modules/log4js/lib/categories.js\");\nconst configuration = __webpack_require__(/*! ./configuration */ \"./node_modules/log4js/lib/configuration.js\");\n\nconst stackReg = /at (?:(.+)\\s+\\()?(?:(.+?):(\\d+)(?::(\\d+))?|([^)]+))\\)?/;\nfunction defaultParseCallStack(data, skipIdx = 4) {\n  const stacklines = data.stack.split(\"\\n\").slice(skipIdx);\n  const lineMatch = stackReg.exec(stacklines[0]);\n  if (lineMatch && lineMatch.length === 6) {\n    return {\n      functionName: lineMatch[1],\n      fileName: lineMatch[2],\n      lineNumber: parseInt(lineMatch[3], 10),\n      columnNumber: parseInt(lineMatch[4], 10),\n      callStack: stacklines.join(\"\\n\")\n    };\n  }\n  return null;\n}\n\n/**\n * Logger to log messages.\n * use {@see log4js#getLogger(String)} to get an instance.\n *\n * @name Logger\n * @namespace Log4js\n * @param name name of category to log to\n * @param level - the loglevel for the category\n * @param dispatch - the function which will receive the logevents\n *\n * @author Stephan Strittmatter\n */\nclass Logger {\n  constructor(name) {\n    if (!name) {\n      throw new Error(\"No category provided.\");\n    }\n    this.category = name;\n    this.context = {};\n    this.parseCallStack = defaultParseCallStack;\n    debug(`Logger created (${this.category}, ${this.level})`);\n  }\n\n  get level() {\n    return levels.getLevel(\n      categories.getLevelForCategory(this.category),\n      levels.TRACE\n    );\n  }\n\n  set level(level) {\n    categories.setLevelForCategory(\n      this.category,\n      levels.getLevel(level, this.level)\n    );\n  }\n\n  get useCallStack() {\n    return categories.getEnableCallStackForCategory(this.category);\n  }\n\n  set useCallStack(bool) {\n    categories.setEnableCallStackForCategory(this.category, bool === true);\n  }\n\n  log(level, ...args) {\n    const logLevel = levels.getLevel(level, levels.INFO);\n    if (this.isLevelEnabled(logLevel)) {\n      this._log(logLevel, args);\n    }\n  }\n\n  isLevelEnabled(otherLevel) {\n    return this.level.isLessThanOrEqualTo(otherLevel);\n  }\n\n  _log(level, data) {\n    debug(`sending log data (${level}) to appenders`);\n    const loggingEvent = new LoggingEvent(\n      this.category,\n      level,\n      data,\n      this.context,\n      this.useCallStack && this.parseCallStack(new Error())\n    );\n    clustering.send(loggingEvent);\n  }\n\n  addContext(key, value) {\n    this.context[key] = value;\n  }\n\n  removeContext(key) {\n    delete this.context[key];\n  }\n\n  clearContext() {\n    this.context = {};\n  }\n\n  setParseCallStackFunction(parseFunction) {\n    this.parseCallStack = parseFunction;\n  }\n}\n\nfunction addLevelMethods(target) {\n  const level = levels.getLevel(target);\n\n  const levelStrLower = level.toString().toLowerCase();\n  const levelMethod = levelStrLower.replace(/_([a-z])/g, g =>\n    g[1].toUpperCase()\n  );\n  const isLevelMethod = levelMethod[0].toUpperCase() + levelMethod.slice(1);\n\n  Logger.prototype[`is${isLevelMethod}Enabled`] = function() {\n    return this.isLevelEnabled(level);\n  };\n\n  Logger.prototype[levelMethod] = function(...args) {\n    this.log(level, ...args);\n  };\n}\n\nlevels.levels.forEach(addLevelMethods);\n\nconfiguration.addListener(() => {\n  levels.levels.forEach(addLevelMethods);\n});\n\nmodule.exports = Logger;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/log4js/lib/logger.js?");

/***/ }),

/***/ "./node_modules/marked/src/Lexer.js":
/*!******************************************!*\
  !*** ./node_modules/marked/src/Lexer.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Tokenizer = __webpack_require__(/*! ./Tokenizer.js */ \"./node_modules/marked/src/Tokenizer.js\");\nconst { defaults } = __webpack_require__(/*! ./defaults.js */ \"./node_modules/marked/src/defaults.js\");\nconst { block, inline } = __webpack_require__(/*! ./rules.js */ \"./node_modules/marked/src/rules.js\");\nconst { repeatString } = __webpack_require__(/*! ./helpers.js */ \"./node_modules/marked/src/helpers.js\");\n\n/**\n * smartypants text replacement\n */\nfunction smartypants(text) {\n  return text\n    // em-dashes\n    .replace(/---/g, '\\u2014')\n    // en-dashes\n    .replace(/--/g, '\\u2013')\n    // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\n    // closing singles & apostrophes\n    .replace(/'/g, '\\u2019')\n    // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\n    // closing doubles\n    .replace(/\"/g, '\\u201d')\n    // ellipses\n    .replace(/\\.{3}/g, '\\u2026');\n}\n\n/**\n * mangle email addresses\n */\nfunction mangle(text) {\n  let out = '',\n    i,\n    ch;\n\n  const l = text.length;\n  for (i = 0; i < l; i++) {\n    ch = text.charCodeAt(i);\n    if (Math.random() > 0.5) {\n      ch = 'x' + ch.toString(16);\n    }\n    out += '&#' + ch + ';';\n  }\n\n  return out;\n}\n\n/**\n * Block Lexer\n */\nmodule.exports = class Lexer {\n  constructor(options) {\n    this.tokens = [];\n    this.tokens.links = Object.create(null);\n    this.options = options || defaults;\n    this.options.tokenizer = this.options.tokenizer || new Tokenizer();\n    this.tokenizer = this.options.tokenizer;\n    this.tokenizer.options = this.options;\n\n    const rules = {\n      block: block.normal,\n      inline: inline.normal\n    };\n\n    if (this.options.pedantic) {\n      rules.block = block.pedantic;\n      rules.inline = inline.pedantic;\n    } else if (this.options.gfm) {\n      rules.block = block.gfm;\n      if (this.options.breaks) {\n        rules.inline = inline.breaks;\n      } else {\n        rules.inline = inline.gfm;\n      }\n    }\n    this.tokenizer.rules = rules;\n  }\n\n  /**\n   * Expose Rules\n   */\n  static get rules() {\n    return {\n      block,\n      inline\n    };\n  }\n\n  /**\n   * Static Lex Method\n   */\n  static lex(src, options) {\n    const lexer = new Lexer(options);\n    return lexer.lex(src);\n  }\n\n  /**\n   * Static Lex Inline Method\n   */\n  static lexInline(src, options) {\n    const lexer = new Lexer(options);\n    return lexer.inlineTokens(src);\n  }\n\n  /**\n   * Preprocessing\n   */\n  lex(src) {\n    src = src\n      .replace(/\\r\\n|\\r/g, '\\n')\n      .replace(/\\t/g, '    ');\n\n    this.blockTokens(src, this.tokens, true);\n\n    this.inline(this.tokens);\n\n    return this.tokens;\n  }\n\n  /**\n   * Lexing\n   */\n  blockTokens(src, tokens = [], top = true) {\n    src = src.replace(/^ +$/gm, '');\n    let token, i, l, lastToken;\n\n    while (src) {\n      // newline\n      if (token = this.tokenizer.space(src)) {\n        src = src.substring(token.raw.length);\n        if (token.type) {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.code(src, tokens)) {\n        src = src.substring(token.raw.length);\n        if (token.type) {\n          tokens.push(token);\n        } else {\n          lastToken = tokens[tokens.length - 1];\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n        }\n        continue;\n      }\n\n      // fences\n      if (token = this.tokenizer.fences(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // heading\n      if (token = this.tokenizer.heading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // table no leading pipe (gfm)\n      if (token = this.tokenizer.nptable(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // hr\n      if (token = this.tokenizer.hr(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // blockquote\n      if (token = this.tokenizer.blockquote(src)) {\n        src = src.substring(token.raw.length);\n        token.tokens = this.blockTokens(token.text, [], top);\n        tokens.push(token);\n        continue;\n      }\n\n      // list\n      if (token = this.tokenizer.list(src)) {\n        src = src.substring(token.raw.length);\n        l = token.items.length;\n        for (i = 0; i < l; i++) {\n          token.items[i].tokens = this.blockTokens(token.items[i].text, [], false);\n        }\n        tokens.push(token);\n        continue;\n      }\n\n      // html\n      if (token = this.tokenizer.html(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // def\n      if (top && (token = this.tokenizer.def(src))) {\n        src = src.substring(token.raw.length);\n        if (!this.tokens.links[token.tag]) {\n          this.tokens.links[token.tag] = {\n            href: token.href,\n            title: token.title\n          };\n        }\n        continue;\n      }\n\n      // table (gfm)\n      if (token = this.tokenizer.table(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // lheading\n      if (token = this.tokenizer.lheading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // top-level paragraph\n      if (top && (token = this.tokenizer.paragraph(src))) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // text\n      if (token = this.tokenizer.text(src, tokens)) {\n        src = src.substring(token.raw.length);\n        if (token.type) {\n          tokens.push(token);\n        } else {\n          lastToken = tokens[tokens.length - 1];\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n        }\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    return tokens;\n  }\n\n  inline(tokens) {\n    let i,\n      j,\n      k,\n      l2,\n      row,\n      token;\n\n    const l = tokens.length;\n    for (i = 0; i < l; i++) {\n      token = tokens[i];\n      switch (token.type) {\n        case 'paragraph':\n        case 'text':\n        case 'heading': {\n          token.tokens = [];\n          this.inlineTokens(token.text, token.tokens);\n          break;\n        }\n        case 'table': {\n          token.tokens = {\n            header: [],\n            cells: []\n          };\n\n          // header\n          l2 = token.header.length;\n          for (j = 0; j < l2; j++) {\n            token.tokens.header[j] = [];\n            this.inlineTokens(token.header[j], token.tokens.header[j]);\n          }\n\n          // cells\n          l2 = token.cells.length;\n          for (j = 0; j < l2; j++) {\n            row = token.cells[j];\n            token.tokens.cells[j] = [];\n            for (k = 0; k < row.length; k++) {\n              token.tokens.cells[j][k] = [];\n              this.inlineTokens(row[k], token.tokens.cells[j][k]);\n            }\n          }\n\n          break;\n        }\n        case 'blockquote': {\n          this.inline(token.tokens);\n          break;\n        }\n        case 'list': {\n          l2 = token.items.length;\n          for (j = 0; j < l2; j++) {\n            this.inline(token.items[j].tokens);\n          }\n          break;\n        }\n        default: {\n          // do nothing\n        }\n      }\n    }\n\n    return tokens;\n  }\n\n  /**\n   * Lexing/Compiling\n   */\n  inlineTokens(src, tokens = [], inLink = false, inRawBlock = false) {\n    let token;\n\n    // String with links masked to avoid interference with em and strong\n    let maskedSrc = src;\n    let match;\n    let keepPrevChar, prevChar;\n\n    // Mask out reflinks\n    if (this.tokens.links) {\n      const links = Object.keys(this.tokens.links);\n      if (links.length > 0) {\n        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n          if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n          }\n        }\n      }\n    }\n    // Mask out other blocks\n    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n      maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n    }\n\n    while (src) {\n      if (!keepPrevChar) {\n        prevChar = '';\n      }\n      keepPrevChar = false;\n      // escape\n      if (token = this.tokenizer.escape(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // tag\n      if (token = this.tokenizer.tag(src, inLink, inRawBlock)) {\n        src = src.substring(token.raw.length);\n        inLink = token.inLink;\n        inRawBlock = token.inRawBlock;\n        tokens.push(token);\n        continue;\n      }\n\n      // link\n      if (token = this.tokenizer.link(src)) {\n        src = src.substring(token.raw.length);\n        if (token.type === 'link') {\n          token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);\n        }\n        tokens.push(token);\n        continue;\n      }\n\n      // reflink, nolink\n      if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n        src = src.substring(token.raw.length);\n        if (token.type === 'link') {\n          token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);\n        }\n        tokens.push(token);\n        continue;\n      }\n\n      // strong\n      if (token = this.tokenizer.strong(src, maskedSrc, prevChar)) {\n        src = src.substring(token.raw.length);\n        token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);\n        tokens.push(token);\n        continue;\n      }\n\n      // em\n      if (token = this.tokenizer.em(src, maskedSrc, prevChar)) {\n        src = src.substring(token.raw.length);\n        token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);\n        tokens.push(token);\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.codespan(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // br\n      if (token = this.tokenizer.br(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // del (gfm)\n      if (token = this.tokenizer.del(src)) {\n        src = src.substring(token.raw.length);\n        token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);\n        tokens.push(token);\n        continue;\n      }\n\n      // autolink\n      if (token = this.tokenizer.autolink(src, mangle)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // url (gfm)\n      if (!inLink && (token = this.tokenizer.url(src, mangle))) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // text\n      if (token = this.tokenizer.inlineText(src, inRawBlock, smartypants)) {\n        src = src.substring(token.raw.length);\n        prevChar = token.raw.slice(-1);\n        keepPrevChar = true;\n        tokens.push(token);\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    return tokens;\n  }\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/marked/src/Lexer.js?");

/***/ }),

/***/ "./node_modules/marked/src/Parser.js":
/*!*******************************************!*\
  !*** ./node_modules/marked/src/Parser.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Renderer = __webpack_require__(/*! ./Renderer.js */ \"./node_modules/marked/src/Renderer.js\");\nconst TextRenderer = __webpack_require__(/*! ./TextRenderer.js */ \"./node_modules/marked/src/TextRenderer.js\");\nconst Slugger = __webpack_require__(/*! ./Slugger.js */ \"./node_modules/marked/src/Slugger.js\");\nconst { defaults } = __webpack_require__(/*! ./defaults.js */ \"./node_modules/marked/src/defaults.js\");\nconst {\n  unescape\n} = __webpack_require__(/*! ./helpers.js */ \"./node_modules/marked/src/helpers.js\");\n\n/**\n * Parsing & Compiling\n */\nmodule.exports = class Parser {\n  constructor(options) {\n    this.options = options || defaults;\n    this.options.renderer = this.options.renderer || new Renderer();\n    this.renderer = this.options.renderer;\n    this.renderer.options = this.options;\n    this.textRenderer = new TextRenderer();\n    this.slugger = new Slugger();\n  }\n\n  /**\n   * Static Parse Method\n   */\n  static parse(tokens, options) {\n    const parser = new Parser(options);\n    return parser.parse(tokens);\n  }\n\n  /**\n   * Static Parse Inline Method\n   */\n  static parseInline(tokens, options) {\n    const parser = new Parser(options);\n    return parser.parseInline(tokens);\n  }\n\n  /**\n   * Parse Loop\n   */\n  parse(tokens, top = true) {\n    let out = '',\n      i,\n      j,\n      k,\n      l2,\n      l3,\n      row,\n      cell,\n      header,\n      body,\n      token,\n      ordered,\n      start,\n      loose,\n      itemBody,\n      item,\n      checked,\n      task,\n      checkbox;\n\n    const l = tokens.length;\n    for (i = 0; i < l; i++) {\n      token = tokens[i];\n      switch (token.type) {\n        case 'space': {\n          continue;\n        }\n        case 'hr': {\n          out += this.renderer.hr();\n          continue;\n        }\n        case 'heading': {\n          out += this.renderer.heading(\n            this.parseInline(token.tokens),\n            token.depth,\n            unescape(this.parseInline(token.tokens, this.textRenderer)),\n            this.slugger);\n          continue;\n        }\n        case 'code': {\n          out += this.renderer.code(token.text,\n            token.lang,\n            token.escaped);\n          continue;\n        }\n        case 'table': {\n          header = '';\n\n          // header\n          cell = '';\n          l2 = token.header.length;\n          for (j = 0; j < l2; j++) {\n            cell += this.renderer.tablecell(\n              this.parseInline(token.tokens.header[j]),\n              { header: true, align: token.align[j] }\n            );\n          }\n          header += this.renderer.tablerow(cell);\n\n          body = '';\n          l2 = token.cells.length;\n          for (j = 0; j < l2; j++) {\n            row = token.tokens.cells[j];\n\n            cell = '';\n            l3 = row.length;\n            for (k = 0; k < l3; k++) {\n              cell += this.renderer.tablecell(\n                this.parseInline(row[k]),\n                { header: false, align: token.align[k] }\n              );\n            }\n\n            body += this.renderer.tablerow(cell);\n          }\n          out += this.renderer.table(header, body);\n          continue;\n        }\n        case 'blockquote': {\n          body = this.parse(token.tokens);\n          out += this.renderer.blockquote(body);\n          continue;\n        }\n        case 'list': {\n          ordered = token.ordered;\n          start = token.start;\n          loose = token.loose;\n          l2 = token.items.length;\n\n          body = '';\n          for (j = 0; j < l2; j++) {\n            item = token.items[j];\n            checked = item.checked;\n            task = item.task;\n\n            itemBody = '';\n            if (item.task) {\n              checkbox = this.renderer.checkbox(checked);\n              if (loose) {\n                if (item.tokens.length > 0 && item.tokens[0].type === 'text') {\n                  item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                    item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                  }\n                } else {\n                  item.tokens.unshift({\n                    type: 'text',\n                    text: checkbox\n                  });\n                }\n              } else {\n                itemBody += checkbox;\n              }\n            }\n\n            itemBody += this.parse(item.tokens, loose);\n            body += this.renderer.listitem(itemBody, task, checked);\n          }\n\n          out += this.renderer.list(body, ordered, start);\n          continue;\n        }\n        case 'html': {\n          // TODO parse inline content if parameter markdown=1\n          out += this.renderer.html(token.text);\n          continue;\n        }\n        case 'paragraph': {\n          out += this.renderer.paragraph(this.parseInline(token.tokens));\n          continue;\n        }\n        case 'text': {\n          body = token.tokens ? this.parseInline(token.tokens) : token.text;\n          while (i + 1 < l && tokens[i + 1].type === 'text') {\n            token = tokens[++i];\n            body += '\\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);\n          }\n          out += top ? this.renderer.paragraph(body) : body;\n          continue;\n        }\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Parse Inline Tokens\n   */\n  parseInline(tokens, renderer) {\n    renderer = renderer || this.renderer;\n    let out = '',\n      i,\n      token;\n\n    const l = tokens.length;\n    for (i = 0; i < l; i++) {\n      token = tokens[i];\n      switch (token.type) {\n        case 'escape': {\n          out += renderer.text(token.text);\n          break;\n        }\n        case 'html': {\n          out += renderer.html(token.text);\n          break;\n        }\n        case 'link': {\n          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'image': {\n          out += renderer.image(token.href, token.title, token.text);\n          break;\n        }\n        case 'strong': {\n          out += renderer.strong(this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'em': {\n          out += renderer.em(this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'codespan': {\n          out += renderer.codespan(token.text);\n          break;\n        }\n        case 'br': {\n          out += renderer.br();\n          break;\n        }\n        case 'del': {\n          out += renderer.del(this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'text': {\n          out += renderer.text(token.text);\n          break;\n        }\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n    return out;\n  }\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/marked/src/Parser.js?");

/***/ }),

/***/ "./node_modules/marked/src/Renderer.js":
/*!*********************************************!*\
  !*** ./node_modules/marked/src/Renderer.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { defaults } = __webpack_require__(/*! ./defaults.js */ \"./node_modules/marked/src/defaults.js\");\nconst {\n  cleanUrl,\n  escape\n} = __webpack_require__(/*! ./helpers.js */ \"./node_modules/marked/src/helpers.js\");\n\n/**\n * Renderer\n */\nmodule.exports = class Renderer {\n  constructor(options) {\n    this.options = options || defaults;\n  }\n\n  code(code, infostring, escaped) {\n    const lang = (infostring || '').match(/\\S*/)[0];\n    if (this.options.highlight) {\n      const out = this.options.highlight(code, lang);\n      if (out != null && out !== code) {\n        escaped = true;\n        code = out;\n      }\n    }\n\n    if (!lang) {\n      return '<pre><code>'\n        + (escaped ? code : escape(code, true))\n        + '</code></pre>\\n';\n    }\n\n    return '<pre><code class=\"'\n      + this.options.langPrefix\n      + escape(lang, true)\n      + '\">'\n      + (escaped ? code : escape(code, true))\n      + '</code></pre>\\n';\n  }\n\n  blockquote(quote) {\n    return '<blockquote>\\n' + quote + '</blockquote>\\n';\n  }\n\n  html(html) {\n    return html;\n  }\n\n  heading(text, level, raw, slugger) {\n    if (this.options.headerIds) {\n      return '<h'\n        + level\n        + ' id=\"'\n        + this.options.headerPrefix\n        + slugger.slug(raw)\n        + '\">'\n        + text\n        + '</h'\n        + level\n        + '>\\n';\n    }\n    // ignore IDs\n    return '<h' + level + '>' + text + '</h' + level + '>\\n';\n  }\n\n  hr() {\n    return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n  }\n\n  list(body, ordered, start) {\n    const type = ordered ? 'ol' : 'ul',\n      startatt = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n    return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n  }\n\n  listitem(text) {\n    return '<li>' + text + '</li>\\n';\n  }\n\n  checkbox(checked) {\n    return '<input '\n      + (checked ? 'checked=\"\" ' : '')\n      + 'disabled=\"\" type=\"checkbox\"'\n      + (this.options.xhtml ? ' /' : '')\n      + '> ';\n  }\n\n  paragraph(text) {\n    return '<p>' + text + '</p>\\n';\n  }\n\n  table(header, body) {\n    if (body) body = '<tbody>' + body + '</tbody>';\n\n    return '<table>\\n'\n      + '<thead>\\n'\n      + header\n      + '</thead>\\n'\n      + body\n      + '</table>\\n';\n  }\n\n  tablerow(content) {\n    return '<tr>\\n' + content + '</tr>\\n';\n  }\n\n  tablecell(content, flags) {\n    const type = flags.header ? 'th' : 'td';\n    const tag = flags.align\n      ? '<' + type + ' align=\"' + flags.align + '\">'\n      : '<' + type + '>';\n    return tag + content + '</' + type + '>\\n';\n  }\n\n  // span level renderer\n  strong(text) {\n    return '<strong>' + text + '</strong>';\n  }\n\n  em(text) {\n    return '<em>' + text + '</em>';\n  }\n\n  codespan(text) {\n    return '<code>' + text + '</code>';\n  }\n\n  br() {\n    return this.options.xhtml ? '<br/>' : '<br>';\n  }\n\n  del(text) {\n    return '<del>' + text + '</del>';\n  }\n\n  link(href, title, text) {\n    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n    if (href === null) {\n      return text;\n    }\n    let out = '<a href=\"' + escape(href) + '\"';\n    if (title) {\n      out += ' title=\"' + title + '\"';\n    }\n    out += '>' + text + '</a>';\n    return out;\n  }\n\n  image(href, title, text) {\n    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n    if (href === null) {\n      return text;\n    }\n\n    let out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n    if (title) {\n      out += ' title=\"' + title + '\"';\n    }\n    out += this.options.xhtml ? '/>' : '>';\n    return out;\n  }\n\n  text(text) {\n    return text;\n  }\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/marked/src/Renderer.js?");

/***/ }),

/***/ "./node_modules/marked/src/Slugger.js":
/*!********************************************!*\
  !*** ./node_modules/marked/src/Slugger.js ***!
  \********************************************/
/***/ ((module) => {

eval("/**\n * Slugger generates header id\n */\nmodule.exports = class Slugger {\n  constructor() {\n    this.seen = {};\n  }\n\n  serialize(value) {\n    return value\n      .toLowerCase()\n      .trim()\n      // remove html tags\n      .replace(/<[!\\/a-z].*?>/ig, '')\n      // remove unwanted chars\n      .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, '')\n      .replace(/\\s/g, '-');\n  }\n\n  /**\n   * Finds the next safe (unique) slug to use\n   */\n  getNextSafeSlug(originalSlug, isDryRun) {\n    let slug = originalSlug;\n    let occurenceAccumulator = 0;\n    if (this.seen.hasOwnProperty(slug)) {\n      occurenceAccumulator = this.seen[originalSlug];\n      do {\n        occurenceAccumulator++;\n        slug = originalSlug + '-' + occurenceAccumulator;\n      } while (this.seen.hasOwnProperty(slug));\n    }\n    if (!isDryRun) {\n      this.seen[originalSlug] = occurenceAccumulator;\n      this.seen[slug] = 0;\n    }\n    return slug;\n  }\n\n  /**\n   * Convert string to unique id\n   * @param {object} options\n   * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.\n   */\n  slug(value, options = {}) {\n    const slug = this.serialize(value);\n    return this.getNextSafeSlug(slug, options.dryrun);\n  }\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/marked/src/Slugger.js?");

/***/ }),

/***/ "./node_modules/marked/src/TextRenderer.js":
/*!*************************************************!*\
  !*** ./node_modules/marked/src/TextRenderer.js ***!
  \*************************************************/
/***/ ((module) => {

eval("/**\n * TextRenderer\n * returns only the textual part of the token\n */\nmodule.exports = class TextRenderer {\n  // no need for block level renderers\n  strong(text) {\n    return text;\n  }\n\n  em(text) {\n    return text;\n  }\n\n  codespan(text) {\n    return text;\n  }\n\n  del(text) {\n    return text;\n  }\n\n  html(text) {\n    return text;\n  }\n\n  text(text) {\n    return text;\n  }\n\n  link(href, title, text) {\n    return '' + text;\n  }\n\n  image(href, title, text) {\n    return '' + text;\n  }\n\n  br() {\n    return '';\n  }\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/marked/src/TextRenderer.js?");

/***/ }),

/***/ "./node_modules/marked/src/Tokenizer.js":
/*!**********************************************!*\
  !*** ./node_modules/marked/src/Tokenizer.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { defaults } = __webpack_require__(/*! ./defaults.js */ \"./node_modules/marked/src/defaults.js\");\nconst {\n  rtrim,\n  splitCells,\n  escape,\n  findClosingBracket\n} = __webpack_require__(/*! ./helpers.js */ \"./node_modules/marked/src/helpers.js\");\n\nfunction outputLink(cap, link, raw) {\n  const href = link.href;\n  const title = link.title ? escape(link.title) : null;\n  const text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n\n  if (cap[0].charAt(0) !== '!') {\n    return {\n      type: 'link',\n      raw,\n      href,\n      title,\n      text\n    };\n  } else {\n    return {\n      type: 'image',\n      raw,\n      href,\n      title,\n      text: escape(text)\n    };\n  }\n}\n\nfunction indentCodeCompensation(raw, text) {\n  const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n\n  if (matchIndentToCode === null) {\n    return text;\n  }\n\n  const indentToCode = matchIndentToCode[1];\n\n  return text\n    .split('\\n')\n    .map(node => {\n      const matchIndentInNode = node.match(/^\\s+/);\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      const [indentInNode] = matchIndentInNode;\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    })\n    .join('\\n');\n}\n\n/**\n * Tokenizer\n */\nmodule.exports = class Tokenizer {\n  constructor(options) {\n    this.options = options || defaults;\n  }\n\n  space(src) {\n    const cap = this.rules.block.newline.exec(src);\n    if (cap) {\n      if (cap[0].length > 1) {\n        return {\n          type: 'space',\n          raw: cap[0]\n        };\n      }\n      return { raw: '\\n' };\n    }\n  }\n\n  code(src, tokens) {\n    const cap = this.rules.block.code.exec(src);\n    if (cap) {\n      const lastToken = tokens[tokens.length - 1];\n      // An indented code block cannot interrupt a paragraph.\n      if (lastToken && lastToken.type === 'paragraph') {\n        return {\n          raw: cap[0],\n          text: cap[0].trimRight()\n        };\n      }\n\n      const text = cap[0].replace(/^ {4}/gm, '');\n      return {\n        type: 'code',\n        raw: cap[0],\n        codeBlockStyle: 'indented',\n        text: !this.options.pedantic\n          ? rtrim(text, '\\n')\n          : text\n      };\n    }\n  }\n\n  fences(src) {\n    const cap = this.rules.block.fences.exec(src);\n    if (cap) {\n      const raw = cap[0];\n      const text = indentCodeCompensation(raw, cap[3] || '');\n\n      return {\n        type: 'code',\n        raw,\n        lang: cap[2] ? cap[2].trim() : cap[2],\n        text\n      };\n    }\n  }\n\n  heading(src) {\n    const cap = this.rules.block.heading.exec(src);\n    if (cap) {\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[1].length,\n        text: cap[2]\n      };\n    }\n  }\n\n  nptable(src) {\n    const cap = this.rules.block.nptable.exec(src);\n    if (cap) {\n      const item = {\n        type: 'table',\n        header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : [],\n        raw: cap[0]\n      };\n\n      if (item.header.length === item.align.length) {\n        let l = item.align.length;\n        let i;\n        for (i = 0; i < l; i++) {\n          if (/^ *-+: *$/.test(item.align[i])) {\n            item.align[i] = 'right';\n          } else if (/^ *:-+: *$/.test(item.align[i])) {\n            item.align[i] = 'center';\n          } else if (/^ *:-+ *$/.test(item.align[i])) {\n            item.align[i] = 'left';\n          } else {\n            item.align[i] = null;\n          }\n        }\n\n        l = item.cells.length;\n        for (i = 0; i < l; i++) {\n          item.cells[i] = splitCells(item.cells[i], item.header.length);\n        }\n\n        return item;\n      }\n    }\n  }\n\n  hr(src) {\n    const cap = this.rules.block.hr.exec(src);\n    if (cap) {\n      return {\n        type: 'hr',\n        raw: cap[0]\n      };\n    }\n  }\n\n  blockquote(src) {\n    const cap = this.rules.block.blockquote.exec(src);\n    if (cap) {\n      const text = cap[0].replace(/^ *> ?/gm, '');\n\n      return {\n        type: 'blockquote',\n        raw: cap[0],\n        text\n      };\n    }\n  }\n\n  list(src) {\n    const cap = this.rules.block.list.exec(src);\n    if (cap) {\n      let raw = cap[0];\n      const bull = cap[2];\n      const isordered = bull.length > 1;\n\n      const list = {\n        type: 'list',\n        raw,\n        ordered: isordered,\n        start: isordered ? +bull.slice(0, -1) : '',\n        loose: false,\n        items: []\n      };\n\n      // Get each top-level item.\n      const itemMatch = cap[0].match(this.rules.block.item);\n\n      let next = false,\n        item,\n        space,\n        bcurr,\n        bnext,\n        addBack,\n        loose,\n        istask,\n        ischecked;\n\n      let l = itemMatch.length;\n      bcurr = this.rules.block.listItemStart.exec(itemMatch[0]);\n      for (let i = 0; i < l; i++) {\n        item = itemMatch[i];\n        raw = item;\n\n        // Determine whether the next list item belongs here.\n        // Backpedal if it does not belong in this list.\n        if (i !== l - 1) {\n          bnext = this.rules.block.listItemStart.exec(itemMatch[i + 1]);\n\n          if (bnext[1].length > bcurr[0].length || bnext[1].length > 3) {\n            // nested list\n            itemMatch.splice(i, 2, itemMatch[i] + '\\n' + itemMatch[i + 1]);\n            i--;\n            l--;\n            continue;\n          } else {\n            if (\n              // different bullet style\n              !this.options.pedantic || this.options.smartLists\n                ? bnext[2][bnext[2].length - 1] !== bull[bull.length - 1]\n                : isordered === (bnext[2].length === 1)\n            ) {\n              addBack = itemMatch.slice(i + 1).join('\\n');\n              list.raw = list.raw.substring(0, list.raw.length - addBack.length);\n              i = l - 1;\n            }\n          }\n          bcurr = bnext;\n        }\n\n        // Remove the list item's bullet\n        // so it is seen as the next token.\n        space = item.length;\n        item = item.replace(/^ *([*+-]|\\d+[.)]) ?/, '');\n\n        // Outdent whatever the\n        // list item contains. Hacky.\n        if (~item.indexOf('\\n ')) {\n          space -= item.length;\n          item = !this.options.pedantic\n            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n            : item.replace(/^ {1,4}/gm, '');\n        }\n\n        // Determine whether item is loose or not.\n        // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n        // for discount behavior.\n        loose = next || /\\n\\n(?!\\s*$)/.test(item);\n        if (i !== l - 1) {\n          next = item.charAt(item.length - 1) === '\\n';\n          if (!loose) loose = next;\n        }\n\n        if (loose) {\n          list.loose = true;\n        }\n\n        // Check for task list items\n        if (this.options.gfm) {\n          istask = /^\\[[ xX]\\] /.test(item);\n          ischecked = undefined;\n          if (istask) {\n            ischecked = item[1] !== ' ';\n            item = item.replace(/^\\[[ xX]\\] +/, '');\n          }\n        }\n\n        list.items.push({\n          type: 'list_item',\n          raw,\n          task: istask,\n          checked: ischecked,\n          loose: loose,\n          text: item\n        });\n      }\n\n      return list;\n    }\n  }\n\n  html(src) {\n    const cap = this.rules.block.html.exec(src);\n    if (cap) {\n      return {\n        type: this.options.sanitize\n          ? 'paragraph'\n          : 'html',\n        raw: cap[0],\n        pre: !this.options.sanitizer\n          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n        text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]\n      };\n    }\n  }\n\n  def(src) {\n    const cap = this.rules.block.def.exec(src);\n    if (cap) {\n      if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n      const tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n      return {\n        tag,\n        raw: cap[0],\n        href: cap[2],\n        title: cap[3]\n      };\n    }\n  }\n\n  table(src) {\n    const cap = this.rules.block.table.exec(src);\n    if (cap) {\n      const item = {\n        type: 'table',\n        header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n      };\n\n      if (item.header.length === item.align.length) {\n        item.raw = cap[0];\n\n        let l = item.align.length;\n        let i;\n        for (i = 0; i < l; i++) {\n          if (/^ *-+: *$/.test(item.align[i])) {\n            item.align[i] = 'right';\n          } else if (/^ *:-+: *$/.test(item.align[i])) {\n            item.align[i] = 'center';\n          } else if (/^ *:-+ *$/.test(item.align[i])) {\n            item.align[i] = 'left';\n          } else {\n            item.align[i] = null;\n          }\n        }\n\n        l = item.cells.length;\n        for (i = 0; i < l; i++) {\n          item.cells[i] = splitCells(\n            item.cells[i].replace(/^ *\\| *| *\\| *$/g, ''),\n            item.header.length);\n        }\n\n        return item;\n      }\n    }\n  }\n\n  lheading(src) {\n    const cap = this.rules.block.lheading.exec(src);\n    if (cap) {\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[2].charAt(0) === '=' ? 1 : 2,\n        text: cap[1]\n      };\n    }\n  }\n\n  paragraph(src) {\n    const cap = this.rules.block.paragraph.exec(src);\n    if (cap) {\n      return {\n        type: 'paragraph',\n        raw: cap[0],\n        text: cap[1].charAt(cap[1].length - 1) === '\\n'\n          ? cap[1].slice(0, -1)\n          : cap[1]\n      };\n    }\n  }\n\n  text(src, tokens) {\n    const cap = this.rules.block.text.exec(src);\n    if (cap) {\n      const lastToken = tokens[tokens.length - 1];\n      if (lastToken && lastToken.type === 'text') {\n        return {\n          raw: cap[0],\n          text: cap[0]\n        };\n      }\n\n      return {\n        type: 'text',\n        raw: cap[0],\n        text: cap[0]\n      };\n    }\n  }\n\n  escape(src) {\n    const cap = this.rules.inline.escape.exec(src);\n    if (cap) {\n      return {\n        type: 'escape',\n        raw: cap[0],\n        text: escape(cap[1])\n      };\n    }\n  }\n\n  tag(src, inLink, inRawBlock) {\n    const cap = this.rules.inline.tag.exec(src);\n    if (cap) {\n      if (!inLink && /^<a /i.test(cap[0])) {\n        inLink = true;\n      } else if (inLink && /^<\\/a>/i.test(cap[0])) {\n        inLink = false;\n      }\n      if (!inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n        inRawBlock = true;\n      } else if (inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n        inRawBlock = false;\n      }\n\n      return {\n        type: this.options.sanitize\n          ? 'text'\n          : 'html',\n        raw: cap[0],\n        inLink,\n        inRawBlock,\n        text: this.options.sanitize\n          ? (this.options.sanitizer\n            ? this.options.sanitizer(cap[0])\n            : escape(cap[0]))\n          : cap[0]\n      };\n    }\n  }\n\n  link(src) {\n    const cap = this.rules.inline.link.exec(src);\n    if (cap) {\n      const lastParenIndex = findClosingBracket(cap[2], '()');\n      if (lastParenIndex > -1) {\n        const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n        const linkLen = start + cap[1].length + lastParenIndex;\n        cap[2] = cap[2].substring(0, lastParenIndex);\n        cap[0] = cap[0].substring(0, linkLen).trim();\n        cap[3] = '';\n      }\n      let href = cap[2];\n      let title = '';\n      if (this.options.pedantic) {\n        const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\n        if (link) {\n          href = link[1];\n          title = link[3];\n        } else {\n          title = '';\n        }\n      } else {\n        title = cap[3] ? cap[3].slice(1, -1) : '';\n      }\n      href = href.trim().replace(/^<([\\s\\S]*)>$/, '$1');\n      const token = outputLink(cap, {\n        href: href ? href.replace(this.rules.inline._escapes, '$1') : href,\n        title: title ? title.replace(this.rules.inline._escapes, '$1') : title\n      }, cap[0]);\n      return token;\n    }\n  }\n\n  reflink(src, links) {\n    let cap;\n    if ((cap = this.rules.inline.reflink.exec(src))\n        || (cap = this.rules.inline.nolink.exec(src))) {\n      let link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n      link = links[link.toLowerCase()];\n      if (!link || !link.href) {\n        const text = cap[0].charAt(0);\n        return {\n          type: 'text',\n          raw: text,\n          text\n        };\n      }\n      const token = outputLink(cap, link, cap[0]);\n      return token;\n    }\n  }\n\n  strong(src, maskedSrc, prevChar = '') {\n    let match = this.rules.inline.strong.start.exec(src);\n\n    if (match && (!match[1] || (match[1] && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar))))) {\n      maskedSrc = maskedSrc.slice(-1 * src.length);\n      const endReg = match[0] === '**' ? this.rules.inline.strong.endAst : this.rules.inline.strong.endUnd;\n\n      endReg.lastIndex = 0;\n\n      let cap;\n      while ((match = endReg.exec(maskedSrc)) != null) {\n        cap = this.rules.inline.strong.middle.exec(maskedSrc.slice(0, match.index + 3));\n        if (cap) {\n          return {\n            type: 'strong',\n            raw: src.slice(0, cap[0].length),\n            text: src.slice(2, cap[0].length - 2)\n          };\n        }\n      }\n    }\n  }\n\n  em(src, maskedSrc, prevChar = '') {\n    let match = this.rules.inline.em.start.exec(src);\n\n    if (match && (!match[1] || (match[1] && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar))))) {\n      maskedSrc = maskedSrc.slice(-1 * src.length);\n      const endReg = match[0] === '*' ? this.rules.inline.em.endAst : this.rules.inline.em.endUnd;\n\n      endReg.lastIndex = 0;\n\n      let cap;\n      while ((match = endReg.exec(maskedSrc)) != null) {\n        cap = this.rules.inline.em.middle.exec(maskedSrc.slice(0, match.index + 2));\n        if (cap) {\n          return {\n            type: 'em',\n            raw: src.slice(0, cap[0].length),\n            text: src.slice(1, cap[0].length - 1)\n          };\n        }\n      }\n    }\n  }\n\n  codespan(src) {\n    const cap = this.rules.inline.code.exec(src);\n    if (cap) {\n      let text = cap[2].replace(/\\n/g, ' ');\n      const hasNonSpaceChars = /[^ ]/.test(text);\n      const hasSpaceCharsOnBothEnds = text.startsWith(' ') && text.endsWith(' ');\n      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n        text = text.substring(1, text.length - 1);\n      }\n      text = escape(text, true);\n      return {\n        type: 'codespan',\n        raw: cap[0],\n        text\n      };\n    }\n  }\n\n  br(src) {\n    const cap = this.rules.inline.br.exec(src);\n    if (cap) {\n      return {\n        type: 'br',\n        raw: cap[0]\n      };\n    }\n  }\n\n  del(src) {\n    const cap = this.rules.inline.del.exec(src);\n    if (cap) {\n      return {\n        type: 'del',\n        raw: cap[0],\n        text: cap[2]\n      };\n    }\n  }\n\n  autolink(src, mangle) {\n    const cap = this.rules.inline.autolink.exec(src);\n    if (cap) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);\n        href = 'mailto:' + text;\n      } else {\n        text = escape(cap[1]);\n        href = text;\n      }\n\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text\n          }\n        ]\n      };\n    }\n  }\n\n  url(src, mangle) {\n    let cap;\n    if (cap = this.rules.inline.url.exec(src)) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);\n        href = 'mailto:' + text;\n      } else {\n        // do extended autolink path validation\n        let prevCapZero;\n        do {\n          prevCapZero = cap[0];\n          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n        } while (prevCapZero !== cap[0]);\n        text = escape(cap[0]);\n        if (cap[1] === 'www.') {\n          href = 'http://' + text;\n        } else {\n          href = text;\n        }\n      }\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text\n          }\n        ]\n      };\n    }\n  }\n\n  inlineText(src, inRawBlock, smartypants) {\n    const cap = this.rules.inline.text.exec(src);\n    if (cap) {\n      let text;\n      if (inRawBlock) {\n        text = this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0];\n      } else {\n        text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);\n      }\n      return {\n        type: 'text',\n        raw: cap[0],\n        text\n      };\n    }\n  }\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/marked/src/Tokenizer.js?");

/***/ }),

/***/ "./node_modules/marked/src/defaults.js":
/*!*********************************************!*\
  !*** ./node_modules/marked/src/defaults.js ***!
  \*********************************************/
/***/ ((module) => {

eval("function getDefaults() {\n  return {\n    baseUrl: null,\n    breaks: false,\n    gfm: true,\n    headerIds: true,\n    headerPrefix: '',\n    highlight: null,\n    langPrefix: 'language-',\n    mangle: true,\n    pedantic: false,\n    renderer: null,\n    sanitize: false,\n    sanitizer: null,\n    silent: false,\n    smartLists: false,\n    smartypants: false,\n    tokenizer: null,\n    walkTokens: null,\n    xhtml: false\n  };\n}\n\nfunction changeDefaults(newDefaults) {\n  module.exports.defaults = newDefaults;\n}\n\nmodule.exports = {\n  defaults: getDefaults(),\n  getDefaults,\n  changeDefaults\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/marked/src/defaults.js?");

/***/ }),

/***/ "./node_modules/marked/src/helpers.js":
/*!********************************************!*\
  !*** ./node_modules/marked/src/helpers.js ***!
  \********************************************/
/***/ ((module) => {

eval("/**\n * Helpers\n */\nconst escapeTest = /[&<>\"']/;\nconst escapeReplace = /[&<>\"']/g;\nconst escapeTestNoEncode = /[<>\"']|&(?!#?\\w+;)/;\nconst escapeReplaceNoEncode = /[<>\"']|&(?!#?\\w+;)/g;\nconst escapeReplacements = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;'\n};\nconst getEscapeReplacement = (ch) => escapeReplacements[ch];\nfunction escape(html, encode) {\n  if (encode) {\n    if (escapeTest.test(html)) {\n      return html.replace(escapeReplace, getEscapeReplacement);\n    }\n  } else {\n    if (escapeTestNoEncode.test(html)) {\n      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n    }\n  }\n\n  return html;\n}\n\nconst unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n\nfunction unescape(html) {\n  // explicitly match decimal, hex, and named HTML entities\n  return html.replace(unescapeTest, (_, n) => {\n    n = n.toLowerCase();\n    if (n === 'colon') return ':';\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n    return '';\n  });\n}\n\nconst caret = /(^|[^\\[])\\^/g;\nfunction edit(regex, opt) {\n  regex = regex.source || regex;\n  opt = opt || '';\n  const obj = {\n    replace: (name, val) => {\n      val = val.source || val;\n      val = val.replace(caret, '$1');\n      regex = regex.replace(name, val);\n      return obj;\n    },\n    getRegex: () => {\n      return new RegExp(regex, opt);\n    }\n  };\n  return obj;\n}\n\nconst nonWordAndColonTest = /[^\\w:]/g;\nconst originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\nfunction cleanUrl(sanitize, base, href) {\n  if (sanitize) {\n    let prot;\n    try {\n      prot = decodeURIComponent(unescape(href))\n        .replace(nonWordAndColonTest, '')\n        .toLowerCase();\n    } catch (e) {\n      return null;\n    }\n    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n      return null;\n    }\n  }\n  if (base && !originIndependentUrl.test(href)) {\n    href = resolveUrl(base, href);\n  }\n  try {\n    href = encodeURI(href).replace(/%25/g, '%');\n  } catch (e) {\n    return null;\n  }\n  return href;\n}\n\nconst baseUrls = {};\nconst justDomain = /^[^:]+:\\/*[^/]*$/;\nconst protocol = /^([^:]+:)[\\s\\S]*$/;\nconst domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\n\nfunction resolveUrl(base, href) {\n  if (!baseUrls[' ' + base]) {\n    // we can ignore everything in base after the last slash of its path component,\n    // but we might need to add _that_\n    // https://tools.ietf.org/html/rfc3986#section-3\n    if (justDomain.test(base)) {\n      baseUrls[' ' + base] = base + '/';\n    } else {\n      baseUrls[' ' + base] = rtrim(base, '/', true);\n    }\n  }\n  base = baseUrls[' ' + base];\n  const relativeBase = base.indexOf(':') === -1;\n\n  if (href.substring(0, 2) === '//') {\n    if (relativeBase) {\n      return href;\n    }\n    return base.replace(protocol, '$1') + href;\n  } else if (href.charAt(0) === '/') {\n    if (relativeBase) {\n      return href;\n    }\n    return base.replace(domain, '$1') + href;\n  } else {\n    return base + href;\n  }\n}\n\nconst noopTest = { exec: function noopTest() {} };\n\nfunction merge(obj) {\n  let i = 1,\n    target,\n    key;\n\n  for (; i < arguments.length; i++) {\n    target = arguments[i];\n    for (key in target) {\n      if (Object.prototype.hasOwnProperty.call(target, key)) {\n        obj[key] = target[key];\n      }\n    }\n  }\n\n  return obj;\n}\n\nfunction splitCells(tableRow, count) {\n  // ensure that every cell-delimiting pipe has a space\n  // before it to distinguish it from an escaped pipe\n  const row = tableRow.replace(/\\|/g, (match, offset, str) => {\n      let escaped = false,\n        curr = offset;\n      while (--curr >= 0 && str[curr] === '\\\\') escaped = !escaped;\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n    cells = row.split(/ \\|/);\n  let i = 0;\n\n  if (cells.length > count) {\n    cells.splice(count);\n  } else {\n    while (cells.length < count) cells.push('');\n  }\n\n  for (; i < cells.length; i++) {\n    // leading or trailing whitespace is ignored per the gfm spec\n    cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n  }\n  return cells;\n}\n\n// Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n// /c*$/ is vulnerable to REDOS.\n// invert: Remove suffix of non-c chars instead. Default falsey.\nfunction rtrim(str, c, invert) {\n  const l = str.length;\n  if (l === 0) {\n    return '';\n  }\n\n  // Length of suffix matching the invert condition.\n  let suffLen = 0;\n\n  // Step left until we fail to match the invert condition.\n  while (suffLen < l) {\n    const currChar = str.charAt(l - suffLen - 1);\n    if (currChar === c && !invert) {\n      suffLen++;\n    } else if (currChar !== c && invert) {\n      suffLen++;\n    } else {\n      break;\n    }\n  }\n\n  return str.substr(0, l - suffLen);\n}\n\nfunction findClosingBracket(str, b) {\n  if (str.indexOf(b[1]) === -1) {\n    return -1;\n  }\n  const l = str.length;\n  let level = 0,\n    i = 0;\n  for (; i < l; i++) {\n    if (str[i] === '\\\\') {\n      i++;\n    } else if (str[i] === b[0]) {\n      level++;\n    } else if (str[i] === b[1]) {\n      level--;\n      if (level < 0) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n\nfunction checkSanitizeDeprecation(opt) {\n  if (opt && opt.sanitize && !opt.silent) {\n    console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');\n  }\n}\n\n// copied from https://stackoverflow.com/a/5450113/806777\nfunction repeatString(pattern, count) {\n  if (count < 1) {\n    return '';\n  }\n  let result = '';\n  while (count > 1) {\n    if (count & 1) {\n      result += pattern;\n    }\n    count >>= 1;\n    pattern += pattern;\n  }\n  return result + pattern;\n}\n\nmodule.exports = {\n  escape,\n  unescape,\n  edit,\n  cleanUrl,\n  resolveUrl,\n  noopTest,\n  merge,\n  splitCells,\n  rtrim,\n  findClosingBracket,\n  checkSanitizeDeprecation,\n  repeatString\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/marked/src/helpers.js?");

/***/ }),

/***/ "./node_modules/marked/src/marked.js":
/*!*******************************************!*\
  !*** ./node_modules/marked/src/marked.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Lexer = __webpack_require__(/*! ./Lexer.js */ \"./node_modules/marked/src/Lexer.js\");\nconst Parser = __webpack_require__(/*! ./Parser.js */ \"./node_modules/marked/src/Parser.js\");\nconst Tokenizer = __webpack_require__(/*! ./Tokenizer.js */ \"./node_modules/marked/src/Tokenizer.js\");\nconst Renderer = __webpack_require__(/*! ./Renderer.js */ \"./node_modules/marked/src/Renderer.js\");\nconst TextRenderer = __webpack_require__(/*! ./TextRenderer.js */ \"./node_modules/marked/src/TextRenderer.js\");\nconst Slugger = __webpack_require__(/*! ./Slugger.js */ \"./node_modules/marked/src/Slugger.js\");\nconst {\n  merge,\n  checkSanitizeDeprecation,\n  escape\n} = __webpack_require__(/*! ./helpers.js */ \"./node_modules/marked/src/helpers.js\");\nconst {\n  getDefaults,\n  changeDefaults,\n  defaults\n} = __webpack_require__(/*! ./defaults.js */ \"./node_modules/marked/src/defaults.js\");\n\n/**\n * Marked\n */\nfunction marked(src, opt, callback) {\n  // throw error in case of non string input\n  if (typeof src === 'undefined' || src === null) {\n    throw new Error('marked(): input parameter is undefined or null');\n  }\n  if (typeof src !== 'string') {\n    throw new Error('marked(): input parameter is of type '\n      + Object.prototype.toString.call(src) + ', string expected');\n  }\n\n  if (typeof opt === 'function') {\n    callback = opt;\n    opt = null;\n  }\n\n  opt = merge({}, marked.defaults, opt || {});\n  checkSanitizeDeprecation(opt);\n\n  if (callback) {\n    const highlight = opt.highlight;\n    let tokens;\n\n    try {\n      tokens = Lexer.lex(src, opt);\n    } catch (e) {\n      return callback(e);\n    }\n\n    const done = function(err) {\n      let out;\n\n      if (!err) {\n        try {\n          out = Parser.parse(tokens, opt);\n        } catch (e) {\n          err = e;\n        }\n      }\n\n      opt.highlight = highlight;\n\n      return err\n        ? callback(err)\n        : callback(null, out);\n    };\n\n    if (!highlight || highlight.length < 3) {\n      return done();\n    }\n\n    delete opt.highlight;\n\n    if (!tokens.length) return done();\n\n    let pending = 0;\n    marked.walkTokens(tokens, function(token) {\n      if (token.type === 'code') {\n        pending++;\n        setTimeout(() => {\n          highlight(token.text, token.lang, function(err, code) {\n            if (err) {\n              return done(err);\n            }\n            if (code != null && code !== token.text) {\n              token.text = code;\n              token.escaped = true;\n            }\n\n            pending--;\n            if (pending === 0) {\n              done();\n            }\n          });\n        }, 0);\n      }\n    });\n\n    if (pending === 0) {\n      done();\n    }\n\n    return;\n  }\n\n  try {\n    const tokens = Lexer.lex(src, opt);\n    if (opt.walkTokens) {\n      marked.walkTokens(tokens, opt.walkTokens);\n    }\n    return Parser.parse(tokens, opt);\n  } catch (e) {\n    e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n    if (opt.silent) {\n      return '<p>An error occurred:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n    }\n    throw e;\n  }\n}\n\n/**\n * Options\n */\n\nmarked.options =\nmarked.setOptions = function(opt) {\n  merge(marked.defaults, opt);\n  changeDefaults(marked.defaults);\n  return marked;\n};\n\nmarked.getDefaults = getDefaults;\n\nmarked.defaults = defaults;\n\n/**\n * Use Extension\n */\n\nmarked.use = function(extension) {\n  const opts = merge({}, extension);\n  if (extension.renderer) {\n    const renderer = marked.defaults.renderer || new Renderer();\n    for (const prop in extension.renderer) {\n      const prevRenderer = renderer[prop];\n      renderer[prop] = (...args) => {\n        let ret = extension.renderer[prop].apply(renderer, args);\n        if (ret === false) {\n          ret = prevRenderer.apply(renderer, args);\n        }\n        return ret;\n      };\n    }\n    opts.renderer = renderer;\n  }\n  if (extension.tokenizer) {\n    const tokenizer = marked.defaults.tokenizer || new Tokenizer();\n    for (const prop in extension.tokenizer) {\n      const prevTokenizer = tokenizer[prop];\n      tokenizer[prop] = (...args) => {\n        let ret = extension.tokenizer[prop].apply(tokenizer, args);\n        if (ret === false) {\n          ret = prevTokenizer.apply(tokenizer, args);\n        }\n        return ret;\n      };\n    }\n    opts.tokenizer = tokenizer;\n  }\n  if (extension.walkTokens) {\n    const walkTokens = marked.defaults.walkTokens;\n    opts.walkTokens = (token) => {\n      extension.walkTokens(token);\n      if (walkTokens) {\n        walkTokens(token);\n      }\n    };\n  }\n  marked.setOptions(opts);\n};\n\n/**\n * Run callback for every token\n */\n\nmarked.walkTokens = function(tokens, callback) {\n  for (const token of tokens) {\n    callback(token);\n    switch (token.type) {\n      case 'table': {\n        for (const cell of token.tokens.header) {\n          marked.walkTokens(cell, callback);\n        }\n        for (const row of token.tokens.cells) {\n          for (const cell of row) {\n            marked.walkTokens(cell, callback);\n          }\n        }\n        break;\n      }\n      case 'list': {\n        marked.walkTokens(token.items, callback);\n        break;\n      }\n      default: {\n        if (token.tokens) {\n          marked.walkTokens(token.tokens, callback);\n        }\n      }\n    }\n  }\n};\n\n/**\n * Parse Inline\n */\nmarked.parseInline = function(src, opt) {\n  // throw error in case of non string input\n  if (typeof src === 'undefined' || src === null) {\n    throw new Error('marked.parseInline(): input parameter is undefined or null');\n  }\n  if (typeof src !== 'string') {\n    throw new Error('marked.parseInline(): input parameter is of type '\n      + Object.prototype.toString.call(src) + ', string expected');\n  }\n\n  opt = merge({}, marked.defaults, opt || {});\n  checkSanitizeDeprecation(opt);\n\n  try {\n    const tokens = Lexer.lexInline(src, opt);\n    if (opt.walkTokens) {\n      marked.walkTokens(tokens, opt.walkTokens);\n    }\n    return Parser.parseInline(tokens, opt);\n  } catch (e) {\n    e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n    if (opt.silent) {\n      return '<p>An error occurred:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n    }\n    throw e;\n  }\n};\n\n/**\n * Expose\n */\n\nmarked.Parser = Parser;\nmarked.parser = Parser.parse;\n\nmarked.Renderer = Renderer;\nmarked.TextRenderer = TextRenderer;\n\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\n\nmarked.Tokenizer = Tokenizer;\n\nmarked.Slugger = Slugger;\n\nmarked.parse = marked;\n\nmodule.exports = marked;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/marked/src/marked.js?");

/***/ }),

/***/ "./node_modules/marked/src/rules.js":
/*!******************************************!*\
  !*** ./node_modules/marked/src/rules.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {\n  noopTest,\n  edit,\n  merge\n} = __webpack_require__(/*! ./helpers.js */ \"./node_modules/marked/src/helpers.js\");\n\n/**\n * Block-Level Grammar\n */\nconst block = {\n  newline: /^\\n+/,\n  code: /^( {4}[^\\n]+\\n*)+/,\n  fences: /^ {0,3}(`{3,}(?=[^`\\n]*\\n)|~{3,})([^\\n]*)\\n(?:|([\\s\\S]*?)\\n)(?: {0,3}\\1[~`]* *(?:\\n+|$)|$)/,\n  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)/,\n  heading: /^ {0,3}(#{1,6}) +([^\\n]*?)(?: +#+)? *(?:\\n+|$)/,\n  blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n  list: /^( {0,3})(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?! {0,3}bull )\\n*|\\s*$)/,\n  html: '^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (6)\n    + '|<(?!script|pre|style)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (7) open tag\n    + '|</(?!script|pre|style)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (7) closing tag\n    + ')',\n  def: /^ {0,3}\\[(label)\\]: *\\n? *<?([^\\s>]+)>?(?:(?: +\\n? *| *\\n *)(title))? *(?:\\n+|$)/,\n  nptable: noopTest,\n  table: noopTest,\n  lheading: /^([^\\n]+)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n  // regex template, placeholders will be replaced according to different paragraph\n  // interruption rules of commonmark and the original markdown spec:\n  _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\\n]+)*)/,\n  text: /^[^\\n]+/\n};\n\nblock._label = /(?!\\s*\\])(?:\\\\[\\[\\]]|[^\\[\\]])+/;\nblock._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\nblock.def = edit(block.def)\n  .replace('label', block._label)\n  .replace('title', block._title)\n  .getRegex();\n\nblock.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nblock.item = /^( *)(bull) ?[^\\n]*(?:\\n(?! *bull ?)[^\\n]*)*/;\nblock.item = edit(block.item, 'gm')\n  .replace(/bull/g, block.bullet)\n  .getRegex();\n\nblock.listItemStart = edit(/^( *)(bull)/)\n  .replace('bull', block.bullet)\n  .getRegex();\n\nblock.list = edit(block.list)\n  .replace(/bull/g, block.bullet)\n  .replace('hr', '\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))')\n  .replace('def', '\\\\n+(?=' + block.def.source + ')')\n  .getRegex();\n\nblock._tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n  + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'\n  + '|track|ul';\nblock._comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\nblock.html = edit(block.html, 'i')\n  .replace('comment', block._comment)\n  .replace('tag', block._tag)\n  .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n  .getRegex();\n\nblock.paragraph = edit(block._paragraph)\n  .replace('hr', block.hr)\n  .replace('heading', ' {0,3}#{1,6} ')\n  .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n  .replace('blockquote', ' {0,3}>')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|!--)')\n  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n\nblock.blockquote = edit(block.blockquote)\n  .replace('paragraph', block.paragraph)\n  .getRegex();\n\n/**\n * Normal Block Grammar\n */\n\nblock.normal = merge({}, block);\n\n/**\n * GFM Block Grammar\n */\n\nblock.gfm = merge({}, block.normal, {\n  nptable: '^ *([^|\\\\n ].*\\\\|.*)\\\\n' // Header\n    + ' {0,3}([-:]+ *\\\\|[-| :]*)' // Align\n    + '(?:\\\\n((?:(?!\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)', // Cells\n  table: '^ *\\\\|(.+)\\\\n' // Header\n    + ' {0,3}\\\\|?( *[-:]+[-| :]*)' // Align\n    + '(?:\\\\n *((?:(?!\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)' // Cells\n});\n\nblock.gfm.nptable = edit(block.gfm.nptable)\n  .replace('hr', block.hr)\n  .replace('heading', ' {0,3}#{1,6} ')\n  .replace('blockquote', ' {0,3}>')\n  .replace('code', ' {4}[^\\\\n]')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|!--)')\n  .replace('tag', block._tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n\nblock.gfm.table = edit(block.gfm.table)\n  .replace('hr', block.hr)\n  .replace('heading', ' {0,3}#{1,6} ')\n  .replace('blockquote', ' {0,3}>')\n  .replace('code', ' {4}[^\\\\n]')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|!--)')\n  .replace('tag', block._tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\n\nblock.pedantic = merge({}, block.normal, {\n  html: edit(\n    '^ *(?:comment *(?:\\\\n|\\\\s*$)'\n    + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n    .replace('comment', block._comment)\n    .replace(/tag/g, '(?!(?:'\n      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n      + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n    .getRegex(),\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n  heading: /^ *(#{1,6}) *([^\\n]+?) *(?:#+ *)?(?:\\n+|$)/,\n  fences: noopTest, // fences not supported\n  paragraph: edit(block.normal._paragraph)\n    .replace('hr', block.hr)\n    .replace('heading', ' *#{1,6} *[^\\n]')\n    .replace('lheading', block.lheading)\n    .replace('blockquote', ' {0,3}>')\n    .replace('|fences', '')\n    .replace('|list', '')\n    .replace('|html', '')\n    .getRegex()\n});\n\n/**\n * Inline-Level Grammar\n */\nconst inline = {\n  escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n  autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n  url: noopTest,\n  tag: '^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>', // CDATA section\n  link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n  reflink: /^!?\\[(label)\\]\\[(?!\\s*\\])((?:\\\\[\\[\\]]?|[^\\[\\]\\\\])+)\\]/,\n  nolink: /^!?\\[(?!\\s*\\])((?:\\[[^\\[\\]]*\\]|\\\\[\\[\\]]|[^\\[\\]])*)\\](?:\\[\\])?/,\n  reflinkSearch: 'reflink|nolink(?!\\\\()',\n  strong: {\n    start: /^(?:(\\*\\*(?=[*punctuation]))|\\*\\*)(?![\\s])|__/, // (1) returns if starts w/ punctuation\n    middle: /^\\*\\*(?:(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)|\\*(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)*?\\*)+?\\*\\*$|^__(?![\\s])((?:(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)*?_)+?)__$/,\n    endAst: /[^punctuation\\s]\\*\\*(?!\\*)|[punctuation]\\*\\*(?!\\*)(?:(?=[punctuation_\\s]|$))/, // last char can't be punct, or final * must also be followed by punct (or endline)\n    endUnd: /[^\\s]__(?!_)(?:(?=[punctuation*\\s])|$)/ // last char can't be a space, and final _ must preceed punct or \\s (or endline)\n  },\n  em: {\n    start: /^(?:(\\*(?=[punctuation]))|\\*)(?![*\\s])|_/, // (1) returns if starts w/ punctuation\n    middle: /^\\*(?:(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)|\\*(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)*?\\*)+?\\*$|^_(?![_\\s])(?:(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)*?_)+?_$/,\n    endAst: /[^punctuation\\s]\\*(?!\\*)|[punctuation]\\*(?!\\*)(?:(?=[punctuation_\\s]|$))/, // last char can't be punct, or final * must also be followed by punct (or endline)\n    endUnd: /[^\\s]_(?!_)(?:(?=[punctuation*\\s])|$)/ // last char can't be a space, and final _ must preceed punct or \\s (or endline)\n  },\n  code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n  br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n  del: noopTest,\n  text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n  punctuation: /^([\\s*punctuation])/\n};\n\n// list of punctuation marks from common mark spec\n// without * and _ to workaround cases with double emphasis\ninline._punctuation = '!\"#$%&\\'()+\\\\-.,/:;<=>?@\\\\[\\\\]`^{|}~';\ninline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();\n\n// sequences em should skip over [title](link), `code`, <html>\ninline._blockSkip = '\\\\[[^\\\\]]*?\\\\]\\\\([^\\\\)]*?\\\\)|`[^`]*?`|<[^>]*?>';\ninline._overlapSkip = '__[^_]*?__|\\\\*\\\\*\\\\[^\\\\*\\\\]*?\\\\*\\\\*';\n\ninline._comment = edit(block._comment).replace('(?:-->|$)', '-->').getRegex();\n\ninline.em.start = edit(inline.em.start)\n  .replace(/punctuation/g, inline._punctuation)\n  .getRegex();\n\ninline.em.middle = edit(inline.em.middle)\n  .replace(/punctuation/g, inline._punctuation)\n  .replace(/overlapSkip/g, inline._overlapSkip)\n  .getRegex();\n\ninline.em.endAst = edit(inline.em.endAst, 'g')\n  .replace(/punctuation/g, inline._punctuation)\n  .getRegex();\n\ninline.em.endUnd = edit(inline.em.endUnd, 'g')\n  .replace(/punctuation/g, inline._punctuation)\n  .getRegex();\n\ninline.strong.start = edit(inline.strong.start)\n  .replace(/punctuation/g, inline._punctuation)\n  .getRegex();\n\ninline.strong.middle = edit(inline.strong.middle)\n  .replace(/punctuation/g, inline._punctuation)\n  .replace(/overlapSkip/g, inline._overlapSkip)\n  .getRegex();\n\ninline.strong.endAst = edit(inline.strong.endAst, 'g')\n  .replace(/punctuation/g, inline._punctuation)\n  .getRegex();\n\ninline.strong.endUnd = edit(inline.strong.endUnd, 'g')\n  .replace(/punctuation/g, inline._punctuation)\n  .getRegex();\n\ninline.blockSkip = edit(inline._blockSkip, 'g')\n  .getRegex();\n\ninline.overlapSkip = edit(inline._overlapSkip, 'g')\n  .getRegex();\n\ninline._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\n\ninline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\ninline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\ninline.autolink = edit(inline.autolink)\n  .replace('scheme', inline._scheme)\n  .replace('email', inline._email)\n  .getRegex();\n\ninline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\n\ninline.tag = edit(inline.tag)\n  .replace('comment', inline._comment)\n  .replace('attribute', inline._attribute)\n  .getRegex();\n\ninline._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\ninline._href = /<(?:\\\\[<>]?|[^\\s<>\\\\])*>|[^\\s\\x00-\\x1f]*/;\ninline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\n\ninline.link = edit(inline.link)\n  .replace('label', inline._label)\n  .replace('href', inline._href)\n  .replace('title', inline._title)\n  .getRegex();\n\ninline.reflink = edit(inline.reflink)\n  .replace('label', inline._label)\n  .getRegex();\n\ninline.reflinkSearch = edit(inline.reflinkSearch, 'g')\n  .replace('reflink', inline.reflink)\n  .replace('nolink', inline.nolink)\n  .getRegex();\n\n/**\n * Normal Inline Grammar\n */\n\ninline.normal = merge({}, inline);\n\n/**\n * Pedantic Inline Grammar\n */\n\ninline.pedantic = merge({}, inline.normal, {\n  strong: {\n    start: /^__|\\*\\*/,\n    middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n    endAst: /\\*\\*(?!\\*)/g,\n    endUnd: /__(?!_)/g\n  },\n  em: {\n    start: /^_|\\*/,\n    middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n    endAst: /\\*(?!\\*)/g,\n    endUnd: /_(?!_)/g\n  },\n  link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n    .replace('label', inline._label)\n    .getRegex(),\n  reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n    .replace('label', inline._label)\n    .getRegex()\n});\n\n/**\n * GFM Inline Grammar\n */\n\ninline.gfm = merge({}, inline.normal, {\n  escape: edit(inline.escape).replace('])', '~|])').getRegex(),\n  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n  url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n  _backpedal: /(?:[^?!.,:;*_~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,\n  del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n  text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@))|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@))/\n});\n\ninline.gfm.url = edit(inline.gfm.url, 'i')\n  .replace('email', inline.gfm._extended_email)\n  .getRegex();\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\ninline.breaks = merge({}, inline.gfm, {\n  br: edit(inline.br).replace('{2,}', '*').getRegex(),\n  text: edit(inline.gfm.text)\n    .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n    .replace(/\\{2,\\}/g, '*')\n    .getRegex()\n});\n\nmodule.exports = {\n  block,\n  inline\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/marked/src/rules.js?");

/***/ }),

/***/ "./node_modules/minimatch/minimatch.js":
/*!*********************************************!*\
  !*** ./node_modules/minimatch/minimatch.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = __webpack_require__(/*! path */ \"path\")\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = __webpack_require__(/*! brace-expansion */ \"./node_modules/brace-expansion/index.js\")\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/minimatch/minimatch.js?");

/***/ }),

/***/ "./node_modules/minimist/index.js":
/*!****************************************!*\
  !*** ./node_modules/minimist/index.js ***!
  \****************************************/
/***/ ((module) => {

eval("module.exports = function (args, opts) {\n    if (!opts) opts = {};\n    \n    var flags = { bools : {}, strings : {}, unknownFn: null };\n\n    if (typeof opts['unknown'] === 'function') {\n        flags.unknownFn = opts['unknown'];\n    }\n\n    if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {\n      flags.allBools = true;\n    } else {\n      [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {\n          flags.bools[key] = true;\n      });\n    }\n    \n    var aliases = {};\n    Object.keys(opts.alias || {}).forEach(function (key) {\n        aliases[key] = [].concat(opts.alias[key]);\n        aliases[key].forEach(function (x) {\n            aliases[x] = [key].concat(aliases[key].filter(function (y) {\n                return x !== y;\n            }));\n        });\n    });\n\n    [].concat(opts.string).filter(Boolean).forEach(function (key) {\n        flags.strings[key] = true;\n        if (aliases[key]) {\n            flags.strings[aliases[key]] = true;\n        }\n     });\n\n    var defaults = opts['default'] || {};\n    \n    var argv = { _ : [] };\n    Object.keys(flags.bools).forEach(function (key) {\n        setArg(key, defaults[key] === undefined ? false : defaults[key]);\n    });\n    \n    var notFlags = [];\n\n    if (args.indexOf('--') !== -1) {\n        notFlags = args.slice(args.indexOf('--')+1);\n        args = args.slice(0, args.indexOf('--'));\n    }\n\n    function argDefined(key, arg) {\n        return (flags.allBools && /^--[^=]+$/.test(arg)) ||\n            flags.strings[key] || flags.bools[key] || aliases[key];\n    }\n\n    function setArg (key, val, arg) {\n        if (arg && flags.unknownFn && !argDefined(key, arg)) {\n            if (flags.unknownFn(arg) === false) return;\n        }\n\n        var value = !flags.strings[key] && isNumber(val)\n            ? Number(val) : val\n        ;\n        setKey(argv, key.split('.'), value);\n        \n        (aliases[key] || []).forEach(function (x) {\n            setKey(argv, x.split('.'), value);\n        });\n    }\n\n    function setKey (obj, keys, value) {\n        var o = obj;\n        for (var i = 0; i < keys.length-1; i++) {\n            var key = keys[i];\n            if (key === '__proto__') return;\n            if (o[key] === undefined) o[key] = {};\n            if (o[key] === Object.prototype || o[key] === Number.prototype\n                || o[key] === String.prototype) o[key] = {};\n            if (o[key] === Array.prototype) o[key] = [];\n            o = o[key];\n        }\n\n        var key = keys[keys.length - 1];\n        if (key === '__proto__') return;\n        if (o === Object.prototype || o === Number.prototype\n            || o === String.prototype) o = {};\n        if (o === Array.prototype) o = [];\n        if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {\n            o[key] = value;\n        }\n        else if (Array.isArray(o[key])) {\n            o[key].push(value);\n        }\n        else {\n            o[key] = [ o[key], value ];\n        }\n    }\n    \n    function aliasIsBoolean(key) {\n      return aliases[key].some(function (x) {\n          return flags.bools[x];\n      });\n    }\n\n    for (var i = 0; i < args.length; i++) {\n        var arg = args[i];\n        \n        if (/^--.+=/.test(arg)) {\n            // Using [\\s\\S] instead of . because js doesn't support the\n            // 'dotall' regex modifier. See:\n            // http://stackoverflow.com/a/1068308/13216\n            var m = arg.match(/^--([^=]+)=([\\s\\S]*)$/);\n            var key = m[1];\n            var value = m[2];\n            if (flags.bools[key]) {\n                value = value !== 'false';\n            }\n            setArg(key, value, arg);\n        }\n        else if (/^--no-.+/.test(arg)) {\n            var key = arg.match(/^--no-(.+)/)[1];\n            setArg(key, false, arg);\n        }\n        else if (/^--.+/.test(arg)) {\n            var key = arg.match(/^--(.+)/)[1];\n            var next = args[i + 1];\n            if (next !== undefined && !/^-/.test(next)\n            && !flags.bools[key]\n            && !flags.allBools\n            && (aliases[key] ? !aliasIsBoolean(key) : true)) {\n                setArg(key, next, arg);\n                i++;\n            }\n            else if (/^(true|false)$/.test(next)) {\n                setArg(key, next === 'true', arg);\n                i++;\n            }\n            else {\n                setArg(key, flags.strings[key] ? '' : true, arg);\n            }\n        }\n        else if (/^-[^-]+/.test(arg)) {\n            var letters = arg.slice(1,-1).split('');\n            \n            var broken = false;\n            for (var j = 0; j < letters.length; j++) {\n                var next = arg.slice(j+2);\n                \n                if (next === '-') {\n                    setArg(letters[j], next, arg)\n                    continue;\n                }\n                \n                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {\n                    setArg(letters[j], next.split('=')[1], arg);\n                    broken = true;\n                    break;\n                }\n                \n                if (/[A-Za-z]/.test(letters[j])\n                && /-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\n                    setArg(letters[j], next, arg);\n                    broken = true;\n                    break;\n                }\n                \n                if (letters[j+1] && letters[j+1].match(/\\W/)) {\n                    setArg(letters[j], arg.slice(j+2), arg);\n                    broken = true;\n                    break;\n                }\n                else {\n                    setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);\n                }\n            }\n            \n            var key = arg.slice(-1)[0];\n            if (!broken && key !== '-') {\n                if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])\n                && !flags.bools[key]\n                && (aliases[key] ? !aliasIsBoolean(key) : true)) {\n                    setArg(key, args[i+1], arg);\n                    i++;\n                }\n                else if (args[i+1] && /^(true|false)$/.test(args[i+1])) {\n                    setArg(key, args[i+1] === 'true', arg);\n                    i++;\n                }\n                else {\n                    setArg(key, flags.strings[key] ? '' : true, arg);\n                }\n            }\n        }\n        else {\n            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {\n                argv._.push(\n                    flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)\n                );\n            }\n            if (opts.stopEarly) {\n                argv._.push.apply(argv._, args.slice(i + 1));\n                break;\n            }\n        }\n    }\n    \n    Object.keys(defaults).forEach(function (key) {\n        if (!hasKey(argv, key.split('.'))) {\n            setKey(argv, key.split('.'), defaults[key]);\n            \n            (aliases[key] || []).forEach(function (x) {\n                setKey(argv, x.split('.'), defaults[key]);\n            });\n        }\n    });\n    \n    if (opts['--']) {\n        argv['--'] = new Array();\n        notFlags.forEach(function(key) {\n            argv['--'].push(key);\n        });\n    }\n    else {\n        notFlags.forEach(function(key) {\n            argv._.push(key);\n        });\n    }\n\n    return argv;\n};\n\nfunction hasKey (obj, keys) {\n    var o = obj;\n    keys.slice(0,-1).forEach(function (key) {\n        o = (o[key] || {});\n    });\n\n    var key = keys[keys.length - 1];\n    return key in o;\n}\n\nfunction isNumber (x) {\n    if (typeof x === 'number') return true;\n    if (/^0x[0-9a-f]+$/i.test(x)) return true;\n    return /^[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x);\n}\n\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/minimist/index.js?");

/***/ }),

/***/ "./node_modules/minipass/index.js":
/*!****************************************!*\
  !*** ./node_modules/minipass/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst EE = __webpack_require__(/*! events */ \"events\")\nconst Stream = __webpack_require__(/*! stream */ \"stream\")\nconst Yallist = __webpack_require__(/*! yallist */ \"./node_modules/yallist/yallist.js\")\nconst SD = __webpack_require__(/*! string_decoder */ \"string_decoder\").StringDecoder\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\nconst DESTROYED = Symbol('destroyed')\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator\n  || Symbol('asyncIterator not implemented')\nconst ITERATOR = doIter && Symbol.iterator\n  || Symbol('iterator not implemented')\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev =>\n  ev === 'end' ||\n  ev === 'finish' ||\n  ev === 'prefinish'\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer ||\n  typeof b === 'object' &&\n  b.constructor &&\n  b.constructor.name === 'ArrayBuffer' &&\n  b.byteLength >= 0\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\nmodule.exports = class Minipass extends Stream {\n  constructor (options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this.pipes = new Yallist()\n    this.buffer = new Yallist()\n    this[OBJECTMODE] = options && options.objectMode || false\n    if (this[OBJECTMODE])\n      this[ENCODING] = null\n    else\n      this[ENCODING] = options && options.encoding || null\n    if (this[ENCODING] === 'buffer')\n      this[ENCODING] = null\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n  }\n\n  get bufferLength () { return this[BUFFERLENGTH] }\n\n  get encoding () { return this[ENCODING] }\n  set encoding (enc) {\n    if (this[OBJECTMODE])\n      throw new Error('cannot set encoding in objectMode')\n\n    if (this[ENCODING] && enc !== this[ENCODING] &&\n        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this.buffer.length)\n        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding (enc) {\n    this.encoding = enc\n  }\n\n  get objectMode () { return this[OBJECTMODE] }\n  set objectMode ( ) { this[OBJECTMODE] = this[OBJECTMODE] || !!  }\n\n  write (chunk, encoding, cb) {\n    if (this[EOF])\n      throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(\n        new Error('Cannot call write after a stream was destroyed'),\n        { code: 'ERR_STREAM_DESTROYED' }\n      ))\n      return true\n    }\n\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (!encoding)\n      encoding = 'utf8'\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk))\n        chunk = Buffer.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // this ensures at this point that the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!this.objectMode && !chunk.length) {\n      const ret = this.flowing\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        cb()\n      return ret\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' && !this[OBJECTMODE] &&\n        // unless it is a string already ready for us to use\n        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    try {\n      return this.flowing\n        ? (this.emit('data', chunk), this.flowing)\n        : (this[BUFFERPUSH](chunk), false)\n    } finally {\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        cb()\n    }\n  }\n\n  read (n) {\n    if (this[DESTROYED])\n      return null\n\n    try {\n      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])\n        return null\n\n      if (this[OBJECTMODE])\n        n = null\n\n      if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n        if (this.encoding)\n          this.buffer = new Yallist([\n            Array.from(this.buffer).join('')\n          ])\n        else\n          this.buffer = new Yallist([\n            Buffer.concat(Array.from(this.buffer), this[BUFFERLENGTH])\n          ])\n      }\n\n      return this[READ](n || null, this.buffer.head.value)\n    } finally {\n      this[MAYBE_EMIT_END]()\n    }\n  }\n\n  [READ] (n, chunk) {\n    if (n === chunk.length || n === null)\n      this[BUFFERSHIFT]()\n    else {\n      this.buffer.head.value = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n\n    return chunk\n  }\n\n  end (chunk, encoding, cb) {\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED])\n      this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME] () {\n    if (this[DESTROYED])\n      return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this.buffer.length)\n      this[FLUSH]()\n    else if (this[EOF])\n      this[MAYBE_EMIT_END]()\n    else\n      this.emit('drain')\n  }\n\n  resume () {\n    return this[RESUME]()\n  }\n\n  pause () {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed () {\n    return this[DESTROYED]\n  }\n\n  get flowing () {\n    return this[FLOWING]\n  }\n\n  get paused () {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH] (chunk) {\n    if (this[OBJECTMODE])\n      this[BUFFERLENGTH] += 1\n    else\n      this[BUFFERLENGTH] += chunk.length\n    return this.buffer.push(chunk)\n  }\n\n  [BUFFERSHIFT] () {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE])\n        this[BUFFERLENGTH] -= 1\n      else\n        this[BUFFERLENGTH] -= this.buffer.head.value.length\n    }\n    return this.buffer.shift()\n  }\n\n  [FLUSH] () {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n  }\n\n  [FLUSHCHUNK] (chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\n  }\n\n  pipe (dest, opts) {\n    if (this[DESTROYED])\n      return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === process.stdout || dest === process.stderr)\n      opts.end = false\n    else\n      opts.end = opts.end !== false\n\n    const p = { dest: dest, opts: opts, ondrain: _ => this[RESUME]() }\n    this.pipes.push(p)\n\n    dest.on('drain', p.ondrain)\n    this[RESUME]()\n    // piping an ended stream ends immediately\n    if (ended && p.opts.end)\n      p.dest.end()\n    return dest\n  }\n\n  addListener (ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on (ev, fn) {\n    try {\n      return super.on(ev, fn)\n    } finally {\n      if (ev === 'data' && !this.pipes.length && !this.flowing)\n        this[RESUME]()\n      else if (isEndish(ev) && this[EMITTED_END]) {\n        super.emit(ev)\n        this.removeAllListeners(ev)\n      }\n    }\n  }\n\n  get emittedEnd () {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END] () {\n    if (!this[EMITTING_END] &&\n        !this[EMITTED_END] &&\n        !this[DESTROYED] &&\n        this.buffer.length === 0 &&\n        this[EOF]) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED])\n        this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit (ev, data) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      if (!data)\n        return\n\n      if (this.pipes.length)\n        this.pipes.forEach(p =>\n          p.dest.write(data) === false && this.pause())\n    } else if (ev === 'end') {\n      // only actual end gets this treatment\n      if (this[EMITTED_END] === true)\n        return\n\n      this[EMITTED_END] = true\n      this.readable = false\n\n      if (this[DECODER]) {\n        data = this[DECODER].end()\n        if (data) {\n          this.pipes.forEach(p => p.dest.write(data))\n          super.emit('data', data)\n        }\n      }\n\n      this.pipes.forEach(p => {\n        p.dest.removeListener('drain', p.ondrain)\n        if (p.opts.end)\n          p.dest.end()\n      })\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED])\n        return\n    }\n\n    // TODO: replace with a spread operator when Node v4 support drops\n    const args = new Array(arguments.length)\n    args[0] = ev\n    args[1] = data\n    if (arguments.length > 2) {\n      for (let i = 2; i < arguments.length; i++) {\n        args[i] = arguments[i]\n      }\n    }\n\n    try {\n      return super.emit.apply(this, args)\n    } finally {\n      if (!isEndish(ev))\n        this[MAYBE_EMIT_END]()\n      else\n        this.removeAllListeners(ev)\n    }\n  }\n\n  // const all = await stream.collect()\n  collect () {\n    const buf = []\n    if (!this[OBJECTMODE])\n      buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE])\n        buf.dataLength += c.length\n    })\n    return p.then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat () {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength))\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise () {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('end', () => resolve())\n      this.on('error', er => reject(er))\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR] () {\n    const next = () => {\n      const res = this.read()\n      if (res !== null)\n        return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF])\n        return Promise.resolve({ done: true })\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return { next }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR] () {\n    const next = () => {\n      const value = this.read()\n      const done = value === null\n      return { value, done }\n    }\n    return { next }\n  }\n\n  destroy (er) {\n    if (this[DESTROYED]) {\n      if (er)\n        this.emit('error', er)\n      else\n        this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this.buffer = new Yallist()\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED])\n      this.close()\n\n    if (er)\n      this.emit('error', er)\n    else // if no error to emit, still reject pending promises\n      this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream (s) {\n    return !!s && (s instanceof Minipass || s instanceof Stream ||\n      s instanceof EE && (\n        typeof s.pipe === 'function' || // readable\n        (typeof s.write === 'function' && typeof s.end === 'function') // writable\n      ))\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/minipass/index.js?");

/***/ }),

/***/ "./node_modules/minizlib/constants.js":
/*!********************************************!*\
  !*** ./node_modules/minizlib/constants.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Update with any zlib constants that are added or changed in the future.\n// Node v6 didn't export this, so we just hard code the version and rely\n// on all the other hard-coded values from zlib v4736.  When node v6\n// support drops, we can just export the realZlibConstants object.\nconst realZlibConstants = __webpack_require__(/*! zlib */ \"zlib\").constants ||\n  /* istanbul ignore next */ { ZLIB_VERNUM: 4736 }\n\nmodule.exports = Object.freeze(Object.assign(Object.create(null), {\n  Z_NO_FLUSH: 0,\n  Z_PARTIAL_FLUSH: 1,\n  Z_SYNC_FLUSH: 2,\n  Z_FULL_FLUSH: 3,\n  Z_FINISH: 4,\n  Z_BLOCK: 5,\n  Z_OK: 0,\n  Z_STREAM_END: 1,\n  Z_NEED_DICT: 2,\n  Z_ERRNO: -1,\n  Z_STREAM_ERROR: -2,\n  Z_DATA_ERROR: -3,\n  Z_MEM_ERROR: -4,\n  Z_BUF_ERROR: -5,\n  Z_VERSION_ERROR: -6,\n  Z_NO_COMPRESSION: 0,\n  Z_BEST_SPEED: 1,\n  Z_BEST_COMPRESSION: 9,\n  Z_DEFAULT_COMPRESSION: -1,\n  Z_FILTERED: 1,\n  Z_HUFFMAN_ONLY: 2,\n  Z_RLE: 3,\n  Z_FIXED: 4,\n  Z_DEFAULT_STRATEGY: 0,\n  DEFLATE: 1,\n  INFLATE: 2,\n  GZIP: 3,\n  GUNZIP: 4,\n  DEFLATERAW: 5,\n  INFLATERAW: 6,\n  UNZIP: 7,\n  BROTLI_DECODE: 8,\n  BROTLI_ENCODE: 9,\n  Z_MIN_WINDOWBITS: 8,\n  Z_MAX_WINDOWBITS: 15,\n  Z_DEFAULT_WINDOWBITS: 15,\n  Z_MIN_CHUNK: 64,\n  Z_MAX_CHUNK: Infinity,\n  Z_DEFAULT_CHUNK: 16384,\n  Z_MIN_MEMLEVEL: 1,\n  Z_MAX_MEMLEVEL: 9,\n  Z_DEFAULT_MEMLEVEL: 8,\n  Z_MIN_LEVEL: -1,\n  Z_MAX_LEVEL: 9,\n  Z_DEFAULT_LEVEL: -1,\n  BROTLI_OPERATION_PROCESS: 0,\n  BROTLI_OPERATION_FLUSH: 1,\n  BROTLI_OPERATION_FINISH: 2,\n  BROTLI_OPERATION_EMIT_METADATA: 3,\n  BROTLI_MODE_GENERIC: 0,\n  BROTLI_MODE_TEXT: 1,\n  BROTLI_MODE_FONT: 2,\n  BROTLI_DEFAULT_MODE: 0,\n  BROTLI_MIN_QUALITY: 0,\n  BROTLI_MAX_QUALITY: 11,\n  BROTLI_DEFAULT_QUALITY: 11,\n  BROTLI_MIN_WINDOW_BITS: 10,\n  BROTLI_MAX_WINDOW_BITS: 24,\n  BROTLI_LARGE_MAX_WINDOW_BITS: 30,\n  BROTLI_DEFAULT_WINDOW: 22,\n  BROTLI_MIN_INPUT_BLOCK_BITS: 16,\n  BROTLI_MAX_INPUT_BLOCK_BITS: 24,\n  BROTLI_PARAM_MODE: 0,\n  BROTLI_PARAM_QUALITY: 1,\n  BROTLI_PARAM_LGWIN: 2,\n  BROTLI_PARAM_LGBLOCK: 3,\n  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,\n  BROTLI_PARAM_SIZE_HINT: 5,\n  BROTLI_PARAM_LARGE_WINDOW: 6,\n  BROTLI_PARAM_NPOSTFIX: 7,\n  BROTLI_PARAM_NDIRECT: 8,\n  BROTLI_DECODER_RESULT_ERROR: 0,\n  BROTLI_DECODER_RESULT_SUCCESS: 1,\n  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,\n  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,\n  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,\n  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,\n  BROTLI_DECODER_NO_ERROR: 0,\n  BROTLI_DECODER_SUCCESS: 1,\n  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,\n  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,\n  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,\n  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,\n  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,\n  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,\n  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,\n  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,\n  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,\n  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,\n  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,\n  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,\n  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,\n  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,\n  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,\n  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,\n  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,\n  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,\n  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,\n  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,\n  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,\n  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,\n  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,\n  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,\n  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,\n  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,\n  BROTLI_DECODER_ERROR_UNREACHABLE: -31,\n}, realZlibConstants))\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/minizlib/constants.js?");

/***/ }),

/***/ "./node_modules/minizlib/index.js":
/*!****************************************!*\
  !*** ./node_modules/minizlib/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst Buffer = __webpack_require__(/*! buffer */ \"buffer\").Buffer\nconst realZlib = __webpack_require__(/*! zlib */ \"zlib\")\n\nconst constants = exports.constants = __webpack_require__(/*! ./constants.js */ \"./node_modules/minizlib/constants.js\")\nconst Minipass = __webpack_require__(/*! minipass */ \"./node_modules/minipass/index.js\")\n\nconst OriginalBufferConcat = Buffer.concat\n\nconst _superWrite = Symbol('_superWrite')\nclass ZlibError extends Error {\n  constructor (err) {\n    super('zlib: ' + err.message)\n    this.code = err.code\n    this.errno = err.errno\n    /* istanbul ignore if */\n    if (!this.code)\n      this.code = 'ZLIB_ERROR'\n\n    this.message = 'zlib: ' + err.message\n    Error.captureStackTrace(this, this.constructor)\n  }\n\n  get name () {\n    return 'ZlibError'\n  }\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _opts = Symbol('opts')\nconst _flushFlag = Symbol('flushFlag')\nconst _finishFlushFlag = Symbol('finishFlushFlag')\nconst _fullFlushFlag = Symbol('fullFlushFlag')\nconst _handle = Symbol('handle')\nconst _onError = Symbol('onError')\nconst _sawError = Symbol('sawError')\nconst _level = Symbol('level')\nconst _strategy = Symbol('strategy')\nconst _ended = Symbol('ended')\nconst _defaultFullFlush = Symbol('_defaultFullFlush')\n\nclass ZlibBase extends Minipass {\n  constructor (opts, mode) {\n    if (!opts || typeof opts !== 'object')\n      throw new TypeError('invalid options for ZlibBase constructor')\n\n    super(opts)\n    this[_sawError] = false\n    this[_ended] = false\n    this[_opts] = opts\n\n    this[_flushFlag] = opts.flush\n    this[_finishFlushFlag] = opts.finishFlush\n    // this will throw if any options are invalid for the class selected\n    try {\n      this[_handle] = new realZlib[mode](opts)\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er)\n    }\n\n    this[_onError] = (err) => {\n      // no sense raising multiple errors, since we abort on the first one.\n      if (this[_sawError])\n        return\n\n      this[_sawError] = true\n\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      this.close()\n      this.emit('error', err)\n    }\n\n    this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n    this.once('end', () => this.close)\n  }\n\n  close () {\n    if (this[_handle]) {\n      this[_handle].close()\n      this[_handle] = null\n      this.emit('close')\n    }\n  }\n\n  reset () {\n    if (!this[_sawError]) {\n      assert(this[_handle], 'zlib binding closed')\n      return this[_handle].reset()\n    }\n  }\n\n  flush (flushFlag) {\n    if (this.ended)\n      return\n\n    if (typeof flushFlag !== 'number')\n      flushFlag = this[_fullFlushFlag]\n    this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }))\n  }\n\n  end (chunk, encoding, cb) {\n    if (chunk)\n      this.write(chunk, encoding)\n    this.flush(this[_finishFlushFlag])\n    this[_ended] = true\n    return super.end(null, null, cb)\n  }\n\n  get ended () {\n    return this[_ended]\n  }\n\n  write (chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (typeof chunk === 'string')\n      chunk = Buffer.from(chunk, encoding)\n\n    if (this[_sawError])\n      return\n    assert(this[_handle], 'zlib binding closed')\n\n    // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n    const nativeHandle = this[_handle]._handle\n    const originalNativeClose = nativeHandle.close\n    nativeHandle.close = () => {}\n    const originalClose = this[_handle].close\n    this[_handle].close = () => {}\n    // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n    Buffer.concat = (args) => args\n    let result\n    try {\n      const flushFlag = typeof chunk[_flushFlag] === 'number'\n        ? chunk[_flushFlag] : this[_flushFlag]\n      result = this[_handle]._processChunk(chunk, flushFlag)\n      // if we don't throw, reset it back how it was\n      Buffer.concat = OriginalBufferConcat\n    } catch (err) {\n      // or if we do, put Buffer.concat() back before we emit error\n      // Error events call into user code, which may call Buffer.concat()\n      Buffer.concat = OriginalBufferConcat\n      this[_onError](new ZlibError(err))\n    } finally {\n      if (this[_handle]) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        this[_handle]._handle = nativeHandle\n        nativeHandle.close = originalNativeClose\n        this[_handle].close = originalClose\n        // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n        this[_handle].removeAllListeners('error')\n        // make sure OUR error listener is still attached tho\n      }\n    }\n\n    if (this[_handle])\n      this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n\n    let writeReturn\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = this[_superWrite](Buffer.from(result[0]))\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = this[_superWrite](result[i])\n        }\n      } else {\n        writeReturn = this[_superWrite](Buffer.from(result))\n      }\n    }\n\n    if (cb)\n      cb()\n    return writeReturn\n  }\n\n  [_superWrite] (data) {\n    return super.write(data)\n  }\n}\n\nclass Zlib extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.Z_NO_FLUSH\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.Z_FULL_FLUSH\n    this[_level] = opts.level\n    this[_strategy] = opts.strategy\n  }\n\n  params (level, strategy) {\n    if (this[_sawError])\n      return\n\n    if (!this[_handle])\n      throw new Error('cannot switch params when binding is closed')\n\n    // no way to test this without also not supporting params at all\n    /* istanbul ignore if */\n    if (!this[_handle].params)\n      throw new Error('not supported in this implementation')\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH)\n      assert(this[_handle], 'zlib binding closed')\n      // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n      const origFlush = this[_handle].flush\n      this[_handle].flush = (flushFlag, cb) => {\n        this.flush(flushFlag)\n        cb()\n      }\n      try {\n        this[_handle].params(level, strategy)\n      } finally {\n        this[_handle].flush = origFlush\n      }\n      /* istanbul ignore else */\n      if (this[_handle]) {\n        this[_level] = level\n        this[_strategy] = strategy\n      }\n    }\n  }\n}\n\n// minimal 2-byte header\nclass Deflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Deflate')\n  }\n}\n\nclass Inflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Inflate')\n  }\n}\n\n// gzip - bigger header, same deflate compression\nconst _portable = Symbol('_portable')\nclass Gzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gzip')\n    this[_portable] = opts && !!opts.portable\n  }\n\n  [_superWrite] (data) {\n    if (!this[_portable])\n      return super[_superWrite](data)\n\n    // we'll always get the header emitted in one first chunk\n    // overwrite the OS indicator byte with 0xFF\n    this[_portable] = false\n    data[9] = 255\n    return super[_superWrite](data)\n  }\n}\n\nclass Gunzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gunzip')\n  }\n}\n\n// raw - no header\nclass DeflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'DeflateRaw')\n  }\n}\n\nclass InflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'InflateRaw')\n  }\n}\n\n// auto-detect header.\nclass Unzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Unzip')\n  }\n}\n\nclass Brotli extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS\n    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH\n\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH\n  }\n}\n\nclass BrotliCompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliCompress')\n  }\n}\n\nclass BrotliDecompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliDecompress')\n  }\n}\n\nexports.Deflate = Deflate\nexports.Inflate = Inflate\nexports.Gzip = Gzip\nexports.Gunzip = Gunzip\nexports.DeflateRaw = DeflateRaw\nexports.InflateRaw = InflateRaw\nexports.Unzip = Unzip\n/* istanbul ignore else */\nif (typeof realZlib.BrotliCompress === 'function') {\n  exports.BrotliCompress = BrotliCompress\n  exports.BrotliDecompress = BrotliDecompress\n} else {\n  exports.BrotliCompress = exports.BrotliDecompress = class {\n    constructor () {\n      throw new Error('Brotli is not supported in this version of Node.js')\n    }\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/minizlib/index.js?");

/***/ }),

/***/ "./node_modules/mkdirp/index.js":
/*!**************************************!*\
  !*** ./node_modules/mkdirp/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const optsArg = __webpack_require__(/*! ./lib/opts-arg.js */ \"./node_modules/mkdirp/lib/opts-arg.js\")\nconst pathArg = __webpack_require__(/*! ./lib/path-arg.js */ \"./node_modules/mkdirp/lib/path-arg.js\")\n\nconst {mkdirpNative, mkdirpNativeSync} = __webpack_require__(/*! ./lib/mkdirp-native.js */ \"./node_modules/mkdirp/lib/mkdirp-native.js\")\nconst {mkdirpManual, mkdirpManualSync} = __webpack_require__(/*! ./lib/mkdirp-manual.js */ \"./node_modules/mkdirp/lib/mkdirp-manual.js\")\nconst {useNative, useNativeSync} = __webpack_require__(/*! ./lib/use-native.js */ \"./node_modules/mkdirp/lib/use-native.js\")\n\n\nconst mkdirp = (path, opts) => {\n  path = pathArg(path)\n  opts = optsArg(opts)\n  return useNative(opts)\n    ? mkdirpNative(path, opts)\n    : mkdirpManual(path, opts)\n}\n\nconst mkdirpSync = (path, opts) => {\n  path = pathArg(path)\n  opts = optsArg(opts)\n  return useNativeSync(opts)\n    ? mkdirpNativeSync(path, opts)\n    : mkdirpManualSync(path, opts)\n}\n\nmkdirp.sync = mkdirpSync\nmkdirp.native = (path, opts) => mkdirpNative(pathArg(path), optsArg(opts))\nmkdirp.manual = (path, opts) => mkdirpManual(pathArg(path), optsArg(opts))\nmkdirp.nativeSync = (path, opts) => mkdirpNativeSync(pathArg(path), optsArg(opts))\nmkdirp.manualSync = (path, opts) => mkdirpManualSync(pathArg(path), optsArg(opts))\n\nmodule.exports = mkdirp\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/mkdirp/index.js?");

/***/ }),

/***/ "./node_modules/mkdirp/lib/find-made.js":
/*!**********************************************!*\
  !*** ./node_modules/mkdirp/lib/find-made.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {dirname} = __webpack_require__(/*! path */ \"path\")\n\nconst findMade = (opts, parent, path = undefined) => {\n  // we never want the 'made' return value to be a root directory\n  if (path === parent)\n    return Promise.resolve()\n\n  return opts.statAsync(parent).then(\n    st => st.isDirectory() ? path : undefined, // will fail later\n    er => er.code === 'ENOENT'\n      ? findMade(opts, dirname(parent), parent)\n      : undefined\n  )\n}\n\nconst findMadeSync = (opts, parent, path = undefined) => {\n  if (path === parent)\n    return undefined\n\n  try {\n    return opts.statSync(parent).isDirectory() ? path : undefined\n  } catch (er) {\n    return er.code === 'ENOENT'\n      ? findMadeSync(opts, dirname(parent), parent)\n      : undefined\n  }\n}\n\nmodule.exports = {findMade, findMadeSync}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/mkdirp/lib/find-made.js?");

/***/ }),

/***/ "./node_modules/mkdirp/lib/mkdirp-manual.js":
/*!**************************************************!*\
  !*** ./node_modules/mkdirp/lib/mkdirp-manual.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {dirname} = __webpack_require__(/*! path */ \"path\")\n\nconst mkdirpManual = (path, opts, made) => {\n  opts.recursive = false\n  const parent = dirname(path)\n  if (parent === path) {\n    return opts.mkdirAsync(path, opts).catch(er => {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR')\n        throw er\n    })\n  }\n\n  return opts.mkdirAsync(path, opts).then(() => made || path, er => {\n    if (er.code === 'ENOENT')\n      return mkdirpManual(parent, opts)\n        .then(made => mkdirpManual(path, opts, made))\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS')\n      throw er\n    return opts.statAsync(path).then(st => {\n      if (st.isDirectory())\n        return made\n      else\n        throw er\n    }, () => { throw er })\n  })\n}\n\nconst mkdirpManualSync = (path, opts, made) => {\n  const parent = dirname(path)\n  opts.recursive = false\n\n  if (parent === path) {\n    try {\n      return opts.mkdirSync(path, opts)\n    } catch (er) {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR')\n        throw er\n      else\n        return\n    }\n  }\n\n  try {\n    opts.mkdirSync(path, opts)\n    return made || path\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made))\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS')\n      throw er\n    try {\n      if (!opts.statSync(path).isDirectory())\n        throw er\n    } catch (_) {\n      throw er\n    }\n  }\n}\n\nmodule.exports = {mkdirpManual, mkdirpManualSync}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/mkdirp/lib/mkdirp-manual.js?");

/***/ }),

/***/ "./node_modules/mkdirp/lib/mkdirp-native.js":
/*!**************************************************!*\
  !*** ./node_modules/mkdirp/lib/mkdirp-native.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {dirname} = __webpack_require__(/*! path */ \"path\")\nconst {findMade, findMadeSync} = __webpack_require__(/*! ./find-made.js */ \"./node_modules/mkdirp/lib/find-made.js\")\nconst {mkdirpManual, mkdirpManualSync} = __webpack_require__(/*! ./mkdirp-manual.js */ \"./node_modules/mkdirp/lib/mkdirp-manual.js\")\n\nconst mkdirpNative = (path, opts) => {\n  opts.recursive = true\n  const parent = dirname(path)\n  if (parent === path)\n    return opts.mkdirAsync(path, opts)\n\n  return findMade(opts, path).then(made =>\n    opts.mkdirAsync(path, opts).then(() => made)\n    .catch(er => {\n      if (er.code === 'ENOENT')\n        return mkdirpManual(path, opts)\n      else\n        throw er\n    }))\n}\n\nconst mkdirpNativeSync = (path, opts) => {\n  opts.recursive = true\n  const parent = dirname(path)\n  if (parent === path)\n    return opts.mkdirSync(path, opts)\n\n  const made = findMadeSync(opts, path)\n  try {\n    opts.mkdirSync(path, opts)\n    return made\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return mkdirpManualSync(path, opts)\n    else\n      throw er\n  }\n}\n\nmodule.exports = {mkdirpNative, mkdirpNativeSync}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/mkdirp/lib/mkdirp-native.js?");

/***/ }),

/***/ "./node_modules/mkdirp/lib/opts-arg.js":
/*!*********************************************!*\
  !*** ./node_modules/mkdirp/lib/opts-arg.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { promisify } = __webpack_require__(/*! util */ \"util\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst optsArg = opts => {\n  if (!opts)\n    opts = { mode: 0o777, fs }\n  else if (typeof opts === 'object')\n    opts = { mode: 0o777, fs, ...opts }\n  else if (typeof opts === 'number')\n    opts = { mode: opts, fs }\n  else if (typeof opts === 'string')\n    opts = { mode: parseInt(opts, 8), fs }\n  else\n    throw new TypeError('invalid options argument')\n\n  opts.mkdir = opts.mkdir || opts.fs.mkdir || fs.mkdir\n  opts.mkdirAsync = promisify(opts.mkdir)\n  opts.stat = opts.stat || opts.fs.stat || fs.stat\n  opts.statAsync = promisify(opts.stat)\n  opts.statSync = opts.statSync || opts.fs.statSync || fs.statSync\n  opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs.mkdirSync\n  return opts\n}\nmodule.exports = optsArg\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/mkdirp/lib/opts-arg.js?");

/***/ }),

/***/ "./node_modules/mkdirp/lib/path-arg.js":
/*!*********************************************!*\
  !*** ./node_modules/mkdirp/lib/path-arg.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform\nconst { resolve, parse } = __webpack_require__(/*! path */ \"path\")\nconst pathArg = path => {\n  if (/\\0/.test(path)) {\n    // simulate same failure that node raises\n    throw Object.assign(\n      new TypeError('path must be a string without null bytes'),\n      {\n        path,\n        code: 'ERR_INVALID_ARG_VALUE',\n      }\n    )\n  }\n\n  path = resolve(path)\n  if (platform === 'win32') {\n    const badWinChars = /[*|\"<>?:]/\n    const {root} = parse(path)\n    if (badWinChars.test(path.substr(root.length))) {\n      throw Object.assign(new Error('Illegal characters in path.'), {\n        path,\n        code: 'EINVAL',\n      })\n    }\n  }\n\n  return path\n}\nmodule.exports = pathArg\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/mkdirp/lib/path-arg.js?");

/***/ }),

/***/ "./node_modules/mkdirp/lib/use-native.js":
/*!***********************************************!*\
  !*** ./node_modules/mkdirp/lib/use-native.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\")\n\nconst version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version\nconst versArr = version.replace(/^v/, '').split('.')\nconst hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12\n\nconst useNative = !hasNative ? () => false : opts => opts.mkdir === fs.mkdir\nconst useNativeSync = !hasNative ? () => false : opts => opts.mkdirSync === fs.mkdirSync\n\nmodule.exports = {useNative, useNativeSync}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/mkdirp/lib/use-native.js?");

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ ((module) => {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/index.js":
/*!********************************************!*\
  !*** ./node_modules/msgpack-lite/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// msgpack.js\n\nexports.encode = __webpack_require__(/*! ./lib/encode */ \"./node_modules/msgpack-lite/lib/encode.js\").encode;\nexports.decode = __webpack_require__(/*! ./lib/decode */ \"./node_modules/msgpack-lite/lib/decode.js\").decode;\n\nexports.Encoder = __webpack_require__(/*! ./lib/encoder */ \"./node_modules/msgpack-lite/lib/encoder.js\").Encoder;\nexports.Decoder = __webpack_require__(/*! ./lib/decoder */ \"./node_modules/msgpack-lite/lib/decoder.js\").Decoder;\n\nexports.createEncodeStream = __webpack_require__(/*! ./lib/encode-stream */ \"./node_modules/msgpack-lite/lib/encode-stream.js\").createEncodeStream;\nexports.createDecodeStream = __webpack_require__(/*! ./lib/decode-stream */ \"./node_modules/msgpack-lite/lib/decode-stream.js\").createDecodeStream;\n\nexports.createCodec = __webpack_require__(/*! ./lib/ext */ \"./node_modules/msgpack-lite/lib/ext.js\").createCodec;\nexports.codec = __webpack_require__(/*! ./lib/codec */ \"./node_modules/msgpack-lite/lib/codec.js\").codec;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/index.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/buffer-global.js":
/*!********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/buffer-global.js ***!
  \********************************************************/
/***/ (function(module) {

eval("/* globals Buffer */\n\nmodule.exports =\n  c((\"undefined\" !== typeof Buffer) && Buffer) ||\n  c(this.Buffer) ||\n  c((\"undefined\" !== typeof window) && window.Buffer) ||\n  this.Buffer;\n\nfunction c(B) {\n  return B && B.isBuffer && B;\n}\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/buffer-global.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/buffer-lite.js":
/*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/buffer-lite.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// buffer-lite.js\n\nvar MAXBUFLEN = 8192;\n\nexports.copy = copy;\nexports.toString = toString;\nexports.write = write;\n\n/**\n * Buffer.prototype.write()\n *\n * @param string {String}\n * @param [offset] {Number}\n * @returns {Number}\n */\n\nfunction write(string, offset) {\n  var buffer = this;\n  var index = offset || (offset |= 0);\n  var length = string.length;\n  var chr = 0;\n  var i = 0;\n  while (i < length) {\n    chr = string.charCodeAt(i++);\n\n    if (chr < 128) {\n      buffer[index++] = chr;\n    } else if (chr < 0x800) {\n      // 2 bytes\n      buffer[index++] = 0xC0 | (chr >>> 6);\n      buffer[index++] = 0x80 | (chr & 0x3F);\n    } else if (chr < 0xD800 || chr > 0xDFFF) {\n      // 3 bytes\n      buffer[index++] = 0xE0 | (chr  >>> 12);\n      buffer[index++] = 0x80 | ((chr >>> 6)  & 0x3F);\n      buffer[index++] = 0x80 | (chr          & 0x3F);\n    } else {\n      // 4 bytes - surrogate pair\n      chr = (((chr - 0xD800) << 10) | (string.charCodeAt(i++) - 0xDC00)) + 0x10000;\n      buffer[index++] = 0xF0 | (chr >>> 18);\n      buffer[index++] = 0x80 | ((chr >>> 12) & 0x3F);\n      buffer[index++] = 0x80 | ((chr >>> 6)  & 0x3F);\n      buffer[index++] = 0x80 | (chr          & 0x3F);\n    }\n  }\n  return index - offset;\n}\n\n/**\n * Buffer.prototype.toString()\n *\n * @param [encoding] {String} ignored\n * @param [start] {Number}\n * @param [end] {Number}\n * @returns {String}\n */\n\nfunction toString(encoding, start, end) {\n  var buffer = this;\n  var index = start|0;\n  if (!end) end = buffer.length;\n  var string = '';\n  var chr = 0;\n\n  while (index < end) {\n    chr = buffer[index++];\n    if (chr < 128) {\n      string += String.fromCharCode(chr);\n      continue;\n    }\n\n    if ((chr & 0xE0) === 0xC0) {\n      // 2 bytes\n      chr = (chr & 0x1F) << 6 |\n            (buffer[index++] & 0x3F);\n\n    } else if ((chr & 0xF0) === 0xE0) {\n      // 3 bytes\n      chr = (chr & 0x0F)             << 12 |\n            (buffer[index++] & 0x3F) << 6  |\n            (buffer[index++] & 0x3F);\n\n    } else if ((chr & 0xF8) === 0xF0) {\n      // 4 bytes\n      chr = (chr & 0x07)             << 18 |\n            (buffer[index++] & 0x3F) << 12 |\n            (buffer[index++] & 0x3F) << 6  |\n            (buffer[index++] & 0x3F);\n    }\n\n    if (chr >= 0x010000) {\n      // A surrogate pair\n      chr -= 0x010000;\n\n      string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);\n    } else {\n      string += String.fromCharCode(chr);\n    }\n  }\n\n  return string;\n}\n\n/**\n * Buffer.prototype.copy()\n *\n * @param target {Buffer}\n * @param [targetStart] {Number}\n * @param [start] {Number}\n * @param [end] {Number}\n * @returns {number}\n */\n\nfunction copy(target, targetStart, start, end) {\n  var i;\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (!targetStart) targetStart = 0;\n  var len = end - start;\n\n  if (target === this && start < targetStart && targetStart < end) {\n    // descending\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else {\n    // ascending\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start];\n    }\n  }\n\n  return len;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/buffer-lite.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/bufferish-array.js":
/*!**********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-array.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// bufferish-array.js\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\n\nvar exports = module.exports = alloc(0);\n\nexports.alloc = alloc;\nexports.concat = Bufferish.concat;\nexports.from = from;\n\n/**\n * @param size {Number}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction alloc(size) {\n  return new Array(size);\n}\n\n/**\n * @param value {Array|ArrayBuffer|Buffer|String}\n * @returns {Array}\n */\n\nfunction from(value) {\n  if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {\n    // TypedArray to Uint8Array\n    value = Bufferish.Uint8Array.from(value);\n  } else if (Bufferish.isArrayBuffer(value)) {\n    // ArrayBuffer to Uint8Array\n    value = new Uint8Array(value);\n  } else if (typeof value === \"string\") {\n    // String to Array\n    return Bufferish.from.call(exports, value);\n  } else if (typeof value === \"number\") {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n\n  // Array-like to Array\n  return Array.prototype.slice.call(value);\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/bufferish-array.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/bufferish-buffer.js":
/*!***********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-buffer.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// bufferish-buffer.js\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar Buffer = Bufferish.global;\n\nvar exports = module.exports = Bufferish.hasBuffer ? alloc(0) : [];\n\nexports.alloc = Bufferish.hasBuffer && Buffer.alloc || alloc;\nexports.concat = Bufferish.concat;\nexports.from = from;\n\n/**\n * @param size {Number}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction alloc(size) {\n  return new Buffer(size);\n}\n\n/**\n * @param value {Array|ArrayBuffer|Buffer|String}\n * @returns {Buffer}\n */\n\nfunction from(value) {\n  if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {\n    // TypedArray to Uint8Array\n    value = Bufferish.Uint8Array.from(value);\n  } else if (Bufferish.isArrayBuffer(value)) {\n    // ArrayBuffer to Uint8Array\n    value = new Uint8Array(value);\n  } else if (typeof value === \"string\") {\n    // String to Buffer\n    return Bufferish.from.call(exports, value);\n  } else if (typeof value === \"number\") {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n\n  // Array-like to Buffer\n  if (Buffer.from && Buffer.from.length !== 1) {\n    return Buffer.from(value); // node v6+\n  } else {\n    return new Buffer(value); // node v4\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/bufferish-buffer.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/bufferish-proto.js":
/*!**********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-proto.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// bufferish-proto.js\n\n/* jshint eqnull:true */\n\nvar BufferLite = __webpack_require__(/*! ./buffer-lite */ \"./node_modules/msgpack-lite/lib/buffer-lite.js\");\n\nexports.copy = copy;\nexports.slice = slice;\nexports.toString = toString;\nexports.write = gen(\"write\");\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar Buffer = Bufferish.global;\n\nvar isBufferShim = Bufferish.hasBuffer && (\"TYPED_ARRAY_SUPPORT\" in Buffer);\nvar brokenTypedArray = isBufferShim && !Buffer.TYPED_ARRAY_SUPPORT;\n\n/**\n * @param target {Buffer|Uint8Array|Array}\n * @param [targetStart] {Number}\n * @param [start] {Number}\n * @param [end] {Number}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction copy(target, targetStart, start, end) {\n  var thisIsBuffer = Bufferish.isBuffer(this);\n  var targetIsBuffer = Bufferish.isBuffer(target);\n  if (thisIsBuffer && targetIsBuffer) {\n    // Buffer to Buffer\n    return this.copy(target, targetStart, start, end);\n  } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer &&\n    Bufferish.isView(this) && Bufferish.isView(target)) {\n    // Uint8Array to Uint8Array (except for minor some browsers)\n    var buffer = (start || end != null) ? slice.call(this, start, end) : this;\n    target.set(buffer, targetStart);\n    return buffer.length;\n  } else {\n    // other cases\n    return BufferLite.copy.call(this, target, targetStart, start, end);\n  }\n}\n\n/**\n * @param [start] {Number}\n * @param [end] {Number}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction slice(start, end) {\n  // for Buffer, Uint8Array (except for minor some browsers) and Array\n  var f = this.slice || (!brokenTypedArray && this.subarray);\n  if (f) return f.call(this, start, end);\n\n  // Uint8Array (for minor some browsers)\n  var target = Bufferish.alloc.call(this, end - start);\n  copy.call(this, target, 0, start, end);\n  return target;\n}\n\n/**\n * Buffer.prototype.toString()\n *\n * @param [encoding] {String} ignored\n * @param [start] {Number}\n * @param [end] {Number}\n * @returns {String}\n */\n\nfunction toString(encoding, start, end) {\n  var f = (!isBufferShim && Bufferish.isBuffer(this)) ? this.toString : BufferLite.toString;\n  return f.apply(this, arguments);\n}\n\n/**\n * @private\n */\n\nfunction gen(method) {\n  return wrap;\n\n  function wrap() {\n    var f = this[method] || BufferLite[method];\n    return f.apply(this, arguments);\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/bufferish-proto.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/bufferish-uint8array.js":
/*!***************************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-uint8array.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// bufferish-uint8array.js\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\n\nvar exports = module.exports = Bufferish.hasArrayBuffer ? alloc(0) : [];\n\nexports.alloc = alloc;\nexports.concat = Bufferish.concat;\nexports.from = from;\n\n/**\n * @param size {Number}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction alloc(size) {\n  return new Uint8Array(size);\n}\n\n/**\n * @param value {Array|ArrayBuffer|Buffer|String}\n * @returns {Uint8Array}\n */\n\nfunction from(value) {\n  if (Bufferish.isView(value)) {\n    // TypedArray to ArrayBuffer\n    var byteOffset = value.byteOffset;\n    var byteLength = value.byteLength;\n    value = value.buffer;\n    if (value.byteLength !== byteLength) {\n      if (value.slice) {\n        value = value.slice(byteOffset, byteOffset + byteLength);\n      } else {\n        // Android 4.1 does not have ArrayBuffer.prototype.slice\n        value = new Uint8Array(value);\n        if (value.byteLength !== byteLength) {\n          // TypedArray to ArrayBuffer to Uint8Array to Array\n          value = Array.prototype.slice.call(value, byteOffset, byteOffset + byteLength);\n        }\n      }\n    }\n  } else if (typeof value === \"string\") {\n    // String to Uint8Array\n    return Bufferish.from.call(exports, value);\n  } else if (typeof value === \"number\") {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n\n  return new Uint8Array(value);\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/bufferish-uint8array.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/bufferish.js":
/*!****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// bufferish.js\n\nvar Buffer = exports.global = __webpack_require__(/*! ./buffer-global */ \"./node_modules/msgpack-lite/lib/buffer-global.js\");\nvar hasBuffer = exports.hasBuffer = Buffer && !!Buffer.isBuffer;\nvar hasArrayBuffer = exports.hasArrayBuffer = (\"undefined\" !== typeof ArrayBuffer);\n\nvar isArray = exports.isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\nexports.isArrayBuffer = hasArrayBuffer ? isArrayBuffer : _false;\nvar isBuffer = exports.isBuffer = hasBuffer ? Buffer.isBuffer : _false;\nvar isView = exports.isView = hasArrayBuffer ? (ArrayBuffer.isView || _is(\"ArrayBuffer\", \"buffer\")) : _false;\n\nexports.alloc = alloc;\nexports.concat = concat;\nexports.from = from;\n\nvar BufferArray = exports.Array = __webpack_require__(/*! ./bufferish-array */ \"./node_modules/msgpack-lite/lib/bufferish-array.js\");\nvar BufferBuffer = exports.Buffer = __webpack_require__(/*! ./bufferish-buffer */ \"./node_modules/msgpack-lite/lib/bufferish-buffer.js\");\nvar BufferUint8Array = exports.Uint8Array = __webpack_require__(/*! ./bufferish-uint8array */ \"./node_modules/msgpack-lite/lib/bufferish-uint8array.js\");\nvar BufferProto = exports.prototype = __webpack_require__(/*! ./bufferish-proto */ \"./node_modules/msgpack-lite/lib/bufferish-proto.js\");\n\n/**\n * @param value {Array|ArrayBuffer|Buffer|String}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction from(value) {\n  if (typeof value === \"string\") {\n    return fromString.call(this, value);\n  } else {\n    return auto(this).from(value);\n  }\n}\n\n/**\n * @param size {Number}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction alloc(size) {\n  return auto(this).alloc(size);\n}\n\n/**\n * @param list {Array} array of (Buffer|Uint8Array|Array)s\n * @param [length]\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction concat(list, length) {\n  if (!length) {\n    length = 0;\n    Array.prototype.forEach.call(list, dryrun);\n  }\n  var ref = (this !== exports) && this || list[0];\n  var result = alloc.call(ref, length);\n  var offset = 0;\n  Array.prototype.forEach.call(list, append);\n  return result;\n\n  function dryrun(buffer) {\n    length += buffer.length;\n  }\n\n  function append(buffer) {\n    offset += BufferProto.copy.call(buffer, result, offset);\n  }\n}\n\nvar _isArrayBuffer = _is(\"ArrayBuffer\");\n\nfunction isArrayBuffer(value) {\n  return (value instanceof ArrayBuffer) || _isArrayBuffer(value);\n}\n\n/**\n * @private\n */\n\nfunction fromString(value) {\n  var expected = value.length * 3;\n  var that = alloc.call(this, expected);\n  var actual = BufferProto.write.call(that, value);\n  if (expected !== actual) {\n    that = BufferProto.slice.call(that, 0, actual);\n  }\n  return that;\n}\n\nfunction auto(that) {\n  return isBuffer(that) ? BufferBuffer\n    : isView(that) ? BufferUint8Array\n    : isArray(that) ? BufferArray\n    : hasBuffer ? BufferBuffer\n    : hasArrayBuffer ? BufferUint8Array\n    : BufferArray;\n}\n\nfunction _false() {\n  return false;\n}\n\nfunction _is(name, key) {\n  /* jshint eqnull:true */\n  name = \"[object \" + name + \"]\";\n  return function(value) {\n    return (value != null) && {}.toString.call(key ? value[key] : value) === name;\n  };\n}\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/bufferish.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/codec-base.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/codec-base.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// codec-base.js\n\nvar IS_ARRAY = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\n\nexports.createCodec = createCodec;\nexports.install = install;\nexports.filter = filter;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\n\nfunction Codec(options) {\n  if (!(this instanceof Codec)) return new Codec(options);\n  this.options = options;\n  this.init();\n}\n\nCodec.prototype.init = function() {\n  var options = this.options;\n\n  if (options && options.uint8array) {\n    this.bufferish = Bufferish.Uint8Array;\n  }\n\n  return this;\n};\n\nfunction install(props) {\n  for (var key in props) {\n    Codec.prototype[key] = add(Codec.prototype[key], props[key]);\n  }\n}\n\nfunction add(a, b) {\n  return (a && b) ? ab : (a || b);\n\n  function ab() {\n    a.apply(this, arguments);\n    return b.apply(this, arguments);\n  }\n}\n\nfunction join(filters) {\n  filters = filters.slice();\n\n  return function(value) {\n    return filters.reduce(iterator, value);\n  };\n\n  function iterator(value, filter) {\n    return filter(value);\n  }\n}\n\nfunction filter(filter) {\n  return IS_ARRAY(filter) ? join(filter) : filter;\n}\n\n// @public\n// msgpack.createCodec()\n\nfunction createCodec(options) {\n  return new Codec(options);\n}\n\n// default shared codec\n\nexports.preset = createCodec({preset: true});\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/codec-base.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/codec.js":
/*!************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/codec.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// codec.js\n\n// load both interfaces\n__webpack_require__(/*! ./read-core */ \"./node_modules/msgpack-lite/lib/read-core.js\");\n__webpack_require__(/*! ./write-core */ \"./node_modules/msgpack-lite/lib/write-core.js\");\n\n// @public\n// msgpack.codec.preset\n\nexports.codec = {\n  preset: __webpack_require__(/*! ./codec-base */ \"./node_modules/msgpack-lite/lib/codec-base.js\").preset\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/codec.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/decode-buffer.js":
/*!********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/decode-buffer.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// decode-buffer.js\n\nexports.DecodeBuffer = DecodeBuffer;\n\nvar preset = __webpack_require__(/*! ./read-core */ \"./node_modules/msgpack-lite/lib/read-core.js\").preset;\n\nvar FlexDecoder = __webpack_require__(/*! ./flex-buffer */ \"./node_modules/msgpack-lite/lib/flex-buffer.js\").FlexDecoder;\n\nFlexDecoder.mixin(DecodeBuffer.prototype);\n\nfunction DecodeBuffer(options) {\n  if (!(this instanceof DecodeBuffer)) return new DecodeBuffer(options);\n\n  if (options) {\n    this.options = options;\n    if (options.codec) {\n      var codec = this.codec = options.codec;\n      if (codec.bufferish) this.bufferish = codec.bufferish;\n    }\n  }\n}\n\nDecodeBuffer.prototype.codec = preset;\n\nDecodeBuffer.prototype.fetch = function() {\n  return this.codec.decode(this);\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/decode-buffer.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/decode-stream.js":
/*!********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/decode-stream.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// decode-stream.js\n\nexports.createDecodeStream = DecodeStream;\n\nvar util = __webpack_require__(/*! util */ \"util\");\nvar Transform = __webpack_require__(/*! stream */ \"stream\").Transform;\nvar DecodeBuffer = __webpack_require__(/*! ./decode-buffer */ \"./node_modules/msgpack-lite/lib/decode-buffer.js\").DecodeBuffer;\n\nutil.inherits(DecodeStream, Transform);\n\nvar DEFAULT_OPTIONS = {objectMode: true};\n\nfunction DecodeStream(options) {\n  if (!(this instanceof DecodeStream)) return new DecodeStream(options);\n  if (options) {\n    options.objectMode = true;\n  } else {\n    options = DEFAULT_OPTIONS;\n  }\n  Transform.call(this, options);\n  var stream = this;\n  var decoder = this.decoder = new DecodeBuffer(options);\n  decoder.push = function(chunk) {\n    stream.push(chunk);\n  };\n}\n\nDecodeStream.prototype._transform = function(chunk, encoding, callback) {\n  this.decoder.write(chunk);\n  this.decoder.flush();\n  if (callback) callback();\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/decode-stream.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/decode.js":
/*!*************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/decode.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// decode.js\n\nexports.decode = decode;\n\nvar DecodeBuffer = __webpack_require__(/*! ./decode-buffer */ \"./node_modules/msgpack-lite/lib/decode-buffer.js\").DecodeBuffer;\n\nfunction decode(input, options) {\n  var decoder = new DecodeBuffer(options);\n  decoder.write(input);\n  return decoder.read();\n}\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/decode.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/decoder.js":
/*!**************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/decoder.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// decoder.js\n\nexports.Decoder = Decoder;\n\nvar EventLite = __webpack_require__(/*! event-lite */ \"./node_modules/event-lite/event-lite.js\");\nvar DecodeBuffer = __webpack_require__(/*! ./decode-buffer */ \"./node_modules/msgpack-lite/lib/decode-buffer.js\").DecodeBuffer;\n\nfunction Decoder(options) {\n  if (!(this instanceof Decoder)) return new Decoder(options);\n  DecodeBuffer.call(this, options);\n}\n\nDecoder.prototype = new DecodeBuffer();\n\nEventLite.mixin(Decoder.prototype);\n\nDecoder.prototype.decode = function(chunk) {\n  if (arguments.length) this.write(chunk);\n  this.flush();\n};\n\nDecoder.prototype.push = function(chunk) {\n  this.emit(\"data\", chunk);\n};\n\nDecoder.prototype.end = function(chunk) {\n  this.decode(chunk);\n  this.emit(\"end\");\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/decoder.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/encode-buffer.js":
/*!********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/encode-buffer.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// encode-buffer.js\n\nexports.EncodeBuffer = EncodeBuffer;\n\nvar preset = __webpack_require__(/*! ./write-core */ \"./node_modules/msgpack-lite/lib/write-core.js\").preset;\n\nvar FlexEncoder = __webpack_require__(/*! ./flex-buffer */ \"./node_modules/msgpack-lite/lib/flex-buffer.js\").FlexEncoder;\n\nFlexEncoder.mixin(EncodeBuffer.prototype);\n\nfunction EncodeBuffer(options) {\n  if (!(this instanceof EncodeBuffer)) return new EncodeBuffer(options);\n\n  if (options) {\n    this.options = options;\n    if (options.codec) {\n      var codec = this.codec = options.codec;\n      if (codec.bufferish) this.bufferish = codec.bufferish;\n    }\n  }\n}\n\nEncodeBuffer.prototype.codec = preset;\n\nEncodeBuffer.prototype.write = function(input) {\n  this.codec.encode(this, input);\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/encode-buffer.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/encode-stream.js":
/*!********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/encode-stream.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// encode-stream.js\n\nexports.createEncodeStream = EncodeStream;\n\nvar util = __webpack_require__(/*! util */ \"util\");\nvar Transform = __webpack_require__(/*! stream */ \"stream\").Transform;\nvar EncodeBuffer = __webpack_require__(/*! ./encode-buffer */ \"./node_modules/msgpack-lite/lib/encode-buffer.js\").EncodeBuffer;\n\nutil.inherits(EncodeStream, Transform);\n\nvar DEFAULT_OPTIONS = {objectMode: true};\n\nfunction EncodeStream(options) {\n  if (!(this instanceof EncodeStream)) return new EncodeStream(options);\n  if (options) {\n    options.objectMode = true;\n  } else {\n    options = DEFAULT_OPTIONS;\n  }\n  Transform.call(this, options);\n\n  var stream = this;\n  var encoder = this.encoder = new EncodeBuffer(options);\n  encoder.push = function(chunk) {\n    stream.push(chunk);\n  };\n}\n\nEncodeStream.prototype._transform = function(chunk, encoding, callback) {\n  this.encoder.write(chunk);\n  if (callback) callback();\n};\n\nEncodeStream.prototype._flush = function(callback) {\n  this.encoder.flush();\n  if (callback) callback();\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/encode-stream.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/encode.js":
/*!*************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/encode.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// encode.js\n\nexports.encode = encode;\n\nvar EncodeBuffer = __webpack_require__(/*! ./encode-buffer */ \"./node_modules/msgpack-lite/lib/encode-buffer.js\").EncodeBuffer;\n\nfunction encode(input, options) {\n  var encoder = new EncodeBuffer(options);\n  encoder.write(input);\n  return encoder.read();\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/encode.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/encoder.js":
/*!**************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/encoder.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// encoder.js\n\nexports.Encoder = Encoder;\n\nvar EventLite = __webpack_require__(/*! event-lite */ \"./node_modules/event-lite/event-lite.js\");\nvar EncodeBuffer = __webpack_require__(/*! ./encode-buffer */ \"./node_modules/msgpack-lite/lib/encode-buffer.js\").EncodeBuffer;\n\nfunction Encoder(options) {\n  if (!(this instanceof Encoder)) return new Encoder(options);\n  EncodeBuffer.call(this, options);\n}\n\nEncoder.prototype = new EncodeBuffer();\n\nEventLite.mixin(Encoder.prototype);\n\nEncoder.prototype.encode = function(chunk) {\n  this.write(chunk);\n  this.emit(\"data\", this.read());\n};\n\nEncoder.prototype.end = function(chunk) {\n  if (arguments.length) this.encode(chunk);\n  this.flush();\n  this.emit(\"end\");\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/encoder.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/ext-buffer.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext-buffer.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// ext-buffer.js\n\nexports.ExtBuffer = ExtBuffer;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\n\nfunction ExtBuffer(buffer, type) {\n  if (!(this instanceof ExtBuffer)) return new ExtBuffer(buffer, type);\n  this.buffer = Bufferish.from(buffer);\n  this.type = type;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/ext-buffer.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/ext-packer.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext-packer.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// ext-packer.js\n\nexports.setExtPackers = setExtPackers;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar Buffer = Bufferish.global;\nvar packTypedArray = Bufferish.Uint8Array.from;\nvar _encode;\n\nvar ERROR_COLUMNS = {name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1};\n\nfunction setExtPackers(codec) {\n  codec.addExtPacker(0x0E, Error, [packError, encode]);\n  codec.addExtPacker(0x01, EvalError, [packError, encode]);\n  codec.addExtPacker(0x02, RangeError, [packError, encode]);\n  codec.addExtPacker(0x03, ReferenceError, [packError, encode]);\n  codec.addExtPacker(0x04, SyntaxError, [packError, encode]);\n  codec.addExtPacker(0x05, TypeError, [packError, encode]);\n  codec.addExtPacker(0x06, URIError, [packError, encode]);\n\n  codec.addExtPacker(0x0A, RegExp, [packRegExp, encode]);\n  codec.addExtPacker(0x0B, Boolean, [packValueOf, encode]);\n  codec.addExtPacker(0x0C, String, [packValueOf, encode]);\n  codec.addExtPacker(0x0D, Date, [Number, encode]);\n  codec.addExtPacker(0x0F, Number, [packValueOf, encode]);\n\n  if (\"undefined\" !== typeof Uint8Array) {\n    codec.addExtPacker(0x11, Int8Array, packTypedArray);\n    codec.addExtPacker(0x12, Uint8Array, packTypedArray);\n    codec.addExtPacker(0x13, Int16Array, packTypedArray);\n    codec.addExtPacker(0x14, Uint16Array, packTypedArray);\n    codec.addExtPacker(0x15, Int32Array, packTypedArray);\n    codec.addExtPacker(0x16, Uint32Array, packTypedArray);\n    codec.addExtPacker(0x17, Float32Array, packTypedArray);\n\n    // PhantomJS/1.9.7 doesn't have Float64Array\n    if (\"undefined\" !== typeof Float64Array) {\n      codec.addExtPacker(0x18, Float64Array, packTypedArray);\n    }\n\n    // IE10 doesn't have Uint8ClampedArray\n    if (\"undefined\" !== typeof Uint8ClampedArray) {\n      codec.addExtPacker(0x19, Uint8ClampedArray, packTypedArray);\n    }\n\n    codec.addExtPacker(0x1A, ArrayBuffer, packTypedArray);\n    codec.addExtPacker(0x1D, DataView, packTypedArray);\n  }\n\n  if (Bufferish.hasBuffer) {\n    codec.addExtPacker(0x1B, Buffer, Bufferish.from);\n  }\n}\n\nfunction encode(input) {\n  if (!_encode) _encode = __webpack_require__(/*! ./encode */ \"./node_modules/msgpack-lite/lib/encode.js\").encode; // lazy load\n  return _encode(input);\n}\n\nfunction packValueOf(value) {\n  return (value).valueOf();\n}\n\nfunction packRegExp(value) {\n  value = RegExp.prototype.toString.call(value).split(\"/\");\n  value.shift();\n  var out = [value.pop()];\n  out.unshift(value.join(\"/\"));\n  return out;\n}\n\nfunction packError(value) {\n  var out = {};\n  for (var key in ERROR_COLUMNS) {\n    out[key] = value[key];\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/ext-packer.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/ext-unpacker.js":
/*!*******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext-unpacker.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// ext-unpacker.js\n\nexports.setExtUnpackers = setExtUnpackers;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar Buffer = Bufferish.global;\nvar _decode;\n\nvar ERROR_COLUMNS = {name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1};\n\nfunction setExtUnpackers(codec) {\n  codec.addExtUnpacker(0x0E, [decode, unpackError(Error)]);\n  codec.addExtUnpacker(0x01, [decode, unpackError(EvalError)]);\n  codec.addExtUnpacker(0x02, [decode, unpackError(RangeError)]);\n  codec.addExtUnpacker(0x03, [decode, unpackError(ReferenceError)]);\n  codec.addExtUnpacker(0x04, [decode, unpackError(SyntaxError)]);\n  codec.addExtUnpacker(0x05, [decode, unpackError(TypeError)]);\n  codec.addExtUnpacker(0x06, [decode, unpackError(URIError)]);\n\n  codec.addExtUnpacker(0x0A, [decode, unpackRegExp]);\n  codec.addExtUnpacker(0x0B, [decode, unpackClass(Boolean)]);\n  codec.addExtUnpacker(0x0C, [decode, unpackClass(String)]);\n  codec.addExtUnpacker(0x0D, [decode, unpackClass(Date)]);\n  codec.addExtUnpacker(0x0F, [decode, unpackClass(Number)]);\n\n  if (\"undefined\" !== typeof Uint8Array) {\n    codec.addExtUnpacker(0x11, unpackClass(Int8Array));\n    codec.addExtUnpacker(0x12, unpackClass(Uint8Array));\n    codec.addExtUnpacker(0x13, [unpackArrayBuffer, unpackClass(Int16Array)]);\n    codec.addExtUnpacker(0x14, [unpackArrayBuffer, unpackClass(Uint16Array)]);\n    codec.addExtUnpacker(0x15, [unpackArrayBuffer, unpackClass(Int32Array)]);\n    codec.addExtUnpacker(0x16, [unpackArrayBuffer, unpackClass(Uint32Array)]);\n    codec.addExtUnpacker(0x17, [unpackArrayBuffer, unpackClass(Float32Array)]);\n\n    // PhantomJS/1.9.7 doesn't have Float64Array\n    if (\"undefined\" !== typeof Float64Array) {\n      codec.addExtUnpacker(0x18, [unpackArrayBuffer, unpackClass(Float64Array)]);\n    }\n\n    // IE10 doesn't have Uint8ClampedArray\n    if (\"undefined\" !== typeof Uint8ClampedArray) {\n      codec.addExtUnpacker(0x19, unpackClass(Uint8ClampedArray));\n    }\n\n    codec.addExtUnpacker(0x1A, unpackArrayBuffer);\n    codec.addExtUnpacker(0x1D, [unpackArrayBuffer, unpackClass(DataView)]);\n  }\n\n  if (Bufferish.hasBuffer) {\n    codec.addExtUnpacker(0x1B, unpackClass(Buffer));\n  }\n}\n\nfunction decode(input) {\n  if (!_decode) _decode = __webpack_require__(/*! ./decode */ \"./node_modules/msgpack-lite/lib/decode.js\").decode; // lazy load\n  return _decode(input);\n}\n\nfunction unpackRegExp(value) {\n  return RegExp.apply(null, value);\n}\n\nfunction unpackError(Class) {\n  return function(value) {\n    var out = new Class();\n    for (var key in ERROR_COLUMNS) {\n      out[key] = value[key];\n    }\n    return out;\n  };\n}\n\nfunction unpackClass(Class) {\n  return function(value) {\n    return new Class(value);\n  };\n}\n\nfunction unpackArrayBuffer(value) {\n  return (new Uint8Array(value)).buffer;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/ext-unpacker.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/ext.js":
/*!**********************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// ext.js\n\n// load both interfaces\n__webpack_require__(/*! ./read-core */ \"./node_modules/msgpack-lite/lib/read-core.js\");\n__webpack_require__(/*! ./write-core */ \"./node_modules/msgpack-lite/lib/write-core.js\");\n\nexports.createCodec = __webpack_require__(/*! ./codec-base */ \"./node_modules/msgpack-lite/lib/codec-base.js\").createCodec;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/ext.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/flex-buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/flex-buffer.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// flex-buffer.js\n\nexports.FlexDecoder = FlexDecoder;\nexports.FlexEncoder = FlexEncoder;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\n\nvar MIN_BUFFER_SIZE = 2048;\nvar MAX_BUFFER_SIZE = 65536;\nvar BUFFER_SHORTAGE = \"BUFFER_SHORTAGE\";\n\nfunction FlexDecoder() {\n  if (!(this instanceof FlexDecoder)) return new FlexDecoder();\n}\n\nfunction FlexEncoder() {\n  if (!(this instanceof FlexEncoder)) return new FlexEncoder();\n}\n\nFlexDecoder.mixin = mixinFactory(getDecoderMethods());\nFlexDecoder.mixin(FlexDecoder.prototype);\n\nFlexEncoder.mixin = mixinFactory(getEncoderMethods());\nFlexEncoder.mixin(FlexEncoder.prototype);\n\nfunction getDecoderMethods() {\n  return {\n    bufferish: Bufferish,\n    write: write,\n    fetch: fetch,\n    flush: flush,\n    push: push,\n    pull: pull,\n    read: read,\n    reserve: reserve,\n    offset: 0\n  };\n\n  function write(chunk) {\n    var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;\n    this.buffer = prev ? (chunk ? this.bufferish.concat([prev, chunk]) : prev) : chunk;\n    this.offset = 0;\n  }\n\n  function flush() {\n    while (this.offset < this.buffer.length) {\n      var start = this.offset;\n      var value;\n      try {\n        value = this.fetch();\n      } catch (e) {\n        if (e && e.message != BUFFER_SHORTAGE) throw e;\n        // rollback\n        this.offset = start;\n        break;\n      }\n      this.push(value);\n    }\n  }\n\n  function reserve(length) {\n    var start = this.offset;\n    var end = start + length;\n    if (end > this.buffer.length) throw new Error(BUFFER_SHORTAGE);\n    this.offset = end;\n    return start;\n  }\n}\n\nfunction getEncoderMethods() {\n  return {\n    bufferish: Bufferish,\n    write: write,\n    fetch: fetch,\n    flush: flush,\n    push: push,\n    pull: pull,\n    read: read,\n    reserve: reserve,\n    send: send,\n    maxBufferSize: MAX_BUFFER_SIZE,\n    minBufferSize: MIN_BUFFER_SIZE,\n    offset: 0,\n    start: 0\n  };\n\n  function fetch() {\n    var start = this.start;\n    if (start < this.offset) {\n      var end = this.start = this.offset;\n      return Bufferish.prototype.slice.call(this.buffer, start, end);\n    }\n  }\n\n  function flush() {\n    while (this.start < this.offset) {\n      var value = this.fetch();\n      if (value) this.push(value);\n    }\n  }\n\n  function pull() {\n    var buffers = this.buffers || (this.buffers = []);\n    var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];\n    buffers.length = 0; // buffer exhausted\n    return chunk;\n  }\n\n  function reserve(length) {\n    var req = length | 0;\n\n    if (this.buffer) {\n      var size = this.buffer.length;\n      var start = this.offset | 0;\n      var end = start + req;\n\n      // is it long enough?\n      if (end < size) {\n        this.offset = end;\n        return start;\n      }\n\n      // flush current buffer\n      this.flush();\n\n      // resize it to 2x current length\n      length = Math.max(length, Math.min(size * 2, this.maxBufferSize));\n    }\n\n    // minimum buffer size\n    length = Math.max(length, this.minBufferSize);\n\n    // allocate new buffer\n    this.buffer = this.bufferish.alloc(length);\n    this.start = 0;\n    this.offset = req;\n    return 0;\n  }\n\n  function send(buffer) {\n    var length = buffer.length;\n    if (length > this.minBufferSize) {\n      this.flush();\n      this.push(buffer);\n    } else {\n      var offset = this.reserve(length);\n      Bufferish.prototype.copy.call(buffer, this.buffer, offset);\n    }\n  }\n}\n\n// common methods\n\nfunction write() {\n  throw new Error(\"method not implemented: write()\");\n}\n\nfunction fetch() {\n  throw new Error(\"method not implemented: fetch()\");\n}\n\nfunction read() {\n  var length = this.buffers && this.buffers.length;\n\n  // fetch the first result\n  if (!length) return this.fetch();\n\n  // flush current buffer\n  this.flush();\n\n  // read from the results\n  return this.pull();\n}\n\nfunction push(chunk) {\n  var buffers = this.buffers || (this.buffers = []);\n  buffers.push(chunk);\n}\n\nfunction pull() {\n  var buffers = this.buffers || (this.buffers = []);\n  return buffers.shift();\n}\n\nfunction mixinFactory(source) {\n  return mixin;\n\n  function mixin(target) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/flex-buffer.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/read-core.js":
/*!****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/read-core.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// read-core.js\n\nvar ExtBuffer = __webpack_require__(/*! ./ext-buffer */ \"./node_modules/msgpack-lite/lib/ext-buffer.js\").ExtBuffer;\nvar ExtUnpacker = __webpack_require__(/*! ./ext-unpacker */ \"./node_modules/msgpack-lite/lib/ext-unpacker.js\");\nvar readUint8 = __webpack_require__(/*! ./read-format */ \"./node_modules/msgpack-lite/lib/read-format.js\").readUint8;\nvar ReadToken = __webpack_require__(/*! ./read-token */ \"./node_modules/msgpack-lite/lib/read-token.js\");\nvar CodecBase = __webpack_require__(/*! ./codec-base */ \"./node_modules/msgpack-lite/lib/codec-base.js\");\n\nCodecBase.install({\n  addExtUnpacker: addExtUnpacker,\n  getExtUnpacker: getExtUnpacker,\n  init: init\n});\n\nexports.preset = init.call(CodecBase.preset);\n\nfunction getDecoder(options) {\n  var readToken = ReadToken.getReadToken(options);\n  return decode;\n\n  function decode(decoder) {\n    var type = readUint8(decoder);\n    var func = readToken[type];\n    if (!func) throw new Error(\"Invalid type: \" + (type ? (\"0x\" + type.toString(16)) : type));\n    return func(decoder);\n  }\n}\n\nfunction init() {\n  var options = this.options;\n  this.decode = getDecoder(options);\n\n  if (options && options.preset) {\n    ExtUnpacker.setExtUnpackers(this);\n  }\n\n  return this;\n}\n\nfunction addExtUnpacker(etype, unpacker) {\n  var unpackers = this.extUnpackers || (this.extUnpackers = []);\n  unpackers[etype] = CodecBase.filter(unpacker);\n}\n\nfunction getExtUnpacker(type) {\n  var unpackers = this.extUnpackers || (this.extUnpackers = []);\n  return unpackers[type] || extUnpacker;\n\n  function extUnpacker(buffer) {\n    return new ExtBuffer(buffer, type);\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/read-core.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/read-format.js":
/*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/read-format.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// read-format.js\n\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\");\nvar Int64Buffer = __webpack_require__(/*! int64-buffer */ \"./node_modules/int64-buffer/int64-buffer.js\");\nvar Uint64BE = Int64Buffer.Uint64BE;\nvar Int64BE = Int64Buffer.Int64BE;\n\nexports.getReadFormat = getReadFormat;\nexports.readUint8 = uint8;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar BufferProto = __webpack_require__(/*! ./bufferish-proto */ \"./node_modules/msgpack-lite/lib/bufferish-proto.js\");\n\nvar HAS_MAP = (\"undefined\" !== typeof Map);\nvar NO_ASSERT = true;\n\nfunction getReadFormat(options) {\n  var binarraybuffer = Bufferish.hasArrayBuffer && options && options.binarraybuffer;\n  var int64 = options && options.int64;\n  var usemap = HAS_MAP && options && options.usemap;\n\n  var readFormat = {\n    map: (usemap ? map_to_map : map_to_obj),\n    array: array,\n    str: str,\n    bin: (binarraybuffer ? bin_arraybuffer : bin_buffer),\n    ext: ext,\n    uint8: uint8,\n    uint16: uint16,\n    uint32: uint32,\n    uint64: read(8, int64 ? readUInt64BE_int64 : readUInt64BE),\n    int8: int8,\n    int16: int16,\n    int32: int32,\n    int64: read(8, int64 ? readInt64BE_int64 : readInt64BE),\n    float32: read(4, readFloatBE),\n    float64: read(8, readDoubleBE)\n  };\n\n  return readFormat;\n}\n\nfunction map_to_obj(decoder, len) {\n  var value = {};\n  var i;\n  var k = new Array(len);\n  var v = new Array(len);\n\n  var decode = decoder.codec.decode;\n  for (i = 0; i < len; i++) {\n    k[i] = decode(decoder);\n    v[i] = decode(decoder);\n  }\n  for (i = 0; i < len; i++) {\n    value[k[i]] = v[i];\n  }\n  return value;\n}\n\nfunction map_to_map(decoder, len) {\n  var value = new Map();\n  var i;\n  var k = new Array(len);\n  var v = new Array(len);\n\n  var decode = decoder.codec.decode;\n  for (i = 0; i < len; i++) {\n    k[i] = decode(decoder);\n    v[i] = decode(decoder);\n  }\n  for (i = 0; i < len; i++) {\n    value.set(k[i], v[i]);\n  }\n  return value;\n}\n\nfunction array(decoder, len) {\n  var value = new Array(len);\n  var decode = decoder.codec.decode;\n  for (var i = 0; i < len; i++) {\n    value[i] = decode(decoder);\n  }\n  return value;\n}\n\nfunction str(decoder, len) {\n  var start = decoder.reserve(len);\n  var end = start + len;\n  return BufferProto.toString.call(decoder.buffer, \"utf-8\", start, end);\n}\n\nfunction bin_buffer(decoder, len) {\n  var start = decoder.reserve(len);\n  var end = start + len;\n  var buf = BufferProto.slice.call(decoder.buffer, start, end);\n  return Bufferish.from(buf);\n}\n\nfunction bin_arraybuffer(decoder, len) {\n  var start = decoder.reserve(len);\n  var end = start + len;\n  var buf = BufferProto.slice.call(decoder.buffer, start, end);\n  return Bufferish.Uint8Array.from(buf).buffer;\n}\n\nfunction ext(decoder, len) {\n  var start = decoder.reserve(len+1);\n  var type = decoder.buffer[start++];\n  var end = start + len;\n  var unpack = decoder.codec.getExtUnpacker(type);\n  if (!unpack) throw new Error(\"Invalid ext type: \" + (type ? (\"0x\" + type.toString(16)) : type));\n  var buf = BufferProto.slice.call(decoder.buffer, start, end);\n  return unpack(buf);\n}\n\nfunction uint8(decoder) {\n  var start = decoder.reserve(1);\n  return decoder.buffer[start];\n}\n\nfunction int8(decoder) {\n  var start = decoder.reserve(1);\n  var value = decoder.buffer[start];\n  return (value & 0x80) ? value - 0x100 : value;\n}\n\nfunction uint16(decoder) {\n  var start = decoder.reserve(2);\n  var buffer = decoder.buffer;\n  return (buffer[start++] << 8) | buffer[start];\n}\n\nfunction int16(decoder) {\n  var start = decoder.reserve(2);\n  var buffer = decoder.buffer;\n  var value = (buffer[start++] << 8) | buffer[start];\n  return (value & 0x8000) ? value - 0x10000 : value;\n}\n\nfunction uint32(decoder) {\n  var start = decoder.reserve(4);\n  var buffer = decoder.buffer;\n  return (buffer[start++] * 16777216) + (buffer[start++] << 16) + (buffer[start++] << 8) + buffer[start];\n}\n\nfunction int32(decoder) {\n  var start = decoder.reserve(4);\n  var buffer = decoder.buffer;\n  return (buffer[start++] << 24) | (buffer[start++] << 16) | (buffer[start++] << 8) | buffer[start];\n}\n\nfunction read(len, method) {\n  return function(decoder) {\n    var start = decoder.reserve(len);\n    return method.call(decoder.buffer, start, NO_ASSERT);\n  };\n}\n\nfunction readUInt64BE(start) {\n  return new Uint64BE(this, start).toNumber();\n}\n\nfunction readInt64BE(start) {\n  return new Int64BE(this, start).toNumber();\n}\n\nfunction readUInt64BE_int64(start) {\n  return new Uint64BE(this, start);\n}\n\nfunction readInt64BE_int64(start) {\n  return new Int64BE(this, start);\n}\n\nfunction readFloatBE(start) {\n  return ieee754.read(this, start, false, 23, 4);\n}\n\nfunction readDoubleBE(start) {\n  return ieee754.read(this, start, false, 52, 8);\n}\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/read-format.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/read-token.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/read-token.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// read-token.js\n\nvar ReadFormat = __webpack_require__(/*! ./read-format */ \"./node_modules/msgpack-lite/lib/read-format.js\");\n\nexports.getReadToken = getReadToken;\n\nfunction getReadToken(options) {\n  var format = ReadFormat.getReadFormat(options);\n\n  if (options && options.useraw) {\n    return init_useraw(format);\n  } else {\n    return init_token(format);\n  }\n}\n\nfunction init_token(format) {\n  var i;\n  var token = new Array(256);\n\n  // positive fixint -- 0x00 - 0x7f\n  for (i = 0x00; i <= 0x7f; i++) {\n    token[i] = constant(i);\n  }\n\n  // fixmap -- 0x80 - 0x8f\n  for (i = 0x80; i <= 0x8f; i++) {\n    token[i] = fix(i - 0x80, format.map);\n  }\n\n  // fixarray -- 0x90 - 0x9f\n  for (i = 0x90; i <= 0x9f; i++) {\n    token[i] = fix(i - 0x90, format.array);\n  }\n\n  // fixstr -- 0xa0 - 0xbf\n  for (i = 0xa0; i <= 0xbf; i++) {\n    token[i] = fix(i - 0xa0, format.str);\n  }\n\n  // nil -- 0xc0\n  token[0xc0] = constant(null);\n\n  // (never used) -- 0xc1\n  token[0xc1] = null;\n\n  // false -- 0xc2\n  // true -- 0xc3\n  token[0xc2] = constant(false);\n  token[0xc3] = constant(true);\n\n  // bin 8 -- 0xc4\n  // bin 16 -- 0xc5\n  // bin 32 -- 0xc6\n  token[0xc4] = flex(format.uint8, format.bin);\n  token[0xc5] = flex(format.uint16, format.bin);\n  token[0xc6] = flex(format.uint32, format.bin);\n\n  // ext 8 -- 0xc7\n  // ext 16 -- 0xc8\n  // ext 32 -- 0xc9\n  token[0xc7] = flex(format.uint8, format.ext);\n  token[0xc8] = flex(format.uint16, format.ext);\n  token[0xc9] = flex(format.uint32, format.ext);\n\n  // float 32 -- 0xca\n  // float 64 -- 0xcb\n  token[0xca] = format.float32;\n  token[0xcb] = format.float64;\n\n  // uint 8 -- 0xcc\n  // uint 16 -- 0xcd\n  // uint 32 -- 0xce\n  // uint 64 -- 0xcf\n  token[0xcc] = format.uint8;\n  token[0xcd] = format.uint16;\n  token[0xce] = format.uint32;\n  token[0xcf] = format.uint64;\n\n  // int 8 -- 0xd0\n  // int 16 -- 0xd1\n  // int 32 -- 0xd2\n  // int 64 -- 0xd3\n  token[0xd0] = format.int8;\n  token[0xd1] = format.int16;\n  token[0xd2] = format.int32;\n  token[0xd3] = format.int64;\n\n  // fixext 1 -- 0xd4\n  // fixext 2 -- 0xd5\n  // fixext 4 -- 0xd6\n  // fixext 8 -- 0xd7\n  // fixext 16 -- 0xd8\n  token[0xd4] = fix(1, format.ext);\n  token[0xd5] = fix(2, format.ext);\n  token[0xd6] = fix(4, format.ext);\n  token[0xd7] = fix(8, format.ext);\n  token[0xd8] = fix(16, format.ext);\n\n  // str 8 -- 0xd9\n  // str 16 -- 0xda\n  // str 32 -- 0xdb\n  token[0xd9] = flex(format.uint8, format.str);\n  token[0xda] = flex(format.uint16, format.str);\n  token[0xdb] = flex(format.uint32, format.str);\n\n  // array 16 -- 0xdc\n  // array 32 -- 0xdd\n  token[0xdc] = flex(format.uint16, format.array);\n  token[0xdd] = flex(format.uint32, format.array);\n\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n  token[0xde] = flex(format.uint16, format.map);\n  token[0xdf] = flex(format.uint32, format.map);\n\n  // negative fixint -- 0xe0 - 0xff\n  for (i = 0xe0; i <= 0xff; i++) {\n    token[i] = constant(i - 0x100);\n  }\n\n  return token;\n}\n\nfunction init_useraw(format) {\n  var i;\n  var token = init_token(format).slice();\n\n  // raw 8 -- 0xd9\n  // raw 16 -- 0xda\n  // raw 32 -- 0xdb\n  token[0xd9] = token[0xc4];\n  token[0xda] = token[0xc5];\n  token[0xdb] = token[0xc6];\n\n  // fixraw -- 0xa0 - 0xbf\n  for (i = 0xa0; i <= 0xbf; i++) {\n    token[i] = fix(i - 0xa0, format.bin);\n  }\n\n  return token;\n}\n\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nfunction flex(lenFunc, decodeFunc) {\n  return function(decoder) {\n    var len = lenFunc(decoder);\n    return decodeFunc(decoder, len);\n  };\n}\n\nfunction fix(len, method) {\n  return function(decoder) {\n    return method(decoder, len);\n  };\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/read-token.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/write-core.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-core.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// write-core.js\n\nvar ExtBuffer = __webpack_require__(/*! ./ext-buffer */ \"./node_modules/msgpack-lite/lib/ext-buffer.js\").ExtBuffer;\nvar ExtPacker = __webpack_require__(/*! ./ext-packer */ \"./node_modules/msgpack-lite/lib/ext-packer.js\");\nvar WriteType = __webpack_require__(/*! ./write-type */ \"./node_modules/msgpack-lite/lib/write-type.js\");\nvar CodecBase = __webpack_require__(/*! ./codec-base */ \"./node_modules/msgpack-lite/lib/codec-base.js\");\n\nCodecBase.install({\n  addExtPacker: addExtPacker,\n  getExtPacker: getExtPacker,\n  init: init\n});\n\nexports.preset = init.call(CodecBase.preset);\n\nfunction getEncoder(options) {\n  var writeType = WriteType.getWriteType(options);\n  return encode;\n\n  function encode(encoder, value) {\n    var func = writeType[typeof value];\n    if (!func) throw new Error(\"Unsupported type \\\"\" + (typeof value) + \"\\\": \" + value);\n    func(encoder, value);\n  }\n}\n\nfunction init() {\n  var options = this.options;\n  this.encode = getEncoder(options);\n\n  if (options && options.preset) {\n    ExtPacker.setExtPackers(this);\n  }\n\n  return this;\n}\n\nfunction addExtPacker(etype, Class, packer) {\n  packer = CodecBase.filter(packer);\n  var name = Class.name;\n  if (name && name !== \"Object\") {\n    var packers = this.extPackers || (this.extPackers = {});\n    packers[name] = extPacker;\n  } else {\n    // fallback for IE\n    var list = this.extEncoderList || (this.extEncoderList = []);\n    list.unshift([Class, extPacker]);\n  }\n\n  function extPacker(value) {\n    if (packer) value = packer(value);\n    return new ExtBuffer(value, etype);\n  }\n}\n\nfunction getExtPacker(value) {\n  var packers = this.extPackers || (this.extPackers = {});\n  var c = value.constructor;\n  var e = c && c.name && packers[c.name];\n  if (e) return e;\n\n  // fallback for IE\n  var list = this.extEncoderList || (this.extEncoderList = []);\n  var len = list.length;\n  for (var i = 0; i < len; i++) {\n    var pair = list[i];\n    if (c === pair[0]) return pair[1];\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/write-core.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/write-token.js":
/*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-token.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// write-token.js\n\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\");\nvar Int64Buffer = __webpack_require__(/*! int64-buffer */ \"./node_modules/int64-buffer/int64-buffer.js\");\nvar Uint64BE = Int64Buffer.Uint64BE;\nvar Int64BE = Int64Buffer.Int64BE;\n\nvar uint8 = __webpack_require__(/*! ./write-uint8 */ \"./node_modules/msgpack-lite/lib/write-uint8.js\").uint8;\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar Buffer = Bufferish.global;\nvar IS_BUFFER_SHIM = Bufferish.hasBuffer && (\"TYPED_ARRAY_SUPPORT\" in Buffer);\nvar NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer.TYPED_ARRAY_SUPPORT;\nvar Buffer_prototype = Bufferish.hasBuffer && Buffer.prototype || {};\n\nexports.getWriteToken = getWriteToken;\n\nfunction getWriteToken(options) {\n  if (options && options.uint8array) {\n    return init_uint8array();\n  } else if (NO_TYPED_ARRAY || (Bufferish.hasBuffer && options && options.safe)) {\n    return init_safe();\n  } else {\n    return init_token();\n  }\n}\n\nfunction init_uint8array() {\n  var token = init_token();\n\n  // float 32 -- 0xca\n  // float 64 -- 0xcb\n  token[0xca] = writeN(0xca, 4, writeFloatBE);\n  token[0xcb] = writeN(0xcb, 8, writeDoubleBE);\n\n  return token;\n}\n\n// Node.js and browsers with TypedArray\n\nfunction init_token() {\n  // (immediate values)\n  // positive fixint -- 0x00 - 0x7f\n  // nil -- 0xc0\n  // false -- 0xc2\n  // true -- 0xc3\n  // negative fixint -- 0xe0 - 0xff\n  var token = uint8.slice();\n\n  // bin 8 -- 0xc4\n  // bin 16 -- 0xc5\n  // bin 32 -- 0xc6\n  token[0xc4] = write1(0xc4);\n  token[0xc5] = write2(0xc5);\n  token[0xc6] = write4(0xc6);\n\n  // ext 8 -- 0xc7\n  // ext 16 -- 0xc8\n  // ext 32 -- 0xc9\n  token[0xc7] = write1(0xc7);\n  token[0xc8] = write2(0xc8);\n  token[0xc9] = write4(0xc9);\n\n  // float 32 -- 0xca\n  // float 64 -- 0xcb\n  token[0xca] = writeN(0xca, 4, (Buffer_prototype.writeFloatBE || writeFloatBE), true);\n  token[0xcb] = writeN(0xcb, 8, (Buffer_prototype.writeDoubleBE || writeDoubleBE), true);\n\n  // uint 8 -- 0xcc\n  // uint 16 -- 0xcd\n  // uint 32 -- 0xce\n  // uint 64 -- 0xcf\n  token[0xcc] = write1(0xcc);\n  token[0xcd] = write2(0xcd);\n  token[0xce] = write4(0xce);\n  token[0xcf] = writeN(0xcf, 8, writeUInt64BE);\n\n  // int 8 -- 0xd0\n  // int 16 -- 0xd1\n  // int 32 -- 0xd2\n  // int 64 -- 0xd3\n  token[0xd0] = write1(0xd0);\n  token[0xd1] = write2(0xd1);\n  token[0xd2] = write4(0xd2);\n  token[0xd3] = writeN(0xd3, 8, writeInt64BE);\n\n  // str 8 -- 0xd9\n  // str 16 -- 0xda\n  // str 32 -- 0xdb\n  token[0xd9] = write1(0xd9);\n  token[0xda] = write2(0xda);\n  token[0xdb] = write4(0xdb);\n\n  // array 16 -- 0xdc\n  // array 32 -- 0xdd\n  token[0xdc] = write2(0xdc);\n  token[0xdd] = write4(0xdd);\n\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n  token[0xde] = write2(0xde);\n  token[0xdf] = write4(0xdf);\n\n  return token;\n}\n\n// safe mode: for old browsers and who needs asserts\n\nfunction init_safe() {\n  // (immediate values)\n  // positive fixint -- 0x00 - 0x7f\n  // nil -- 0xc0\n  // false -- 0xc2\n  // true -- 0xc3\n  // negative fixint -- 0xe0 - 0xff\n  var token = uint8.slice();\n\n  // bin 8 -- 0xc4\n  // bin 16 -- 0xc5\n  // bin 32 -- 0xc6\n  token[0xc4] = writeN(0xc4, 1, Buffer.prototype.writeUInt8);\n  token[0xc5] = writeN(0xc5, 2, Buffer.prototype.writeUInt16BE);\n  token[0xc6] = writeN(0xc6, 4, Buffer.prototype.writeUInt32BE);\n\n  // ext 8 -- 0xc7\n  // ext 16 -- 0xc8\n  // ext 32 -- 0xc9\n  token[0xc7] = writeN(0xc7, 1, Buffer.prototype.writeUInt8);\n  token[0xc8] = writeN(0xc8, 2, Buffer.prototype.writeUInt16BE);\n  token[0xc9] = writeN(0xc9, 4, Buffer.prototype.writeUInt32BE);\n\n  // float 32 -- 0xca\n  // float 64 -- 0xcb\n  token[0xca] = writeN(0xca, 4, Buffer.prototype.writeFloatBE);\n  token[0xcb] = writeN(0xcb, 8, Buffer.prototype.writeDoubleBE);\n\n  // uint 8 -- 0xcc\n  // uint 16 -- 0xcd\n  // uint 32 -- 0xce\n  // uint 64 -- 0xcf\n  token[0xcc] = writeN(0xcc, 1, Buffer.prototype.writeUInt8);\n  token[0xcd] = writeN(0xcd, 2, Buffer.prototype.writeUInt16BE);\n  token[0xce] = writeN(0xce, 4, Buffer.prototype.writeUInt32BE);\n  token[0xcf] = writeN(0xcf, 8, writeUInt64BE);\n\n  // int 8 -- 0xd0\n  // int 16 -- 0xd1\n  // int 32 -- 0xd2\n  // int 64 -- 0xd3\n  token[0xd0] = writeN(0xd0, 1, Buffer.prototype.writeInt8);\n  token[0xd1] = writeN(0xd1, 2, Buffer.prototype.writeInt16BE);\n  token[0xd2] = writeN(0xd2, 4, Buffer.prototype.writeInt32BE);\n  token[0xd3] = writeN(0xd3, 8, writeInt64BE);\n\n  // str 8 -- 0xd9\n  // str 16 -- 0xda\n  // str 32 -- 0xdb\n  token[0xd9] = writeN(0xd9, 1, Buffer.prototype.writeUInt8);\n  token[0xda] = writeN(0xda, 2, Buffer.prototype.writeUInt16BE);\n  token[0xdb] = writeN(0xdb, 4, Buffer.prototype.writeUInt32BE);\n\n  // array 16 -- 0xdc\n  // array 32 -- 0xdd\n  token[0xdc] = writeN(0xdc, 2, Buffer.prototype.writeUInt16BE);\n  token[0xdd] = writeN(0xdd, 4, Buffer.prototype.writeUInt32BE);\n\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n  token[0xde] = writeN(0xde, 2, Buffer.prototype.writeUInt16BE);\n  token[0xdf] = writeN(0xdf, 4, Buffer.prototype.writeUInt32BE);\n\n  return token;\n}\n\nfunction write1(type) {\n  return function(encoder, value) {\n    var offset = encoder.reserve(2);\n    var buffer = encoder.buffer;\n    buffer[offset++] = type;\n    buffer[offset] = value;\n  };\n}\n\nfunction write2(type) {\n  return function(encoder, value) {\n    var offset = encoder.reserve(3);\n    var buffer = encoder.buffer;\n    buffer[offset++] = type;\n    buffer[offset++] = value >>> 8;\n    buffer[offset] = value;\n  };\n}\n\nfunction write4(type) {\n  return function(encoder, value) {\n    var offset = encoder.reserve(5);\n    var buffer = encoder.buffer;\n    buffer[offset++] = type;\n    buffer[offset++] = value >>> 24;\n    buffer[offset++] = value >>> 16;\n    buffer[offset++] = value >>> 8;\n    buffer[offset] = value;\n  };\n}\n\nfunction writeN(type, len, method, noAssert) {\n  return function(encoder, value) {\n    var offset = encoder.reserve(len + 1);\n    encoder.buffer[offset++] = type;\n    method.call(encoder.buffer, value, offset, noAssert);\n  };\n}\n\nfunction writeUInt64BE(value, offset) {\n  new Uint64BE(this, offset, value);\n}\n\nfunction writeInt64BE(value, offset) {\n  new Int64BE(this, offset, value);\n}\n\nfunction writeFloatBE(value, offset) {\n  ieee754.write(this, value, offset, false, 23, 4);\n}\n\nfunction writeDoubleBE(value, offset) {\n  ieee754.write(this, value, offset, false, 52, 8);\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/write-token.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/write-type.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-type.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// write-type.js\n\nvar IS_ARRAY = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\nvar Int64Buffer = __webpack_require__(/*! int64-buffer */ \"./node_modules/int64-buffer/int64-buffer.js\");\nvar Uint64BE = Int64Buffer.Uint64BE;\nvar Int64BE = Int64Buffer.Int64BE;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar BufferProto = __webpack_require__(/*! ./bufferish-proto */ \"./node_modules/msgpack-lite/lib/bufferish-proto.js\");\nvar WriteToken = __webpack_require__(/*! ./write-token */ \"./node_modules/msgpack-lite/lib/write-token.js\");\nvar uint8 = __webpack_require__(/*! ./write-uint8 */ \"./node_modules/msgpack-lite/lib/write-uint8.js\").uint8;\nvar ExtBuffer = __webpack_require__(/*! ./ext-buffer */ \"./node_modules/msgpack-lite/lib/ext-buffer.js\").ExtBuffer;\n\nvar HAS_UINT8ARRAY = (\"undefined\" !== typeof Uint8Array);\nvar HAS_MAP = (\"undefined\" !== typeof Map);\n\nvar extmap = [];\nextmap[1] = 0xd4;\nextmap[2] = 0xd5;\nextmap[4] = 0xd6;\nextmap[8] = 0xd7;\nextmap[16] = 0xd8;\n\nexports.getWriteType = getWriteType;\n\nfunction getWriteType(options) {\n  var token = WriteToken.getWriteToken(options);\n  var useraw = options && options.useraw;\n  var binarraybuffer = HAS_UINT8ARRAY && options && options.binarraybuffer;\n  var isBuffer = binarraybuffer ? Bufferish.isArrayBuffer : Bufferish.isBuffer;\n  var bin = binarraybuffer ? bin_arraybuffer : bin_buffer;\n  var usemap = HAS_MAP && options && options.usemap;\n  var map = usemap ? map_to_map : obj_to_map;\n\n  var writeType = {\n    \"boolean\": bool,\n    \"function\": nil,\n    \"number\": number,\n    \"object\": (useraw ? object_raw : object),\n    \"string\": _string(useraw ? raw_head_size : str_head_size),\n    \"symbol\": nil,\n    \"undefined\": nil\n  };\n\n  return writeType;\n\n  // false -- 0xc2\n  // true -- 0xc3\n  function bool(encoder, value) {\n    var type = value ? 0xc3 : 0xc2;\n    token[type](encoder, value);\n  }\n\n  function number(encoder, value) {\n    var ivalue = value | 0;\n    var type;\n    if (value !== ivalue) {\n      // float 64 -- 0xcb\n      type = 0xcb;\n      token[type](encoder, value);\n      return;\n    } else if (-0x20 <= ivalue && ivalue <= 0x7F) {\n      // positive fixint -- 0x00 - 0x7f\n      // negative fixint -- 0xe0 - 0xff\n      type = ivalue & 0xFF;\n    } else if (0 <= ivalue) {\n      // uint 8 -- 0xcc\n      // uint 16 -- 0xcd\n      // uint 32 -- 0xce\n      type = (ivalue <= 0xFF) ? 0xcc : (ivalue <= 0xFFFF) ? 0xcd : 0xce;\n    } else {\n      // int 8 -- 0xd0\n      // int 16 -- 0xd1\n      // int 32 -- 0xd2\n      type = (-0x80 <= ivalue) ? 0xd0 : (-0x8000 <= ivalue) ? 0xd1 : 0xd2;\n    }\n    token[type](encoder, ivalue);\n  }\n\n  // uint 64 -- 0xcf\n  function uint64(encoder, value) {\n    var type = 0xcf;\n    token[type](encoder, value.toArray());\n  }\n\n  // int 64 -- 0xd3\n  function int64(encoder, value) {\n    var type = 0xd3;\n    token[type](encoder, value.toArray());\n  }\n\n  // str 8 -- 0xd9\n  // str 16 -- 0xda\n  // str 32 -- 0xdb\n  // fixstr -- 0xa0 - 0xbf\n  function str_head_size(length) {\n    return (length < 32) ? 1 : (length <= 0xFF) ? 2 : (length <= 0xFFFF) ? 3 : 5;\n  }\n\n  // raw 16 -- 0xda\n  // raw 32 -- 0xdb\n  // fixraw -- 0xa0 - 0xbf\n  function raw_head_size(length) {\n    return (length < 32) ? 1 : (length <= 0xFFFF) ? 3 : 5;\n  }\n\n  function _string(head_size) {\n    return string;\n\n    function string(encoder, value) {\n      // prepare buffer\n      var length = value.length;\n      var maxsize = 5 + length * 3;\n      encoder.offset = encoder.reserve(maxsize);\n      var buffer = encoder.buffer;\n\n      // expected header size\n      var expected = head_size(length);\n\n      // expected start point\n      var start = encoder.offset + expected;\n\n      // write string\n      length = BufferProto.write.call(buffer, value, start);\n\n      // actual header size\n      var actual = head_size(length);\n\n      // move content when needed\n      if (expected !== actual) {\n        var targetStart = start + actual - expected;\n        var end = start + length;\n        BufferProto.copy.call(buffer, buffer, targetStart, start, end);\n      }\n\n      // write header\n      var type = (actual === 1) ? (0xa0 + length) : (actual <= 3) ? (0xd7 + actual) : 0xdb;\n      token[type](encoder, length);\n\n      // move cursor\n      encoder.offset += length;\n    }\n  }\n\n  function object(encoder, value) {\n    // null\n    if (value === null) return nil(encoder, value);\n\n    // Buffer\n    if (isBuffer(value)) return bin(encoder, value);\n\n    // Array\n    if (IS_ARRAY(value)) return array(encoder, value);\n\n    // int64-buffer objects\n    if (Uint64BE.isUint64BE(value)) return uint64(encoder, value);\n    if (Int64BE.isInt64BE(value)) return int64(encoder, value);\n\n    // ext formats\n    var packer = encoder.codec.getExtPacker(value);\n    if (packer) value = packer(value);\n    if (value instanceof ExtBuffer) return ext(encoder, value);\n\n    // plain old Objects or Map\n    map(encoder, value);\n  }\n\n  function object_raw(encoder, value) {\n    // Buffer\n    if (isBuffer(value)) return raw(encoder, value);\n\n    // others\n    object(encoder, value);\n  }\n\n  // nil -- 0xc0\n  function nil(encoder, value) {\n    var type = 0xc0;\n    token[type](encoder, value);\n  }\n\n  // fixarray -- 0x90 - 0x9f\n  // array 16 -- 0xdc\n  // array 32 -- 0xdd\n  function array(encoder, value) {\n    var length = value.length;\n    var type = (length < 16) ? (0x90 + length) : (length <= 0xFFFF) ? 0xdc : 0xdd;\n    token[type](encoder, length);\n\n    var encode = encoder.codec.encode;\n    for (var i = 0; i < length; i++) {\n      encode(encoder, value[i]);\n    }\n  }\n\n  // bin 8 -- 0xc4\n  // bin 16 -- 0xc5\n  // bin 32 -- 0xc6\n  function bin_buffer(encoder, value) {\n    var length = value.length;\n    var type = (length < 0xFF) ? 0xc4 : (length <= 0xFFFF) ? 0xc5 : 0xc6;\n    token[type](encoder, length);\n    encoder.send(value);\n  }\n\n  function bin_arraybuffer(encoder, value) {\n    bin_buffer(encoder, new Uint8Array(value));\n  }\n\n  // fixext 1 -- 0xd4\n  // fixext 2 -- 0xd5\n  // fixext 4 -- 0xd6\n  // fixext 8 -- 0xd7\n  // fixext 16 -- 0xd8\n  // ext 8 -- 0xc7\n  // ext 16 -- 0xc8\n  // ext 32 -- 0xc9\n  function ext(encoder, value) {\n    var buffer = value.buffer;\n    var length = buffer.length;\n    var type = extmap[length] || ((length < 0xFF) ? 0xc7 : (length <= 0xFFFF) ? 0xc8 : 0xc9);\n    token[type](encoder, length);\n    uint8[value.type](encoder);\n    encoder.send(buffer);\n  }\n\n  // fixmap -- 0x80 - 0x8f\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n  function obj_to_map(encoder, value) {\n    var keys = Object.keys(value);\n    var length = keys.length;\n    var type = (length < 16) ? (0x80 + length) : (length <= 0xFFFF) ? 0xde : 0xdf;\n    token[type](encoder, length);\n\n    var encode = encoder.codec.encode;\n    keys.forEach(function(key) {\n      encode(encoder, key);\n      encode(encoder, value[key]);\n    });\n  }\n\n  // fixmap -- 0x80 - 0x8f\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n  function map_to_map(encoder, value) {\n    if (!(value instanceof Map)) return obj_to_map(encoder, value);\n\n    var length = value.size;\n    var type = (length < 16) ? (0x80 + length) : (length <= 0xFFFF) ? 0xde : 0xdf;\n    token[type](encoder, length);\n\n    var encode = encoder.codec.encode;\n    value.forEach(function(val, key, m) {\n      encode(encoder, key);\n      encode(encoder, val);\n    });\n  }\n\n  // raw 16 -- 0xda\n  // raw 32 -- 0xdb\n  // fixraw -- 0xa0 - 0xbf\n  function raw(encoder, value) {\n    var length = value.length;\n    var type = (length < 32) ? (0xa0 + length) : (length <= 0xFFFF) ? 0xda : 0xdb;\n    token[type](encoder, length);\n    encoder.send(value);\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/write-type.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/write-uint8.js":
/*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-uint8.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// write-unit8.js\n\nvar constant = exports.uint8 = new Array(256);\n\nfor (var i = 0x00; i <= 0xFF; i++) {\n  constant[i] = write0(i);\n}\n\nfunction write0(type) {\n  return function(encoder) {\n    var offset = encoder.reserve(1);\n    encoder.buffer[offset] = type;\n  };\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/msgpack-lite/lib/write-uint8.js?");

/***/ }),

/***/ "./node_modules/nice-try/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/nice-try/src/index.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Tries to execute a function and discards any error that occurs.\n * @param {Function} fn - Function that might or might not throw an error.\n * @returns {?*} Return-value of the function when no error occurred.\n */\nmodule.exports = function(fn) {\n\n\ttry { return fn() } catch (e) {}\n\n}\n\n//# sourceURL=webpack://coc.nvim/./node_modules/nice-try/src/index.js?");

/***/ }),

/***/ "./node_modules/node-int64/Int64.js":
/*!******************************************!*\
  !*** ./node_modules/node-int64/Int64.js ***!
  \******************************************/
/***/ ((module) => {

eval("//     Int64.js\n//\n//     Copyright (c) 2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n/**\n * Support for handling 64-bit int numbers in Javascript (node.js)\n *\n * JS Numbers are IEEE-754 binary double-precision floats, which limits the\n * range of values that can be represented with integer precision to:\n *\n * 2^^53 <= N <= 2^53\n *\n * Int64 objects wrap a node Buffer that holds the 8-bytes of int64 data.  These\n * objects operate directly on the buffer which means that if they are created\n * using an existing buffer then setting the value will modify the Buffer, and\n * vice-versa.\n *\n * Internal Representation\n *\n * The internal buffer format is Big Endian.  I.e. the most-significant byte is\n * at buffer[0], the least-significant at buffer[7].  For the purposes of\n * converting to/from JS native numbers, the value is assumed to be a signed\n * integer stored in 2's complement form.\n *\n * For details about IEEE-754 see:\n * http://en.wikipedia.org/wiki/Double_precision_floating-point_format\n */\n\n// Useful masks and values for bit twiddling\nvar MASK31 =  0x7fffffff, VAL31 = 0x80000000;\nvar MASK32 =  0xffffffff, VAL32 = 0x100000000;\n\n// Map for converting hex octets to strings\nvar _HEX = [];\nfor (var i = 0; i < 256; i++) {\n  _HEX[i] = (i > 0xF ? '' : '0') + i.toString(16);\n}\n\n//\n// Int64\n//\n\n/**\n * Constructor accepts any of the following argument types:\n *\n * new Int64(buffer[, offset=0]) - Existing Buffer with byte offset\n * new Int64(Uint8Array[, offset=0]) - Existing Uint8Array with a byte offset\n * new Int64(string)             - Hex string (throws if n is outside int64 range)\n * new Int64(number)             - Number (throws if n is outside int64 range)\n * new Int64(hi, lo)             - Raw bits as two 32-bit values\n */\nvar Int64 = module.exports = function(a1, a2) {\n  if (a1 instanceof Buffer) {\n    this.buffer = a1;\n    this.offset = a2 || 0;\n  } else if (Object.prototype.toString.call(a1) == '[object Uint8Array]') {\n    // Under Browserify, Buffers can extend Uint8Arrays rather than an\n    // instance of Buffer. We could assume the passed in Uint8Array is actually\n    // a buffer but that won't handle the case where a raw Uint8Array is passed\n    // in. We construct a new Buffer just in case.\n    this.buffer = new Buffer(a1);\n    this.offset = a2 || 0;\n  } else {\n    this.buffer = this.buffer || new Buffer(8);\n    this.offset = 0;\n    this.setValue.apply(this, arguments);\n  }\n};\n\n\n// Max integer value that JS can accurately represent\nInt64.MAX_INT = Math.pow(2, 53);\n\n// Min integer value that JS can accurately represent\nInt64.MIN_INT = -Math.pow(2, 53);\n\nInt64.prototype = {\n\n  constructor: Int64,\n\n  /**\n   * Do in-place 2's compliment.  See\n   * http://en.wikipedia.org/wiki/Two's_complement\n   */\n  _2scomp: function() {\n    var b = this.buffer, o = this.offset, carry = 1;\n    for (var i = o + 7; i >= o; i--) {\n      var v = (b[i] ^ 0xff) + carry;\n      b[i] = v & 0xff;\n      carry = v >> 8;\n    }\n  },\n\n  /**\n   * Set the value. Takes any of the following arguments:\n   *\n   * setValue(string) - A hexidecimal string\n   * setValue(number) - Number (throws if n is outside int64 range)\n   * setValue(hi, lo) - Raw bits as two 32-bit values\n   */\n  setValue: function(hi, lo) {\n    var negate = false;\n    if (arguments.length == 1) {\n      if (typeof(hi) == 'number') {\n        // Simplify bitfield retrieval by using abs() value.  We restore sign\n        // later\n        negate = hi < 0;\n        hi = Math.abs(hi);\n        lo = hi % VAL32;\n        hi = hi / VAL32;\n        if (hi > VAL32) throw new RangeError(hi  + ' is outside Int64 range');\n        hi = hi | 0;\n      } else if (typeof(hi) == 'string') {\n        hi = (hi + '').replace(/^0x/, '');\n        lo = hi.substr(-8);\n        hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : '';\n        hi = parseInt(hi, 16);\n        lo = parseInt(lo, 16);\n      } else {\n        throw new Error(hi + ' must be a Number or String');\n      }\n    }\n\n    // Technically we should throw if hi or lo is outside int32 range here, but\n    // it's not worth the effort. Anything past the 32'nd bit is ignored.\n\n    // Copy bytes to buffer\n    var b = this.buffer, o = this.offset;\n    for (var i = 7; i >= 0; i--) {\n      b[o+i] = lo & 0xff;\n      lo = i == 4 ? hi : lo >>> 8;\n    }\n\n    // Restore sign of passed argument\n    if (negate) this._2scomp();\n  },\n\n  /**\n   * Convert to a native JS number.\n   *\n   * WARNING: Do not expect this value to be accurate to integer precision for\n   * large (positive or negative) numbers!\n   *\n   * @param allowImprecise If true, no check is performed to verify the\n   * returned value is accurate to integer precision.  If false, imprecise\n   * numbers (very large positive or negative numbers) will be forced to +/-\n   * Infinity.\n   */\n  toNumber: function(allowImprecise) {\n    var b = this.buffer, o = this.offset;\n\n    // Running sum of octets, doing a 2's complement\n    var negate = b[o] & 0x80, x = 0, carry = 1;\n    for (var i = 7, m = 1; i >= 0; i--, m *= 256) {\n      var v = b[o+i];\n\n      // 2's complement for negative numbers\n      if (negate) {\n        v = (v ^ 0xff) + carry;\n        carry = v >> 8;\n        v = v & 0xff;\n      }\n\n      x += v * m;\n    }\n\n    // Return Infinity if we've lost integer precision\n    if (!allowImprecise && x >= Int64.MAX_INT) {\n      return negate ? -Infinity : Infinity;\n    }\n\n    return negate ? -x : x;\n  },\n\n  /**\n   * Convert to a JS Number. Returns +/-Infinity for values that can't be\n   * represented to integer precision.\n   */\n  valueOf: function() {\n    return this.toNumber(false);\n  },\n\n  /**\n   * Return string value\n   *\n   * @param radix Just like Number#toString()'s radix\n   */\n  toString: function(radix) {\n    return this.valueOf().toString(radix || 10);\n  },\n\n  /**\n   * Return a string showing the buffer octets, with MSB on the left.\n   *\n   * @param sep separator string. default is '' (empty string)\n   */\n  toOctetString: function(sep) {\n    var out = new Array(8);\n    var b = this.buffer, o = this.offset;\n    for (var i = 0; i < 8; i++) {\n      out[i] = _HEX[b[o+i]];\n    }\n    return out.join(sep || '');\n  },\n\n  /**\n   * Returns the int64's 8 bytes in a buffer.\n   *\n   * @param {bool} [rawBuffer=false]  If no offset and this is true, return the internal buffer.  Should only be used if\n   *                                  you're discarding the Int64 afterwards, as it breaks encapsulation.\n   */\n  toBuffer: function(rawBuffer) {\n    if (rawBuffer && this.offset === 0) return this.buffer;\n\n    var out = new Buffer(8);\n    this.buffer.copy(out, 0, this.offset, this.offset + 8);\n    return out;\n  },\n\n  /**\n   * Copy 8 bytes of int64 into target buffer at target offset.\n   *\n   * @param {Buffer} targetBuffer       Buffer to copy into.\n   * @param {number} [targetOffset=0]   Offset into target buffer.\n   */\n  copy: function(targetBuffer, targetOffset) {\n    this.buffer.copy(targetBuffer, targetOffset || 0, this.offset, this.offset + 8);\n  },\n\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other in sort order.\n   *\n   * @param {Int64} other  Other Int64 to compare.\n   */\n  compare: function(other) {\n\n    // If sign bits differ ...\n    if ((this.buffer[this.offset] & 0x80) != (other.buffer[other.offset] & 0x80)) {\n      return other.buffer[other.offset] - this.buffer[this.offset];\n    }\n\n    // otherwise, compare bytes lexicographically\n    for (var i = 0; i < 8; i++) {\n      if (this.buffer[this.offset+i] !== other.buffer[other.offset+i]) {\n        return this.buffer[this.offset+i] - other.buffer[other.offset+i];\n      }\n    }\n    return 0;\n  },\n\n  /**\n   * Returns a boolean indicating if this integer is equal to other.\n   *\n   * @param {Int64} other  Other Int64 to compare.\n   */\n  equals: function(other) {\n    return this.compare(other) === 0;\n  },\n\n  /**\n   * Pretty output in console.log\n   */\n  inspect: function() {\n    return '[Int64 value:' + this + ' octets:' + this.toOctetString(' ') + ']';\n  }\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/node-int64/Int64.js?");

/***/ }),

/***/ "./node_modules/object-keys/implementation.js":
/*!****************************************************!*\
  !*** ./node_modules/object-keys/implementation.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar keysShim;\nif (!Object.keys) {\n\t// modified from https://github.com/es-shims/es5-shim\n\tvar has = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\tvar isArgs = __webpack_require__(/*! ./isArguments */ \"./node_modules/object-keys/isArguments.js\"); // eslint-disable-line global-require\n\tvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\tvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\n\tvar hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');\n\tvar dontEnums = [\n\t\t'toString',\n\t\t'toLocaleString',\n\t\t'valueOf',\n\t\t'hasOwnProperty',\n\t\t'isPrototypeOf',\n\t\t'propertyIsEnumerable',\n\t\t'constructor'\n\t];\n\tvar equalsConstructorPrototype = function (o) {\n\t\tvar ctor = o.constructor;\n\t\treturn ctor && ctor.prototype === o;\n\t};\n\tvar excludedKeys = {\n\t\t$applicationCache: true,\n\t\t$console: true,\n\t\t$external: true,\n\t\t$frame: true,\n\t\t$frameElement: true,\n\t\t$frames: true,\n\t\t$innerHeight: true,\n\t\t$innerWidth: true,\n\t\t$onmozfullscreenchange: true,\n\t\t$onmozfullscreenerror: true,\n\t\t$outerHeight: true,\n\t\t$outerWidth: true,\n\t\t$pageXOffset: true,\n\t\t$pageYOffset: true,\n\t\t$parent: true,\n\t\t$scrollLeft: true,\n\t\t$scrollTop: true,\n\t\t$scrollX: true,\n\t\t$scrollY: true,\n\t\t$self: true,\n\t\t$webkitIndexedDB: true,\n\t\t$webkitStorageInfo: true,\n\t\t$window: true\n\t};\n\tvar hasAutomationEqualityBug = (function () {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined') { return false; }\n\t\tfor (var k in window) {\n\t\t\ttry {\n\t\t\t\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tequalsConstructorPrototype(window[k]);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}());\n\tvar equalsConstructorPrototypeIfNotBuggy = function (o) {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t}\n\t\ttry {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tkeysShim = function keys(object) {\n\t\tvar isObject = object !== null && typeof object === 'object';\n\t\tvar isFunction = toStr.call(object) === '[object Function]';\n\t\tvar isArguments = isArgs(object);\n\t\tvar isString = isObject && toStr.call(object) === '[object String]';\n\t\tvar theKeys = [];\n\n\t\tif (!isObject && !isFunction && !isArguments) {\n\t\t\tthrow new TypeError('Object.keys called on a non-object');\n\t\t}\n\n\t\tvar skipProto = hasProtoEnumBug && isFunction;\n\t\tif (isString && object.length > 0 && !has.call(object, 0)) {\n\t\t\tfor (var i = 0; i < object.length; ++i) {\n\t\t\t\ttheKeys.push(String(i));\n\t\t\t}\n\t\t}\n\n\t\tif (isArguments && object.length > 0) {\n\t\t\tfor (var j = 0; j < object.length; ++j) {\n\t\t\t\ttheKeys.push(String(j));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var name in object) {\n\t\t\t\tif (!(skipProto && name === 'prototype') && has.call(object, name)) {\n\t\t\t\t\ttheKeys.push(String(name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\n\n\t\t\tfor (var k = 0; k < dontEnums.length; ++k) {\n\t\t\t\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\n\t\t\t\t\ttheKeys.push(dontEnums[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theKeys;\n\t};\n}\nmodule.exports = keysShim;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/object-keys/implementation.js?");

/***/ }),

/***/ "./node_modules/object-keys/index.js":
/*!*******************************************!*\
  !*** ./node_modules/object-keys/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar slice = Array.prototype.slice;\nvar isArgs = __webpack_require__(/*! ./isArguments */ \"./node_modules/object-keys/isArguments.js\");\n\nvar origKeys = Object.keys;\nvar keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(/*! ./implementation */ \"./node_modules/object-keys/implementation.js\");\n\nvar originalKeys = Object.keys;\n\nkeysShim.shim = function shimObjectKeys() {\n\tif (Object.keys) {\n\t\tvar keysWorksWithArguments = (function () {\n\t\t\t// Safari 5.0 bug\n\t\t\tvar args = Object.keys(arguments);\n\t\t\treturn args && args.length === arguments.length;\n\t\t}(1, 2));\n\t\tif (!keysWorksWithArguments) {\n\t\t\tObject.keys = function keys(object) { // eslint-disable-line func-name-matching\n\t\t\t\tif (isArgs(object)) {\n\t\t\t\t\treturn originalKeys(slice.call(object));\n\t\t\t\t}\n\t\t\t\treturn originalKeys(object);\n\t\t\t};\n\t\t}\n\t} else {\n\t\tObject.keys = keysShim;\n\t}\n\treturn Object.keys || keysShim;\n};\n\nmodule.exports = keysShim;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/object-keys/index.js?");

/***/ }),

/***/ "./node_modules/object-keys/isArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/object-keys/isArguments.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar toStr = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toStr.call(value);\n\tvar isArgs = str === '[object Arguments]';\n\tif (!isArgs) {\n\t\tisArgs = str !== '[object Array]' &&\n\t\t\tvalue !== null &&\n\t\t\ttypeof value === 'object' &&\n\t\t\ttypeof value.length === 'number' &&\n\t\t\tvalue.length >= 0 &&\n\t\t\ttoStr.call(value.callee) === '[object Function]';\n\t}\n\treturn isArgs;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/object-keys/isArguments.js?");

/***/ }),

/***/ "./node_modules/once/once.js":
/*!***********************************!*\
  !*** ./node_modules/once/once.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var wrappy = __webpack_require__(/*! wrappy */ \"./node_modules/wrappy/wrappy.js\")\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/once/once.js?");

/***/ }),

/***/ "./node_modules/p-finally/index.js":
/*!*****************************************!*\
  !*** ./node_modules/p-finally/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = (promise, onFinally) => {\n\tonFinally = onFinally || (() => {});\n\n\treturn promise.then(\n\t\tval => new Promise(resolve => {\n\t\t\tresolve(onFinally());\n\t\t}).then(() => val),\n\t\terr => new Promise(resolve => {\n\t\t\tresolve(onFinally());\n\t\t}).then(() => {\n\t\t\tthrow err;\n\t\t})\n\t);\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/p-finally/index.js?");

/***/ }),

/***/ "./node_modules/path-is-absolute/index.js":
/*!************************************************!*\
  !*** ./node_modules/path-is-absolute/index.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction posix(path) {\n\treturn path.charAt(0) === '/';\n}\n\nfunction win32(path) {\n\t// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n\tvar splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\tvar result = splitDeviceRe.exec(path);\n\tvar device = result[1] || '';\n\tvar isUnc = Boolean(device && device.charAt(1) !== ':');\n\n\t// UNC paths are always absolute\n\treturn Boolean(result[2] || isUnc);\n}\n\nmodule.exports = process.platform === 'win32' ? win32 : posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/path-is-absolute/index.js?");

/***/ }),

/***/ "./node_modules/path-key/index.js":
/*!****************************************!*\
  !*** ./node_modules/path-key/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = opts => {\n\topts = opts || {};\n\n\tconst env = opts.env || process.env;\n\tconst platform = opts.platform || process.platform;\n\n\tif (platform !== 'win32') {\n\t\treturn 'PATH';\n\t}\n\n\treturn Object.keys(env).find(x => x.toUpperCase() === 'PATH') || 'Path';\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/path-key/index.js?");

/***/ }),

/***/ "./node_modules/process-nextick-args/index.js":
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nif (typeof process === 'undefined' ||\n    !process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/process-nextick-args/index.js?");

/***/ }),

/***/ "./node_modules/promise.prototype.finally/implementation.js":
/*!******************************************************************!*\
  !*** ./node_modules/promise.prototype.finally/implementation.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar requirePromise = __webpack_require__(/*! ./requirePromise */ \"./node_modules/promise.prototype.finally/requirePromise.js\");\n\nrequirePromise();\n\nvar IsCallable = __webpack_require__(/*! es-abstract/2018/IsCallable */ \"./node_modules/es-abstract/2018/IsCallable.js\");\nvar SpeciesConstructor = __webpack_require__(/*! es-abstract/2018/SpeciesConstructor */ \"./node_modules/es-abstract/2018/SpeciesConstructor.js\");\nvar Type = __webpack_require__(/*! es-abstract/2018/Type */ \"./node_modules/es-abstract/2018/Type.js\");\n\nvar promiseResolve = function PromiseResolve(C, value) {\n\treturn new C(function (resolve) {\n\t\tresolve(value);\n\t});\n};\n\nvar OriginalPromise = Promise;\n\nvar createThenFinally = function CreateThenFinally(C, onFinally) {\n\treturn function (value) {\n\t\tvar result = onFinally();\n\t\tvar promise = promiseResolve(C, result);\n\t\tvar valueThunk = function () {\n\t\t\treturn value;\n\t\t};\n\t\treturn promise.then(valueThunk);\n\t};\n};\n\nvar createCatchFinally = function CreateCatchFinally(C, onFinally) {\n\treturn function (reason) {\n\t\tvar result = onFinally();\n\t\tvar promise = promiseResolve(C, result);\n\t\tvar thrower = function () {\n\t\t\tthrow reason;\n\t\t};\n\t\treturn promise.then(thrower);\n\t};\n};\n\nvar promiseFinally = function finally_(onFinally) {\n\t/* eslint no-invalid-this: 0 */\n\n\tvar promise = this;\n\n\tif (Type(promise) !== 'Object') {\n\t\tthrow new TypeError('receiver is not an Object');\n\t}\n\n\tvar C = SpeciesConstructor(promise, OriginalPromise); // may throw\n\n\tvar thenFinally = onFinally;\n\tvar catchFinally = onFinally;\n\tif (IsCallable(onFinally)) {\n\t\tthenFinally = createThenFinally(C, onFinally);\n\t\tcatchFinally = createCatchFinally(C, onFinally);\n\t}\n\n\treturn promise.then(thenFinally, catchFinally);\n};\n\nif (Object.getOwnPropertyDescriptor) {\n\tvar descriptor = Object.getOwnPropertyDescriptor(promiseFinally, 'name');\n\tif (descriptor && descriptor.configurable) {\n\t\tObject.defineProperty(promiseFinally, 'name', { configurable: true, value: 'finally' });\n\t}\n}\n\nmodule.exports = promiseFinally;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/promise.prototype.finally/implementation.js?");

/***/ }),

/***/ "./node_modules/promise.prototype.finally/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/promise.prototype.finally/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\nvar define = __webpack_require__(/*! define-properties */ \"./node_modules/define-properties/index.js\");\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/promise.prototype.finally/implementation.js\");\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./node_modules/promise.prototype.finally/polyfill.js\");\nvar shim = __webpack_require__(/*! ./shim */ \"./node_modules/promise.prototype.finally/shim.js\");\n\nvar bound = bind.call(Function.call, getPolyfill());\n\ndefine(bound, {\n\tgetPolyfill: getPolyfill,\n\timplementation: implementation,\n\tshim: shim\n});\n\nmodule.exports = bound;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/promise.prototype.finally/index.js?");

/***/ }),

/***/ "./node_modules/promise.prototype.finally/polyfill.js":
/*!************************************************************!*\
  !*** ./node_modules/promise.prototype.finally/polyfill.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar requirePromise = __webpack_require__(/*! ./requirePromise */ \"./node_modules/promise.prototype.finally/requirePromise.js\");\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/promise.prototype.finally/implementation.js\");\n\nmodule.exports = function getPolyfill() {\n\trequirePromise();\n\treturn typeof Promise.prototype['finally'] === 'function' ? Promise.prototype['finally'] : implementation;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/promise.prototype.finally/polyfill.js?");

/***/ }),

/***/ "./node_modules/promise.prototype.finally/requirePromise.js":
/*!******************************************************************!*\
  !*** ./node_modules/promise.prototype.finally/requirePromise.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function requirePromise() {\n\tif (typeof Promise !== 'function') {\n\t\tthrow new TypeError('`Promise.prototype.finally` requires a global `Promise` be available.');\n\t}\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/promise.prototype.finally/requirePromise.js?");

/***/ }),

/***/ "./node_modules/promise.prototype.finally/shim.js":
/*!********************************************************!*\
  !*** ./node_modules/promise.prototype.finally/shim.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar requirePromise = __webpack_require__(/*! ./requirePromise */ \"./node_modules/promise.prototype.finally/requirePromise.js\");\n\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./node_modules/promise.prototype.finally/polyfill.js\");\nvar define = __webpack_require__(/*! define-properties */ \"./node_modules/define-properties/index.js\");\n\nmodule.exports = function shimPromiseFinally() {\n\trequirePromise();\n\n\tvar polyfill = getPolyfill();\n\tdefine(Promise.prototype, { 'finally': polyfill }, {\n\t\t'finally': function testFinally() {\n\t\t\treturn Promise.prototype['finally'] !== polyfill;\n\t\t}\n\t});\n\treturn polyfill;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/promise.prototype.finally/shim.js?");

/***/ }),

/***/ "./node_modules/pump/index.js":
/*!************************************!*\
  !*** ./node_modules/pump/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var once = __webpack_require__(/*! once */ \"./node_modules/once/once.js\")\nvar eos = __webpack_require__(/*! end-of-stream */ \"./node_modules/end-of-stream/index.js\")\nvar fs = __webpack_require__(/*! fs */ \"fs\") // we only need fs to get the ReadStream and WriteStream prototypes\n\nvar noop = function () {}\nvar ancient = /^v?\\.0/.test(process.version)\n\nvar isFn = function (fn) {\n  return typeof fn === 'function'\n}\n\nvar isFS = function (stream) {\n  if (!ancient) return false // newer node version do not need to care about fs is a special way\n  if (!fs) return false // browser\n  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)\n}\n\nvar isRequest = function (stream) {\n  return stream.setHeader && isFn(stream.abort)\n}\n\nvar destroyer = function (stream, reading, writing, callback) {\n  callback = once(callback)\n\n  var closed = false\n  stream.on('close', function () {\n    closed = true\n  })\n\n  eos(stream, {readable: reading, writable: writing}, function (err) {\n    if (err) return callback(err)\n    closed = true\n    callback()\n  })\n\n  var destroyed = false\n  return function (err) {\n    if (closed) return\n    if (destroyed) return\n    destroyed = true\n\n    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks\n    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want\n\n    if (isFn(stream.destroy)) return stream.destroy()\n\n    callback(err || new Error('stream was destroyed'))\n  }\n}\n\nvar call = function (fn) {\n  fn()\n}\n\nvar pipe = function (from, to) {\n  return from.pipe(to)\n}\n\nvar pump = function () {\n  var streams = Array.prototype.slice.call(arguments)\n  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop\n\n  if (Array.isArray(streams[0])) streams = streams[0]\n  if (streams.length < 2) throw new Error('pump requires two streams per minimum')\n\n  var error\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1\n    var writing = i > 0\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err\n      if (err) destroys.forEach(call)\n      if (reading) return\n      destroys.forEach(call)\n      callback(error)\n    })\n  })\n\n  return streams.reduce(pipe)\n}\n\nmodule.exports = pump\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/pump/index.js?");

/***/ }),

/***/ "./node_modules/rc/index.js":
/*!**********************************!*\
  !*** ./node_modules/rc/index.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var cc   = __webpack_require__(/*! ./lib/utils */ \"./node_modules/rc/lib/utils.js\")\nvar join = __webpack_require__(/*! path */ \"path\").join\nvar deepExtend = __webpack_require__(/*! deep-extend */ \"./node_modules/deep-extend/lib/deep-extend.js\")\nvar etc = '/etc'\nvar win = process.platform === \"win32\"\nvar home = win\n           ? process.env.USERPROFILE\n           : process.env.HOME\n\nmodule.exports = function (name, defaults, argv, parse) {\n  if('string' !== typeof name)\n    throw new Error('rc(name): name *must* be string')\n  if(!argv)\n    argv = __webpack_require__(/*! minimist */ \"./node_modules/minimist/index.js\")(process.argv.slice(2))\n  defaults = (\n      'string' === typeof defaults\n    ? cc.json(defaults) : defaults\n    ) || {}\n\n  parse = parse || cc.parse\n\n  var env = cc.env(name + '_')\n\n  var configs = [defaults]\n  var configFiles = []\n  function addConfigFile (file) {\n    if (configFiles.indexOf(file) >= 0) return\n    var fileConfig = cc.file(file)\n    if (fileConfig) {\n      configs.push(parse(fileConfig))\n      configFiles.push(file)\n    }\n  }\n\n  // which files do we look at?\n  if (!win)\n   [join(etc, name, 'config'),\n    join(etc, name + 'rc')].forEach(addConfigFile)\n  if (home)\n   [join(home, '.config', name, 'config'),\n    join(home, '.config', name),\n    join(home, '.' + name, 'config'),\n    join(home, '.' + name + 'rc')].forEach(addConfigFile)\n  addConfigFile(cc.find('.'+name+'rc'))\n  if (env.config) addConfigFile(env.config)\n  if (argv.config) addConfigFile(argv.config)\n\n  return deepExtend.apply(null, configs.concat([\n    env,\n    argv,\n    configFiles.length ? {configs: configFiles, config: configFiles[configFiles.length - 1]} : undefined,\n  ]))\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/rc/index.js?");

/***/ }),

/***/ "./node_modules/rc/lib/utils.js":
/*!**************************************!*\
  !*** ./node_modules/rc/lib/utils.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar fs   = __webpack_require__(/*! fs */ \"fs\")\nvar ini  = __webpack_require__(/*! ini */ \"./node_modules/ini/ini.js\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar stripJsonComments = __webpack_require__(/*! strip-json-comments */ \"./node_modules/rc/node_modules/strip-json-comments/index.js\")\n\nvar parse = exports.parse = function (content) {\n\n  //if it ends in .json or starts with { then it must be json.\n  //must be done this way, because ini accepts everything.\n  //can't just try and parse it and let it throw if it's not ini.\n  //everything is ini. even json with a syntax error.\n\n  if(/^\\s*{/.test(content))\n    return JSON.parse(stripJsonComments(content))\n  return ini.parse(content)\n\n}\n\nvar file = exports.file = function () {\n  var args = [].slice.call(arguments).filter(function (arg) { return arg != null })\n\n  //path.join breaks if it's a not a string, so just skip this.\n  for(var i in args)\n    if('string' !== typeof args[i])\n      return\n\n  var file = path.join.apply(null, args)\n  var content\n  try {\n    return fs.readFileSync(file,'utf-8')\n  } catch (err) {\n    return\n  }\n}\n\nvar json = exports.json = function () {\n  var content = file.apply(null, arguments)\n  return content ? parse(content) : null\n}\n\nvar env = exports.env = function (prefix, env) {\n  env = env || process.env\n  var obj = {}\n  var l = prefix.length\n  for(var k in env) {\n    if(k.toLowerCase().indexOf(prefix.toLowerCase()) === 0) {\n\n      var keypath = k.substring(l).split('__')\n\n      // Trim empty strings from keypath array\n      var _emptyStringIndex\n      while ((_emptyStringIndex=keypath.indexOf('')) > -1) {\n        keypath.splice(_emptyStringIndex, 1)\n      }\n\n      var cursor = obj\n      keypath.forEach(function _buildSubObj(_subkey,i){\n\n        // (check for _subkey first so we ignore empty strings)\n        // (check for cursor to avoid assignment to primitive objects)\n        if (!_subkey || typeof cursor !== 'object')\n          return\n\n        // If this is the last key, just stuff the value in there\n        // Assigns actual value from env variable to final key\n        // (unless it's just an empty string- in that case use the last valid key)\n        if (i === keypath.length-1)\n          cursor[_subkey] = env[k]\n\n\n        // Build sub-object if nothing already exists at the keypath\n        if (cursor[_subkey] === undefined)\n          cursor[_subkey] = {}\n\n        // Increment cursor used to track the object at the current depth\n        cursor = cursor[_subkey]\n\n      })\n\n    }\n\n  }\n\n  return obj\n}\n\nvar find = exports.find = function () {\n  var rel = path.join.apply(null, [].slice.call(arguments))\n\n  function find(start, rel) {\n    var file = path.join(start, rel)\n    try {\n      fs.statSync(file)\n      return file\n    } catch (err) {\n      if(path.dirname(start) !== start) // root\n        return find(path.dirname(start), rel)\n    }\n  }\n  return find(process.cwd(), rel)\n}\n\n\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/rc/lib/utils.js?");

/***/ }),

/***/ "./node_modules/rc/node_modules/strip-json-comments/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rc/node_modules/strip-json-comments/index.js ***!
  \*******************************************************************/
/***/ ((module) => {

"use strict";
eval("\nvar singleComment = 1;\nvar multiComment = 2;\n\nfunction stripWithoutWhitespace() {\n\treturn '';\n}\n\nfunction stripWithWhitespace(str, start, end) {\n\treturn str.slice(start, end).replace(/\\S/g, ' ');\n}\n\nmodule.exports = function (str, opts) {\n\topts = opts || {};\n\n\tvar currentChar;\n\tvar nextChar;\n\tvar insideString = false;\n\tvar insideComment = false;\n\tvar offset = 0;\n\tvar ret = '';\n\tvar strip = opts.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;\n\n\tfor (var i = 0; i < str.length; i++) {\n\t\tcurrentChar = str[i];\n\t\tnextChar = str[i + 1];\n\n\t\tif (!insideComment && currentChar === '\"') {\n\t\t\tvar escaped = str[i - 1] === '\\\\' && str[i - 2] !== '\\\\';\n\t\t\tif (!escaped) {\n\t\t\t\tinsideString = !insideString;\n\t\t\t}\n\t\t}\n\n\t\tif (insideString) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!insideComment && currentChar + nextChar === '//') {\n\t\t\tret += str.slice(offset, i);\n\t\t\toffset = i;\n\t\t\tinsideComment = singleComment;\n\t\t\ti++;\n\t\t} else if (insideComment === singleComment && currentChar + nextChar === '\\r\\n') {\n\t\t\ti++;\n\t\t\tinsideComment = false;\n\t\t\tret += strip(str, offset, i);\n\t\t\toffset = i;\n\t\t\tcontinue;\n\t\t} else if (insideComment === singleComment && currentChar === '\\n') {\n\t\t\tinsideComment = false;\n\t\t\tret += strip(str, offset, i);\n\t\t\toffset = i;\n\t\t} else if (!insideComment && currentChar + nextChar === '/*') {\n\t\t\tret += str.slice(offset, i);\n\t\t\toffset = i;\n\t\t\tinsideComment = multiComment;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t} else if (insideComment === multiComment && currentChar + nextChar === '*/') {\n\t\t\ti++;\n\t\t\tinsideComment = false;\n\t\t\tret += strip(str, offset, i + 1);\n\t\t\toffset = i + 1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn ret + (insideComment ? strip(str.substr(offset)) : str.substr(offset));\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/rc/node_modules/strip-json-comments/index.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};\n\n//# sourceURL=webpack://coc.nvim/./node_modules/readable-stream/lib/_stream_duplex.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\n\nmodule.exports = PassThrough;\n\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n//# sourceURL=webpack://coc.nvim/./node_modules/readable-stream/lib/_stream_passthrough.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = __webpack_require__(/*! events */ \"events\").EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = __webpack_require__(/*! util */ \"util\");\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ \"./node_modules/readable-stream/lib/internal/streams/BufferList.js\");\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n//# sourceURL=webpack://coc.nvim/./node_modules/readable-stream/lib/_stream_readable.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\n\nmodule.exports = Transform;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n//# sourceURL=webpack://coc.nvim/./node_modules/readable-stream/lib/_stream_transform.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/node.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};\n\n//# sourceURL=webpack://coc.nvim/./node_modules/readable-stream/lib/_stream_writable.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!*************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar util = __webpack_require__(/*! util */ \"util\");\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}\n\n//# sourceURL=webpack://coc.nvim/./node_modules/readable-stream/lib/internal/streams/BufferList.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};\n\n//# sourceURL=webpack://coc.nvim/./node_modules/readable-stream/lib/internal/streams/destroy.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream.js":
/*!*********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! stream */ \"stream\");\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/readable-stream/lib/internal/streams/stream.js?");

/***/ }),

/***/ "./node_modules/readable-stream/readable.js":
/*!**************************************************!*\
  !*** ./node_modules/readable-stream/readable.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var Stream = __webpack_require__(/*! stream */ \"stream\");\nif (process.env.READABLE_STREAM === 'disable' && Stream) {\n  module.exports = Stream;\n  exports = module.exports = Stream.Readable;\n  exports.Readable = Stream.Readable;\n  exports.Writable = Stream.Writable;\n  exports.Duplex = Stream.Duplex;\n  exports.Transform = Stream.Transform;\n  exports.PassThrough = Stream.PassThrough;\n  exports.Stream = Stream;\n} else {\n  exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\n  exports.Stream = Stream || exports;\n  exports.Readable = exports;\n  exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\n  exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n  exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\n  exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"./node_modules/readable-stream/lib/_stream_passthrough.js\");\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/readable-stream/readable.js?");

/***/ }),

/***/ "./node_modules/rfc-3986/index.js":
/*!****************************************!*\
  !*** ./node_modules/rfc-3986/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// Load modules\n\n// Delcare internals\n\nvar internals = {\n    rfc3986: {}\n};\n\ninternals.generate = function () {\n\n    /**\n     * elements separated by forward slash (\"/\") are alternatives.\n     */\n    var or = '|';\n\n    /**\n     * DIGIT = %x30-39 ; 0-9\n     */\n    var digit = '0-9';\n    var digitOnly = '[' + digit + ']';\n\n    /**\n     * ALPHA = %x41-5A / %x61-7A   ; A-Z / a-z\n     */\n    var alpha = 'a-zA-Z';\n    var alphaOnly = '[' + alpha + ']';\n\n    /**\n     * cidr       = DIGIT                ; 0-9\n     *            / %x31-32 DIGIT         ; 10-29\n     *            / \"3\" %x30-32           ; 30-32\n     */\n    internals.rfc3986.cidr = digitOnly + or + '[1-2]' + digitOnly + or + '3' + '[0-2]';\n\n    /**\n     * HEXDIG = DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\n     */\n    var hexDigit = digit + 'A-Fa-f';\n    var hexDigitOnly = '[' + hexDigit + ']';\n\n    /**\n     * unreserved = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n     */\n    var unreserved = alpha + digit + '-\\\\._~';\n\n    /**\n     * sub-delims = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n     */\n    var subDelims = '!\\\\$&\\'\\\\(\\\\)\\\\*\\\\+,;=';\n\n    /**\n     * pct-encoded = \"%\" HEXDIG HEXDIG\n     */\n    var pctEncoded = '%' + hexDigit;\n\n    /**\n     * pchar = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n     */\n    var pchar = unreserved + pctEncoded + subDelims + ':@';\n    var pcharOnly = '[' + pchar + ']';\n\n    /**\n     * Rule to support zero-padded addresses.\n     */\n    var zeroPad = '0?';\n\n    /**\n     * dec-octet   = DIGIT                 ; 0-9\n     *            / %x31-39 DIGIT         ; 10-99\n     *            / \"1\" 2DIGIT            ; 100-199\n     *            / \"2\" %x30-34 DIGIT     ; 200-249\n     *            / \"25\" %x30-35          ; 250-255\n     */\n    var decOctect = '(?:' + zeroPad + zeroPad + digitOnly + or + zeroPad + '[1-9]' + digitOnly + or + '1' + digitOnly + digitOnly + or + '2' + '[0-4]' + digitOnly + or + '25' + '[0-5])';\n\n    /**\n     * IPv4address = dec-octet \".\" dec-octet \".\" dec-octet \".\" dec-octet\n     */\n    internals.rfc3986.IPv4address = '(?:' + decOctect + '\\\\.){3}' + decOctect;\n\n    /**\n     * h16 = 1*4HEXDIG ; 16 bits of address represented in hexadecimal\n     * ls32 = ( h16 \":\" h16 ) / IPv4address ; least-significant 32 bits of address\n     * IPv6address =                            6( h16 \":\" ) ls32\n     *             /                       \"::\" 5( h16 \":\" ) ls32\n     *             / [               h16 ] \"::\" 4( h16 \":\" ) ls32\n     *             / [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n     *             / [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n     *             / [ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n     *             / [ *4( h16 \":\" ) h16 ] \"::\"              ls32\n     *             / [ *5( h16 \":\" ) h16 ] \"::\"              h16\n     *             / [ *6( h16 \":\" ) h16 ] \"::\"\n     */\n    var h16 = hexDigitOnly + '{1,4}';\n    var ls32 = '(?:' + h16 + ':' + h16 + '|' + internals.rfc3986.IPv4address + ')';\n    var IPv6SixHex = '(?:' + h16 + ':){6}' + ls32;\n    var IPv6FiveHex = '::(?:' + h16 + ':){5}' + ls32;\n    var IPv6FourHex = '(?:' + h16 + ')?::(?:' + h16 + ':){4}' + ls32;\n    var IPv6ThreeHex = '(?:(?:' + h16 + ':){0,1}' + h16 + ')?::(?:' + h16 + ':){3}' + ls32;\n    var IPv6TwoHex = '(?:(?:' + h16 + ':){0,2}' + h16 + ')?::(?:' + h16 + ':){2}' + ls32;\n    var IPv6OneHex = '(?:(?:' + h16 + ':){0,3}' + h16 + ')?::' + h16 + ':' + ls32;\n    var IPv6NoneHex = '(?:(?:' + h16 + ':){0,4}' + h16 + ')?::' + ls32;\n    var IPv6NoneHex2 = '(?:(?:' + h16 + ':){0,5}' + h16 + ')?::' + h16;\n    var IPv6NoneHex3 = '(?:(?:' + h16 + ':){0,6}' + h16 + ')?::';\n    internals.rfc3986.IPv6address = '(?:' + IPv6SixHex + or + IPv6FiveHex + or + IPv6FourHex + or + IPv6ThreeHex + or + IPv6TwoHex + or + IPv6OneHex + or + IPv6NoneHex + or + IPv6NoneHex2 + or + IPv6NoneHex3 + ')';\n\n    /**\n     * IPvFuture = \"v\" 1*HEXDIG \".\" 1*( unreserved / sub-delims / \":\" )\n     */\n    internals.rfc3986.IPvFuture = 'v' + hexDigitOnly + '+\\\\.[' + unreserved + subDelims + ':]+';\n\n    /**\n     * scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n     */\n    internals.rfc3986.scheme = alphaOnly + '[' + alpha + digit + '+-\\\\.]*';\n\n    /**\n     * userinfo = *( unreserved / pct-encoded / sub-delims / \":\" )\n     */\n    var userinfo = '[' + unreserved + pctEncoded + subDelims + ':]*';\n\n    /**\n     * IP-literal = \"[\" ( IPv6address / IPvFuture  ) \"]\"\n     */\n    internals.rfc3986.IPLiteral = '\\\\[(?:' + internals.rfc3986.IPv6address + or + internals.rfc3986.IPvFuture + ')\\\\]';\n\n    /**\n     * reg-name = *( unreserved / pct-encoded / sub-delims )\n     */\n    var regName = '[' + unreserved + pctEncoded + subDelims + ']{0,255}';\n\n    /**\n     * host = IP-literal / IPv4address / reg-name\n     */\n    var host = '(?:' + internals.rfc3986.IPLiteral + or + internals.rfc3986.IPv4address + or + regName + ')';\n\n    /**\n     * port = *DIGIT\n     */\n    var port = digitOnly + '*';\n\n    /**\n     * authority   = [ userinfo \"@\" ] host [ \":\" port ]\n     */\n    var authority = '(?:' + userinfo + '@)?' + host + '(?::' + port + ')?';\n\n    /**\n     * segment       = *pchar\n     * segment-nz    = 1*pchar\n     * path          = path-abempty    ; begins with \"/\" or is empty\n     *               / path-absolute   ; begins with \"/\" but not \"//\"\n     *               / path-noscheme   ; begins with a non-colon segment\n     *               / path-rootless   ; begins with a segment\n     *               / path-empty      ; zero characters\n     * path-abempty  = *( \"/\" segment )\n     * path-absolute = \"/\" [ segment-nz *( \"/\" segment ) ]\n     * path-rootless = segment-nz *( \"/\" segment )\n     */\n    var segment = pcharOnly + '*';\n    var segmentNz = pcharOnly + '+';\n    var pathAbEmpty = '(?:\\\\/' + segment + ')*';\n    var pathAbsolute = '\\\\/(?:' + segmentNz + pathAbEmpty + ')?';\n    var pathRootless = segmentNz + pathAbEmpty;\n\n    /**\n     * hier-part = \"//\" authority path\n     */\n    internals.rfc3986.hierPart = '(?:' + '(?:\\\\/\\\\/' + authority + pathAbEmpty + ')' + or + pathAbsolute + or + pathRootless + ')';\n\n    /**\n     * query = *( pchar / \"/\" / \"?\" )\n     */\n    internals.rfc3986.query = '[' + pchar + '\\\\/\\\\?]*(?=#|$)'; //Finish matching either at the fragment part or end of the line.\n\n    /**\n     * fragment = *( pchar / \"/\" / \"?\" )\n     */\n    internals.rfc3986.fragment = '[' + pchar + '\\\\/\\\\?]*';\n\n    /**\n     * URI = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]\n     *\n     * OR\n     *\n     * relative-ref = relative-part [ \"?\" query ] [ \"#\" fragment ]\n     */\n    internals.rfc3986.uri = '^(?:' + internals.rfc3986.scheme + ':' + internals.rfc3986.hierPart + ')(?:\\\\?' + internals.rfc3986.query + ')?' + '(?:#' + internals.rfc3986.fragment + ')?$';\n};\n\ninternals.generate();\n\nmodule.exports = internals.rfc3986;\n\n//# sourceURL=webpack://coc.nvim/./node_modules/rfc-3986/index.js?");

/***/ }),

/***/ "./node_modules/rfdc/index.js":
/*!************************************!*\
  !*** ./node_modules/rfdc/index.js ***!
  \************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = rfdc\n\nfunction rfdc (opts) {\n  opts = opts || {}\n\n  if (opts.circles) return rfdcCircles(opts)\n  return opts.proto ? cloneProto : clone\n\n  function cloneArray (a, fn) {\n    var keys = Object.keys(a)\n    var a2 = new Array(keys.length)\n    for (var i = 0; i < keys.length; i++) {\n      var k = keys[i]\n      var cur = a[k]\n      if (typeof cur !== 'object' || cur === null) {\n        a2[k] = cur\n      } else if (cur instanceof Date) {\n        a2[k] = new Date(cur)\n      } else {\n        a2[k] = fn(cur)\n      }\n    }\n    return a2\n  }\n\n  function clone (o) {\n    if (typeof o !== 'object' || o === null) return o\n    if (o instanceof Date) return new Date(o)\n    if (Array.isArray(o)) return cloneArray(o, clone)\n    var o2 = {}\n    for (var k in o) {\n      if (Object.hasOwnProperty.call(o, k) === false) continue\n      var cur = o[k]\n      if (typeof cur !== 'object' || cur === null) {\n        o2[k] = cur\n      } else if (cur instanceof Date) {\n        o2[k] = new Date(cur)\n      } else {\n        o2[k] = clone(cur)\n      }\n    }\n    return o2\n  }\n\n  function cloneProto (o) {\n    if (typeof o !== 'object' || o === null) return o\n    if (o instanceof Date) return new Date(o)\n    if (Array.isArray(o)) return cloneArray(o, cloneProto)\n    var o2 = {}\n    for (var k in o) {\n      var cur = o[k]\n      if (typeof cur !== 'object' || cur === null) {\n        o2[k] = cur\n      } else if (cur instanceof Date) {\n        o2[k] = new Date(cur)\n      } else {\n        o2[k] = cloneProto(cur)\n      }\n    }\n    return o2\n  }\n}\n\nfunction rfdcCircles (opts) {\n  var refs = []\n  var refsNew = []\n\n  return opts.proto ? cloneProto : clone\n\n  function cloneArray (a, fn) {\n    var keys = Object.keys(a)\n    var a2 = new Array(keys.length)\n    for (var i = 0; i < keys.length; i++) {\n      var k = keys[i]\n      var cur = a[k]\n      if (typeof cur !== 'object' || cur === null) {\n        a2[k] = cur\n      } else if (cur instanceof Date) {\n        a2[k] = new Date(cur)\n      } else {\n        var index = refs.indexOf(cur)\n        if (index !== -1) {\n          a2[k] = refsNew[index]\n        } else {\n          a2[k] = fn(cur)\n        }\n      }\n    }\n    return a2\n  }\n\n  function clone (o) {\n    if (typeof o !== 'object' || o === null) return o\n    if (o instanceof Date) return new Date(o)\n    if (Array.isArray(o)) return cloneArray(o, clone)\n    var o2 = {}\n    refs.push(o)\n    refsNew.push(o2)\n    for (var k in o) {\n      if (Object.hasOwnProperty.call(o, k) === false) continue\n      var cur = o[k]\n      if (typeof cur !== 'object' || cur === null) {\n        o2[k] = cur\n      } else if (cur instanceof Date) {\n        o2[k] = new Date(cur)\n      } else {\n        var i = refs.indexOf(cur)\n        if (i !== -1) {\n          o2[k] = refsNew[i]\n        } else {\n          o2[k] = clone(cur)\n        }\n      }\n    }\n    refs.pop()\n    refsNew.pop()\n    return o2\n  }\n\n  function cloneProto (o) {\n    if (typeof o !== 'object' || o === null) return o\n    if (o instanceof Date) return new Date(o)\n    if (Array.isArray(o)) return cloneArray(o, cloneProto)\n    var o2 = {}\n    refs.push(o)\n    refsNew.push(o2)\n    for (var k in o) {\n      var cur = o[k]\n      if (typeof cur !== 'object' || cur === null) {\n        o2[k] = cur\n      } else if (cur instanceof Date) {\n        o2[k] = new Date(cur)\n      } else {\n        var i = refs.indexOf(cur)\n        if (i !== -1) {\n          o2[k] = refsNew[i]\n        } else {\n          o2[k] = cloneProto(cur)\n        }\n      }\n    }\n    refs.pop()\n    refsNew.pop()\n    return o2\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/rfdc/index.js?");

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/safe-buffer/index.js?");

/***/ }),

/***/ "./node_modules/semver/classes/comparator.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/classes/comparator.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const ANY = Symbol('SemVer ANY')\n// hoisted class for cyclic dependency\nclass Comparator {\n  static get ANY () {\n    return ANY\n  }\n  constructor (comp, options) {\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    debug('comparator', comp, options)\n    this.options = options\n    this.loose = !!options.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n    debug('comp', this)\n  }\n\n  parse (comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : ''\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString () {\n    return this.value\n  }\n\n  test (version) {\n    debug('Comparator.test', version, this.options.loose)\n\n    if (this.semver === ANY || version === ANY) {\n      return true\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options)\n  }\n\n  intersects (comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required')\n    }\n\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true\n      }\n      return new Range(comp.value, options).test(this.value)\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true\n      }\n      return new Range(this.value, options).test(comp.semver)\n    }\n\n    const sameDirectionIncreasing =\n      (this.operator === '>=' || this.operator === '>') &&\n      (comp.operator === '>=' || comp.operator === '>')\n    const sameDirectionDecreasing =\n      (this.operator === '<=' || this.operator === '<') &&\n      (comp.operator === '<=' || comp.operator === '<')\n    const sameSemVer = this.semver.version === comp.semver.version\n    const differentDirectionsInclusive =\n      (this.operator === '>=' || this.operator === '<=') &&\n      (comp.operator === '>=' || comp.operator === '<=')\n    const oppositeDirectionsLessThan =\n      cmp(this.semver, '<', comp.semver, options) &&\n      (this.operator === '>=' || this.operator === '>') &&\n        (comp.operator === '<=' || comp.operator === '<')\n    const oppositeDirectionsGreaterThan =\n      cmp(this.semver, '>', comp.semver, options) &&\n      (this.operator === '<=' || this.operator === '<') &&\n        (comp.operator === '>=' || comp.operator === '>')\n\n    return (\n      sameDirectionIncreasing ||\n      sameDirectionDecreasing ||\n      (sameSemVer && differentDirectionsInclusive) ||\n      oppositeDirectionsLessThan ||\n      oppositeDirectionsGreaterThan\n    )\n  }\n}\n\nmodule.exports = Comparator\n\nconst {re, t} = __webpack_require__(/*! ../internal/re */ \"./node_modules/semver/internal/re.js\")\nconst cmp = __webpack_require__(/*! ../functions/cmp */ \"./node_modules/semver/functions/cmp.js\")\nconst debug = __webpack_require__(/*! ../internal/debug */ \"./node_modules/semver/internal/debug.js\")\nconst SemVer = __webpack_require__(/*! ./semver */ \"./node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ./range */ \"./node_modules/semver/classes/range.js\")\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/classes/comparator.js?");

/***/ }),

/***/ "./node_modules/semver/classes/range.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/classes/range.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// hoisted class for cyclic dependency\nclass Range {\n  constructor (range, options) {\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, options)\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value\n      this.set = [[range]]\n      this.format()\n      return this\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    this.includePrerelease = !!options.includePrerelease\n\n    // First, split based on boolean or ||\n    this.raw = range\n    this.set = range\n      .split(/\\s*\\|\\|\\s*/)\n      // map the range to a 2d array of comparators\n      .map(range => this.parseRange(range.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${range}`)\n    }\n\n    this.format()\n  }\n\n  format () {\n    this.range = this.set\n      .map((comps) => {\n        return comps.join(' ').trim()\n      })\n      .join('||')\n      .trim()\n    return this.range\n  }\n\n  toString () {\n    return this.range\n  }\n\n  parseRange (range) {\n    const loose = this.options.loose\n    range = range.trim()\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    debug('hyphen replace', range)\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n    debug('comparator trim', range, re[t.COMPARATORTRIM])\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n\n    // normalize spaces\n    range = range.split(/\\s+/).join(' ')\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    return range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      .map(comp => replaceGTE0(comp, this.options))\n      // in loose mode, throw out any that are not valid comparators\n      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)\n      .map(comp => new Comparator(comp, this.options))\n  }\n\n  intersects (range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required')\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options)\n              })\n            })\n          )\n        })\n      )\n    })\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test (version) {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\nmodule.exports = Range\n\nconst Comparator = __webpack_require__(/*! ./comparator */ \"./node_modules/semver/classes/comparator.js\")\nconst debug = __webpack_require__(/*! ../internal/debug */ \"./node_modules/semver/internal/debug.js\")\nconst SemVer = __webpack_require__(/*! ./semver */ \"./node_modules/semver/classes/semver.js\")\nconst {\n  re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace\n} = __webpack_require__(/*! ../internal/re */ \"./node_modules/semver/internal/re.js\")\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nconst isSatisfiable = (comparators, options) => {\n  let result = true\n  const remainingComparators = comparators.slice()\n  let testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nconst parseComparator = (comp, options) => {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\nconst replaceTildes = (comp, options) =>\n  comp.trim().split(/\\s+/).map((comp) => {\n    return replaceTilde(comp, options)\n  }).join(' ')\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\nconst replaceCarets = (comp, options) =>\n  comp.trim().split(/\\s+/).map((comp) => {\n    return replaceCaret(comp, options)\n  }).join(' ')\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options)\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options)\n  return comp.split(/\\s+/).map((comp) => {\n    return replaceXRange(comp, options)\n  }).join(' ')\n}\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<')\n        pr = '-0'\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[t.STAR], '')\n}\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options)\n  return comp.trim()\n    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\nconst hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr, tb) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return (`${from} ${to}`).trim()\n}\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === Comparator.ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/classes/range.js?");

/***/ }),

/***/ "./node_modules/semver/classes/semver.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/classes/semver.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const debug = __webpack_require__(/*! ../internal/debug */ \"./node_modules/semver/internal/debug.js\")\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(/*! ../internal/constants */ \"./node_modules/semver/internal/constants.js\")\nconst { re, t } = __webpack_require__(/*! ../internal/re */ \"./node_modules/semver/internal/re.js\")\n\nconst { compareIdentifiers } = __webpack_require__(/*! ../internal/identifiers */ \"./node_modules/semver/internal/identifiers.js\")\nclass SemVer {\n  constructor (version, options) {\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n          version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    debug('SemVer', version, options)\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString () {\n    return this.version\n  }\n\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other)\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    )\n  }\n\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    let i = 0\n    do {\n      const a = this.build[i]\n      const b = other.build[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n  inc (release, identifier) {\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor = 0\n        this.major++\n        this.inc('pre', identifier)\n        break\n      case 'preminor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor++\n        this.inc('pre', identifier)\n        break\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0\n        this.inc('patch', identifier)\n        this.inc('pre', identifier)\n        break\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier)\n        }\n        this.inc('pre', identifier)\n        break\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++\n        }\n        this.minor = 0\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++\n        }\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++\n        }\n        this.prerelease = []\n        break\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n      case 'pre':\n        if (this.prerelease.length === 0) {\n          this.prerelease = [0]\n        } else {\n          let i = this.prerelease.length\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++\n              i = -2\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            this.prerelease.push(0)\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          if (this.prerelease[0] === identifier) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = [identifier, 0]\n            }\n          } else {\n            this.prerelease = [identifier, 0]\n          }\n        }\n        break\n\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.format()\n    this.raw = this.version\n    return this\n  }\n}\n\nmodule.exports = SemVer\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/classes/semver.js?");

/***/ }),

/***/ "./node_modules/semver/functions/clean.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/clean.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const parse = __webpack_require__(/*! ./parse */ \"./node_modules/semver/functions/parse.js\")\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\nmodule.exports = clean\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/clean.js?");

/***/ }),

/***/ "./node_modules/semver/functions/cmp.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/cmp.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const eq = __webpack_require__(/*! ./eq */ \"./node_modules/semver/functions/eq.js\")\nconst neq = __webpack_require__(/*! ./neq */ \"./node_modules/semver/functions/neq.js\")\nconst gt = __webpack_require__(/*! ./gt */ \"./node_modules/semver/functions/gt.js\")\nconst gte = __webpack_require__(/*! ./gte */ \"./node_modules/semver/functions/gte.js\")\nconst lt = __webpack_require__(/*! ./lt */ \"./node_modules/semver/functions/lt.js\")\nconst lte = __webpack_require__(/*! ./lte */ \"./node_modules/semver/functions/lte.js\")\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`)\n  }\n}\nmodule.exports = cmp\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/cmp.js?");

/***/ }),

/***/ "./node_modules/semver/functions/coerce.js":
/*!*************************************************!*\
  !*** ./node_modules/semver/functions/coerce.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\nconst parse = __webpack_require__(/*! ./parse */ \"./node_modules/semver/functions/parse.js\")\nconst {re, t} = __webpack_require__(/*! ../internal/re */ \"./node_modules/semver/internal/re.js\")\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    let next\n    while ((next = re[t.COERCERTL].exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    re[t.COERCERTL].lastIndex = -1\n  }\n\n  if (match === null)\n    return null\n\n  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)\n}\nmodule.exports = coerce\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/coerce.js?");

/***/ }),

/***/ "./node_modules/semver/functions/compare-build.js":
/*!********************************************************!*\
  !*** ./node_modules/semver/functions/compare-build.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose)\n  const versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\nmodule.exports = compareBuild\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/compare-build.js?");

/***/ }),

/***/ "./node_modules/semver/functions/compare-loose.js":
/*!********************************************************!*\
  !*** ./node_modules/semver/functions/compare-loose.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/semver/functions/compare.js\")\nconst compareLoose = (a, b) => compare(a, b, true)\nmodule.exports = compareLoose\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/compare-loose.js?");

/***/ }),

/***/ "./node_modules/semver/functions/compare.js":
/*!**************************************************!*\
  !*** ./node_modules/semver/functions/compare.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\nconst compare = (a, b, loose) =>\n  new SemVer(a, loose).compare(new SemVer(b, loose))\n\nmodule.exports = compare\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/compare.js?");

/***/ }),

/***/ "./node_modules/semver/functions/diff.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/functions/diff.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const parse = __webpack_require__(/*! ./parse */ \"./node_modules/semver/functions/parse.js\")\nconst eq = __webpack_require__(/*! ./eq */ \"./node_modules/semver/functions/eq.js\")\n\nconst diff = (version1, version2) => {\n  if (eq(version1, version2)) {\n    return null\n  } else {\n    const v1 = parse(version1)\n    const v2 = parse(version2)\n    const hasPre = v1.prerelease.length || v2.prerelease.length\n    const prefix = hasPre ? 'pre' : ''\n    const defaultResult = hasPre ? 'prerelease' : ''\n    for (const key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key\n        }\n      }\n    }\n    return defaultResult // may be undefined\n  }\n}\nmodule.exports = diff\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/diff.js?");

/***/ }),

/***/ "./node_modules/semver/functions/eq.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/eq.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/semver/functions/compare.js\")\nconst eq = (a, b, loose) => compare(a, b, loose) === 0\nmodule.exports = eq\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/eq.js?");

/***/ }),

/***/ "./node_modules/semver/functions/gt.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/gt.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/semver/functions/compare.js\")\nconst gt = (a, b, loose) => compare(a, b, loose) > 0\nmodule.exports = gt\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/gt.js?");

/***/ }),

/***/ "./node_modules/semver/functions/gte.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/gte.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/semver/functions/compare.js\")\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0\nmodule.exports = gte\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/gte.js?");

/***/ }),

/***/ "./node_modules/semver/functions/inc.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/inc.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\n\nconst inc = (version, release, options, identifier) => {\n  if (typeof (options) === 'string') {\n    identifier = options\n    options = undefined\n  }\n\n  try {\n    return new SemVer(version, options).inc(release, identifier).version\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = inc\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/inc.js?");

/***/ }),

/***/ "./node_modules/semver/functions/lt.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/lt.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/semver/functions/compare.js\")\nconst lt = (a, b, loose) => compare(a, b, loose) < 0\nmodule.exports = lt\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/lt.js?");

/***/ }),

/***/ "./node_modules/semver/functions/lte.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/lte.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/semver/functions/compare.js\")\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0\nmodule.exports = lte\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/lte.js?");

/***/ }),

/***/ "./node_modules/semver/functions/major.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/major.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\nconst major = (a, loose) => new SemVer(a, loose).major\nmodule.exports = major\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/major.js?");

/***/ }),

/***/ "./node_modules/semver/functions/minor.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/minor.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\nconst minor = (a, loose) => new SemVer(a, loose).minor\nmodule.exports = minor\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/minor.js?");

/***/ }),

/***/ "./node_modules/semver/functions/neq.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/neq.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/semver/functions/compare.js\")\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0\nmodule.exports = neq\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/neq.js?");

/***/ }),

/***/ "./node_modules/semver/functions/parse.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/parse.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {MAX_LENGTH} = __webpack_require__(/*! ../internal/constants */ \"./node_modules/semver/internal/constants.js\")\nconst { re, t } = __webpack_require__(/*! ../internal/re */ \"./node_modules/semver/internal/re.js\")\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\n\nconst parse = (version, options) => {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null\n  }\n\n  const r = options.loose ? re[t.LOOSE] : re[t.FULL]\n  if (!r.test(version)) {\n    return null\n  }\n\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    return null\n  }\n}\n\nmodule.exports = parse\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/parse.js?");

/***/ }),

/***/ "./node_modules/semver/functions/patch.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/patch.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\nconst patch = (a, loose) => new SemVer(a, loose).patch\nmodule.exports = patch\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/patch.js?");

/***/ }),

/***/ "./node_modules/semver/functions/prerelease.js":
/*!*****************************************************!*\
  !*** ./node_modules/semver/functions/prerelease.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const parse = __webpack_require__(/*! ./parse */ \"./node_modules/semver/functions/parse.js\")\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\nmodule.exports = prerelease\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/prerelease.js?");

/***/ }),

/***/ "./node_modules/semver/functions/rcompare.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/functions/rcompare.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/semver/functions/compare.js\")\nconst rcompare = (a, b, loose) => compare(b, a, loose)\nmodule.exports = rcompare\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/rcompare.js?");

/***/ }),

/***/ "./node_modules/semver/functions/rsort.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/rsort.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compareBuild = __webpack_require__(/*! ./compare-build */ \"./node_modules/semver/functions/compare-build.js\")\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))\nmodule.exports = rsort\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/rsort.js?");

/***/ }),

/***/ "./node_modules/semver/functions/satisfies.js":
/*!****************************************************!*\
  !*** ./node_modules/semver/functions/satisfies.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/semver/classes/range.js\")\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\nmodule.exports = satisfies\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/satisfies.js?");

/***/ }),

/***/ "./node_modules/semver/functions/sort.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/functions/sort.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compareBuild = __webpack_require__(/*! ./compare-build */ \"./node_modules/semver/functions/compare-build.js\")\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))\nmodule.exports = sort\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/sort.js?");

/***/ }),

/***/ "./node_modules/semver/functions/valid.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/valid.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const parse = __webpack_require__(/*! ./parse */ \"./node_modules/semver/functions/parse.js\")\nconst valid = (version, options) => {\n  const v = parse(version, options)\n  return v ? v.version : null\n}\nmodule.exports = valid\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/functions/valid.js?");

/***/ }),

/***/ "./node_modules/semver/index.js":
/*!**************************************!*\
  !*** ./node_modules/semver/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// just pre-load all the stuff that index.js lazily exports\nconst internalRe = __webpack_require__(/*! ./internal/re */ \"./node_modules/semver/internal/re.js\")\nmodule.exports = {\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: __webpack_require__(/*! ./internal/constants */ \"./node_modules/semver/internal/constants.js\").SEMVER_SPEC_VERSION,\n  SemVer: __webpack_require__(/*! ./classes/semver */ \"./node_modules/semver/classes/semver.js\"),\n  compareIdentifiers: __webpack_require__(/*! ./internal/identifiers */ \"./node_modules/semver/internal/identifiers.js\").compareIdentifiers,\n  rcompareIdentifiers: __webpack_require__(/*! ./internal/identifiers */ \"./node_modules/semver/internal/identifiers.js\").rcompareIdentifiers,\n  parse: __webpack_require__(/*! ./functions/parse */ \"./node_modules/semver/functions/parse.js\"),\n  valid: __webpack_require__(/*! ./functions/valid */ \"./node_modules/semver/functions/valid.js\"),\n  clean: __webpack_require__(/*! ./functions/clean */ \"./node_modules/semver/functions/clean.js\"),\n  inc: __webpack_require__(/*! ./functions/inc */ \"./node_modules/semver/functions/inc.js\"),\n  diff: __webpack_require__(/*! ./functions/diff */ \"./node_modules/semver/functions/diff.js\"),\n  major: __webpack_require__(/*! ./functions/major */ \"./node_modules/semver/functions/major.js\"),\n  minor: __webpack_require__(/*! ./functions/minor */ \"./node_modules/semver/functions/minor.js\"),\n  patch: __webpack_require__(/*! ./functions/patch */ \"./node_modules/semver/functions/patch.js\"),\n  prerelease: __webpack_require__(/*! ./functions/prerelease */ \"./node_modules/semver/functions/prerelease.js\"),\n  compare: __webpack_require__(/*! ./functions/compare */ \"./node_modules/semver/functions/compare.js\"),\n  rcompare: __webpack_require__(/*! ./functions/rcompare */ \"./node_modules/semver/functions/rcompare.js\"),\n  compareLoose: __webpack_require__(/*! ./functions/compare-loose */ \"./node_modules/semver/functions/compare-loose.js\"),\n  compareBuild: __webpack_require__(/*! ./functions/compare-build */ \"./node_modules/semver/functions/compare-build.js\"),\n  sort: __webpack_require__(/*! ./functions/sort */ \"./node_modules/semver/functions/sort.js\"),\n  rsort: __webpack_require__(/*! ./functions/rsort */ \"./node_modules/semver/functions/rsort.js\"),\n  gt: __webpack_require__(/*! ./functions/gt */ \"./node_modules/semver/functions/gt.js\"),\n  lt: __webpack_require__(/*! ./functions/lt */ \"./node_modules/semver/functions/lt.js\"),\n  eq: __webpack_require__(/*! ./functions/eq */ \"./node_modules/semver/functions/eq.js\"),\n  neq: __webpack_require__(/*! ./functions/neq */ \"./node_modules/semver/functions/neq.js\"),\n  gte: __webpack_require__(/*! ./functions/gte */ \"./node_modules/semver/functions/gte.js\"),\n  lte: __webpack_require__(/*! ./functions/lte */ \"./node_modules/semver/functions/lte.js\"),\n  cmp: __webpack_require__(/*! ./functions/cmp */ \"./node_modules/semver/functions/cmp.js\"),\n  coerce: __webpack_require__(/*! ./functions/coerce */ \"./node_modules/semver/functions/coerce.js\"),\n  Comparator: __webpack_require__(/*! ./classes/comparator */ \"./node_modules/semver/classes/comparator.js\"),\n  Range: __webpack_require__(/*! ./classes/range */ \"./node_modules/semver/classes/range.js\"),\n  satisfies: __webpack_require__(/*! ./functions/satisfies */ \"./node_modules/semver/functions/satisfies.js\"),\n  toComparators: __webpack_require__(/*! ./ranges/to-comparators */ \"./node_modules/semver/ranges/to-comparators.js\"),\n  maxSatisfying: __webpack_require__(/*! ./ranges/max-satisfying */ \"./node_modules/semver/ranges/max-satisfying.js\"),\n  minSatisfying: __webpack_require__(/*! ./ranges/min-satisfying */ \"./node_modules/semver/ranges/min-satisfying.js\"),\n  minVersion: __webpack_require__(/*! ./ranges/min-version */ \"./node_modules/semver/ranges/min-version.js\"),\n  validRange: __webpack_require__(/*! ./ranges/valid */ \"./node_modules/semver/ranges/valid.js\"),\n  outside: __webpack_require__(/*! ./ranges/outside */ \"./node_modules/semver/ranges/outside.js\"),\n  gtr: __webpack_require__(/*! ./ranges/gtr */ \"./node_modules/semver/ranges/gtr.js\"),\n  ltr: __webpack_require__(/*! ./ranges/ltr */ \"./node_modules/semver/ranges/ltr.js\"),\n  intersects: __webpack_require__(/*! ./ranges/intersects */ \"./node_modules/semver/ranges/intersects.js\"),\n  simplifyRange: __webpack_require__(/*! ./ranges/simplify */ \"./node_modules/semver/ranges/simplify.js\"),\n  subset: __webpack_require__(/*! ./ranges/subset */ \"./node_modules/semver/ranges/subset.js\"),\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/index.js?");

/***/ }),

/***/ "./node_modules/semver/internal/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/internal/constants.js ***!
  \***************************************************/
/***/ ((module) => {

eval("// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0'\n\nconst MAX_LENGTH = 256\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n  /* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH = 16\n\nmodule.exports = {\n  SEMVER_SPEC_VERSION,\n  MAX_LENGTH,\n  MAX_SAFE_INTEGER,\n  MAX_SAFE_COMPONENT_LENGTH\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/internal/constants.js?");

/***/ }),

/***/ "./node_modules/semver/internal/debug.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/internal/debug.js ***!
  \***********************************************/
/***/ ((module) => {

eval("const debug = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {}\n\nmodule.exports = debug\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/internal/debug.js?");

/***/ }),

/***/ "./node_modules/semver/internal/identifiers.js":
/*!*****************************************************!*\
  !*** ./node_modules/semver/internal/identifiers.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("const numeric = /^[0-9]+$/\nconst compareIdentifiers = (a, b) => {\n  const anum = numeric.test(a)\n  const bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/internal/identifiers.js?");

/***/ }),

/***/ "./node_modules/semver/internal/re.js":
/*!********************************************!*\
  !*** ./node_modules/semver/internal/re.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("const { MAX_SAFE_COMPONENT_LENGTH } = __webpack_require__(/*! ./constants */ \"./node_modules/semver/internal/constants.js\")\nconst debug = __webpack_require__(/*! ./debug */ \"./node_modules/semver/internal/debug.js\")\nexports = module.exports = {}\n\n// The actual regexps go on exports.re\nconst re = exports.re = []\nconst src = exports.src = []\nconst t = exports.t = {}\nlet R = 0\n\nconst createToken = (name, value, isGlobal) => {\n  const index = R++\n  debug(index, value)\n  t[name] = index\n  src[index] = value\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*')\ncreateToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*')\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`)\n\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`)\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`)\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)\n\ncreateToken('GTLT', '((?:<|>)?=?)')\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`)\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`)\n\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n                   `)?)?`)\n\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n                        `)?)?`)\n\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`)\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCE', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:$|[^\\\\d])`)\ncreateToken('COERCERTL', src[t.COERCE], true)\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE', '(?:~>?)')\n\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true)\nexports.tildeTrimReplace = '$1~'\n\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET', '(?:\\\\^)')\n\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true)\nexports.caretTrimReplace = '$1^'\n\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`)\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`)\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)\nexports.comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s+-\\\\s+` +\n                   `(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s*$`)\n\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s+-\\\\s+` +\n                        `(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s*$`)\n\n// Star ranges basically just allow anything at all.\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*')\n// >=0.0.0 is like a star\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\.0\\.0\\\\s*$')\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\.0\\.0-0\\\\s*$')\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/internal/re.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/gtr.js":
/*!*******************************************!*\
  !*** ./node_modules/semver/ranges/gtr.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Determine if version is greater than all the versions possible in the range.\nconst outside = __webpack_require__(/*! ./outside */ \"./node_modules/semver/ranges/outside.js\")\nconst gtr = (version, range, options) => outside(version, range, '>', options)\nmodule.exports = gtr\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/ranges/gtr.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/intersects.js":
/*!**************************************************!*\
  !*** ./node_modules/semver/ranges/intersects.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/semver/classes/range.js\")\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2)\n}\nmodule.exports = intersects\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/ranges/intersects.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/ltr.js":
/*!*******************************************!*\
  !*** ./node_modules/semver/ranges/ltr.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const outside = __webpack_require__(/*! ./outside */ \"./node_modules/semver/ranges/outside.js\")\n// Determine if version is less than all the versions possible in the range\nconst ltr = (version, range, options) => outside(version, range, '<', options)\nmodule.exports = ltr\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/ranges/ltr.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/max-satisfying.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/max-satisfying.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/semver/classes/range.js\")\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\nmodule.exports = maxSatisfying\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/ranges/max-satisfying.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/min-satisfying.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/min-satisfying.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/semver/classes/range.js\")\nconst minSatisfying = (versions, range, options) => {\n  let min = null\n  let minSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\nmodule.exports = minSatisfying\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/ranges/min-satisfying.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/min-version.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/ranges/min-version.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/semver/classes/range.js\")\nconst gt = __webpack_require__(/*! ../functions/gt */ \"./node_modules/semver/functions/gt.js\")\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose)\n\n  let minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!minver || gt(minver, compver)) {\n            minver = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`)\n      }\n    })\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\nmodule.exports = minVersion\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/ranges/min-version.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/outside.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/ranges/outside.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\nconst Comparator = __webpack_require__(/*! ../classes/comparator */ \"./node_modules/semver/classes/comparator.js\")\nconst {ANY} = Comparator\nconst Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/semver/classes/range.js\")\nconst satisfies = __webpack_require__(/*! ../functions/satisfies */ \"./node_modules/semver/functions/satisfies.js\")\nconst gt = __webpack_require__(/*! ../functions/gt */ \"./node_modules/semver/functions/gt.js\")\nconst lt = __webpack_require__(/*! ../functions/lt */ \"./node_modules/semver/functions/lt.js\")\nconst lte = __webpack_require__(/*! ../functions/lte */ \"./node_modules/semver/functions/lte.js\")\nconst gte = __webpack_require__(/*! ../functions/gte */ \"./node_modules/semver/functions/gte.js\")\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  let gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let high = null\n    let low = null\n\n    comparators.forEach((comparator) => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = outside\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/ranges/outside.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/simplify.js":
/*!************************************************!*\
  !*** ./node_modules/semver/ranges/simplify.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = __webpack_require__(/*! ../functions/satisfies.js */ \"./node_modules/semver/functions/satisfies.js\")\nconst compare = __webpack_require__(/*! ../functions/compare.js */ \"./node_modules/semver/functions/compare.js\")\nmodule.exports = (versions, range, options) => {\n  const set = []\n  let min = null\n  let prev = null\n  const v = versions.sort((a, b) => compare(a, b, options))\n  for (const version of v) {\n    const included = satisfies(version, range, options)\n    if (included) {\n      prev = version\n      if (!min)\n        min = version\n    } else {\n      if (prev) {\n        set.push([min, prev])\n      }\n      prev = null\n      min = null\n    }\n  }\n  if (min)\n    set.push([min, null])\n\n  const ranges = []\n  for (const [min, max] of set) {\n    if (min === max)\n      ranges.push(min)\n    else if (!max && min === v[0])\n      ranges.push('*')\n    else if (!max)\n      ranges.push(`>=${min}`)\n    else if (min === v[0])\n      ranges.push(`<=${max}`)\n    else\n      ranges.push(`${min} - ${max}`)\n  }\n  const simplified = ranges.join(' || ')\n  const original = typeof range.raw === 'string' ? range.raw : String(range)\n  return simplified.length < original.length ? simplified : range\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/ranges/simplify.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/subset.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/ranges/subset.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Range = __webpack_require__(/*! ../classes/range.js */ \"./node_modules/semver/classes/range.js\")\nconst { ANY } = __webpack_require__(/*! ../classes/comparator.js */ \"./node_modules/semver/classes/comparator.js\")\nconst satisfies = __webpack_require__(/*! ../functions/satisfies.js */ \"./node_modules/semver/functions/satisfies.js\")\nconst compare = __webpack_require__(/*! ../functions/compare.js */ \"./node_modules/semver/functions/compare.js\")\n\n// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a subset of some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else return false\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n// - If LT\n//   - If LT.semver is greater than that of any > comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n// - If any C is a = range, and GT or LT are set, return false\n// - Else return true\n\nconst subset = (sub, dom, options) => {\n  sub = new Range(sub, options)\n  dom = new Range(dom, options)\n  let sawNonNull = false\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options)\n      sawNonNull = sawNonNull || isSub !== null\n      if (isSub)\n        continue OUTER\n    }\n    // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n    if (sawNonNull)\n      return false\n  }\n  return true\n}\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub.length === 1 && sub[0].semver === ANY)\n    return dom.length === 1 && dom[0].semver === ANY\n\n  const eqSet = new Set()\n  let gt, lt\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=')\n      gt = higherGT(gt, c, options)\n    else if (c.operator === '<' || c.operator === '<=')\n      lt = lowerLT(lt, c, options)\n    else\n      eqSet.add(c.semver)\n  }\n\n  if (eqSet.size > 1)\n    return null\n\n  let gtltComp\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options)\n    if (gtltComp > 0)\n      return null\n    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))\n      return null\n  }\n\n  // will iterate one or zero times\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options))\n      return null\n\n    if (lt && !satisfies(eq, String(lt), options))\n      return null\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options))\n        return false\n    }\n    return true\n  }\n\n  let higher, lower\n  let hasDomLT, hasDomGT\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='\n    if (gt) {\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options)\n        if (higher === c)\n          return false\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))\n        return false\n    }\n    if (lt) {\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options)\n        if (lower === c)\n          return false\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))\n        return false\n    }\n    if (!c.operator && (lt || gt) && gtltComp !== 0)\n      return false\n  }\n\n  // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n  if (gt && hasDomLT && !lt && gtltComp !== 0)\n    return false\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0)\n    return false\n\n  return true\n}\n\n// >=1.2.3 is lower than >1.2.3\nconst higherGT = (a, b, options) => {\n  if (!a)\n    return b\n  const comp = compare(a.semver, b.semver, options)\n  return comp > 0 ? a\n    : comp < 0 ? b\n    : b.operator === '>' && a.operator === '>=' ? b\n    : a\n}\n\n// <=1.2.3 is higher than <1.2.3\nconst lowerLT = (a, b, options) => {\n  if (!a)\n    return b\n  const comp = compare(a.semver, b.semver, options)\n  return comp < 0 ? a\n    : comp > 0 ? b\n    : b.operator === '<' && a.operator === '<=' ? b\n    : a\n}\n\nmodule.exports = subset\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/ranges/subset.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/to-comparators.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/to-comparators.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/semver/classes/range.js\")\n\n// Mostly just for testing and legacy API reasons\nconst toComparators = (range, options) =>\n  new Range(range, options).set\n    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))\n\nmodule.exports = toComparators\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/ranges/to-comparators.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/valid.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/ranges/valid.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/semver/classes/range.js\")\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = validRange\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/semver/ranges/valid.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/***/ (function() {

eval("(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/signal-exit/index.js":
/*!*******************************************!*\
  !*** ./node_modules/signal-exit/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\nvar assert = __webpack_require__(/*! assert */ \"assert\")\nvar signals = __webpack_require__(/*! ./signals.js */ \"./node_modules/signal-exit/signals.js\")\nvar isWin = /^win/i.test(process.platform)\n\nvar EE = __webpack_require__(/*! events */ \"events\")\n/* istanbul ignore if */\nif (typeof EE !== 'function') {\n  EE = EE.EventEmitter\n}\n\nvar emitter\nif (process.__signal_exit_emitter__) {\n  emitter = process.__signal_exit_emitter__\n} else {\n  emitter = process.__signal_exit_emitter__ = new EE()\n  emitter.count = 0\n  emitter.emitted = {}\n}\n\n// Because this emitter is a global, we have to check to see if a\n// previous version of this library failed to enable infinite listeners.\n// I know what you're about to say.  But literally everything about\n// signal-exit is a compromise with evil.  Get used to it.\nif (!emitter.infinite) {\n  emitter.setMaxListeners(Infinity)\n  emitter.infinite = true\n}\n\nmodule.exports = function (cb, opts) {\n  assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')\n\n  if (loaded === false) {\n    load()\n  }\n\n  var ev = 'exit'\n  if (opts && opts.alwaysLast) {\n    ev = 'afterexit'\n  }\n\n  var remove = function () {\n    emitter.removeListener(ev, cb)\n    if (emitter.listeners('exit').length === 0 &&\n        emitter.listeners('afterexit').length === 0) {\n      unload()\n    }\n  }\n  emitter.on(ev, cb)\n\n  return remove\n}\n\nmodule.exports.unload = unload\nfunction unload () {\n  if (!loaded) {\n    return\n  }\n  loaded = false\n\n  signals.forEach(function (sig) {\n    try {\n      process.removeListener(sig, sigListeners[sig])\n    } catch (er) {}\n  })\n  process.emit = originalProcessEmit\n  process.reallyExit = originalProcessReallyExit\n  emitter.count -= 1\n}\n\nfunction emit (event, code, signal) {\n  if (emitter.emitted[event]) {\n    return\n  }\n  emitter.emitted[event] = true\n  emitter.emit(event, code, signal)\n}\n\n// { <signal>: <listener fn>, ... }\nvar sigListeners = {}\nsignals.forEach(function (sig) {\n  sigListeners[sig] = function listener () {\n    // If there are no other listeners, an exit is coming!\n    // Simplest way: remove us and then re-send the signal.\n    // We know that this will kill the process, so we can\n    // safely emit now.\n    var listeners = process.listeners(sig)\n    if (listeners.length === emitter.count) {\n      unload()\n      emit('exit', null, sig)\n      /* istanbul ignore next */\n      emit('afterexit', null, sig)\n      /* istanbul ignore next */\n      if (isWin && sig === 'SIGHUP') {\n        // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n        // so use a supported signal instead\n        sig = 'SIGINT'\n      }\n      process.kill(process.pid, sig)\n    }\n  }\n})\n\nmodule.exports.signals = function () {\n  return signals\n}\n\nmodule.exports.load = load\n\nvar loaded = false\n\nfunction load () {\n  if (loaded) {\n    return\n  }\n  loaded = true\n\n  // This is the number of onSignalExit's that are in play.\n  // It's important so that we can count the correct number of\n  // listeners on signals, and don't wait for the other one to\n  // handle it instead of us.\n  emitter.count += 1\n\n  signals = signals.filter(function (sig) {\n    try {\n      process.on(sig, sigListeners[sig])\n      return true\n    } catch (er) {\n      return false\n    }\n  })\n\n  process.emit = processEmit\n  process.reallyExit = processReallyExit\n}\n\nvar originalProcessReallyExit = process.reallyExit\nfunction processReallyExit (code) {\n  process.exitCode = code || 0\n  emit('exit', process.exitCode, null)\n  /* istanbul ignore next */\n  emit('afterexit', process.exitCode, null)\n  /* istanbul ignore next */\n  originalProcessReallyExit.call(process, process.exitCode)\n}\n\nvar originalProcessEmit = process.emit\nfunction processEmit (ev, arg) {\n  if (ev === 'exit') {\n    if (arg !== undefined) {\n      process.exitCode = arg\n    }\n    var ret = originalProcessEmit.apply(this, arguments)\n    emit('exit', process.exitCode, null)\n    /* istanbul ignore next */\n    emit('afterexit', process.exitCode, null)\n    return ret\n  } else {\n    return originalProcessEmit.apply(this, arguments)\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/signal-exit/index.js?");

/***/ }),

/***/ "./node_modules/signal-exit/signals.js":
/*!*********************************************!*\
  !*** ./node_modules/signal-exit/signals.js ***!
  \*********************************************/
/***/ ((module) => {

eval("// This is not the set of all possible signals.\n//\n// It IS, however, the set of all signals that trigger\n// an exit on either Linux or BSD systems.  Linux is a\n// superset of the signal names supported on BSD, and\n// the unknown signals just fail to register, so we can\n// catch that easily enough.\n//\n// Don't bother with SIGKILL.  It's uncatchable, which\n// means that we can't fire any callbacks anyway.\n//\n// If a user does happen to register a handler on a non-\n// fatal signal like SIGWINCH or something, and then\n// exit, it'll end up firing `process.emit('exit')`, so\n// the handler will be fired anyway.\n//\n// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n// artificially, inherently leave the process in a\n// state from which it is not safe to try and enter JS\n// listeners.\nmodule.exports = [\n  'SIGABRT',\n  'SIGALRM',\n  'SIGHUP',\n  'SIGINT',\n  'SIGTERM'\n]\n\nif (process.platform !== 'win32') {\n  module.exports.push(\n    'SIGVTALRM',\n    'SIGXCPU',\n    'SIGXFSZ',\n    'SIGUSR2',\n    'SIGTRAP',\n    'SIGSYS',\n    'SIGQUIT',\n    'SIGIOT'\n    // should detect profiler and enable/disable accordingly.\n    // see #21\n    // 'SIGPROF'\n  )\n}\n\nif (process.platform === 'linux') {\n  module.exports.push(\n    'SIGIO',\n    'SIGPOLL',\n    'SIGPWR',\n    'SIGSTKFLT',\n    'SIGUNUSED'\n  )\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/signal-exit/signals.js?");

/***/ }),

/***/ "./node_modules/streamroller/lib/DateRollingFileStream.js":
/*!****************************************************************!*\
  !*** ./node_modules/streamroller/lib/DateRollingFileStream.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const RollingFileWriteStream = __webpack_require__(/*! ./RollingFileWriteStream */ \"./node_modules/streamroller/lib/RollingFileWriteStream.js\");\n\n// just to adapt the previous version\nclass DateRollingFileStream extends RollingFileWriteStream {\n  constructor(filename, pattern, options) {\n    if (pattern && typeof(pattern) === 'object') {\n      options = pattern;\n      pattern = null;\n    }\n    if (!options) {\n      options = {};\n    }\n    if (!pattern) {\n      pattern = 'yyyy-MM-dd';\n    }\n    if (options.daysToKeep) {\n      options.numToKeep = options.daysToKeep;\n    }\n    if (pattern.startsWith('.')) {\n      pattern = pattern.substring(1);\n    }\n    options.pattern = pattern;\n    super(filename, options);\n    this.mode = this.options.mode;\n  }\n\n  get theStream() {\n    return this.currentFileStream;\n  }\n\n}\n\nmodule.exports = DateRollingFileStream;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/lib/DateRollingFileStream.js?");

/***/ }),

/***/ "./node_modules/streamroller/lib/RollingFileStream.js":
/*!************************************************************!*\
  !*** ./node_modules/streamroller/lib/RollingFileStream.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const RollingFileWriteStream = __webpack_require__(/*! ./RollingFileWriteStream */ \"./node_modules/streamroller/lib/RollingFileWriteStream.js\");\n\n// just to adapt the previous version\nclass RollingFileStream extends RollingFileWriteStream {\n  constructor(filename, size, backups, options) {\n    if (!options) {\n      options = {};\n    }\n    if (size) {\n      options.maxSize = size;\n    }\n    if (!backups) {\n      backups = 1;\n    }\n    options.numToKeep = backups;\n    super(filename, options);\n    this.backups = this.options.numToKeep;\n    this.size = this.options.maxSize;\n  }\n\n  get theStream() {\n    return this.currentFileStream;\n  }\n\n}\n\nmodule.exports = RollingFileStream;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/lib/RollingFileStream.js?");

/***/ }),

/***/ "./node_modules/streamroller/lib/RollingFileWriteStream.js":
/*!*****************************************************************!*\
  !*** ./node_modules/streamroller/lib/RollingFileWriteStream.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")(\"streamroller:RollingFileWriteStream\");\nconst fs = __webpack_require__(/*! fs-extra */ \"./node_modules/streamroller/node_modules/fs-extra/lib/index.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst newNow = __webpack_require__(/*! ./now */ \"./node_modules/streamroller/lib/now.js\");\nconst format = __webpack_require__(/*! date-format */ \"./node_modules/streamroller/node_modules/date-format/lib/index.js\");\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\nconst fileNameFormatter = __webpack_require__(/*! ./fileNameFormatter */ \"./node_modules/streamroller/lib/fileNameFormatter.js\");\nconst fileNameParser = __webpack_require__(/*! ./fileNameParser */ \"./node_modules/streamroller/lib/fileNameParser.js\");\nconst moveAndMaybeCompressFile = __webpack_require__(/*! ./moveAndMaybeCompressFile */ \"./node_modules/streamroller/lib/moveAndMaybeCompressFile.js\");\n\n/**\n * RollingFileWriteStream is mainly used when writing to a file rolling by date or size.\n * RollingFileWriteStream inherits from stream.Writable\n */\nclass RollingFileWriteStream extends Writable {\n  /**\n   * Create a RollingFileWriteStream\n   * @constructor\n   * @param {string} filePath - The file path to write.\n   * @param {object} options - The extra options\n   * @param {number} options.numToKeep - The max numbers of files to keep.\n   * @param {number} options.maxSize - The maxSize one file can reach. Unit is Byte.\n   *                                   This should be more than 1024. The default is Number.MAX_SAFE_INTEGER.\n   * @param {string} options.mode - The mode of the files. The default is '0644'. Refer to stream.writable for more.\n   * @param {string} options.flags - The default is 'a'. Refer to stream.flags for more.\n   * @param {boolean} options.compress - Whether to compress backup files.\n   * @param {boolean} options.keepFileExt - Whether to keep the file extension.\n   * @param {string} options.pattern - The date string pattern in the file name.\n   * @param {boolean} options.alwaysIncludePattern - Whether to add date to the name of the first file.\n   */\n  constructor(filePath, options) {\n    debug(`constructor: creating RollingFileWriteStream. path=${filePath}`);\n    super(options);\n    this.options = this._parseOption(options);\n    this.fileObject = path.parse(filePath);\n    if (this.fileObject.dir === \"\") {\n      this.fileObject = path.parse(path.join(process.cwd(), filePath));\n    }\n    this.fileFormatter = fileNameFormatter({\n      file: this.fileObject,\n      alwaysIncludeDate: this.options.alwaysIncludePattern,\n      needsIndex: this.options.maxSize < Number.MAX_SAFE_INTEGER,\n      compress: this.options.compress,\n      keepFileExt: this.options.keepFileExt\n    });\n\n    this.fileNameParser = fileNameParser({\n      file: this.fileObject,\n      keepFileExt: this.options.keepFileExt,\n      pattern: this.options.pattern\n    });\n\n    this.state = {\n      currentSize: 0\n    };\n\n    if (this.options.pattern) {\n      this.state.currentDate = format(this.options.pattern, newNow());\n    }\n\n    this.filename = this.fileFormatter({\n      index: 0,\n      date: this.state.currentDate\n    });\n    if ([\"a\", \"a+\", \"as\", \"as+\"].includes(this.options.flags)) {\n      this._setExistingSizeAndDate();\n    }\n\n    debug(\n      `constructor: create new file ${this.filename}, state=${JSON.stringify(\n        this.state\n      )}`\n    );\n    this._renewWriteStream();\n  }\n\n  _setExistingSizeAndDate() {\n    try {\n      const stats = fs.statSync(this.filename);\n      this.state.currentSize = stats.size;\n      if (this.options.pattern) {\n        this.state.currentDate = format(this.options.pattern, stats.mtime);\n      }\n    } catch (e) {\n      //file does not exist, that's fine - move along\n      return;\n    }\n  }\n\n  _parseOption(rawOptions) {\n    const defaultOptions = {\n      maxSize: Number.MAX_SAFE_INTEGER,\n      numToKeep: Number.MAX_SAFE_INTEGER,\n      encoding: \"utf8\",\n      mode: parseInt(\"0644\", 8),\n      flags: \"a\",\n      compress: false,\n      keepFileExt: false,\n      alwaysIncludePattern: false\n    };\n    const options = Object.assign({}, defaultOptions, rawOptions);\n    if (options.maxSize <= 0) {\n      throw new Error(`options.maxSize (${options.maxSize}) should be > 0`);\n    }\n    if (options.numToKeep <= 0) {\n      throw new Error(`options.numToKeep (${options.numToKeep}) should be > 0`);\n    }\n    debug(\n      `_parseOption: creating stream with option=${JSON.stringify(options)}`\n    );\n    return options;\n  }\n\n  _final(callback) {\n    this.currentFileStream.end(\"\", this.options.encoding, callback);\n  }\n\n  _write(chunk, encoding, callback) {\n    this._shouldRoll().then(() => {\n      debug(\n        `_write: writing chunk. ` +\n          `file=${this.currentFileStream.path} ` +\n          `state=${JSON.stringify(this.state)} ` +\n          `chunk=${chunk}`\n      );\n      this.currentFileStream.write(chunk, encoding, e => {\n        this.state.currentSize += chunk.length;\n        callback(e);\n      });\n    });\n  }\n\n  async _shouldRoll() {\n    if (this._dateChanged() || this._tooBig()) {\n      debug(\n        `_shouldRoll: rolling because dateChanged? ${this._dateChanged()} or tooBig? ${this._tooBig()}`\n      );\n      await this._roll();\n    }\n  }\n\n  _dateChanged() {\n    return (\n      this.state.currentDate &&\n      this.state.currentDate !== format(this.options.pattern, newNow())\n    );\n  }\n\n  _tooBig() {\n    return this.state.currentSize >= this.options.maxSize;\n  }\n\n  _roll() {\n    debug(`_roll: closing the current stream`);\n    return new Promise((resolve, reject) => {\n      this.currentFileStream.end(\"\", this.options.encoding, () => {\n        this._moveOldFiles()\n          .then(resolve)\n          .catch(reject);\n      });\n    });\n  }\n\n  async _moveOldFiles() {\n    const files = await this._getExistingFiles();\n    const todaysFiles = this.state.currentDate\n      ? files.filter(f => f.date === this.state.currentDate)\n      : files;\n    for (let i = todaysFiles.length; i >= 0; i--) {\n      debug(`_moveOldFiles: i = ${i}`);\n      const sourceFilePath = this.fileFormatter({\n        date: this.state.currentDate,\n        index: i\n      });\n      const targetFilePath = this.fileFormatter({\n        date: this.state.currentDate,\n        index: i + 1\n      });\n\n      await moveAndMaybeCompressFile(\n        sourceFilePath,\n        targetFilePath,\n        this.options.compress && i === 0\n      );\n    }\n\n    this.state.currentSize = 0;\n    this.state.currentDate = this.state.currentDate\n      ? format(this.options.pattern, newNow())\n      : null;\n    debug(\n      `_moveOldFiles: finished rolling files. state=${JSON.stringify(\n        this.state\n      )}`\n    );\n    this._renewWriteStream();\n    // wait for the file to be open before cleaning up old ones,\n    // otherwise the daysToKeep calculations can be off\n    await new Promise((resolve, reject) => {\n      this.currentFileStream.write(\"\", \"utf8\", () => {\n        this._clean()\n          .then(resolve)\n          .catch(reject);\n      });\n    });\n  }\n\n  // Sorted from the oldest to the latest\n  async _getExistingFiles() {\n    const files = await fs.readdir(this.fileObject.dir).catch(() => []);\n\n    debug(`_getExistingFiles: files=${files}`);\n    const existingFileDetails = files\n      .map(n => this.fileNameParser(n))\n      .filter(n => n);\n\n    const getKey = n =>\n      (n.timestamp ? n.timestamp : newNow().getTime()) - n.index;\n    existingFileDetails.sort((a, b) => getKey(a) - getKey(b));\n\n    return existingFileDetails;\n  }\n\n  _renewWriteStream() {\n    fs.ensureDirSync(this.fileObject.dir);\n    const filePath = this.fileFormatter({\n      date: this.state.currentDate,\n      index: 0\n    });\n    const ops = {\n      flags: this.options.flags,\n      encoding: this.options.encoding,\n      mode: this.options.mode\n    };\n    this.currentFileStream = fs.createWriteStream(filePath, ops);\n    this.currentFileStream.on(\"error\", e => {\n      this.emit(\"error\", e);\n    });\n  }\n\n  async _clean() {\n    const existingFileDetails = await this._getExistingFiles();\n    debug(\n      `_clean: numToKeep = ${this.options.numToKeep}, existingFiles = ${existingFileDetails.length}`\n    );\n    debug(\"_clean: existing files are: \", existingFileDetails);\n    if (this._tooManyFiles(existingFileDetails.length)) {\n      const fileNamesToRemove = existingFileDetails\n        .slice(0, existingFileDetails.length - this.options.numToKeep - 1)\n        .map(f => path.format({ dir: this.fileObject.dir, base: f.filename }));\n      await deleteFiles(fileNamesToRemove);\n    }\n  }\n\n  _tooManyFiles(numFiles) {\n    return this.options.numToKeep > 0 && numFiles > this.options.numToKeep;\n  }\n}\n\nconst deleteFiles = fileNames => {\n  debug(`deleteFiles: files to delete: ${fileNames}`);\n  return Promise.all(fileNames.map(f => fs.unlink(f).catch((e) => {\n    debug(`deleteFiles: error when unlinking ${f}, ignoring. Error was ${e}`);\n  })));\n};\n\nmodule.exports = RollingFileWriteStream;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/lib/RollingFileWriteStream.js?");

/***/ }),

/***/ "./node_modules/streamroller/lib/fileNameFormatter.js":
/*!************************************************************!*\
  !*** ./node_modules/streamroller/lib/fileNameFormatter.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")(\"streamroller:fileNameFormatter\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst FILENAME_SEP = \".\";\nconst ZIP_EXT = \".gz\";\n\nmodule.exports = ({\n  file,\n  keepFileExt,\n  needsIndex,\n  alwaysIncludeDate,\n  compress\n}) => {\n  const dirAndName = path.join(file.dir, file.name);\n\n  const ext = f => f + file.ext;\n\n  const index = (f, i, d) =>\n    (needsIndex || !d) && i ? f + FILENAME_SEP + i : f;\n\n  const date = (f, i, d) => {\n    return (i > 0 || alwaysIncludeDate) && d ? f + FILENAME_SEP + d : f;\n  };\n\n  const gzip = (f, i) => (i && compress ? f + ZIP_EXT : f);\n\n  const parts = keepFileExt\n    ? [date, index, ext, gzip]\n    : [ext, date, index, gzip];\n\n  return ({ date, index }) => {\n    debug(`_formatFileName: date=${date}, index=${index}`);\n    return parts.reduce(\n      (filename, part) => part(filename, index, date),\n      dirAndName\n    );\n  };\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/lib/fileNameFormatter.js?");

/***/ }),

/***/ "./node_modules/streamroller/lib/fileNameParser.js":
/*!*********************************************************!*\
  !*** ./node_modules/streamroller/lib/fileNameParser.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")(\"streamroller:fileNameParser\");\nconst FILENAME_SEP = \".\";\nconst ZIP_EXT = \".gz\";\nconst format = __webpack_require__(/*! date-format */ \"./node_modules/streamroller/node_modules/date-format/lib/index.js\");\n\nmodule.exports = ({ file, keepFileExt, pattern }) => {\n  // All these functions take two arguments: f, the filename, and p, the result placeholder\n  // They return the filename with any matching parts removed.\n  // The \"zip\" function, for instance, removes the \".gz\" part of the filename (if present)\n  const zip = (f, p) => {\n    if (f.endsWith(ZIP_EXT)) {\n      debug(\"it is gzipped\");\n      p.isCompressed = true;\n      return f.slice(0, -1 * ZIP_EXT.length);\n    }\n    return f;\n  };\n\n  const __NOT_MATCHING__ = \"__NOT_MATCHING__\";\n\n  const extAtEnd = f => {\n    if (f.startsWith(file.name) && f.endsWith(file.ext)) {\n      debug(\"it starts and ends with the right things\");\n      return f.slice(file.name.length + 1, -1 * file.ext.length);\n    }\n    return __NOT_MATCHING__;\n  };\n\n  const extInMiddle = f => {\n    if (f.startsWith(file.base)) {\n      debug(\"it starts with the right things\");\n      return f.slice(file.base.length + 1);\n    }\n    return __NOT_MATCHING__;\n  };\n\n  const dateAndIndex = (f, p) => {\n    const items = f.split(FILENAME_SEP);\n    let indexStr = items[items.length - 1];\n    debug(\"items: \", items, \", indexStr: \", indexStr);\n    let dateStr = f;\n    if (indexStr !== undefined && indexStr.match(/^\\d+$/)) {\n      dateStr = f.slice(0, -1 * (indexStr.length + 1));\n      debug(`dateStr is ${dateStr}`);\n      if (pattern && !dateStr) {\n        dateStr = indexStr;\n        indexStr = \"0\";\n      }\n    } else {\n      indexStr = \"0\";\n    }\n\n    try {\n      // Two arguments for new Date() are intentional. This will set other date\n      // components to minimal values in the current timezone instead of UTC,\n      // as new Date(0) will do.\n      const date = format.parse(pattern, dateStr, new Date(0, 0));\n      if (format.asString(pattern, date) !== dateStr) return f;\n      p.index = parseInt(indexStr, 10);\n      p.date = dateStr;\n      p.timestamp = date.getTime();\n      return \"\";\n    } catch (e) {\n      //not a valid date, don't panic.\n      debug(`Problem parsing ${dateStr} as ${pattern}, error was: `, e);\n      return f;\n    }\n  };\n\n  const index = (f, p) => {\n    if (f.match(/^\\d+$/)) {\n      debug(\"it has an index\");\n      p.index = parseInt(f, 10);\n      return \"\";\n    }\n    return f;\n  };\n\n  let parts = [\n    zip,\n    keepFileExt ? extAtEnd : extInMiddle,\n    pattern ? dateAndIndex : index\n  ];\n\n  return filename => {\n    let result = { filename, index: 0, isCompressed: false };\n    // pass the filename through each of the file part parsers\n    let whatsLeftOver = parts.reduce(\n      (remains, part) => part(remains, result),\n      filename\n    );\n    // if there's anything left after parsing, then it wasn't a valid filename\n    return whatsLeftOver ? null : result;\n  };\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/lib/fileNameParser.js?");

/***/ }),

/***/ "./node_modules/streamroller/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/streamroller/lib/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = {\n  RollingFileWriteStream: __webpack_require__(/*! ./RollingFileWriteStream */ \"./node_modules/streamroller/lib/RollingFileWriteStream.js\"),\n  RollingFileStream: __webpack_require__(/*! ./RollingFileStream */ \"./node_modules/streamroller/lib/RollingFileStream.js\"),\n  DateRollingFileStream: __webpack_require__(/*! ./DateRollingFileStream */ \"./node_modules/streamroller/lib/DateRollingFileStream.js\")\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/lib/index.js?");

/***/ }),

/***/ "./node_modules/streamroller/lib/moveAndMaybeCompressFile.js":
/*!*******************************************************************!*\
  !*** ./node_modules/streamroller/lib/moveAndMaybeCompressFile.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('streamroller:moveAndMaybeCompressFile');\nconst fs = __webpack_require__(/*! fs-extra */ \"./node_modules/streamroller/node_modules/fs-extra/lib/index.js\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nconst moveAndMaybeCompressFile = async (\n  sourceFilePath,\n  targetFilePath,\n  needCompress\n) => {\n  if (sourceFilePath === targetFilePath) {\n    debug(\n      `moveAndMaybeCompressFile: source and target are the same, not doing anything`\n    );\n    return;\n  }\n    if (await fs.pathExists(sourceFilePath)) {\n\n      debug(\n        `moveAndMaybeCompressFile: moving file from ${sourceFilePath} to ${targetFilePath} ${\n          needCompress ? \"with\" : \"without\"\n        } compress`\n      );\n      if (needCompress) {\n        await new Promise((resolve, reject) => {\n          fs.createReadStream(sourceFilePath)\n            .pipe(zlib.createGzip())\n            .pipe(fs.createWriteStream(targetFilePath))\n            .on(\"finish\", () => {\n              debug(\n                `moveAndMaybeCompressFile: finished compressing ${targetFilePath}, deleting ${sourceFilePath}`\n              );\n              fs.unlink(sourceFilePath)\n                .then(resolve)\n                .catch(() => {\n                  debug(`Deleting ${sourceFilePath} failed, truncating instead`);\n                  fs.truncate(sourceFilePath).then(resolve).catch(reject)\n                });\n            });\n        });\n      } else {\n        debug(\n          `moveAndMaybeCompressFile: deleting file=${targetFilePath}, renaming ${sourceFilePath} to ${targetFilePath}`\n        );\n        try {\n          await fs.move(sourceFilePath, targetFilePath, { overwrite: true });\n        } catch (e) {\n          debug(\n            `moveAndMaybeCompressFile: error moving ${sourceFilePath} to ${targetFilePath}`, e\n          );\n          debug(`Trying copy+truncate instead`);\n          await fs.copy(sourceFilePath, targetFilePath, { overwrite: true });\n          await fs.truncate(sourceFilePath);\n        }\n      }\n    }\n};\n\nmodule.exports = moveAndMaybeCompressFile;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/lib/moveAndMaybeCompressFile.js?");

/***/ }),

/***/ "./node_modules/streamroller/lib/now.js":
/*!**********************************************!*\
  !*** ./node_modules/streamroller/lib/now.js ***!
  \**********************************************/
/***/ ((module) => {

eval("// allows us to inject a mock date in tests\nmodule.exports = () => new Date();\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/lib/now.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/date-format/lib/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/date-format/lib/index.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction padWithZeros(vNumber, width) {\n  var numAsString = vNumber.toString();\n  while (numAsString.length < width) {\n    numAsString = \"0\" + numAsString;\n  }\n  return numAsString;\n}\n\nfunction addZero(vNumber) {\n  return padWithZeros(vNumber, 2);\n}\n\n/**\n * Formats the TimeOffset\n * Thanks to http://www.svendtofte.com/code/date_format/\n * @private\n */\nfunction offset(timezoneOffset) {\n  var os = Math.abs(timezoneOffset);\n  var h = String(Math.floor(os / 60));\n  var m = String(os % 60);\n  if (h.length === 1) {\n    h = \"0\" + h;\n  }\n  if (m.length === 1) {\n    m = \"0\" + m;\n  }\n  return timezoneOffset < 0 ? \"+\" + h + m : \"-\" + h + m;\n}\n\nfunction datePart(date, displayUTC, part) {\n  return displayUTC ? date[\"getUTC\" + part]() : date[\"get\" + part]();\n}\n\nfunction asString(format, date) {\n  if (typeof format !== \"string\") {\n    date = format;\n    format = module.exports.ISO8601_FORMAT;\n  }\n  if (!date) {\n    date = module.exports.now();\n  }\n\n  var displayUTC = format.indexOf(\"O\") > -1;\n\n  var vDay = addZero(datePart(date, displayUTC, \"Date\"));\n  var vMonth = addZero(datePart(date, displayUTC, \"Month\") + 1);\n  var vYearLong = addZero(datePart(date, displayUTC, \"FullYear\"));\n  var vYearShort = addZero(vYearLong.substring(2, 4));\n  var vYear = format.indexOf(\"yyyy\") > -1 ? vYearLong : vYearShort;\n  var vHour = addZero(datePart(date, displayUTC, \"Hours\"));\n  var vMinute = addZero(datePart(date, displayUTC, \"Minutes\"));\n  var vSecond = addZero(datePart(date, displayUTC, \"Seconds\"));\n  var vMillisecond = padWithZeros(\n    datePart(date, displayUTC, \"Milliseconds\"),\n    3\n  );\n  var vTimeZone = offset(date.getTimezoneOffset());\n  var formatted = format\n    .replace(/dd/g, vDay)\n    .replace(/MM/g, vMonth)\n    .replace(/y{1,4}/g, vYear)\n    .replace(/hh/g, vHour)\n    .replace(/mm/g, vMinute)\n    .replace(/ss/g, vSecond)\n    .replace(/SSS/g, vMillisecond)\n    .replace(/O/g, vTimeZone);\n  return formatted;\n}\n\nfunction extractDateParts(pattern, str, missingValuesDate) {\n  var matchers = [\n    {\n      pattern: /y{1,4}/,\n      regexp: \"\\\\d{1,4}\",\n      fn: function(date, value) {\n        date.setFullYear(value);\n      }\n    },\n    {\n      pattern: /MM/,\n      regexp: \"\\\\d{1,2}\",\n      fn: function(date, value) {\n        date.setMonth(value - 1);\n      }\n    },\n    {\n      pattern: /dd/,\n      regexp: \"\\\\d{1,2}\",\n      fn: function(date, value) {\n        date.setDate(value);\n      }\n    },\n    {\n      pattern: /hh/,\n      regexp: \"\\\\d{1,2}\",\n      fn: function(date, value) {\n        date.setHours(value);\n      }\n    },\n    {\n      pattern: /mm/,\n      regexp: \"\\\\d\\\\d\",\n      fn: function(date, value) {\n        date.setMinutes(value);\n      }\n    },\n    {\n      pattern: /ss/,\n      regexp: \"\\\\d\\\\d\",\n      fn: function(date, value) {\n        date.setSeconds(value);\n      }\n    },\n    {\n      pattern: /SSS/,\n      regexp: \"\\\\d\\\\d\\\\d\",\n      fn: function(date, value) {\n        date.setMilliseconds(value);\n      }\n    },\n    {\n      pattern: /O/,\n      regexp: \"[+-]\\\\d{3,4}|Z\",\n      fn: function(date, value) {\n        if (value === \"Z\") {\n          value = 0;\n        }\n        var offset = Math.abs(value);\n        var minutes = (offset % 100) + Math.floor(offset / 100) * 60;\n        date.setMinutes(date.getMinutes() + (value > 0 ? minutes : -minutes));\n      }\n    }\n  ];\n\n  var parsedPattern = matchers.reduce(\n    function(p, m) {\n      if (m.pattern.test(p.regexp)) {\n        m.index = p.regexp.match(m.pattern).index;\n        p.regexp = p.regexp.replace(m.pattern, \"(\" + m.regexp + \")\");\n      } else {\n        m.index = -1;\n      }\n      return p;\n    },\n    { regexp: pattern, index: [] }\n  );\n\n  var dateFns = matchers.filter(function(m) {\n    return m.index > -1;\n  });\n  dateFns.sort(function(a, b) {\n    return a.index - b.index;\n  });\n\n  var matcher = new RegExp(parsedPattern.regexp);\n  var matches = matcher.exec(str);\n  if (matches) {\n    var date = missingValuesDate || module.exports.now();\n    dateFns.forEach(function(f, i) {\n      f.fn(date, matches[i + 1]);\n    });\n    return date;\n  }\n\n  throw new Error(\n    \"String '\" + str + \"' could not be parsed as '\" + pattern + \"'\"\n  );\n}\n\nfunction parse(pattern, str, missingValuesDate) {\n  if (!pattern) {\n    throw new Error(\"pattern must be supplied\");\n  }\n\n  return extractDateParts(pattern, str, missingValuesDate);\n}\n\n/**\n * Used for testing - replace this function with a fixed date.\n */\nfunction now() {\n  return new Date();\n}\n\nmodule.exports = asString;\nmodule.exports.asString = asString;\nmodule.exports.parse = parse;\nmodule.exports.now = now;\nmodule.exports.ISO8601_FORMAT = \"yyyy-MM-ddThh:mm:ss.SSS\";\nmodule.exports.ISO8601_WITH_TZ_OFFSET_FORMAT = \"yyyy-MM-ddThh:mm:ss.SSSO\";\nmodule.exports.DATETIME_FORMAT = \"dd MM yyyy hh:mm:ss.SSS\";\nmodule.exports.ABSOLUTETIME_FORMAT = \"hh:mm:ss.SSS\";\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/date-format/lib/index.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/copy-sync.js":
/*!************************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/copy-sync.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdirpSync = __webpack_require__(/*! ../mkdirs */ \"./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js\").mkdirsSync\nconst utimesSync = __webpack_require__(/*! ../util/utimes.js */ \"./node_modules/streamroller/node_modules/fs-extra/lib/util/utimes.js\").utimesMillisSync\nconst stat = __webpack_require__(/*! ../util/stat */ \"./node_modules/streamroller/node_modules/fs-extra/lib/util/stat.js\")\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy')\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy')\n  return handleFilterAndCopy(destStat, src, dest, opts)\n}\n\nfunction handleFilterAndCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirpSync(destParent)\n  return startCopy(destStat, src, dest, opts)\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  if (typeof fs.copyFileSync === 'function') {\n    fs.copyFileSync(src, dest)\n    fs.chmodSync(dest, srcStat.mode)\n    if (opts.preserveTimestamps) {\n      return utimesSync(dest, srcStat.atime, srcStat.mtime)\n    }\n    return\n  }\n  return copyFileFallback(srcStat, src, dest, opts)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts) {\n  const BUF_LENGTH = 64 * 1024\n  const _buff = __webpack_require__(/*! ../util/buffer */ \"./node_modules/streamroller/node_modules/fs-extra/lib/util/buffer.js\")(BUF_LENGTH)\n\n  const fdr = fs.openSync(src, 'r')\n  const fdw = fs.openSync(dest, 'w', srcStat.mode)\n  let pos = 0\n\n  while (pos < srcStat.size) {\n    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)\n    fs.writeSync(fdw, _buff, 0, bytesRead)\n    pos += bytesRead\n  }\n\n  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime)\n\n  fs.closeSync(fdr)\n  fs.closeSync(fdw)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts)\n  if (destStat && !destStat.isDirectory()) {\n    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n  }\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return fs.chmodSync(dest, srcStat.mode)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy')\n  return startCopy(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\nmodule.exports = copySync\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/copy-sync.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/index.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = {\n  copySync: __webpack_require__(/*! ./copy-sync */ \"./node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/copy-sync.js\")\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/index.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/copy/copy.js":
/*!**************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/copy/copy.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdirp = __webpack_require__(/*! ../mkdirs */ \"./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js\").mkdirs\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/streamroller/node_modules/fs-extra/lib/path-exists/index.js\").pathExists\nconst utimes = __webpack_require__(/*! ../util/utimes */ \"./node_modules/streamroller/node_modules/fs-extra/lib/util/utimes.js\").utimesMillis\nconst stat = __webpack_require__(/*! ../util/stat */ \"./node_modules/streamroller/node_modules/fs-extra/lib/util/stat.js\")\n\nfunction copy (src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts\n    opts = {}\n  } else if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  cb = cb || function () {}\n  opts = opts || {}\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  stat.checkPaths(src, dest, 'copy', (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'copy', err => {\n      if (err) return cb(err)\n      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)\n      return checkParentDir(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction checkParentDir (destStat, src, dest, opts, cb) {\n  const destParent = path.dirname(dest)\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err)\n    if (dirExists) return startCopy(destStat, src, dest, opts, cb)\n    mkdirp(destParent, err => {\n      if (err) return cb(err)\n      return startCopy(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction handleFilter (onInclude, destStat, src, dest, opts, cb) {\n  Promise.resolve(opts.filter(src, dest)).then(include => {\n    if (include) return onInclude(destStat, src, dest, opts, cb)\n    return cb()\n  }, error => cb(error))\n}\n\nfunction startCopy (destStat, src, dest, opts, cb) {\n  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)\n  return getStats(destStat, src, dest, opts, cb)\n}\n\nfunction getStats (destStat, src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat\n  stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isFile() ||\n             srcStat.isCharacterDevice() ||\n             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)\n  })\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)\n  return mayCopyFile(srcStat, src, dest, opts, cb)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err)\n      return copyFile(srcStat, src, dest, opts, cb)\n    })\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`))\n  } else return cb()\n}\n\nfunction copyFile (srcStat, src, dest, opts, cb) {\n  if (typeof fs.copyFile === 'function') {\n    return fs.copyFile(src, dest, err => {\n      if (err) return cb(err)\n      return setDestModeAndTimestamps(srcStat, dest, opts, cb)\n    })\n  }\n  return copyFileFallback(srcStat, src, dest, opts, cb)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts, cb) {\n  const rs = fs.createReadStream(src)\n  rs.on('error', err => cb(err)).once('open', () => {\n    const ws = fs.createWriteStream(dest, { mode: srcStat.mode })\n    ws.on('error', err => cb(err))\n      .on('open', () => rs.pipe(ws))\n      .once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb))\n  })\n}\n\nfunction setDestModeAndTimestamps (srcStat, dest, opts, cb) {\n  fs.chmod(dest, srcStat.mode, err => {\n    if (err) return cb(err)\n    if (opts.preserveTimestamps) {\n      return utimes(dest, srcStat.atime, srcStat.mtime, cb)\n    }\n    return cb()\n  })\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts, cb)\n  if (destStat && !destStat.isDirectory()) {\n    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n  }\n  return copyDir(src, dest, opts, cb)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts, cb) {\n  fs.mkdir(dest, err => {\n    if (err) return cb(err)\n    copyDir(src, dest, opts, err => {\n      if (err) return cb(err)\n      return fs.chmod(dest, srcStat.mode, cb)\n    })\n  })\n}\n\nfunction copyDir (src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err)\n    return copyDirItems(items, src, dest, opts, cb)\n  })\n}\n\nfunction copyDirItems (items, src, dest, opts, cb) {\n  const item = items.pop()\n  if (!item) return cb()\n  return copyDirItem(items, item, src, dest, opts, cb)\n}\n\nfunction copyDirItem (items, item, src, dest, opts, cb) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  stat.checkPaths(srcItem, destItem, 'copy', (err, stats) => {\n    if (err) return cb(err)\n    const { destStat } = stats\n    startCopy(destStat, srcItem, destItem, opts, err => {\n      if (err) return cb(err)\n      return copyDirItems(items, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction onLink (destStat, src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrc) => {\n    if (err) return cb(err)\n    if (opts.dereference) {\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n    }\n\n    if (!destStat) {\n      return fs.symlink(resolvedSrc, dest, cb)\n    } else {\n      fs.readlink(dest, (err, resolvedDest) => {\n        if (err) {\n          // dest exists and is a regular file or directory,\n          // Windows may throw UNKNOWN error. If dest already exists,\n          // fs throws error anyway, so no need to guard against it here.\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)\n          return cb(err)\n        }\n        if (opts.dereference) {\n          resolvedDest = path.resolve(process.cwd(), resolvedDest)\n        }\n        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))\n        }\n\n        // do not copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n        if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))\n        }\n        return copyLink(resolvedSrc, dest, cb)\n      })\n    }\n  })\n}\n\nfunction copyLink (resolvedSrc, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err)\n    return fs.symlink(resolvedSrc, dest, cb)\n  })\n}\n\nmodule.exports = copy\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/copy/copy.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/copy/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/copy/index.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/streamroller/node_modules/universalify/index.js\").fromCallback\nmodule.exports = {\n  copy: u(__webpack_require__(/*! ./copy */ \"./node_modules/streamroller/node_modules/fs-extra/lib/copy/copy.js\"))\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/copy/index.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/empty/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/empty/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/streamroller/node_modules/universalify/index.js\").fromCallback\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js\")\nconst remove = __webpack_require__(/*! ../remove */ \"./node_modules/streamroller/node_modules/fs-extra/lib/remove/index.js\")\n\nconst emptyDir = u(function emptyDir (dir, callback) {\n  callback = callback || function () {}\n  fs.readdir(dir, (err, items) => {\n    if (err) return mkdir.mkdirs(dir, callback)\n\n    items = items.map(item => path.join(dir, item))\n\n    deleteItem()\n\n    function deleteItem () {\n      const item = items.pop()\n      if (!item) return callback()\n      remove.remove(item, err => {\n        if (err) return callback(err)\n        deleteItem()\n      })\n    }\n  })\n})\n\nfunction emptyDirSync (dir) {\n  let items\n  try {\n    items = fs.readdirSync(dir)\n  } catch (err) {\n    return mkdir.mkdirsSync(dir)\n  }\n\n  items.forEach(item => {\n    item = path.join(dir, item)\n    remove.removeSync(item)\n  })\n}\n\nmodule.exports = {\n  emptyDirSync,\n  emptydirSync: emptyDirSync,\n  emptyDir,\n  emptydir: emptyDir\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/empty/index.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/ensure/file.js":
/*!****************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/ensure/file.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/streamroller/node_modules/universalify/index.js\").fromCallback\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/streamroller/node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\nfunction createFile (file, callback) {\n  function makeFile () {\n    fs.writeFile(file, '', err => {\n      if (err) return callback(err)\n      callback()\n    })\n  }\n\n  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err\n    if (!err && stats.isFile()) return callback()\n    const dir = path.dirname(file)\n    pathExists(dir, (err, dirExists) => {\n      if (err) return callback(err)\n      if (dirExists) return makeFile()\n      mkdir.mkdirs(dir, err => {\n        if (err) return callback(err)\n        makeFile()\n      })\n    })\n  })\n}\n\nfunction createFileSync (file) {\n  let stats\n  try {\n    stats = fs.statSync(file)\n  } catch (e) {}\n  if (stats && stats.isFile()) return\n\n  const dir = path.dirname(file)\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  fs.writeFileSync(file, '')\n}\n\nmodule.exports = {\n  createFile: u(createFile),\n  createFileSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/ensure/file.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/ensure/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/ensure/index.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst file = __webpack_require__(/*! ./file */ \"./node_modules/streamroller/node_modules/fs-extra/lib/ensure/file.js\")\nconst link = __webpack_require__(/*! ./link */ \"./node_modules/streamroller/node_modules/fs-extra/lib/ensure/link.js\")\nconst symlink = __webpack_require__(/*! ./symlink */ \"./node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink.js\")\n\nmodule.exports = {\n  // file\n  createFile: file.createFile,\n  createFileSync: file.createFileSync,\n  ensureFile: file.createFile,\n  ensureFileSync: file.createFileSync,\n  // link\n  createLink: link.createLink,\n  createLinkSync: link.createLinkSync,\n  ensureLink: link.createLink,\n  ensureLinkSync: link.createLinkSync,\n  // symlink\n  createSymlink: symlink.createSymlink,\n  createSymlinkSync: symlink.createSymlinkSync,\n  ensureSymlink: symlink.createSymlink,\n  ensureSymlinkSync: symlink.createSymlinkSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/ensure/index.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/ensure/link.js":
/*!****************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/ensure/link.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/streamroller/node_modules/universalify/index.js\").fromCallback\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/streamroller/node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\nfunction createLink (srcpath, dstpath, callback) {\n  function makeLink (srcpath, dstpath) {\n    fs.link(srcpath, dstpath, err => {\n      if (err) return callback(err)\n      callback(null)\n    })\n  }\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureLink')\n        return callback(err)\n      }\n\n      const dir = path.dirname(dstpath)\n      pathExists(dir, (err, dirExists) => {\n        if (err) return callback(err)\n        if (dirExists) return makeLink(srcpath, dstpath)\n        mkdir.mkdirs(dir, err => {\n          if (err) return callback(err)\n          makeLink(srcpath, dstpath)\n        })\n      })\n    })\n  })\n}\n\nfunction createLinkSync (srcpath, dstpath) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  try {\n    fs.lstatSync(srcpath)\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  const dir = path.dirname(dstpath)\n  const dirExists = fs.existsSync(dir)\n  if (dirExists) return fs.linkSync(srcpath, dstpath)\n  mkdir.mkdirsSync(dir)\n\n  return fs.linkSync(srcpath, dstpath)\n}\n\nmodule.exports = {\n  createLink: u(createLink),\n  createLinkSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/ensure/link.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-paths.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-paths.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/streamroller/node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nfunction symlinkPaths (srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink')\n        return callback(err)\n      }\n      return callback(null, {\n        'toCwd': srcpath,\n        'toDst': srcpath\n      })\n    })\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    return pathExists(relativeToDst, (err, exists) => {\n      if (err) return callback(err)\n      if (exists) {\n        return callback(null, {\n          'toCwd': relativeToDst,\n          'toDst': srcpath\n        })\n      } else {\n        return fs.lstat(srcpath, (err) => {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink')\n            return callback(err)\n          }\n          return callback(null, {\n            'toCwd': srcpath,\n            'toDst': path.relative(dstdir, srcpath)\n          })\n        })\n      }\n    })\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  let exists\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      'toCwd': srcpath,\n      'toDst': srcpath\n    }\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    exists = fs.existsSync(relativeToDst)\n    if (exists) {\n      return {\n        'toCwd': relativeToDst,\n        'toDst': srcpath\n      }\n    } else {\n      exists = fs.existsSync(srcpath)\n      if (!exists) throw new Error('relative srcpath does not exist')\n      return {\n        'toCwd': srcpath,\n        'toDst': path.relative(dstdir, srcpath)\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  symlinkPaths,\n  symlinkPathsSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-paths.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-type.js":
/*!************************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-type.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\n\nfunction symlinkType (srcpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n  if (type) return callback(null, type)\n  fs.lstat(srcpath, (err, stats) => {\n    if (err) return callback(null, 'file')\n    type = (stats && stats.isDirectory()) ? 'dir' : 'file'\n    callback(null, type)\n  })\n}\n\nfunction symlinkTypeSync (srcpath, type) {\n  let stats\n\n  if (type) return type\n  try {\n    stats = fs.lstatSync(srcpath)\n  } catch (e) {\n    return 'file'\n  }\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nmodule.exports = {\n  symlinkType,\n  symlinkTypeSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-type.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/streamroller/node_modules/universalify/index.js\").fromCallback\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst _mkdirs = __webpack_require__(/*! ../mkdirs */ \"./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js\")\nconst mkdirs = _mkdirs.mkdirs\nconst mkdirsSync = _mkdirs.mkdirsSync\n\nconst _symlinkPaths = __webpack_require__(/*! ./symlink-paths */ \"./node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-paths.js\")\nconst symlinkPaths = _symlinkPaths.symlinkPaths\nconst symlinkPathsSync = _symlinkPaths.symlinkPathsSync\n\nconst _symlinkType = __webpack_require__(/*! ./symlink-type */ \"./node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-type.js\")\nconst symlinkType = _symlinkType.symlinkType\nconst symlinkTypeSync = _symlinkType.symlinkTypeSync\n\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/streamroller/node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\nfunction createSymlink (srcpath, dstpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    symlinkPaths(srcpath, dstpath, (err, relative) => {\n      if (err) return callback(err)\n      srcpath = relative.toDst\n      symlinkType(relative.toCwd, type, (err, type) => {\n        if (err) return callback(err)\n        const dir = path.dirname(dstpath)\n        pathExists(dir, (err, dirExists) => {\n          if (err) return callback(err)\n          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)\n          mkdirs(dir, err => {\n            if (err) return callback(err)\n            fs.symlink(srcpath, dstpath, type, callback)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction createSymlinkSync (srcpath, dstpath, type) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  const relative = symlinkPathsSync(srcpath, dstpath)\n  srcpath = relative.toDst\n  type = symlinkTypeSync(relative.toCwd, type)\n  const dir = path.dirname(dstpath)\n  const exists = fs.existsSync(dir)\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type)\n  mkdirsSync(dir)\n  return fs.symlinkSync(srcpath, dstpath, type)\n}\n\nmodule.exports = {\n  createSymlink: u(createSymlink),\n  createSymlinkSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/fs/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/fs/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// This is adapted from https://github.com/normalize/mz\n// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/streamroller/node_modules/universalify/index.js\").fromCallback\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\n\nconst api = [\n  'access',\n  'appendFile',\n  'chmod',\n  'chown',\n  'close',\n  'copyFile',\n  'fchmod',\n  'fchown',\n  'fdatasync',\n  'fstat',\n  'fsync',\n  'ftruncate',\n  'futimes',\n  'lchown',\n  'lchmod',\n  'link',\n  'lstat',\n  'mkdir',\n  'mkdtemp',\n  'open',\n  'readFile',\n  'readdir',\n  'readlink',\n  'realpath',\n  'rename',\n  'rmdir',\n  'stat',\n  'symlink',\n  'truncate',\n  'unlink',\n  'utimes',\n  'writeFile'\n].filter(key => {\n  // Some commands are not available on some systems. Ex:\n  // fs.copyFile was added in Node.js v8.5.0\n  // fs.mkdtemp was added in Node.js v5.10.0\n  // fs.lchown is not available on at least some Linux\n  return typeof fs[key] === 'function'\n})\n\n// Export all keys:\nObject.keys(fs).forEach(key => {\n  if (key === 'promises') {\n    // fs.promises is a getter property that triggers ExperimentalWarning\n    // Don't re-export it here, the getter is defined in \"lib/index.js\"\n    return\n  }\n  exports[key] = fs[key]\n})\n\n// Universalify async methods:\napi.forEach(method => {\n  exports[method] = u(fs[method])\n})\n\n// We differ from mz/fs in that we still ship the old, broken, fs.exists()\n// since we are a drop-in replacement for the native module\nexports.exists = function (filename, callback) {\n  if (typeof callback === 'function') {\n    return fs.exists(filename, callback)\n  }\n  return new Promise(resolve => {\n    return fs.exists(filename, resolve)\n  })\n}\n\n// fs.read() & fs.write need special treatment due to multiple callback args\n\nexports.read = function (fd, buffer, offset, length, position, callback) {\n  if (typeof callback === 'function') {\n    return fs.read(fd, buffer, offset, length, position, callback)\n  }\n  return new Promise((resolve, reject) => {\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffer })\n    })\n  })\n}\n\n// Function signature can be\n// fs.write(fd, buffer[, offset[, length[, position]]], callback)\n// OR\n// fs.write(fd, string[, position[, encoding]], callback)\n// We need to handle both cases, so we use ...args\nexports.write = function (fd, buffer, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.write(fd, buffer, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffer })\n    })\n  })\n}\n\n// fs.realpath.native only available in Node v9.2+\nif (typeof fs.realpath.native === 'function') {\n  exports.realpath.native = u(fs.realpath.native)\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/fs/index.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = Object.assign(\n  {},\n  // Export promiseified graceful-fs:\n  __webpack_require__(/*! ./fs */ \"./node_modules/streamroller/node_modules/fs-extra/lib/fs/index.js\"),\n  // Export extra methods:\n  __webpack_require__(/*! ./copy-sync */ \"./node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/index.js\"),\n  __webpack_require__(/*! ./copy */ \"./node_modules/streamroller/node_modules/fs-extra/lib/copy/index.js\"),\n  __webpack_require__(/*! ./empty */ \"./node_modules/streamroller/node_modules/fs-extra/lib/empty/index.js\"),\n  __webpack_require__(/*! ./ensure */ \"./node_modules/streamroller/node_modules/fs-extra/lib/ensure/index.js\"),\n  __webpack_require__(/*! ./json */ \"./node_modules/streamroller/node_modules/fs-extra/lib/json/index.js\"),\n  __webpack_require__(/*! ./mkdirs */ \"./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js\"),\n  __webpack_require__(/*! ./move-sync */ \"./node_modules/streamroller/node_modules/fs-extra/lib/move-sync/index.js\"),\n  __webpack_require__(/*! ./move */ \"./node_modules/streamroller/node_modules/fs-extra/lib/move/index.js\"),\n  __webpack_require__(/*! ./output */ \"./node_modules/streamroller/node_modules/fs-extra/lib/output/index.js\"),\n  __webpack_require__(/*! ./path-exists */ \"./node_modules/streamroller/node_modules/fs-extra/lib/path-exists/index.js\"),\n  __webpack_require__(/*! ./remove */ \"./node_modules/streamroller/node_modules/fs-extra/lib/remove/index.js\")\n)\n\n// Export fs.promises as a getter property so that we don't trigger\n// ExperimentalWarning before fs.promises is actually accessed.\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nif (Object.getOwnPropertyDescriptor(fs, 'promises')) {\n  Object.defineProperty(module.exports, \"promises\", ({\n    get () { return fs.promises }\n  }))\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/index.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/json/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/json/index.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/streamroller/node_modules/universalify/index.js\").fromCallback\nconst jsonFile = __webpack_require__(/*! ./jsonfile */ \"./node_modules/streamroller/node_modules/fs-extra/lib/json/jsonfile.js\")\n\njsonFile.outputJson = u(__webpack_require__(/*! ./output-json */ \"./node_modules/streamroller/node_modules/fs-extra/lib/json/output-json.js\"))\njsonFile.outputJsonSync = __webpack_require__(/*! ./output-json-sync */ \"./node_modules/streamroller/node_modules/fs-extra/lib/json/output-json-sync.js\")\n// aliases\njsonFile.outputJSON = jsonFile.outputJson\njsonFile.outputJSONSync = jsonFile.outputJsonSync\njsonFile.writeJSON = jsonFile.writeJson\njsonFile.writeJSONSync = jsonFile.writeJsonSync\njsonFile.readJSON = jsonFile.readJson\njsonFile.readJSONSync = jsonFile.readJsonSync\n\nmodule.exports = jsonFile\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/json/index.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/json/jsonfile.js":
/*!******************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/json/jsonfile.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/streamroller/node_modules/universalify/index.js\").fromCallback\nconst jsonFile = __webpack_require__(/*! jsonfile */ \"./node_modules/streamroller/node_modules/jsonfile/index.js\")\n\nmodule.exports = {\n  // jsonfile exports\n  readJson: u(jsonFile.readFile),\n  readJsonSync: jsonFile.readFileSync,\n  writeJson: u(jsonFile.writeFile),\n  writeJsonSync: jsonFile.writeFileSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/json/jsonfile.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/json/output-json-sync.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/json/output-json-sync.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js\")\nconst jsonFile = __webpack_require__(/*! ./jsonfile */ \"./node_modules/streamroller/node_modules/fs-extra/lib/json/jsonfile.js\")\n\nfunction outputJsonSync (file, data, options) {\n  const dir = path.dirname(file)\n\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  jsonFile.writeJsonSync(file, data, options)\n}\n\nmodule.exports = outputJsonSync\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/json/output-json-sync.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/json/output-json.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/json/output-json.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/streamroller/node_modules/fs-extra/lib/path-exists/index.js\").pathExists\nconst jsonFile = __webpack_require__(/*! ./jsonfile */ \"./node_modules/streamroller/node_modules/fs-extra/lib/json/jsonfile.js\")\n\nfunction outputJson (file, data, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n\n  const dir = path.dirname(file)\n\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return jsonFile.writeJson(file, data, options, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n      jsonFile.writeJson(file, data, options, callback)\n    })\n  })\n}\n\nmodule.exports = outputJson\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/json/output-json.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/streamroller/node_modules/universalify/index.js\").fromCallback\nconst mkdirs = u(__webpack_require__(/*! ./mkdirs */ \"./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/mkdirs.js\"))\nconst mkdirsSync = __webpack_require__(/*! ./mkdirs-sync */ \"./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js\")\n\nmodule.exports = {\n  mkdirs,\n  mkdirsSync,\n  // alias\n  mkdirp: mkdirs,\n  mkdirpSync: mkdirsSync,\n  ensureDir: mkdirs,\n  ensureDirSync: mkdirsSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst invalidWin32Path = __webpack_require__(/*! ./win32 */ \"./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/win32.js\").invalidWin32Path\n\nconst o777 = parseInt('0777', 8)\n\nfunction mkdirsSync (p, opts, made) {\n  if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  let mode = opts.mode\n  const xfs = opts.fs || fs\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    throw errInval\n  }\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  p = path.resolve(p)\n\n  try {\n    xfs.mkdirSync(p, mode)\n    made = made || p\n  } catch (err0) {\n    if (err0.code === 'ENOENT') {\n      if (path.dirname(p) === p) throw err0\n      made = mkdirsSync(path.dirname(p), opts, made)\n      mkdirsSync(p, opts, made)\n    } else {\n      // In the case of any other error, just see if there's a dir there\n      // already. If so, then hooray!  If not, then something is borked.\n      let stat\n      try {\n        stat = xfs.statSync(p)\n      } catch (err1) {\n        throw err0\n      }\n      if (!stat.isDirectory()) throw err0\n    }\n  }\n\n  return made\n}\n\nmodule.exports = mkdirsSync\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/mkdirs.js":
/*!******************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/mkdirs.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst invalidWin32Path = __webpack_require__(/*! ./win32 */ \"./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/win32.js\").invalidWin32Path\n\nconst o777 = parseInt('0777', 8)\n\nfunction mkdirs (p, opts, callback, made) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  } else if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    return callback(errInval)\n  }\n\n  let mode = opts.mode\n  const xfs = opts.fs || fs\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  callback = callback || function () {}\n  p = path.resolve(p)\n\n  xfs.mkdir(p, mode, er => {\n    if (!er) {\n      made = made || p\n      return callback(null, made)\n    }\n    switch (er.code) {\n      case 'ENOENT':\n        if (path.dirname(p) === p) return callback(er)\n        mkdirs(path.dirname(p), opts, (er, made) => {\n          if (er) callback(er, made)\n          else mkdirs(p, opts, callback, made)\n        })\n        break\n\n      // In the case of any other error, just see if there's a dir\n      // there already.  If so, then hooray!  If not, then something\n      // is borked.\n      default:\n        xfs.stat(p, (er2, stat) => {\n          // if the stat fails, then that's super weird.\n          // let the original error be the failure reason.\n          if (er2 || !stat.isDirectory()) callback(er, made)\n          else callback(null, made)\n        })\n        break\n    }\n  })\n}\n\nmodule.exports = mkdirs\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/mkdirs.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/win32.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/win32.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\")\n\n// get drive on windows\nfunction getRootPath (p) {\n  p = path.normalize(path.resolve(p)).split(path.sep)\n  if (p.length > 0) return p[0]\n  return null\n}\n\n// http://stackoverflow.com/a/62888/10333 contains more accurate\n// TODO: expand to include the rest\nconst INVALID_PATH_CHARS = /[<>:\"|?*]/\n\nfunction invalidWin32Path (p) {\n  const rp = getRootPath(p)\n  p = p.replace(rp, '')\n  return INVALID_PATH_CHARS.test(p)\n}\n\nmodule.exports = {\n  getRootPath,\n  invalidWin32Path\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/win32.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/move-sync/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/move-sync/index.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = {\n  moveSync: __webpack_require__(/*! ./move-sync */ \"./node_modules/streamroller/node_modules/fs-extra/lib/move-sync/move-sync.js\")\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/move-sync/index.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/move-sync/move-sync.js":
/*!************************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/move-sync/move-sync.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst copySync = __webpack_require__(/*! ../copy-sync */ \"./node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/index.js\").copySync\nconst removeSync = __webpack_require__(/*! ../remove */ \"./node_modules/streamroller/node_modules/fs-extra/lib/remove/index.js\").removeSync\nconst mkdirpSync = __webpack_require__(/*! ../mkdirs */ \"./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js\").mkdirpSync\nconst stat = __webpack_require__(/*! ../util/stat */ \"./node_modules/streamroller/node_modules/fs-extra/lib/util/stat.js\")\n\nfunction moveSync (src, dest, opts) {\n  opts = opts || {}\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  const { srcStat } = stat.checkPathsSync(src, dest, 'move')\n  stat.checkParentPathsSync(src, srcStat, dest, 'move')\n  mkdirpSync(path.dirname(dest))\n  return doRename(src, dest, overwrite)\n}\n\nfunction doRename (src, dest, overwrite) {\n  if (overwrite) {\n    removeSync(dest)\n    return rename(src, dest, overwrite)\n  }\n  if (fs.existsSync(dest)) throw new Error('dest already exists.')\n  return rename(src, dest, overwrite)\n}\n\nfunction rename (src, dest, overwrite) {\n  try {\n    fs.renameSync(src, dest)\n  } catch (err) {\n    if (err.code !== 'EXDEV') throw err\n    return moveAcrossDevice(src, dest, overwrite)\n  }\n}\n\nfunction moveAcrossDevice (src, dest, overwrite) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copySync(src, dest, opts)\n  return removeSync(src)\n}\n\nmodule.exports = moveSync\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/move-sync/move-sync.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/move/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/move/index.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/streamroller/node_modules/universalify/index.js\").fromCallback\nmodule.exports = {\n  move: u(__webpack_require__(/*! ./move */ \"./node_modules/streamroller/node_modules/fs-extra/lib/move/move.js\"))\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/move/index.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/move/move.js":
/*!**************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/move/move.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst copy = __webpack_require__(/*! ../copy */ \"./node_modules/streamroller/node_modules/fs-extra/lib/copy/index.js\").copy\nconst remove = __webpack_require__(/*! ../remove */ \"./node_modules/streamroller/node_modules/fs-extra/lib/remove/index.js\").remove\nconst mkdirp = __webpack_require__(/*! ../mkdirs */ \"./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js\").mkdirp\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/streamroller/node_modules/fs-extra/lib/path-exists/index.js\").pathExists\nconst stat = __webpack_require__(/*! ../util/stat */ \"./node_modules/streamroller/node_modules/fs-extra/lib/util/stat.js\")\n\nfunction move (src, dest, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  stat.checkPaths(src, dest, 'move', (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'move', err => {\n      if (err) return cb(err)\n      mkdirp(path.dirname(dest), err => {\n        if (err) return cb(err)\n        return doRename(src, dest, overwrite, cb)\n      })\n    })\n  })\n}\n\nfunction doRename (src, dest, overwrite, cb) {\n  if (overwrite) {\n    return remove(dest, err => {\n      if (err) return cb(err)\n      return rename(src, dest, overwrite, cb)\n    })\n  }\n  pathExists(dest, (err, destExists) => {\n    if (err) return cb(err)\n    if (destExists) return cb(new Error('dest already exists.'))\n    return rename(src, dest, overwrite, cb)\n  })\n}\n\nfunction rename (src, dest, overwrite, cb) {\n  fs.rename(src, dest, err => {\n    if (!err) return cb()\n    if (err.code !== 'EXDEV') return cb(err)\n    return moveAcrossDevice(src, dest, overwrite, cb)\n  })\n}\n\nfunction moveAcrossDevice (src, dest, overwrite, cb) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copy(src, dest, opts, err => {\n    if (err) return cb(err)\n    return remove(src, cb)\n  })\n}\n\nmodule.exports = move\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/move/move.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/output/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/output/index.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/streamroller/node_modules/universalify/index.js\").fromCallback\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"./node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"./node_modules/streamroller/node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  const dir = path.dirname(file)\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n\n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\nfunction outputFileSync (file, ...args) {\n  const dir = path.dirname(file)\n  if (fs.existsSync(dir)) {\n    return fs.writeFileSync(file, ...args)\n  }\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync(file, ...args)\n}\n\nmodule.exports = {\n  outputFile: u(outputFile),\n  outputFileSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/output/index.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/path-exists/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/path-exists/index.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/streamroller/node_modules/universalify/index.js\").fromPromise\nconst fs = __webpack_require__(/*! ../fs */ \"./node_modules/streamroller/node_modules/fs-extra/lib/fs/index.js\")\n\nfunction pathExists (path) {\n  return fs.access(path).then(() => true).catch(() => false)\n}\n\nmodule.exports = {\n  pathExists: u(pathExists),\n  pathExistsSync: fs.existsSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/path-exists/index.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/remove/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/remove/index.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"./node_modules/streamroller/node_modules/universalify/index.js\").fromCallback\nconst rimraf = __webpack_require__(/*! ./rimraf */ \"./node_modules/streamroller/node_modules/fs-extra/lib/remove/rimraf.js\")\n\nmodule.exports = {\n  remove: u(rimraf),\n  removeSync: rimraf.sync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/remove/index.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/remove/rimraf.js":
/*!******************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/remove/rimraf.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\n\nconst isWindows = (process.platform === 'win32')\n\nfunction defaults (options) {\n  const methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(m => {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n}\n\nfunction rimraf (p, options, cb) {\n  let busyTries = 0\n\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  rimraf_(p, options, function CB (er) {\n    if (er) {\n      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&\n          busyTries < options.maxBusyTries) {\n        busyTries++\n        const time = busyTries * 100\n        // try again, with the same exact callback as this one.\n        return setTimeout(() => rimraf_(p, options, CB), time)\n      }\n\n      // already gone\n      if (er.code === 'ENOENT') er = null\n    }\n\n    cb(er)\n  })\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, (er, st) => {\n    if (er && er.code === 'ENOENT') {\n      return cb(null)\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === 'EPERM' && isWindows) {\n      return fixWinEPERM(p, options, er, cb)\n    }\n\n    if (st && st.isDirectory()) {\n      return rmdir(p, options, er, cb)\n    }\n\n    options.unlink(p, er => {\n      if (er) {\n        if (er.code === 'ENOENT') {\n          return cb(null)\n        }\n        if (er.code === 'EPERM') {\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        }\n        if (er.code === 'EISDIR') {\n          return rmdir(p, options, er, cb)\n        }\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  options.chmod(p, 0o666, er2 => {\n    if (er2) {\n      cb(er2.code === 'ENOENT' ? null : er)\n    } else {\n      options.stat(p, (er3, stats) => {\n        if (er3) {\n          cb(er3.code === 'ENOENT' ? null : er)\n        } else if (stats.isDirectory()) {\n          rmdir(p, options, er, cb)\n        } else {\n          options.unlink(p, cb)\n        }\n      })\n    }\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  let stats\n\n  assert(p)\n  assert(options)\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  try {\n    options.chmodSync(p, 0o666)\n  } catch (er2) {\n    if (er2.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  try {\n    stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  if (stats.isDirectory()) {\n    rmdirSync(p, options, er)\n  } else {\n    options.unlinkSync(p)\n  }\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, er => {\n    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {\n      rmkids(p, options, cb)\n    } else if (er && er.code === 'ENOTDIR') {\n      cb(originalEr)\n    } else {\n      cb(er)\n    }\n  })\n}\n\nfunction rmkids (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, (er, files) => {\n    if (er) return cb(er)\n\n    let n = files.length\n    let errState\n\n    if (n === 0) return options.rmdir(p, cb)\n\n    files.forEach(f => {\n      rimraf(path.join(p, f), options, er => {\n        if (errState) {\n          return\n        }\n        if (er) return cb(errState = er)\n        if (--n === 0) {\n          options.rmdir(p, cb)\n        }\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  let st\n\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  try {\n    st = options.lstatSync(p)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er.code === 'EPERM' && isWindows) {\n      fixWinEPERMSync(p, options, er)\n    }\n  }\n\n  try {\n    // sunos lets the root user unlink directories, which is... weird.\n    if (st && st.isDirectory()) {\n      rmdirSync(p, options, null)\n    } else {\n      options.unlinkSync(p)\n    }\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    } else if (er.code === 'EPERM') {\n      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n    } else if (er.code !== 'EISDIR') {\n      throw er\n    }\n    rmdirSync(p, options, er)\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === 'ENOTDIR') {\n      throw originalEr\n    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {\n      rmkidsSync(p, options)\n    } else if (er.code !== 'ENOENT') {\n      throw er\n    }\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))\n\n  if (isWindows) {\n    // We only end up here once we got ENOTEMPTY at least once, and\n    // at this point, we are guaranteed to have removed all the kids.\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n    // try really hard to delete stuff on windows, because it has a\n    // PROFOUNDLY annoying habit of not closing handles promptly when\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\n    const startTime = Date.now()\n    do {\n      try {\n        const ret = options.rmdirSync(p, options)\n        return ret\n      } catch (er) { }\n    } while (Date.now() - startTime < 500) // give up after 500ms\n  } else {\n    const ret = options.rmdirSync(p, options)\n    return ret\n  }\n}\n\nmodule.exports = rimraf\nrimraf.sync = rimrafSync\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/remove/rimraf.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/util/buffer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/util/buffer.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n/* eslint-disable node/no-deprecated-api */\nmodule.exports = function (size) {\n  if (typeof Buffer.allocUnsafe === 'function') {\n    try {\n      return Buffer.allocUnsafe(size)\n    } catch (e) {\n      return new Buffer(size)\n    }\n  }\n  return new Buffer(size)\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/util/buffer.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/util/stat.js":
/*!**************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/util/stat.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\nconst NODE_VERSION_MAJOR_WITH_BIGINT = 10\nconst NODE_VERSION_MINOR_WITH_BIGINT = 5\nconst NODE_VERSION_PATCH_WITH_BIGINT = 0\nconst nodeVersion = process.versions.node.split('.')\nconst nodeVersionMajor = Number.parseInt(nodeVersion[0], 10)\nconst nodeVersionMinor = Number.parseInt(nodeVersion[1], 10)\nconst nodeVersionPatch = Number.parseInt(nodeVersion[2], 10)\n\nfunction nodeSupportsBigInt () {\n  if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {\n    return true\n  } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {\n    if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {\n      return true\n    } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {\n      if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfunction getStats (src, dest, cb) {\n  if (nodeSupportsBigInt()) {\n    fs.stat(src, { bigint: true }, (err, srcStat) => {\n      if (err) return cb(err)\n      fs.stat(dest, { bigint: true }, (err, destStat) => {\n        if (err) {\n          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })\n          return cb(err)\n        }\n        return cb(null, { srcStat, destStat })\n      })\n    })\n  } else {\n    fs.stat(src, (err, srcStat) => {\n      if (err) return cb(err)\n      fs.stat(dest, (err, destStat) => {\n        if (err) {\n          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })\n          return cb(err)\n        }\n        return cb(null, { srcStat, destStat })\n      })\n    })\n  }\n}\n\nfunction getStatsSync (src, dest) {\n  let srcStat, destStat\n  if (nodeSupportsBigInt()) {\n    srcStat = fs.statSync(src, { bigint: true })\n  } else {\n    srcStat = fs.statSync(src)\n  }\n  try {\n    if (nodeSupportsBigInt()) {\n      destStat = fs.statSync(dest, { bigint: true })\n    } else {\n      destStat = fs.statSync(dest)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nfunction checkPaths (src, dest, funcName, cb) {\n  getStats(src, dest, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n      return cb(new Error('Source and destination must not be the same.'))\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return cb(null, { srcStat, destStat })\n  })\n}\n\nfunction checkPathsSync (src, dest, funcName) {\n  const { srcStat, destStat } = getStatsSync(src, dest)\n  if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    throw new Error('Source and destination must not be the same.')\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\n  if (nodeSupportsBigInt()) {\n    fs.stat(destParent, { bigint: true }, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb()\n        return cb(err)\n      }\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n        return cb(new Error(errMsg(src, dest, funcName)))\n      }\n      return checkParentPaths(src, srcStat, destParent, funcName, cb)\n    })\n  } else {\n    fs.stat(destParent, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb()\n        return cb(err)\n      }\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n        return cb(new Error(errMsg(src, dest, funcName)))\n      }\n      return checkParentPaths(src, srcStat, destParent, funcName, cb)\n    })\n  }\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    if (nodeSupportsBigInt()) {\n      destStat = fs.statSync(destParent, { bigint: true })\n    } else {\n      destStat = fs.statSync(destParent)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/util/stat.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/fs-extra/lib/util/utimes.js":
/*!****************************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/fs-extra/lib/util/utimes.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\nconst os = __webpack_require__(/*! os */ \"os\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\n// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not\nfunction hasMillisResSync () {\n  let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  const d = new Date(1435410243862)\n  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141')\n  const fd = fs.openSync(tmpfile, 'r+')\n  fs.futimesSync(fd, d, d)\n  fs.closeSync(fd)\n  return fs.statSync(tmpfile).mtime > 1435410243000\n}\n\nfunction hasMillisRes (callback) {\n  let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  const d = new Date(1435410243862)\n  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {\n    if (err) return callback(err)\n    fs.open(tmpfile, 'r+', (err, fd) => {\n      if (err) return callback(err)\n      fs.futimes(fd, d, d, err => {\n        if (err) return callback(err)\n        fs.close(fd, err => {\n          if (err) return callback(err)\n          fs.stat(tmpfile, (err, stats) => {\n            if (err) return callback(err)\n            callback(null, stats.mtime > 1435410243000)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction timeRemoveMillis (timestamp) {\n  if (typeof timestamp === 'number') {\n    return Math.floor(timestamp / 1000) * 1000\n  } else if (timestamp instanceof Date) {\n    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)\n  } else {\n    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')\n  }\n}\n\nfunction utimesMillis (path, atime, mtime, callback) {\n  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)\n  fs.open(path, 'r+', (err, fd) => {\n    if (err) return callback(err)\n    fs.futimes(fd, atime, mtime, futimesErr => {\n      fs.close(fd, closeErr => {\n        if (callback) callback(futimesErr || closeErr)\n      })\n    })\n  })\n}\n\nfunction utimesMillisSync (path, atime, mtime) {\n  const fd = fs.openSync(path, 'r+')\n  fs.futimesSync(fd, atime, mtime)\n  return fs.closeSync(fd)\n}\n\nmodule.exports = {\n  hasMillisRes,\n  hasMillisResSync,\n  timeRemoveMillis,\n  utimesMillis,\n  utimesMillisSync\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/fs-extra/lib/util/utimes.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/jsonfile/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/jsonfile/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var _fs\ntry {\n  _fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\")\n} catch (_) {\n  _fs = __webpack_require__(/*! fs */ \"fs\")\n}\n\nfunction readFile (file, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  fs.readFile(file, options, function (err, data) {\n    if (err) return callback(err)\n\n    data = stripBom(data)\n\n    var obj\n    try {\n      obj = JSON.parse(data, options ? options.reviver : null)\n    } catch (err2) {\n      if (shouldThrow) {\n        err2.message = file + ': ' + err2.message\n        return callback(err2)\n      } else {\n        return callback(null, null)\n      }\n    }\n\n    callback(null, obj)\n  })\n}\n\nfunction readFileSync (file, options) {\n  options = options || {}\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  try {\n    var content = fs.readFileSync(file, options)\n    content = stripBom(content)\n    return JSON.parse(content, options.reviver)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = file + ': ' + err.message\n      throw err\n    } else {\n      return null\n    }\n  }\n}\n\nfunction stringify (obj, options) {\n  var spaces\n  var EOL = '\\n'\n  if (typeof options === 'object' && options !== null) {\n    if (options.spaces) {\n      spaces = options.spaces\n    }\n    if (options.EOL) {\n      EOL = options.EOL\n    }\n  }\n\n  var str = JSON.stringify(obj, options ? options.replacer : null, spaces)\n\n  return str.replace(/\\n/g, EOL) + EOL\n}\n\nfunction writeFile (file, obj, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var str = ''\n  try {\n    str = stringify(obj, options)\n  } catch (err) {\n    // Need to return whether a callback was passed or not\n    if (callback) callback(err, null)\n    return\n  }\n\n  fs.writeFile(file, str, options, callback)\n}\n\nfunction writeFileSync (file, obj, options) {\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var str = stringify(obj, options)\n  // not sure if fs.writeFileSync returns anything, but just in case\n  return fs.writeFileSync(file, str, options)\n}\n\nfunction stripBom (content) {\n  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified\n  if (Buffer.isBuffer(content)) content = content.toString('utf8')\n  content = content.replace(/^\\uFEFF/, '')\n  return content\n}\n\nvar jsonfile = {\n  readFile: readFile,\n  readFileSync: readFileSync,\n  writeFile: writeFile,\n  writeFileSync: writeFileSync\n}\n\nmodule.exports = jsonfile\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/jsonfile/index.js?");

/***/ }),

/***/ "./node_modules/streamroller/node_modules/universalify/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/streamroller/node_modules/universalify/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.fromCallback = function (fn) {\n  return Object.defineProperty(function () {\n    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)\n    else {\n      return new Promise((resolve, reject) => {\n        arguments[arguments.length] = (err, res) => {\n          if (err) return reject(err)\n          resolve(res)\n        }\n        arguments.length++\n        fn.apply(this, arguments)\n      })\n    }\n  }, 'name', { value: fn.name })\n}\n\nexports.fromPromise = function (fn) {\n  return Object.defineProperty(function () {\n    const cb = arguments[arguments.length - 1]\n    if (typeof cb !== 'function') return fn.apply(this, arguments)\n    else fn.apply(this, arguments).then(r => cb(null, r), cb)\n  }, 'name', { value: fn.name })\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/streamroller/node_modules/universalify/index.js?");

/***/ }),

/***/ "./node_modules/string-width/index.js":
/*!********************************************!*\
  !*** ./node_modules/string-width/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst stripAnsi = __webpack_require__(/*! strip-ansi */ \"./node_modules/strip-ansi/index.js\");\nconst isFullwidthCodePoint = __webpack_require__(/*! is-fullwidth-code-point */ \"./node_modules/string-width/node_modules/is-fullwidth-code-point/index.js\");\nconst emojiRegex = __webpack_require__(/*! emoji-regex */ \"./node_modules/emoji-regex/index.js\");\n\nconst stringWidth = string => {\n\tstring = string.replace(emojiRegex(), '  ');\n\n\tif (typeof string !== 'string' || string.length === 0) {\n\t\treturn 0;\n\t}\n\n\tstring = stripAnsi(string);\n\n\tlet width = 0;\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tconst code = string.codePointAt(i);\n\n\t\t// Ignore control characters\n\t\tif (code <= 0x1F || (code >= 0x7F && code <= 0x9F)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Ignore combining characters\n\t\tif (code >= 0x300 && code <= 0x36F) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Surrogates\n\t\tif (code > 0xFFFF) {\n\t\t\ti++;\n\t\t}\n\n\t\twidth += isFullwidthCodePoint(code) ? 2 : 1;\n\t}\n\n\treturn width;\n};\n\nmodule.exports = stringWidth;\n// TODO: remove this in the next major version\nmodule.exports.default = stringWidth;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/string-width/index.js?");

/***/ }),

/***/ "./node_modules/string-width/node_modules/is-fullwidth-code-point/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/string-width/node_modules/is-fullwidth-code-point/index.js ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";
eval("/* eslint-disable yoda */\n\n\nconst isFullwidthCodePoint = codePoint => {\n\tif (Number.isNaN(codePoint)) {\n\t\treturn false;\n\t}\n\n\t// Code points are derived from:\n\t// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt\n\tif (\n\t\tcodePoint >= 0x1100 && (\n\t\t\tcodePoint <= 0x115F || // Hangul Jamo\n\t\t\tcodePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n\t\t\tcodePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET\n\t\t\t// CJK Radicals Supplement .. Enclosed CJK Letters and Months\n\t\t\t(0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F) ||\n\t\t\t// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n\t\t\t(0x3250 <= codePoint && codePoint <= 0x4DBF) ||\n\t\t\t// CJK Unified Ideographs .. Yi Radicals\n\t\t\t(0x4E00 <= codePoint && codePoint <= 0xA4C6) ||\n\t\t\t// Hangul Jamo Extended-A\n\t\t\t(0xA960 <= codePoint && codePoint <= 0xA97C) ||\n\t\t\t// Hangul Syllables\n\t\t\t(0xAC00 <= codePoint && codePoint <= 0xD7A3) ||\n\t\t\t// CJK Compatibility Ideographs\n\t\t\t(0xF900 <= codePoint && codePoint <= 0xFAFF) ||\n\t\t\t// Vertical Forms\n\t\t\t(0xFE10 <= codePoint && codePoint <= 0xFE19) ||\n\t\t\t// CJK Compatibility Forms .. Small Form Variants\n\t\t\t(0xFE30 <= codePoint && codePoint <= 0xFE6B) ||\n\t\t\t// Halfwidth and Fullwidth Forms\n\t\t\t(0xFF01 <= codePoint && codePoint <= 0xFF60) ||\n\t\t\t(0xFFE0 <= codePoint && codePoint <= 0xFFE6) ||\n\t\t\t// Kana Supplement\n\t\t\t(0x1B000 <= codePoint && codePoint <= 0x1B001) ||\n\t\t\t// Enclosed Ideographic Supplement\n\t\t\t(0x1F200 <= codePoint && codePoint <= 0x1F251) ||\n\t\t\t// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n\t\t\t(0x20000 <= codePoint && codePoint <= 0x3FFFD)\n\t\t)\n\t) {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\nmodule.exports = isFullwidthCodePoint;\nmodule.exports.default = isFullwidthCodePoint;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/string-width/node_modules/is-fullwidth-code-point/index.js?");

/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n\n//# sourceURL=webpack://coc.nvim/./node_modules/string_decoder/lib/string_decoder.js?");

/***/ }),

/***/ "./node_modules/strip-ansi/index.js":
/*!******************************************!*\
  !*** ./node_modules/strip-ansi/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst ansiRegex = __webpack_require__(/*! ansi-regex */ \"./node_modules/ansi-regex/index.js\");\n\nmodule.exports = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/strip-ansi/index.js?");

/***/ }),

/***/ "./node_modules/strip-eof/index.js":
/*!*****************************************!*\
  !*** ./node_modules/strip-eof/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function (x) {\n\tvar lf = typeof x === 'string' ? '\\n' : '\\n'.charCodeAt();\n\tvar cr = typeof x === 'string' ? '\\r' : '\\r'.charCodeAt();\n\n\tif (x[x.length - 1] === lf) {\n\t\tx = x.slice(0, x.length - 1);\n\t}\n\n\tif (x[x.length - 1] === cr) {\n\t\tx = x.slice(0, x.length - 1);\n\t}\n\n\treturn x;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/strip-eof/index.js?");

/***/ }),

/***/ "./node_modules/supports-color/index.js":
/*!**********************************************!*\
  !*** ./node_modules/supports-color/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst os = __webpack_require__(/*! os */ \"os\");\nconst tty = __webpack_require__(/*! tty */ \"tty\");\nconst hasFlag = __webpack_require__(/*! has-flag */ \"./node_modules/has-flag/index.js\");\n\nconst {env} = process;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false') ||\n\thasFlag('color=never')) {\n\tforceColor = 0;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = 1;\n}\n\nif ('FORCE_COLOR' in env) {\n\tif (env.FORCE_COLOR === 'true') {\n\t\tforceColor = 1;\n\t} else if (env.FORCE_COLOR === 'false') {\n\t\tforceColor = 0;\n\t} else {\n\t\tforceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);\n\t}\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(haveStream, streamIsTTY) {\n\tif (forceColor === 0) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (haveStream && !streamIsTTY && forceColor === undefined) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor || 0;\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\t// Windows 10 build 10586 is the first Windows release that supports 256 colors.\n\t\t// Windows 10 build 14931 is the first release that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif ('GITHUB_ACTIONS' in env) {\n\t\treturn 1;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream, stream && stream.isTTY);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: translateLevel(supportsColor(true, tty.isatty(1))),\n\tstderr: translateLevel(supportsColor(true, tty.isatty(2)))\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/supports-color/index.js?");

/***/ }),

/***/ "./node_modules/tar/index.js":
/*!***********************************!*\
  !*** ./node_modules/tar/index.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n// high-level commands\nexports.c = exports.create = __webpack_require__(/*! ./lib/create.js */ \"./node_modules/tar/lib/create.js\")\nexports.r = exports.replace = __webpack_require__(/*! ./lib/replace.js */ \"./node_modules/tar/lib/replace.js\")\nexports.t = exports.list = __webpack_require__(/*! ./lib/list.js */ \"./node_modules/tar/lib/list.js\")\nexports.u = exports.update = __webpack_require__(/*! ./lib/update.js */ \"./node_modules/tar/lib/update.js\")\nexports.x = exports.extract = __webpack_require__(/*! ./lib/extract.js */ \"./node_modules/tar/lib/extract.js\")\n\n// classes\nexports.Pack = __webpack_require__(/*! ./lib/pack.js */ \"./node_modules/tar/lib/pack.js\")\nexports.Unpack = __webpack_require__(/*! ./lib/unpack.js */ \"./node_modules/tar/lib/unpack.js\")\nexports.Parse = __webpack_require__(/*! ./lib/parse.js */ \"./node_modules/tar/lib/parse.js\")\nexports.ReadEntry = __webpack_require__(/*! ./lib/read-entry.js */ \"./node_modules/tar/lib/read-entry.js\")\nexports.WriteEntry = __webpack_require__(/*! ./lib/write-entry.js */ \"./node_modules/tar/lib/write-entry.js\")\nexports.Header = __webpack_require__(/*! ./lib/header.js */ \"./node_modules/tar/lib/header.js\")\nexports.Pax = __webpack_require__(/*! ./lib/pax.js */ \"./node_modules/tar/lib/pax.js\")\nexports.types = __webpack_require__(/*! ./lib/types.js */ \"./node_modules/tar/lib/types.js\")\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/index.js?");

/***/ }),

/***/ "./node_modules/tar/lib/create.js":
/*!****************************************!*\
  !*** ./node_modules/tar/lib/create.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// tar -c\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"./node_modules/tar/lib/high-level-opt.js\")\n\nconst Pack = __webpack_require__(/*! ./pack.js */ \"./node_modules/tar/lib/pack.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"./node_modules/fs-minipass/index.js\")\nconst t = __webpack_require__(/*! ./list.js */ \"./node_modules/tar/lib/list.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\nconst c = module.exports = (opt_, files, cb) => {\n  if (typeof files === 'function')\n    cb = files\n\n  if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  return opt.file && opt.sync ? createFileSync(opt, files)\n    : opt.file ? createFile(opt, files, cb)\n    : opt.sync ? createSync(opt, files)\n    : create(opt, files)\n}\n\nconst createFileSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    mode: opt.mode || 0o666\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst createFile = (opt, files, cb) => {\n  const p = new Pack(opt)\n  const stream = new fsm.WriteStream(opt.file, {\n    mode: opt.mode || 0o666\n  })\n  p.pipe(stream)\n\n  const promise = new Promise((res, rej) => {\n    stream.on('error', rej)\n    stream.on('close', res)\n    p.on('error', rej)\n  })\n\n  addFilesAsync(p, files)\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@')\n      t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry)\n      })\n    else\n      p.add(file)\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@')\n      return t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        noResume: true,\n        onentry: entry => p.add(entry)\n      }).then(_ => addFilesAsync(p, files))\n    else\n      p.add(file)\n  }\n  p.end()\n}\n\nconst createSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  addFilesSync(p, files)\n  return p\n}\n\nconst create = (opt, files) => {\n  const p = new Pack(opt)\n  addFilesAsync(p, files)\n  return p\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/create.js?");

/***/ }),

/***/ "./node_modules/tar/lib/extract.js":
/*!*****************************************!*\
  !*** ./node_modules/tar/lib/extract.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// tar -x\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"./node_modules/tar/lib/high-level-opt.js\")\nconst Unpack = __webpack_require__(/*! ./unpack.js */ \"./node_modules/tar/lib/unpack.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"./node_modules/fs-minipass/index.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\nconst x = module.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function')\n    cb = opt_, files = null, opt_ = {}\n  else if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (typeof files === 'function')\n    cb = files, files = null\n\n  if (!files)\n    files = []\n  else\n    files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  if (files.length)\n    filesFilter(opt, files)\n\n  return opt.file && opt.sync ? extractFileSync(opt)\n    : opt.file ? extractFile(opt, cb)\n    : opt.sync ? extractSync(opt)\n    : extract(opt)\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [f.replace(/\\/+$/, ''), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\\/+$/, ''))\n    : file => mapHas(file.replace(/\\/+$/, ''))\n}\n\nconst extractFileSync = opt => {\n  const u = new Unpack.Sync(opt)\n\n  const file = opt.file\n  let threw = true\n  let fd\n  const stat = fs.statSync(file)\n  // This trades a zero-byte read() syscall for a stat\n  // However, it will usually result in less memory allocation\n  const readSize = opt.maxReadSize || 16*1024*1024\n  const stream = new fsm.ReadStreamSync(file, {\n    readSize: readSize,\n    size: stat.size\n  })\n  stream.pipe(u)\n}\n\nconst extractFile = (opt, cb) => {\n  const u = new Unpack(opt)\n  const readSize = opt.maxReadSize || 16*1024*1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    u.on('error', reject)\n    u.on('close', resolve)\n\n    // This trades a zero-byte read() syscall for a stat\n    // However, it will usually result in less memory allocation\n    fs.stat(file, (er, stat) => {\n      if (er)\n        reject(er)\n      else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size\n        })\n        stream.on('error', reject)\n        stream.pipe(u)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst extractSync = opt => {\n  return new Unpack.Sync(opt)\n}\n\nconst extract = opt => {\n  return new Unpack(opt)\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/extract.js?");

/***/ }),

/***/ "./node_modules/tar/lib/get-write-flag.js":
/*!************************************************!*\
  !*** ./node_modules/tar/lib/get-write-flag.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Get the appropriate flag to use for creating files\n// We use fmap on Windows platforms for files less than\n// 512kb.  This is a fairly low limit, but avoids making\n// things slower in some cases.  Since most of what this\n// library is used for is extracting tarballs of many\n// relatively small files in npm packages and the like,\n// it can be a big boost on Windows platforms.\n// Only supported in Node v12.9.0 and above.\nconst platform = process.env.__FAKE_PLATFORM__ || process.platform\nconst isWindows = platform === 'win32'\nconst fs = global.__FAKE_TESTING_FS__ || __webpack_require__(/*! fs */ \"fs\")\n\n/* istanbul ignore next */\nconst { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs.constants\n\nconst fMapEnabled = isWindows && !!UV_FS_O_FILEMAP\nconst fMapLimit = 512 * 1024\nconst fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY\nmodule.exports = !fMapEnabled ? () => 'w'\n  : size => size < fMapLimit ? fMapFlag : 'w'\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/get-write-flag.js?");

/***/ }),

/***/ "./node_modules/tar/lib/header.js":
/*!****************************************!*\
  !*** ./node_modules/tar/lib/header.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// parse a 512-byte header block to a data object, or vice-versa\n// encode returns `true` if a pax extended header is needed, because\n// the data could not be faithfully encoded in a simple header.\n// (Also, check header.needPax to see if it needs a pax header.)\n\nconst types = __webpack_require__(/*! ./types.js */ \"./node_modules/tar/lib/types.js\")\nconst pathModule = __webpack_require__(/*! path */ \"path\").posix\nconst large = __webpack_require__(/*! ./large-numbers.js */ \"./node_modules/tar/lib/large-numbers.js\")\n\nconst SLURP = Symbol('slurp')\nconst TYPE = Symbol('type')\n\nclass Header {\n  constructor (data, off, ex, gex) {\n    this.cksumValid = false\n    this.needPax = false\n    this.nullBlock = false\n\n    this.block = null\n    this.path = null\n    this.mode = null\n    this.uid = null\n    this.gid = null\n    this.size = null\n    this.mtime = null\n    this.cksum = null\n    this[TYPE] = '0'\n    this.linkpath = null\n    this.uname = null\n    this.gname = null\n    this.devmaj = 0\n    this.devmin = 0\n    this.atime = null\n    this.ctime = null\n\n    if (Buffer.isBuffer(data))\n      this.decode(data, off || 0, ex, gex)\n    else if (data)\n      this.set(data)\n  }\n\n  decode (buf, off, ex, gex) {\n    if (!off)\n      off = 0\n\n    if (!buf || !(buf.length >= off + 512))\n      throw new Error('need 512 bytes for header')\n\n    this.path = decString(buf, off, 100)\n    this.mode = decNumber(buf, off + 100, 8)\n    this.uid = decNumber(buf, off + 108, 8)\n    this.gid = decNumber(buf, off + 116, 8)\n    this.size = decNumber(buf, off + 124, 12)\n    this.mtime = decDate(buf, off + 136, 12)\n    this.cksum = decNumber(buf, off + 148, 12)\n\n    // if we have extended or global extended headers, apply them now\n    // See https://github.com/npm/node-tar/pull/187\n    this[SLURP](ex)\n    this[SLURP](gex, true)\n\n    // old tar versions marked dirs as a file with a trailing /\n    this[TYPE] = decString(buf, off + 156, 1)\n    if (this[TYPE] === '')\n      this[TYPE] = '0'\n    if (this[TYPE] === '0' && this.path.substr(-1) === '/')\n      this[TYPE] = '5'\n\n    // tar implementations sometimes incorrectly put the stat(dir).size\n    // as the size in the tarball, even though Directory entries are\n    // not able to have any body at all.  In the very rare chance that\n    // it actually DOES have a body, we weren't going to do anything with\n    // it anyway, and it'll just be a warning about an invalid header.\n    if (this[TYPE] === '5')\n      this.size = 0\n\n    this.linkpath = decString(buf, off + 157, 100)\n    if (buf.slice(off + 257, off + 265).toString() === 'ustar\\u000000') {\n      this.uname = decString(buf, off + 265, 32)\n      this.gname = decString(buf, off + 297, 32)\n      this.devmaj = decNumber(buf, off + 329, 8)\n      this.devmin = decNumber(buf, off + 337, 8)\n      if (buf[off + 475] !== 0) {\n        // definitely a prefix, definitely >130 chars.\n        const prefix = decString(buf, off + 345, 155)\n        this.path = prefix + '/' + this.path\n      } else {\n        const prefix = decString(buf, off + 345, 130)\n        if (prefix)\n          this.path = prefix + '/' + this.path\n        this.atime = decDate(buf, off + 476, 12)\n        this.ctime = decDate(buf, off + 488, 12)\n      }\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i]\n    }\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i]\n    }\n    this.cksumValid = sum === this.cksum\n    if (this.cksum === null && sum === 8 * 0x20)\n      this.nullBlock = true\n  }\n\n  [SLURP] (ex, global) {\n    for (let k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path'))\n        this[k] = ex[k]\n    }\n  }\n\n  encode (buf, off) {\n    if (!buf) {\n      buf = this.block = Buffer.alloc(512)\n      off = 0\n    }\n\n    if (!off)\n      off = 0\n\n    if (!(buf.length >= off + 512))\n      throw new Error('need 512 bytes for header')\n\n    const prefixSize = this.ctime || this.atime ? 130 : 155\n    const split = splitPrefix(this.path || '', prefixSize)\n    const path = split[0]\n    const prefix = split[1]\n    this.needPax = split[2]\n\n    this.needPax = encString(buf, off, 100, path) || this.needPax\n    this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax\n    this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax\n    this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax\n    this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax\n    this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax\n    buf[off + 156] = this[TYPE].charCodeAt(0)\n    this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax\n    buf.write('ustar\\u000000', off + 257, 8)\n    this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax\n    this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax\n    this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax\n    this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax\n    this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax\n    if (buf[off + 475] !== 0)\n      this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax\n    else {\n      this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax\n      this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax\n      this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i]\n    }\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i]\n    }\n    this.cksum = sum\n    encNumber(buf, off + 148, 8, this.cksum)\n    this.cksumValid = true\n\n    return this.needPax\n  }\n\n  set (data) {\n    for (let i in data) {\n      if (data[i] !== null && data[i] !== undefined)\n        this[i] = data[i]\n    }\n  }\n\n  get type () {\n    return types.name.get(this[TYPE]) || this[TYPE]\n  }\n\n  get typeKey () {\n    return this[TYPE]\n  }\n\n  set type (type) {\n    if (types.code.has(type))\n      this[TYPE] = types.code.get(type)\n    else\n      this[TYPE] = type\n  }\n}\n\nconst splitPrefix = (p, prefixSize) => {\n  const pathSize = 100\n  let pp = p\n  let prefix = ''\n  let ret\n  const root = pathModule.parse(p).root || '.'\n\n  if (Buffer.byteLength(pp) < pathSize)\n    ret = [pp, prefix, false]\n  else {\n    // first set prefix to the dir, and path to the base\n    prefix = pathModule.dirname(pp)\n    pp = pathModule.basename(pp)\n\n    do {\n      // both fit!\n      if (Buffer.byteLength(pp) <= pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize)\n        ret = [pp, prefix, false]\n\n      // prefix fits in prefix, but path doesn't fit in path\n      else if (Buffer.byteLength(pp) > pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize)\n        ret = [pp.substr(0, pathSize - 1), prefix, true]\n\n      else {\n        // make path take a bit from prefix\n        pp = pathModule.join(pathModule.basename(prefix), pp)\n        prefix = pathModule.dirname(prefix)\n      }\n    } while (prefix !== root && !ret)\n\n    // at this point, found no resolution, just truncate\n    if (!ret)\n      ret = [p.substr(0, pathSize - 1), '', true]\n  }\n  return ret\n}\n\nconst decString = (buf, off, size) =>\n  buf.slice(off, off + size).toString('utf8').replace(/\\0.*/, '')\n\nconst decDate = (buf, off, size) =>\n  numToDate(decNumber(buf, off, size))\n\nconst numToDate = num => num === null ? null : new Date(num * 1000)\n\nconst decNumber = (buf, off, size) =>\n  buf[off] & 0x80 ? large.parse(buf.slice(off, off + size))\n    : decSmallNumber(buf, off, size)\n\nconst nanNull = value => isNaN(value) ? null : value\n\nconst decSmallNumber = (buf, off, size) =>\n  nanNull(parseInt(\n    buf.slice(off, off + size)\n      .toString('utf8').replace(/\\0.*$/, '').trim(), 8))\n\n// the maximum encodable as a null-terminated octal, by field size\nconst MAXNUM = {\n  12: 0o77777777777,\n  8 : 0o7777777\n}\n\nconst encNumber = (buf, off, size, number) =>\n  number === null ? false :\n  number > MAXNUM[size] || number < 0\n    ? (large.encode(number, buf.slice(off, off + size)), true)\n    : (encSmallNumber(buf, off, size, number), false)\n\nconst encSmallNumber = (buf, off, size, number) =>\n  buf.write(octalString(number, size), off, size, 'ascii')\n\nconst octalString = (number, size) =>\n  padOctal(Math.floor(number).toString(8), size)\n\nconst padOctal = (string, size) =>\n  (string.length === size - 1 ? string\n  : new Array(size - string.length - 1).join('0') + string + ' ') + '\\0'\n\nconst encDate = (buf, off, size, date) =>\n  date === null ? false :\n  encNumber(buf, off, size, date.getTime() / 1000)\n\n// enough to fill the longest string we've got\nconst NULLS = new Array(156).join('\\0')\n// pad with nulls, return true if it's longer or non-ascii\nconst encString = (buf, off, size, string) =>\n  string === null ? false :\n  (buf.write(string + NULLS, off, size, 'utf8'),\n   string.length !== Buffer.byteLength(string) || string.length > size)\n\nmodule.exports = Header\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/header.js?");

/***/ }),

/***/ "./node_modules/tar/lib/high-level-opt.js":
/*!************************************************!*\
  !*** ./node_modules/tar/lib/high-level-opt.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// turn tar(1) style args like `C` into the more verbose things like `cwd`\n\nconst argmap = new Map([\n  ['C', 'cwd'],\n  ['f', 'file'],\n  ['z', 'gzip'],\n  ['P', 'preservePaths'],\n  ['U', 'unlink'],\n  ['strip-components', 'strip'],\n  ['stripComponents', 'strip'],\n  ['keep-newer', 'newer'],\n  ['keepNewer', 'newer'],\n  ['keep-newer-files', 'newer'],\n  ['keepNewerFiles', 'newer'],\n  ['k', 'keep'],\n  ['keep-existing', 'keep'],\n  ['keepExisting', 'keep'],\n  ['m', 'noMtime'],\n  ['no-mtime', 'noMtime'],\n  ['p', 'preserveOwner'],\n  ['L', 'follow'],\n  ['h', 'follow']\n])\n\nconst parse = module.exports = opt => opt ? Object.keys(opt).map(k => [\n  argmap.has(k) ? argmap.get(k) : k, opt[k]\n]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/high-level-opt.js?");

/***/ }),

/***/ "./node_modules/tar/lib/large-numbers.js":
/*!***********************************************!*\
  !*** ./node_modules/tar/lib/large-numbers.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\n\nconst encode = exports.encode = (num, buf) => {\n  if (!Number.isSafeInteger(num))\n    // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw Error('cannot encode number outside of javascript safe integer range')\n  else if (num < 0)\n    encodeNegative(num, buf)\n  else\n    encodePositive(num, buf)\n  return buf\n}\n\nconst encodePositive = (num, buf) => {\n  buf[0] = 0x80\n\n  for (var i = buf.length; i > 1; i--) {\n    buf[i-1] = num & 0xff\n    num = Math.floor(num / 0x100)\n  }\n}\n\nconst encodeNegative = (num, buf) => {\n  buf[0] = 0xff\n  var flipped = false\n  num = num * -1\n  for (var i = buf.length; i > 1; i--) {\n    var byte = num & 0xff\n    num = Math.floor(num / 0x100)\n    if (flipped)\n      buf[i-1] = onesComp(byte)\n    else if (byte === 0)\n      buf[i-1] = 0\n    else {\n      flipped = true\n      buf[i-1] = twosComp(byte)\n    }\n  }\n}\n\nconst parse = exports.parse = (buf) => {\n  var post = buf[buf.length - 1]\n  var pre = buf[0]\n  var value;\n  if (pre === 0x80)\n    value = pos(buf.slice(1, buf.length))\n  else if (pre === 0xff)\n    value = twos(buf)\n  else\n    throw Error('invalid base256 encoding')\n\n  if (!Number.isSafeInteger(value))\n    // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw Error('parsed number outside of javascript safe integer range')\n\n  return value\n}\n\nconst twos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  var flipped = false\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    var f\n    if (flipped)\n      f = onesComp(byte)\n    else if (byte === 0)\n      f = byte\n    else {\n      flipped = true\n      f = twosComp(byte)\n    }\n    if (f !== 0)\n      sum -= f * Math.pow(256, len - i - 1)\n  }\n  return sum\n}\n\nconst pos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    if (byte !== 0)\n      sum += byte * Math.pow(256, len - i - 1)\n  }\n  return sum\n}\n\nconst onesComp = byte => (0xff ^ byte) & 0xff\n\nconst twosComp = byte => ((0xff ^ byte) + 1) & 0xff\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/large-numbers.js?");

/***/ }),

/***/ "./node_modules/tar/lib/list.js":
/*!**************************************!*\
  !*** ./node_modules/tar/lib/list.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// XXX: This shares a lot in common with extract.js\n// maybe some DRY opportunity here?\n\n// tar -t\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"./node_modules/tar/lib/high-level-opt.js\")\nconst Parser = __webpack_require__(/*! ./parse.js */ \"./node_modules/tar/lib/parse.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"./node_modules/fs-minipass/index.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\nconst t = module.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function')\n    cb = opt_, files = null, opt_ = {}\n  else if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (typeof files === 'function')\n    cb = files, files = null\n\n  if (!files)\n    files = []\n  else\n    files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  if (files.length)\n    filesFilter(opt, files)\n\n  if (!opt.noResume)\n    onentryFunction(opt)\n\n  return opt.file && opt.sync ? listFileSync(opt)\n    : opt.file ? listFile(opt, cb)\n    : list(opt)\n}\n\nconst onentryFunction = opt => {\n  const onentry = opt.onentry\n  opt.onentry = onentry ? e => {\n    onentry(e)\n    e.resume()\n  } : e => e.resume()\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [f.replace(/\\/+$/, ''), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\\/+$/, ''))\n    : file => mapHas(file.replace(/\\/+$/, ''))\n}\n\nconst listFileSync = opt => {\n  const p = list(opt)\n  const file = opt.file\n  let threw = true\n  let fd\n  try {\n    const stat = fs.statSync(file)\n    const readSize = opt.maxReadSize || 16*1024*1024\n    if (stat.size < readSize) {\n      p.end(fs.readFileSync(file))\n    } else {\n      let pos = 0\n      const buf = Buffer.allocUnsafe(readSize)\n      fd = fs.openSync(file, 'r')\n      while (pos < stat.size) {\n        let bytesRead = fs.readSync(fd, buf, 0, readSize, pos)\n        pos += bytesRead\n        p.write(buf.slice(0, bytesRead))\n      }\n      p.end()\n    }\n    threw = false\n  } finally {\n    if (threw && fd)\n      try { fs.closeSync(fd) } catch (er) {}\n  }\n}\n\nconst listFile = (opt, cb) => {\n  const parse = new Parser(opt)\n  const readSize = opt.maxReadSize || 16*1024*1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    parse.on('error', reject)\n    parse.on('end', resolve)\n\n    fs.stat(file, (er, stat) => {\n      if (er)\n        reject(er)\n      else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size\n        })\n        stream.on('error', reject)\n        stream.pipe(parse)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst list = opt => new Parser(opt)\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/list.js?");

/***/ }),

/***/ "./node_modules/tar/lib/mkdir.js":
/*!***************************************!*\
  !*** ./node_modules/tar/lib/mkdir.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// wrapper around mkdirp for tar's needs.\n\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nconst mkdirp = __webpack_require__(/*! mkdirp */ \"./node_modules/mkdirp/index.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst chownr = __webpack_require__(/*! chownr */ \"./node_modules/chownr/chownr.js\")\n\nclass SymlinkError extends Error {\n  constructor (symlink, path) {\n    super('Cannot extract through symbolic link')\n    this.path = path\n    this.symlink = symlink\n  }\n\n  get name () {\n    return 'SylinkError'\n  }\n}\n\nclass CwdError extends Error {\n  constructor (path, code) {\n    super(code + ': Cannot cd into \\'' + path + '\\'')\n    this.path = path\n    this.code = code\n  }\n\n  get name () {\n    return 'CwdError'\n  }\n}\n\nconst mkdir = module.exports = (dir, opt, cb) => {\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    ( uid !== opt.processUid || gid !== opt.processGid )\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = opt.cwd\n\n  const done = (er, created) => {\n    if (er)\n      cb(er)\n    else {\n      cache.set(dir, true)\n      if (created && doChown)\n        chownr(created, uid, gid, er => done(er))\n      else if (needChmod)\n        fs.chmod(dir, mode, cb)\n      else\n        cb()\n    }\n  }\n\n  if (cache && cache.get(dir) === true)\n    return done()\n\n  if (dir === cwd)\n    return fs.stat(dir, (er, st) => {\n      if (er || !st.isDirectory())\n        er = new CwdError(dir, er && er.code || 'ENOTDIR')\n      done(er)\n    })\n\n  if (preserve)\n    return mkdirp(dir, {mode}).then(made => done(null, made), done)\n\n  const sub = path.relative(cwd, dir)\n  const parts = sub.split(/\\/|\\\\/)\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)\n}\n\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n  if (!parts.length)\n    return cb(null, created)\n  const p = parts.shift()\n  const part = base + '/' + p\n  if (cache.get(part))\n    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n}\n\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {\n  if (er) {\n    if (er.path && path.dirname(er.path) === cwd &&\n        (er.code === 'ENOTDIR' || er.code === 'ENOENT'))\n      return cb(new CwdError(cwd, er.code))\n\n    fs.lstat(part, (statEr, st) => {\n      if (statEr)\n        cb(statEr)\n      else if (st.isDirectory())\n        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n      else if (unlink)\n        fs.unlink(part, er => {\n          if (er)\n            return cb(er)\n          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n        })\n      else if (st.isSymbolicLink())\n        return cb(new SymlinkError(part, part + '/' + parts.join('/')))\n      else\n        cb(er)\n    })\n  } else {\n    created = created || part\n    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  }\n}\n\nconst mkdirSync = module.exports.sync = (dir, opt) => {\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    ( uid !== opt.processUid || gid !== opt.processGid )\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = opt.cwd\n\n  const done = (created) => {\n    cache.set(dir, true)\n    if (created && doChown)\n      chownr.sync(created, uid, gid)\n    if (needChmod)\n      fs.chmodSync(dir, mode)\n  }\n\n  if (cache && cache.get(dir) === true)\n    return done()\n\n  if (dir === cwd) {\n    let ok = false\n    let code = 'ENOTDIR'\n    try {\n      ok = fs.statSync(dir).isDirectory()\n    } catch (er) {\n      code = er.code\n    } finally {\n      if (!ok)\n        throw new CwdError(dir, code)\n    }\n    done()\n    return\n  }\n\n  if (preserve)\n    return done(mkdirp.sync(dir, mode))\n\n  const sub = path.relative(cwd, dir)\n  const parts = sub.split(/\\/|\\\\/)\n  let created = null\n  for (let p = parts.shift(), part = cwd;\n       p && (part += '/' + p);\n       p = parts.shift()) {\n\n    if (cache.get(part))\n      continue\n\n    try {\n      fs.mkdirSync(part, mode)\n      created = created || part\n      cache.set(part, true)\n    } catch (er) {\n      if (er.path && path.dirname(er.path) === cwd &&\n          (er.code === 'ENOTDIR' || er.code === 'ENOENT'))\n        return new CwdError(cwd, er.code)\n\n      const st = fs.lstatSync(part)\n      if (st.isDirectory()) {\n        cache.set(part, true)\n        continue\n      } else if (unlink) {\n        fs.unlinkSync(part)\n        fs.mkdirSync(part, mode)\n        created = created || part\n        cache.set(part, true)\n        continue\n      } else if (st.isSymbolicLink())\n        return new SymlinkError(part, part + '/' + parts.join('/'))\n    }\n  }\n\n  return done(created)\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/mkdir.js?");

/***/ }),

/***/ "./node_modules/tar/lib/mode-fix.js":
/*!******************************************!*\
  !*** ./node_modules/tar/lib/mode-fix.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = (mode, isDir, portable) => {\n  mode &= 0o7777\n\n  // in portable mode, use the minimum reasonable umask\n  // if this system creates files with 0o664 by default\n  // (as some linux distros do), then we'll write the\n  // archive with 0o644 instead.  Also, don't ever create\n  // a file that is not readable/writable by the owner.\n  if (portable) {\n    mode = (mode | 0o600) &~0o22\n  }\n\n  // if dirs are readable, then they should be listable\n  if (isDir) {\n    if (mode & 0o400)\n      mode |= 0o100\n    if (mode & 0o40)\n      mode |= 0o10\n    if (mode & 0o4)\n      mode |= 0o1\n  }\n  return mode\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/mode-fix.js?");

/***/ }),

/***/ "./node_modules/tar/lib/pack.js":
/*!**************************************!*\
  !*** ./node_modules/tar/lib/pack.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nclass PackJob {\n  constructor (path, absolute) {\n    this.path = path || './'\n    this.absolute = absolute\n    this.entry = null\n    this.stat = null\n    this.readdir = null\n    this.pending = false\n    this.ignore = false\n    this.piped = false\n  }\n}\n\nconst MiniPass = __webpack_require__(/*! minipass */ \"./node_modules/minipass/index.js\")\nconst zlib = __webpack_require__(/*! minizlib */ \"./node_modules/minizlib/index.js\")\nconst ReadEntry = __webpack_require__(/*! ./read-entry.js */ \"./node_modules/tar/lib/read-entry.js\")\nconst WriteEntry = __webpack_require__(/*! ./write-entry.js */ \"./node_modules/tar/lib/write-entry.js\")\nconst WriteEntrySync = WriteEntry.Sync\nconst WriteEntryTar = WriteEntry.Tar\nconst Yallist = __webpack_require__(/*! yallist */ \"./node_modules/yallist/yallist.js\")\nconst EOF = Buffer.alloc(1024)\nconst ONSTAT = Symbol('onStat')\nconst ENDED = Symbol('ended')\nconst QUEUE = Symbol('queue')\nconst CURRENT = Symbol('current')\nconst PROCESS = Symbol('process')\nconst PROCESSING = Symbol('processing')\nconst PROCESSJOB = Symbol('processJob')\nconst JOBS = Symbol('jobs')\nconst JOBDONE = Symbol('jobDone')\nconst ADDFSENTRY = Symbol('addFSEntry')\nconst ADDTARENTRY = Symbol('addTarEntry')\nconst STAT = Symbol('stat')\nconst READDIR = Symbol('readdir')\nconst ONREADDIR = Symbol('onreaddir')\nconst PIPE = Symbol('pipe')\nconst ENTRY = Symbol('entry')\nconst ENTRYOPT = Symbol('entryOpt')\nconst WRITEENTRYCLASS = Symbol('writeEntryClass')\nconst WRITE = Symbol('write')\nconst ONDRAIN = Symbol('ondrain')\n\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst warner = __webpack_require__(/*! ./warn-mixin.js */ \"./node_modules/tar/lib/warn-mixin.js\")\n\nconst Pack = warner(class Pack extends MiniPass {\n  constructor (opt) {\n    super(opt)\n    opt = opt || Object.create(null)\n    this.opt = opt\n    this.file = opt.file || ''\n    this.cwd = opt.cwd || process.cwd()\n    this.maxReadSize = opt.maxReadSize\n    this.preservePaths = !!opt.preservePaths\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.prefix = (opt.prefix || '').replace(/(\\\\|\\/)+$/, '')\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.readdirCache = opt.readdirCache || new Map()\n\n    this[WRITEENTRYCLASS] = WriteEntry\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    this.portable = !!opt.portable\n    this.zip = null\n    if (opt.gzip) {\n      if (typeof opt.gzip !== 'object')\n        opt.gzip = {}\n      if (this.portable)\n        opt.gzip.portable = true\n      this.zip = new zlib.Gzip(opt.gzip)\n      this.zip.on('data', chunk => super.write(chunk))\n      this.zip.on('end', _ => super.end())\n      this.zip.on('drain', _ => this[ONDRAIN]())\n      this.on('resume', _ => this.zip.resume())\n    } else\n      this.on('drain', this[ONDRAIN])\n\n    this.noDirRecurse = !!opt.noDirRecurse\n    this.follow = !!opt.follow\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true\n\n    this[QUEUE] = new Yallist\n    this[JOBS] = 0\n    this.jobs = +opt.jobs || 4\n    this[PROCESSING] = false\n    this[ENDED] = false\n  }\n\n  [WRITE] (chunk) {\n    return super.write(chunk)\n  }\n\n  add (path) {\n    this.write(path)\n    return this\n  }\n\n  end (path) {\n    if (path)\n      this.write(path)\n    this[ENDED] = true\n    this[PROCESS]()\n    return this\n  }\n\n  write (path) {\n    if (this[ENDED])\n      throw new Error('write after end')\n\n    if (path instanceof ReadEntry)\n      this[ADDTARENTRY](path)\n    else\n      this[ADDFSENTRY](path)\n    return this.flowing\n  }\n\n  [ADDTARENTRY] (p) {\n    const absolute = path.resolve(this.cwd, p.path)\n    if (this.prefix)\n      p.path = this.prefix + '/' + p.path.replace(/^\\.(\\/+|$)/, '')\n\n    // in this case, we don't have to wait for the stat\n    if (!this.filter(p.path, p))\n      p.resume()\n    else {\n      const job = new PackJob(p.path, absolute, false)\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))\n      job.entry.on('end', _ => this[JOBDONE](job))\n      this[JOBS] += 1\n      this[QUEUE].push(job)\n    }\n\n    this[PROCESS]()\n  }\n\n  [ADDFSENTRY] (p) {\n    const absolute = path.resolve(this.cwd, p)\n    if (this.prefix)\n      p = this.prefix + '/' + p.replace(/^\\.(\\/+|$)/, '')\n\n    this[QUEUE].push(new PackJob(p, absolute))\n    this[PROCESS]()\n  }\n\n  [STAT] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    const stat = this.follow ? 'stat' : 'lstat'\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er)\n        this.emit('error', er)\n      else\n        this[ONSTAT](job, stat)\n    })\n  }\n\n  [ONSTAT] (job, stat) {\n    this.statCache.set(job.absolute, stat)\n    job.stat = stat\n\n    // now we have the stat, we can filter it.\n    if (!this.filter(job.path, stat))\n      job.ignore = true\n\n    this[PROCESS]()\n  }\n\n  [READDIR] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er)\n        return this.emit('error', er)\n      this[ONREADDIR](job, entries)\n    })\n  }\n\n  [ONREADDIR] (job, entries) {\n    this.readdirCache.set(job.absolute, entries)\n    job.readdir = entries\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    if (this[PROCESSING])\n      return\n\n    this[PROCESSING] = true\n    for (let w = this[QUEUE].head;\n         w !== null && this[JOBS] < this.jobs;\n         w = w.next) {\n      this[PROCESSJOB](w.value)\n      if (w.value.ignore) {\n        const p = w.next\n        this[QUEUE].removeNode(w)\n        w.next = p\n      }\n    }\n\n    this[PROCESSING] = false\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip)\n        this.zip.end(EOF)\n      else {\n        super.write(EOF)\n        super.end()\n      }\n    }\n  }\n\n  get [CURRENT] () {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value\n  }\n\n  [JOBDONE] (job) {\n    this[QUEUE].shift()\n    this[JOBS] -= 1\n    this[PROCESS]()\n  }\n\n  [PROCESSJOB] (job) {\n    if (job.pending)\n      return\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped)\n        this[PIPE](job)\n      return\n    }\n\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute))\n        this[ONSTAT](job, this.statCache.get(job.absolute))\n      else\n        this[STAT](job)\n    }\n    if (!job.stat)\n      return\n\n    // filtered out!\n    if (job.ignore)\n      return\n\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute))\n        this[ONREADDIR](job, this.readdirCache.get(job.absolute))\n      else\n        this[READDIR](job)\n      if (!job.readdir)\n        return\n    }\n\n    // we know it doesn't have an entry, because that got checked above\n    job.entry = this[ENTRY](job)\n    if (!job.entry) {\n      job.ignore = true\n      return\n    }\n\n    if (job === this[CURRENT] && !job.piped)\n      this[PIPE](job)\n  }\n\n  [ENTRYOPT] (job) {\n    return {\n      onwarn: (code, msg, data) => this.warn(code, msg, data),\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime\n    }\n  }\n\n  [ENTRY] (job) {\n    this[JOBS] += 1\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))\n        .on('end', () => this[JOBDONE](job))\n        .on('error', er => this.emit('error', er))\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n\n  [ONDRAIN] () {\n    if (this[CURRENT] && this[CURRENT].entry)\n      this[CURRENT].entry.resume()\n  }\n\n  // like .pipe() but using super, because our write() is special\n  [PIPE] (job) {\n    job.piped = true\n\n    if (job.readdir)\n      job.readdir.forEach(entry => {\n        const p = this.prefix ?\n          job.path.slice(this.prefix.length + 1) || './'\n          : job.path\n\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n\n    const source = job.entry\n    const zip = this.zip\n\n    if (zip)\n      source.on('data', chunk => {\n        if (!zip.write(chunk))\n          source.pause()\n      })\n    else\n      source.on('data', chunk => {\n        if (!super.write(chunk))\n          source.pause()\n      })\n  }\n\n  pause () {\n    if (this.zip)\n      this.zip.pause()\n    return super.pause()\n  }\n})\n\nclass PackSync extends Pack {\n  constructor (opt) {\n    super(opt)\n    this[WRITEENTRYCLASS] = WriteEntrySync\n  }\n\n  // pause/resume are no-ops in sync streams.\n  pause () {}\n  resume () {}\n\n  [STAT] (job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync'\n    this[ONSTAT](job, fs[stat](job.absolute))\n  }\n\n  [READDIR] (job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute))\n  }\n\n  // gotta get it all in this tick\n  [PIPE] (job) {\n    const source = job.entry\n    const zip = this.zip\n\n    if (job.readdir)\n      job.readdir.forEach(entry => {\n        const p = this.prefix ?\n          job.path.slice(this.prefix.length + 1) || './'\n          : job.path\n\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n\n    if (zip)\n      source.on('data', chunk => {\n        zip.write(chunk)\n      })\n    else\n      source.on('data', chunk => {\n        super[WRITE](chunk)\n      })\n  }\n}\n\nPack.Sync = PackSync\n\nmodule.exports = Pack\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/pack.js?");

/***/ }),

/***/ "./node_modules/tar/lib/parse.js":
/*!***************************************!*\
  !*** ./node_modules/tar/lib/parse.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\n\nconst warner = __webpack_require__(/*! ./warn-mixin.js */ \"./node_modules/tar/lib/warn-mixin.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst Header = __webpack_require__(/*! ./header.js */ \"./node_modules/tar/lib/header.js\")\nconst EE = __webpack_require__(/*! events */ \"events\")\nconst Yallist = __webpack_require__(/*! yallist */ \"./node_modules/yallist/yallist.js\")\nconst maxMetaEntrySize = 1024 * 1024\nconst Entry = __webpack_require__(/*! ./read-entry.js */ \"./node_modules/tar/lib/read-entry.js\")\nconst Pax = __webpack_require__(/*! ./pax.js */ \"./node_modules/tar/lib/pax.js\")\nconst zlib = __webpack_require__(/*! minizlib */ \"./node_modules/minizlib/index.js\")\n\nconst gzipHeader = Buffer.from([0x1f, 0x8b])\nconst STATE = Symbol('state')\nconst WRITEENTRY = Symbol('writeEntry')\nconst READENTRY = Symbol('readEntry')\nconst NEXTENTRY = Symbol('nextEntry')\nconst PROCESSENTRY = Symbol('processEntry')\nconst EX = Symbol('extendedHeader')\nconst GEX = Symbol('globalExtendedHeader')\nconst META = Symbol('meta')\nconst EMITMETA = Symbol('emitMeta')\nconst BUFFER = Symbol('buffer')\nconst QUEUE = Symbol('queue')\nconst ENDED = Symbol('ended')\nconst EMITTEDEND = Symbol('emittedEnd')\nconst EMIT = Symbol('emit')\nconst UNZIP = Symbol('unzip')\nconst CONSUMECHUNK = Symbol('consumeChunk')\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub')\nconst CONSUMEBODY = Symbol('consumeBody')\nconst CONSUMEMETA = Symbol('consumeMeta')\nconst CONSUMEHEADER = Symbol('consumeHeader')\nconst CONSUMING = Symbol('consuming')\nconst BUFFERCONCAT = Symbol('bufferConcat')\nconst MAYBEEND = Symbol('maybeEnd')\nconst WRITING = Symbol('writing')\nconst ABORTED = Symbol('aborted')\nconst DONE = Symbol('onDone')\nconst SAW_VALID_ENTRY = Symbol('sawValidEntry')\nconst SAW_NULL_BLOCK = Symbol('sawNullBlock')\nconst SAW_EOF = Symbol('sawEOF')\n\nconst noop = _ => true\n\nmodule.exports = warner(class Parser extends EE {\n  constructor (opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.file = opt.file || ''\n\n    // set to boolean false when an entry starts.  1024 bytes of \\0\n    // is technically a valid tarball, albeit a boring one.\n    this[SAW_VALID_ENTRY] = null\n\n    // these BADARCHIVE errors can't be detected early. listen on DONE.\n    this.on(DONE, _ => {\n      if (this[STATE] === 'begin' || this[SAW_VALID_ENTRY] === false) {\n        // either less than 1 block of data, or all entries were invalid.\n        // Either way, probably not even a tarball.\n        this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format')\n      }\n    })\n\n    if (opt.ondone)\n      this.on(DONE, opt.ondone)\n    else\n      this.on(DONE, _ => {\n        this.emit('prefinish')\n        this.emit('finish')\n        this.emit('end')\n        this.emit('close')\n      })\n\n    this.strict = !!opt.strict\n    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize\n    this.filter = typeof opt.filter === 'function' ? opt.filter : noop\n\n    // have to set this so that streams are ok piping into it\n    this.writable = true\n    this.readable = false\n\n    this[QUEUE] = new Yallist()\n    this[BUFFER] = null\n    this[READENTRY] = null\n    this[WRITEENTRY] = null\n    this[STATE] = 'begin'\n    this[META] = ''\n    this[EX] = null\n    this[GEX] = null\n    this[ENDED] = false\n    this[UNZIP] = null\n    this[ABORTED] = false\n    this[SAW_NULL_BLOCK] = false\n    this[SAW_EOF] = false\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n    if (typeof opt.onentry === 'function')\n      this.on('entry', opt.onentry)\n  }\n\n  [CONSUMEHEADER] (chunk, position) {\n    if (this[SAW_VALID_ENTRY] === null)\n      this[SAW_VALID_ENTRY] = false\n    let header\n    try {\n      header = new Header(chunk, position, this[EX], this[GEX])\n    } catch (er) {\n      return this.warn('TAR_ENTRY_INVALID', er)\n    }\n\n    if (header.nullBlock) {\n      if (this[SAW_NULL_BLOCK]) {\n        this[SAW_EOF] = true\n        // ending an archive with no entries.  pointless, but legal.\n        if (this[STATE] === 'begin')\n          this[STATE] = 'header'\n        this[EMIT]('eof')\n      } else {\n        this[SAW_NULL_BLOCK] = true\n        this[EMIT]('nullBlock')\n      }\n    } else {\n      this[SAW_NULL_BLOCK] = false\n      if (!header.cksumValid)\n        this.warn('TAR_ENTRY_INVALID', 'checksum failure', {header})\n      else if (!header.path)\n        this.warn('TAR_ENTRY_INVALID', 'path is required', {header})\n      else {\n        const type = header.type\n        if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)\n          this.warn('TAR_ENTRY_INVALID', 'linkpath required', {header})\n        else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)\n          this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', {header})\n        else {\n          const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])\n\n          // we do this for meta & ignored entries as well, because they\n          // are still valid tar, or else we wouldn't know to ignore them\n          if (!this[SAW_VALID_ENTRY]) {\n            if (entry.remain) {\n              // this might be the one!\n              const onend = () => {\n                if (!entry.invalid)\n                  this[SAW_VALID_ENTRY] = true\n              }\n              entry.on('end', onend)\n            } else {\n              this[SAW_VALID_ENTRY] = true\n            }\n          }\n\n          if (entry.meta) {\n            if (entry.size > this.maxMetaEntrySize) {\n              entry.ignore = true\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = 'ignore'\n              entry.resume()\n            } else if (entry.size > 0) {\n              this[META] = ''\n              entry.on('data', c => this[META] += c)\n              this[STATE] = 'meta'\n            }\n          } else {\n            this[EX] = null\n            entry.ignore = entry.ignore || !this.filter(entry.path, entry)\n\n            if (entry.ignore) {\n              // probably valid, just not something we care about\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = entry.remain ? 'ignore' : 'header'\n              entry.resume()\n            } else {\n              if (entry.remain)\n                this[STATE] = 'body'\n              else {\n                this[STATE] = 'header'\n                entry.end()\n              }\n\n              if (!this[READENTRY]) {\n                this[QUEUE].push(entry)\n                this[NEXTENTRY]()\n              } else\n                this[QUEUE].push(entry)\n            }\n          }\n        }\n      }\n    }\n  }\n\n  [PROCESSENTRY] (entry) {\n    let go = true\n\n    if (!entry) {\n      this[READENTRY] = null\n      go = false\n    } else if (Array.isArray(entry))\n      this.emit.apply(this, entry)\n    else {\n      this[READENTRY] = entry\n      this.emit('entry', entry)\n      if (!entry.emittedEnd) {\n        entry.on('end', _ => this[NEXTENTRY]())\n        go = false\n      }\n    }\n\n    return go\n  }\n\n  [NEXTENTRY] () {\n    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))\n\n    if (!this[QUEUE].length) {\n      // At this point, there's nothing in the queue, but we may have an\n      // entry which is being consumed (readEntry).\n      // If we don't, then we definitely can handle more data.\n      // If we do, and either it's flowing, or it has never had any data\n      // written to it, then it needs more.\n      // The only other possibility is that it has returned false from a\n      // write() call, so we wait for the next drain to continue.\n      const re = this[READENTRY]\n      const drainNow = !re || re.flowing || re.size === re.remain\n      if (drainNow) {\n        if (!this[WRITING])\n          this.emit('drain')\n      } else\n        re.once('drain', _ => this.emit('drain'))\n     }\n  }\n\n  [CONSUMEBODY] (chunk, position) {\n    // write up to but no  more than writeEntry.blockRemain\n    const entry = this[WRITEENTRY]\n    const br = entry.blockRemain\n    const c = (br >= chunk.length && position === 0) ? chunk\n      : chunk.slice(position, position + br)\n\n    entry.write(c)\n\n    if (!entry.blockRemain) {\n      this[STATE] = 'header'\n      this[WRITEENTRY] = null\n      entry.end()\n    }\n\n    return c.length\n  }\n\n  [CONSUMEMETA] (chunk, position) {\n    const entry = this[WRITEENTRY]\n    const ret = this[CONSUMEBODY](chunk, position)\n\n    // if we finished, then the entry is reset\n    if (!this[WRITEENTRY])\n      this[EMITMETA](entry)\n\n    return ret\n  }\n\n  [EMIT] (ev, data, extra) {\n    if (!this[QUEUE].length && !this[READENTRY])\n      this.emit(ev, data, extra)\n    else\n      this[QUEUE].push([ev, data, extra])\n  }\n\n  [EMITMETA] (entry) {\n    this[EMIT]('meta', this[META])\n    switch (entry.type) {\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this[EX] = Pax.parse(this[META], this[EX], false)\n        break\n\n      case 'GlobalExtendedHeader':\n        this[GEX] = Pax.parse(this[META], this[GEX], true)\n        break\n\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].path = this[META].replace(/\\0.*/, '')\n        break\n\n      case 'NextFileHasLongLinkpath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].linkpath = this[META].replace(/\\0.*/, '')\n        break\n\n      /* istanbul ignore next */\n      default: throw new Error('unknown meta: ' + entry.type)\n    }\n  }\n\n  abort (error) {\n    this[ABORTED] = true\n    this.emit('abort', error)\n    // always throws, even in non-strict mode\n    this.warn('TAR_ABORT', error, { recoverable: false })\n  }\n\n  write (chunk) {\n    if (this[ABORTED])\n      return\n\n    // first write, might be gzipped\n    if (this[UNZIP] === null && chunk) {\n      if (this[BUFFER]) {\n        chunk = Buffer.concat([this[BUFFER], chunk])\n        this[BUFFER] = null\n      }\n      if (chunk.length < gzipHeader.length) {\n        this[BUFFER] = chunk\n        return true\n      }\n      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {\n        if (chunk[i] !== gzipHeader[i])\n          this[UNZIP] = false\n      }\n      if (this[UNZIP] === null) {\n        const ended = this[ENDED]\n        this[ENDED] = false\n        this[UNZIP] = new zlib.Unzip()\n        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))\n        this[UNZIP].on('error', er => this.abort(er))\n        this[UNZIP].on('end', _ => {\n          this[ENDED] = true\n          this[CONSUMECHUNK]()\n        })\n        this[WRITING] = true\n        const ret = this[UNZIP][ended ? 'end' : 'write' ](chunk)\n        this[WRITING] = false\n        return ret\n      }\n    }\n\n    this[WRITING] = true\n    if (this[UNZIP])\n      this[UNZIP].write(chunk)\n    else\n      this[CONSUMECHUNK](chunk)\n    this[WRITING] = false\n\n    // return false if there's a queue, or if the current entry isn't flowing\n    const ret =\n      this[QUEUE].length ? false :\n      this[READENTRY] ? this[READENTRY].flowing :\n      true\n\n    // if we have no queue, then that means a clogged READENTRY\n    if (!ret && !this[QUEUE].length)\n      this[READENTRY].once('drain', _ => this.emit('drain'))\n\n    return ret\n  }\n\n  [BUFFERCONCAT] (c) {\n    if (c && !this[ABORTED])\n      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c\n  }\n\n  [MAYBEEND] () {\n    if (this[ENDED] &&\n        !this[EMITTEDEND] &&\n        !this[ABORTED] &&\n        !this[CONSUMING]) {\n      this[EMITTEDEND] = true\n      const entry = this[WRITEENTRY]\n      if (entry && entry.blockRemain) {\n        // truncated, likely a damaged file\n        const have = this[BUFFER] ? this[BUFFER].length : 0\n        this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${\n          entry.blockRemain} more bytes, only ${have} available)`, {entry})\n        if (this[BUFFER])\n          entry.write(this[BUFFER])\n        entry.end()\n      }\n      this[EMIT](DONE)\n    }\n  }\n\n  [CONSUMECHUNK] (chunk) {\n    if (this[CONSUMING])\n      this[BUFFERCONCAT](chunk)\n    else if (!chunk && !this[BUFFER])\n      this[MAYBEEND]()\n    else {\n      this[CONSUMING] = true\n      if (this[BUFFER]) {\n        this[BUFFERCONCAT](chunk)\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      } else {\n        this[CONSUMECHUNKSUB](chunk)\n      }\n\n      while (this[BUFFER] &&\n          this[BUFFER].length >= 512 &&\n          !this[ABORTED] &&\n          !this[SAW_EOF]) {\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      }\n      this[CONSUMING] = false\n    }\n\n    if (!this[BUFFER] || this[ENDED])\n      this[MAYBEEND]()\n  }\n\n  [CONSUMECHUNKSUB] (chunk) {\n    // we know that we are in CONSUMING mode, so anything written goes into\n    // the buffer.  Advance the position and put any remainder in the buffer.\n    let position = 0\n    let length = chunk.length\n    while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {\n      switch (this[STATE]) {\n        case 'begin':\n        case 'header':\n          this[CONSUMEHEADER](chunk, position)\n          position += 512\n          break\n\n        case 'ignore':\n        case 'body':\n          position += this[CONSUMEBODY](chunk, position)\n          break\n\n        case 'meta':\n          position += this[CONSUMEMETA](chunk, position)\n          break\n\n        /* istanbul ignore next */\n        default:\n          throw new Error('invalid state: ' + this[STATE])\n      }\n    }\n\n    if (position < length) {\n      if (this[BUFFER])\n        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])\n      else\n        this[BUFFER] = chunk.slice(position)\n    }\n  }\n\n  end (chunk) {\n    if (!this[ABORTED]) {\n      if (this[UNZIP])\n        this[UNZIP].end(chunk)\n      else {\n        this[ENDED] = true\n        this.write(chunk)\n      }\n    }\n  }\n})\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/parse.js?");

/***/ }),

/***/ "./node_modules/tar/lib/path-reservations.js":
/*!***************************************************!*\
  !*** ./node_modules/tar/lib/path-reservations.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\n\nmodule.exports = () => {\n  // path => [function or Set]\n  // A Set object means a directory reservation\n  // A fn is a direct reservation on that path\n  const queues = new Map()\n\n  // fn => {paths:[path,...], dirs:[path, ...]}\n  const reservations = new Map()\n\n  // return a set of parent dirs for a given path\n  const { join } = __webpack_require__(/*! path */ \"path\")\n  const getDirs = path =>\n    join(path).split(/[\\\\\\/]/).slice(0, -1).reduce((set, path) =>\n      set.length ? set.concat(join(set[set.length-1], path)) : [path], [])\n\n  // functions currently running\n  const running = new Set()\n\n  // return the queues for each path the function cares about\n  // fn => {paths, dirs}\n  const getQueues = fn => {\n    const res = reservations.get(fn)\n    /* istanbul ignore if - unpossible */\n    if (!res)\n      throw new Error('function does not have any path reservations')\n    return {\n      paths: res.paths.map(path => queues.get(path)),\n      dirs: [...res.dirs].map(path => queues.get(path)),\n    }\n  }\n\n  // check if fn is first in line for all its paths, and is\n  // included in the first set for all its dir queues\n  const check = fn => {\n    const {paths, dirs} = getQueues(fn)\n    return paths.every(q => q[0] === fn) &&\n      dirs.every(q => q[0] instanceof Set && q[0].has(fn))\n  }\n\n  // run the function if it's first in line and not already running\n  const run = fn => {\n    if (running.has(fn) || !check(fn))\n      return false\n    running.add(fn)\n    fn(() => clear(fn))\n    return true\n  }\n\n  const clear = fn => {\n    if (!running.has(fn))\n      return false\n\n    const { paths, dirs } = reservations.get(fn)\n    const next = new Set()\n\n    paths.forEach(path => {\n      const q = queues.get(path)\n      assert.equal(q[0], fn)\n      if (q.length === 1)\n        queues.delete(path)\n      else {\n        q.shift()\n        if (typeof q[0] === 'function')\n          next.add(q[0])\n        else\n          q[0].forEach(fn => next.add(fn))\n      }\n    })\n\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      assert(q[0] instanceof Set)\n      if (q[0].size === 1 && q.length === 1) {\n        queues.delete(dir)\n      } else if (q[0].size === 1) {\n        q.shift()\n\n        // must be a function or else the Set would've been reused\n        next.add(q[0])\n      } else\n        q[0].delete(fn)\n    })\n    running.delete(fn)\n\n    next.forEach(fn => run(fn))\n    return true\n  }\n\n  const reserve = (paths, fn) => {\n    const dirs = new Set(\n      paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))\n    )\n    reservations.set(fn, {dirs, paths})\n    paths.forEach(path => {\n      const q = queues.get(path)\n      if (!q)\n        queues.set(path, [fn])\n      else\n        q.push(fn)\n    })\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      if (!q)\n        queues.set(dir, [new Set([fn])])\n      else if (q[q.length-1] instanceof Set)\n        q[q.length-1].add(fn)\n      else\n        q.push(new Set([fn]))\n    })\n\n    return run(fn)\n  }\n\n  return { check, reserve }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/path-reservations.js?");

/***/ }),

/***/ "./node_modules/tar/lib/pax.js":
/*!*************************************!*\
  !*** ./node_modules/tar/lib/pax.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Header = __webpack_require__(/*! ./header.js */ \"./node_modules/tar/lib/header.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\nclass Pax {\n  constructor (obj, global) {\n    this.atime = obj.atime || null\n    this.charset = obj.charset || null\n    this.comment = obj.comment || null\n    this.ctime = obj.ctime || null\n    this.gid = obj.gid || null\n    this.gname = obj.gname || null\n    this.linkpath = obj.linkpath || null\n    this.mtime = obj.mtime || null\n    this.path = obj.path || null\n    this.size = obj.size || null\n    this.uid = obj.uid || null\n    this.uname = obj.uname || null\n    this.dev = obj.dev || null\n    this.ino = obj.ino || null\n    this.nlink = obj.nlink || null\n    this.global = global || false\n  }\n\n  encode () {\n    const body = this.encodeBody()\n    if (body === '')\n      return null\n\n    const bodyLen = Buffer.byteLength(body)\n    // round up to 512 bytes\n    // add 512 for header\n    const bufLen = 512 * Math.ceil(1 + bodyLen / 512)\n    const buf = Buffer.allocUnsafe(bufLen)\n\n    // 0-fill the header section, it might not hit every field\n    for (let i = 0; i < 512; i++) {\n      buf[i] = 0\n    }\n\n    new Header({\n      // XXX split the path\n      // then the path should be PaxHeader + basename, but less than 99,\n      // prepend with the dirname\n      path: ('PaxHeader/' + path.basename(this.path)).slice(0, 99),\n      mode: this.mode || 0o644,\n      uid: this.uid || null,\n      gid: this.gid || null,\n      size: bodyLen,\n      mtime: this.mtime || null,\n      type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',\n      linkpath: '',\n      uname: this.uname || '',\n      gname: this.gname || '',\n      devmaj: 0,\n      devmin: 0,\n      atime: this.atime || null,\n      ctime: this.ctime || null\n    }).encode(buf)\n\n    buf.write(body, 512, bodyLen, 'utf8')\n\n    // null pad after the body\n    for (let i = bodyLen + 512; i < buf.length; i++) {\n      buf[i] = 0\n    }\n\n    return buf\n  }\n\n  encodeBody () {\n    return (\n      this.encodeField('path') +\n      this.encodeField('ctime') +\n      this.encodeField('atime') +\n      this.encodeField('dev') +\n      this.encodeField('ino') +\n      this.encodeField('nlink') +\n      this.encodeField('charset') +\n      this.encodeField('comment') +\n      this.encodeField('gid') +\n      this.encodeField('gname') +\n      this.encodeField('linkpath') +\n      this.encodeField('mtime') +\n      this.encodeField('size') +\n      this.encodeField('uid') +\n      this.encodeField('uname')\n    )\n  }\n\n  encodeField (field) {\n    if (this[field] === null || this[field] === undefined)\n      return ''\n    const v = this[field] instanceof Date ? this[field].getTime() / 1000\n      : this[field]\n    const s = ' ' +\n      (field === 'dev' || field === 'ino' || field === 'nlink'\n       ? 'SCHILY.' : '') +\n      field + '=' + v + '\\n'\n    const byteLen = Buffer.byteLength(s)\n    // the digits includes the length of the digits in ascii base-10\n    // so if it's 9 characters, then adding 1 for the 9 makes it 10\n    // which makes it 11 chars.\n    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1\n    if (byteLen + digits >= Math.pow(10, digits))\n      digits += 1\n    const len = digits + byteLen\n    return len + s\n  }\n}\n\nPax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g)\n\nconst merge = (a, b) =>\n  b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a\n\nconst parseKV = string =>\n  string\n    .replace(/\\n$/, '')\n    .split('\\n')\n    .reduce(parseKVLine, Object.create(null))\n\nconst parseKVLine = (set, line) => {\n  const n = parseInt(line, 10)\n\n  // XXX Values with \\n in them will fail this.\n  // Refactor to not be a naive line-by-line parse.\n  if (n !== Buffer.byteLength(line) + 1)\n    return set\n\n  line = line.substr((n + ' ').length)\n  const kv = line.split('=')\n  const k = kv.shift().replace(/^SCHILY\\.(dev|ino|nlink)/, '$1')\n  if (!k)\n    return set\n\n  const v = kv.join('=')\n  set[k] = /^([A-Z]+\\.)?([mac]|birth|creation)time$/.test(k)\n    ?  new Date(v * 1000)\n    : /^[0-9]+$/.test(v) ? +v\n    : v\n  return set\n}\n\nmodule.exports = Pax\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/pax.js?");

/***/ }),

/***/ "./node_modules/tar/lib/read-entry.js":
/*!********************************************!*\
  !*** ./node_modules/tar/lib/read-entry.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst types = __webpack_require__(/*! ./types.js */ \"./node_modules/tar/lib/types.js\")\nconst MiniPass = __webpack_require__(/*! minipass */ \"./node_modules/minipass/index.js\")\n\nconst SLURP = Symbol('slurp')\nmodule.exports = class ReadEntry extends MiniPass {\n  constructor (header, ex, gex) {\n    super()\n    // read entries always start life paused.  this is to avoid the\n    // situation where Minipass's auto-ending empty streams results\n    // in an entry ending before we're ready for it.\n    this.pause()\n    this.extended = ex\n    this.globalExtended = gex\n    this.header = header\n    this.startBlockSize = 512 * Math.ceil(header.size / 512)\n    this.blockRemain = this.startBlockSize\n    this.remain = header.size\n    this.type = header.type\n    this.meta = false\n    this.ignore = false\n    switch (this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break\n\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this.meta = true\n        break\n\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n      default:\n        this.ignore = true\n    }\n\n    this.path = header.path\n    this.mode = header.mode\n    if (this.mode)\n      this.mode = this.mode & 0o7777\n    this.uid = header.uid\n    this.gid = header.gid\n    this.uname = header.uname\n    this.gname = header.gname\n    this.size = header.size\n    this.mtime = header.mtime\n    this.atime = header.atime\n    this.ctime = header.ctime\n    this.linkpath = header.linkpath\n    this.uname = header.uname\n    this.gname = header.gname\n\n    if (ex) this[SLURP](ex)\n    if (gex) this[SLURP](gex, true)\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain)\n      throw new Error('writing more to entry than is appropriate')\n\n    const r = this.remain\n    const br = this.blockRemain\n    this.remain = Math.max(0, r - writeLen)\n    this.blockRemain = Math.max(0, br - writeLen)\n    if (this.ignore)\n      return true\n\n    if (r >= writeLen)\n      return super.write(data)\n\n    // r < writeLen\n    return super.write(data.slice(0, r))\n  }\n\n  [SLURP] (ex, global) {\n    for (let k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path'))\n        this[k] = ex[k]\n    }\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/read-entry.js?");

/***/ }),

/***/ "./node_modules/tar/lib/replace.js":
/*!*****************************************!*\
  !*** ./node_modules/tar/lib/replace.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// tar -r\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"./node_modules/tar/lib/high-level-opt.js\")\nconst Pack = __webpack_require__(/*! ./pack.js */ \"./node_modules/tar/lib/pack.js\")\nconst Parse = __webpack_require__(/*! ./parse.js */ \"./node_modules/tar/lib/parse.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"./node_modules/fs-minipass/index.js\")\nconst t = __webpack_require__(/*! ./list.js */ \"./node_modules/tar/lib/list.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nconst Header = __webpack_require__(/*! ./header.js */ \"./node_modules/tar/lib/header.js\")\n\nconst r = module.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file)\n    throw new TypeError('file is required')\n\n  if (opt.gzip)\n    throw new TypeError('cannot append to compressed archives')\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  return opt.sync ? replaceSync(opt, files)\n    : replace(opt, files, cb)\n}\n\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n\n  let threw = true\n  let fd\n  let position\n\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+')\n    } catch (er) {\n      if (er.code === 'ENOENT')\n        fd = fs.openSync(opt.file, 'w+')\n      else\n        throw er\n    }\n\n    const st = fs.fstatSync(fd)\n    const headBuf = Buffer.alloc(512)\n\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(\n          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos\n        )\n\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)\n          throw new Error('cannot append to compressed archives')\n\n        if (!bytes)\n          break POSITION\n      }\n\n      let h = new Header(headBuf)\n      if (!h.cksumValid)\n        break\n      let entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > st.size)\n        break\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize\n      if (opt.mtimeCache)\n        opt.mtimeCache.set(h.path, h.mtime)\n    }\n    threw = false\n\n    streamSync(opt, p, position, fd, files)\n  } finally {\n    if (threw)\n      try { fs.closeSync(fd) } catch (er) {}\n  }\n}\n\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst replace = (opt, files, cb) => {\n  files = Array.from(files)\n  const p = new Pack(opt)\n\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er)\n        fs.close(fd, _ => cb_(er))\n      else\n        cb_(null, pos)\n    }\n\n    let position = 0\n    if (size === 0)\n      return cb(null, 0)\n\n    let bufPos = 0\n    const headBuf = Buffer.alloc(512)\n    const onread = (er, bytes) => {\n      if (er)\n        return cb(er)\n      bufPos += bytes\n      if (bufPos < 512 && bytes)\n        return fs.read(\n          fd, headBuf, bufPos, headBuf.length - bufPos,\n          position + bufPos, onread\n        )\n\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)\n        return cb(new Error('cannot append to compressed archives'))\n\n      // truncated header\n      if (bufPos < 512)\n        return cb(null, position)\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid)\n        return cb(null, position)\n\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > size)\n        return cb(null, position)\n\n      position += entryBlockSize + 512\n      if (position >= size)\n        return cb(null, position)\n\n      if (opt.mtimeCache)\n        opt.mtimeCache.set(h.path, h.mtime)\n      bufPos = 0\n      fs.read(fd, headBuf, 0, 512, position, onread)\n    }\n    fs.read(fd, headBuf, 0, 512, position, onread)\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject)\n    let flag = 'r+'\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+'\n        return fs.open(opt.file, flag, onopen)\n      }\n\n      if (er)\n        return reject(er)\n\n      fs.fstat(fd, (er, st) => {\n        if (er)\n          return reject(er)\n        getPos(fd, st.size, (er, position) => {\n          if (er)\n            return reject(er)\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position\n          })\n          p.pipe(stream)\n          stream.on('error', reject)\n          stream.on('close', resolve)\n          addFilesAsync(p, files)\n        })\n      })\n    }\n    fs.open(opt.file, flag, onopen)\n  })\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@')\n      t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry)\n      })\n    else\n      p.add(file)\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@')\n      return t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        noResume: true,\n        onentry: entry => p.add(entry)\n      }).then(_ => addFilesAsync(p, files))\n    else\n      p.add(file)\n  }\n  p.end()\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/replace.js?");

/***/ }),

/***/ "./node_modules/tar/lib/types.js":
/*!***************************************!*\
  !*** ./node_modules/tar/lib/types.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// map types from key to human-friendly name\nexports.name = new Map([\n  ['0', 'File'],\n  // same as File\n  ['', 'OldFile'],\n  ['1', 'Link'],\n  ['2', 'SymbolicLink'],\n  // Devices and FIFOs aren't fully supported\n  // they are parsed, but skipped when unpacking\n  ['3', 'CharacterDevice'],\n  ['4', 'BlockDevice'],\n  ['5', 'Directory'],\n  ['6', 'FIFO'],\n  // same as File\n  ['7', 'ContiguousFile'],\n  // pax headers\n  ['g', 'GlobalExtendedHeader'],\n  ['x', 'ExtendedHeader'],\n  // vendor-specific stuff\n  // skip\n  ['A', 'SolarisACL'],\n  // like 5, but with data, which should be skipped\n  ['D', 'GNUDumpDir'],\n  // metadata only, skip\n  ['I', 'Inode'],\n  // data = link path of next file\n  ['K', 'NextFileHasLongLinkpath'],\n  // data = path of next file\n  ['L', 'NextFileHasLongPath'],\n  // skip\n  ['M', 'ContinuationFile'],\n  // like L\n  ['N', 'OldGnuLongPath'],\n  // skip\n  ['S', 'SparseFile'],\n  // skip\n  ['V', 'TapeVolumeHeader'],\n  // like x\n  ['X', 'OldExtendedHeader']\n])\n\n// map the other direction\nexports.code = new Map(Array.from(exports.name).map(kv => [kv[1], kv[0]]))\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/types.js?");

/***/ }),

/***/ "./node_modules/tar/lib/unpack.js":
/*!****************************************!*\
  !*** ./node_modules/tar/lib/unpack.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst EE = __webpack_require__(/*! events */ \"events\").EventEmitter\nconst Parser = __webpack_require__(/*! ./parse.js */ \"./node_modules/tar/lib/parse.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"./node_modules/fs-minipass/index.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ./mkdir.js */ \"./node_modules/tar/lib/mkdir.js\")\nconst mkdirSync = mkdir.sync\nconst wc = __webpack_require__(/*! ./winchars.js */ \"./node_modules/tar/lib/winchars.js\")\nconst pathReservations = __webpack_require__(/*! ./path-reservations.js */ \"./node_modules/tar/lib/path-reservations.js\")\n\nconst ONENTRY = Symbol('onEntry')\nconst CHECKFS = Symbol('checkFs')\nconst CHECKFS2 = Symbol('checkFs2')\nconst ISREUSABLE = Symbol('isReusable')\nconst MAKEFS = Symbol('makeFs')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst LINK = Symbol('link')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst UNSUPPORTED = Symbol('unsupported')\nconst UNKNOWN = Symbol('unknown')\nconst CHECKPATH = Symbol('checkPath')\nconst MKDIR = Symbol('mkdir')\nconst ONERROR = Symbol('onError')\nconst PENDING = Symbol('pending')\nconst PEND = Symbol('pend')\nconst UNPEND = Symbol('unpend')\nconst ENDED = Symbol('ended')\nconst MAYBECLOSE = Symbol('maybeClose')\nconst SKIP = Symbol('skip')\nconst DOCHOWN = Symbol('doChown')\nconst UID = Symbol('uid')\nconst GID = Symbol('gid')\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\")\nconst getFlag = __webpack_require__(/*! ./get-write-flag.js */ \"./node_modules/tar/lib/get-write-flag.js\")\n\n/* istanbul ignore next */\nconst neverCalled = () => {\n  throw new Error('sync function called cb somehow?!?')\n}\n\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* istanbul ignore next */\nconst unlinkFile = (path, cb) => {\n  if (process.platform !== 'win32')\n    return fs.unlink(path, cb)\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.rename(path, name, er => {\n    if (er)\n      return cb(er)\n    fs.unlink(name, cb)\n  })\n}\n\n/* istanbul ignore next */\nconst unlinkFileSync = path => {\n  if (process.platform !== 'win32')\n    return fs.unlinkSync(path)\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.renameSync(path, name)\n  fs.unlinkSync(name)\n}\n\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) =>\n  a === a >>> 0 ? a\n  : b === b >>> 0 ? b\n  : c\n\nclass Unpack extends Parser {\n  constructor (opt) {\n    if (!opt)\n      opt = {}\n\n    opt.ondone = _ => {\n      this[ENDED] = true\n      this[MAYBECLOSE]()\n    }\n\n    super(opt)\n\n    this.reservations = pathReservations()\n\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null\n\n    this.writable = true\n    this.readable = false\n\n    this[PENDING] = 0\n    this[ENDED] = false\n\n    this.dirCache = opt.dirCache || new Map()\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number')\n        throw new TypeError('cannot set owner without number uid and gid')\n      if (opt.preserveOwner)\n        throw new TypeError(\n          'cannot preserve owner in archive and also set owner explicitly')\n      this.uid = opt.uid\n      this.gid = opt.gid\n      this.setOwner = true\n    } else {\n      this.uid = null\n      this.gid = null\n      this.setOwner = false\n    }\n\n    // default true for root\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number')\n      this.preserveOwner = process.getuid && process.getuid() === 0\n    else\n      this.preserveOwner = !!opt.preserveOwner\n\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?\n      process.getuid() : null\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?\n      process.getgid() : null\n\n    // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n    this.forceChown = opt.forceChown === true\n\n    // turn ><?| in filenames into 0xf000-higher encoded forms\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n\n    // do not unpack over files that are newer than what's in the archive\n    this.newer = !!opt.newer\n\n    // do not unpack over ANY files\n    this.keep = !!opt.keep\n\n    // do not set mtime/atime of extracted entries\n    this.noMtime = !!opt.noMtime\n\n    // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n    this.preservePaths = !!opt.preservePaths\n\n    // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n    this.unlink = !!opt.unlink\n\n    this.cwd = path.resolve(opt.cwd || process.cwd())\n    this.strip = +opt.strip || 0\n    this.processUmask = process.umask()\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask\n    // default mode for dirs created as parents\n    this.dmode = opt.dmode || (0o0777 & (~this.umask))\n    this.fmode = opt.fmode || (0o0666 & (~this.umask))\n    this.on('entry', entry => this[ONENTRY](entry))\n  }\n\n  // a bad or damaged archive is a warning for Parser, but an error\n  // when extracting.  Mark those errors as unrecoverable, because\n  // the Unpack contract cannot be met.\n  warn (code, msg, data = {}) {\n    if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT')\n      data.recoverable = false\n    return super.warn(code, msg, data)\n  }\n\n  [MAYBECLOSE] () {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish')\n      this.emit('finish')\n      this.emit('end')\n      this.emit('close')\n    }\n  }\n\n  [CHECKPATH] (entry) {\n    if (this.strip) {\n      const parts = entry.path.split(/\\/|\\\\/)\n      if (parts.length < this.strip)\n        return false\n      entry.path = parts.slice(this.strip).join('/')\n\n      if (entry.type === 'Link') {\n        const linkparts = entry.linkpath.split(/\\/|\\\\/)\n        if (linkparts.length >= this.strip)\n          entry.linkpath = linkparts.slice(this.strip).join('/')\n      }\n    }\n\n    if (!this.preservePaths) {\n      const p = entry.path\n      if (p.match(/(^|\\/|\\\\)\\.\\.(\\\\|\\/|$)/)) {\n        this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {\n          entry,\n          path: p,\n        })\n        return false\n      }\n\n      // absolutes on posix are also absolutes on win32\n      // so we only need to test this one to get both\n      if (path.win32.isAbsolute(p)) {\n        const parsed = path.win32.parse(p)\n        entry.path = p.substr(parsed.root.length)\n        const r = parsed.root\n        this.warn('TAR_ENTRY_INFO', `stripping ${r} from absolute path`, {\n          entry,\n          path: p,\n        })\n      }\n    }\n\n    // only encode : chars that aren't drive letter indicators\n    if (this.win32) {\n      const parsed = path.win32.parse(entry.path)\n      entry.path = parsed.root === '' ? wc.encode(entry.path)\n        : parsed.root + wc.encode(entry.path.substr(parsed.root.length))\n    }\n\n    if (path.isAbsolute(entry.path))\n      entry.absolute = entry.path\n    else\n      entry.absolute = path.resolve(this.cwd, entry.path)\n\n    return true\n  }\n\n  [ONENTRY] (entry) {\n    if (!this[CHECKPATH](entry))\n      return entry.resume()\n\n    assert.equal(typeof entry.absolute, 'string')\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode)\n          entry.mode = entry.mode | 0o700\n\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry)\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n        return this[UNSUPPORTED](entry)\n    }\n  }\n\n  [ONERROR] (er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError')\n      this.emit('error', er)\n    else {\n      this.warn('TAR_ENTRY_ERROR', er, {entry})\n      this[UNPEND]()\n      entry.resume()\n    }\n  }\n\n  [MKDIR] (dir, mode, cb) {\n    mkdir(dir, {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode\n    }, cb)\n  }\n\n  [DOCHOWN] (entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown ||\n      this.preserveOwner &&\n      ( typeof entry.uid === 'number' && entry.uid !== this.processUid ||\n        typeof entry.gid === 'number' && entry.gid !== this.processGid )\n      ||\n      ( typeof this.uid === 'number' && this.uid !== this.processUid ||\n        typeof this.gid === 'number' && this.gid !== this.processGid )\n  }\n\n  [UID] (entry) {\n    return uint32(this.uid, entry.uid, this.processUid)\n  }\n\n  [GID] (entry) {\n    return uint32(this.gid, entry.gid, this.processGid)\n  }\n\n  [FILE] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.fmode\n    const stream = new fsm.WriteStream(entry.absolute, {\n      flags: getFlag(entry.size),\n      mode: mode,\n      autoClose: false\n    })\n    stream.on('error', er => this[ONERROR](er, entry))\n\n    let actions = 1\n    const done = er => {\n      if (er)\n        return this[ONERROR](er, entry)\n\n      if (--actions === 0) {\n        fs.close(stream.fd, er => {\n          fullyDone()\n          er ? this[ONERROR](er, entry) : this[UNPEND]()\n        })\n      }\n    }\n\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute\n      const fd = stream.fd\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        fs.futimes(fd, atime, mtime, er =>\n          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))\n          : done())\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n        fs.fchown(fd, uid, gid, er =>\n          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))\n          : done())\n      }\n\n      done()\n    })\n\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n    tx.pipe(stream)\n  }\n\n  [DIRECTORY] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er) {\n        fullyDone()\n        return this[ONERROR](er, entry)\n      }\n\n      let actions = 1\n      const done = _ => {\n        if (--actions === 0) {\n          fullyDone()\n          this[UNPEND]()\n          entry.resume()\n        }\n      }\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)\n      }\n\n      done()\n    })\n  }\n\n  [UNSUPPORTED] (entry) {\n    entry.unsupported = true\n    this.warn('TAR_ENTRY_UNSUPPORTED',\n      `unsupported entry type: ${entry.type}`, {entry})\n    entry.resume()\n  }\n\n  [SYMLINK] (entry, done) {\n    this[LINK](entry, entry.linkpath, 'symlink', done)\n  }\n\n  [HARDLINK] (entry, done) {\n    this[LINK](entry, path.resolve(this.cwd, entry.linkpath), 'link', done)\n  }\n\n  [PEND] () {\n    this[PENDING]++\n  }\n\n  [UNPEND] () {\n    this[PENDING]--\n    this[MAYBECLOSE]()\n  }\n\n  [SKIP] (entry) {\n    this[UNPEND]()\n    entry.resume()\n  }\n\n  // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n  [ISREUSABLE] (entry, st) {\n    return entry.type === 'File' &&\n      !this.unlink &&\n      st.isFile() &&\n      st.nlink <= 1 &&\n      process.platform !== 'win32'\n  }\n\n  // check if a thing is there, and if so, try to clobber it\n  [CHECKFS] (entry) {\n    this[PEND]()\n    const paths = [entry.path]\n    if (entry.linkpath)\n      paths.push(entry.linkpath)\n    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done))\n  }\n  [CHECKFS2] (entry, done) {\n    this[MKDIR](path.dirname(entry.absolute), this.dmode, er => {\n      if (er) {\n        done()\n        return this[ONERROR](er, entry)\n      }\n      fs.lstat(entry.absolute, (er, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n          this[SKIP](entry)\n          done()\n        } else if (er || this[ISREUSABLE](entry, st)) {\n          this[MAKEFS](null, entry, done)\n        }\n        else if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            if (!entry.mode || (st.mode & 0o7777) === entry.mode)\n              this[MAKEFS](null, entry, done)\n            else\n              fs.chmod(entry.absolute, entry.mode,\n                er => this[MAKEFS](er, entry, done))\n          } else\n            fs.rmdir(entry.absolute, er => this[MAKEFS](er, entry, done))\n        } else\n          unlinkFile(entry.absolute, er => this[MAKEFS](er, entry, done))\n      })\n    })\n  }\n\n  [MAKEFS] (er, entry, done) {\n    if (er)\n      return this[ONERROR](er, entry)\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry, done)\n\n      case 'Link':\n        return this[HARDLINK](entry, done)\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry, done)\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry, done)\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    // XXX: get the type ('file' or 'dir') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er)\n        return this[ONERROR](er, entry)\n      done()\n      this[UNPEND]()\n      entry.resume()\n    })\n  }\n}\n\nclass UnpackSync extends Unpack {\n  constructor (opt) {\n    super(opt)\n  }\n\n  [CHECKFS] (entry) {\n    const er = this[MKDIR](path.dirname(entry.absolute), this.dmode, neverCalled)\n    if (er)\n      return this[ONERROR](er, entry)\n    try {\n      const st = fs.lstatSync(entry.absolute)\n      if (this.keep || this.newer && st.mtime > entry.mtime)\n        return this[SKIP](entry)\n      else if (this[ISREUSABLE](entry, st))\n        return this[MAKEFS](null, entry, neverCalled)\n      else {\n        try {\n          if (st.isDirectory()) {\n            if (entry.type === 'Directory') {\n              if (entry.mode && (st.mode & 0o7777) !== entry.mode)\n                fs.chmodSync(entry.absolute, entry.mode)\n            } else\n              fs.rmdirSync(entry.absolute)\n          } else\n            unlinkFileSync(entry.absolute)\n          return this[MAKEFS](null, entry, neverCalled)\n        } catch (er) {\n          return this[ONERROR](er, entry)\n        }\n      }\n    } catch (er) {\n      return this[MAKEFS](null, entry, neverCalled)\n    }\n  }\n\n  [FILE] (entry, _) {\n    const mode = entry.mode & 0o7777 || this.fmode\n\n    const oner = er => {\n      let closeError\n      try {\n        fs.closeSync(fd)\n      } catch (e) {\n        closeError = e\n      }\n      if (er || closeError)\n        this[ONERROR](er || closeError, entry)\n    }\n\n    let stream\n    let fd\n    try {\n      fd = fs.openSync(entry.absolute, getFlag(entry.size), mode)\n    } catch (er) {\n      return oner(er)\n    }\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length)\n      } catch (er) {\n        oner(er)\n      }\n    })\n\n    tx.on('end', _ => {\n      let er = null\n      // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        try {\n          fs.futimesSync(fd, atime, mtime)\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime)\n          } catch (utimeser) {\n            er = futimeser\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n\n        try {\n          fs.fchownSync(fd, uid, gid)\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid)\n          } catch (chowner) {\n            er = er || fchowner\n          }\n        }\n      }\n\n      oner(er)\n    })\n  }\n\n  [DIRECTORY] (entry, _) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    const er = this[MKDIR](entry.absolute, mode)\n    if (er)\n      return this[ONERROR](er, entry)\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)\n      } catch (er) {}\n    }\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))\n      } catch (er) {}\n    }\n    entry.resume()\n  }\n\n  [MKDIR] (dir, mode) {\n    try {\n      return mkdir.sync(dir, {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode\n      })\n    } catch (er) {\n      return er\n    }\n  }\n\n  [LINK] (entry, linkpath, link, _) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute)\n      entry.resume()\n    } catch (er) {\n      return this[ONERROR](er, entry)\n    }\n  }\n}\n\nUnpack.Sync = UnpackSync\nmodule.exports = Unpack\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/unpack.js?");

/***/ }),

/***/ "./node_modules/tar/lib/update.js":
/*!****************************************!*\
  !*** ./node_modules/tar/lib/update.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// tar -u\n\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"./node_modules/tar/lib/high-level-opt.js\")\nconst r = __webpack_require__(/*! ./replace.js */ \"./node_modules/tar/lib/replace.js\")\n// just call tar.r with the filter and mtimeCache\n\nconst u = module.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file)\n    throw new TypeError('file is required')\n\n  if (opt.gzip)\n    throw new TypeError('cannot append to compressed archives')\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  mtimeFilter(opt)\n  return r(opt, files, cb)\n}\n\nconst mtimeFilter = opt => {\n  const filter = opt.filter\n\n  if (!opt.mtimeCache)\n    opt.mtimeCache = new Map()\n\n  opt.filter = filter ? (path, stat) =>\n    filter(path, stat) && !(opt.mtimeCache.get(path) > stat.mtime)\n    : (path, stat) => !(opt.mtimeCache.get(path) > stat.mtime)\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/update.js?");

/***/ }),

/***/ "./node_modules/tar/lib/warn-mixin.js":
/*!********************************************!*\
  !*** ./node_modules/tar/lib/warn-mixin.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = Base => class extends Base {\n  warn (code, message, data = {}) {\n    if (this.file)\n      data.file = this.file\n    if (this.cwd)\n      data.cwd = this.cwd\n    data.code = message instanceof Error && message.code || code\n    data.tarCode = code\n    if (!this.strict && data.recoverable !== false) {\n      if (message instanceof Error) {\n        data = Object.assign(message, data)\n        message = message.message\n      }\n      this.emit('warn', data.tarCode, message, data)\n    } else if (message instanceof Error) {\n      this.emit('error', Object.assign(message, data))\n    } else\n      this.emit('error', Object.assign(new Error(`${code}: ${message}`), data))\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/warn-mixin.js?");

/***/ }),

/***/ "./node_modules/tar/lib/winchars.js":
/*!******************************************!*\
  !*** ./node_modules/tar/lib/winchars.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// When writing files on Windows, translate the characters to their\n// 0xf000 higher-encoded versions.\n\nconst raw = [\n  '|',\n  '<',\n  '>',\n  '?',\n  ':'\n]\n\nconst win = raw.map(char =>\n  String.fromCharCode(0xf000 + char.charCodeAt(0)))\n\nconst toWin = new Map(raw.map((char, i) => [char, win[i]]))\nconst toRaw = new Map(win.map((char, i) => [char, raw[i]]))\n\nmodule.exports = {\n  encode: s => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s),\n  decode: s => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s)\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/winchars.js?");

/***/ }),

/***/ "./node_modules/tar/lib/write-entry.js":
/*!*********************************************!*\
  !*** ./node_modules/tar/lib/write-entry.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst MiniPass = __webpack_require__(/*! minipass */ \"./node_modules/minipass/index.js\")\nconst Pax = __webpack_require__(/*! ./pax.js */ \"./node_modules/tar/lib/pax.js\")\nconst Header = __webpack_require__(/*! ./header.js */ \"./node_modules/tar/lib/header.js\")\nconst ReadEntry = __webpack_require__(/*! ./read-entry.js */ \"./node_modules/tar/lib/read-entry.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\nconst types = __webpack_require__(/*! ./types.js */ \"./node_modules/tar/lib/types.js\")\nconst maxReadSize = 16 * 1024 * 1024\nconst PROCESS = Symbol('process')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst HEADER = Symbol('header')\nconst READ = Symbol('read')\nconst LSTAT = Symbol('lstat')\nconst ONLSTAT = Symbol('onlstat')\nconst ONREAD = Symbol('onread')\nconst ONREADLINK = Symbol('onreadlink')\nconst OPENFILE = Symbol('openfile')\nconst ONOPENFILE = Symbol('onopenfile')\nconst CLOSE = Symbol('close')\nconst MODE = Symbol('mode')\nconst warner = __webpack_require__(/*! ./warn-mixin.js */ \"./node_modules/tar/lib/warn-mixin.js\")\nconst winchars = __webpack_require__(/*! ./winchars.js */ \"./node_modules/tar/lib/winchars.js\")\n\nconst modeFix = __webpack_require__(/*! ./mode-fix.js */ \"./node_modules/tar/lib/mode-fix.js\")\n\nconst WriteEntry = warner(class WriteEntry extends MiniPass {\n  constructor (p, opt) {\n    opt = opt || {}\n    super(opt)\n    if (typeof p !== 'string')\n      throw new TypeError('path is required')\n    this.path = p\n    // suppress atime, ctime, uid, gid, uname, gname\n    this.portable = !!opt.portable\n    // until node has builtin pwnam functions, this'll have to do\n    this.myuid = process.getuid && process.getuid()\n    this.myuser = process.env.USER || ''\n    this.maxReadSize = opt.maxReadSize || maxReadSize\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.preservePaths = !!opt.preservePaths\n    this.cwd = opt.cwd || process.cwd()\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    let pathWarn = false\n    if (!this.preservePaths && path.win32.isAbsolute(p)) {\n      // absolutes on posix are also absolutes on win32\n      // so we only need to test this one to get both\n      const parsed = path.win32.parse(p)\n      this.path = p.substr(parsed.root.length)\n      pathWarn = parsed.root\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n    if (this.win32) {\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'))\n      p = p.replace(/\\\\/g, '/')\n    }\n\n    this.absolute = opt.absolute || path.resolve(this.cwd, p)\n\n    if (this.path === '')\n      this.path = './'\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.statCache.has(this.absolute))\n      this[ONLSTAT](this.statCache.get(this.absolute))\n    else\n      this[LSTAT]()\n  }\n\n  [LSTAT] () {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONLSTAT](stat)\n    })\n  }\n\n  [ONLSTAT] (stat) {\n    this.statCache.set(this.absolute, stat)\n    this.stat = stat\n    if (!stat.isFile())\n      stat.size = 0\n    this.type = getType(stat)\n    this.emit('stat', stat)\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    switch (this.type) {\n      case 'File': return this[FILE]()\n      case 'Directory': return this[DIRECTORY]()\n      case 'SymbolicLink': return this[SYMLINK]()\n      // unsupported types are ignored.\n      default: return this.end()\n    }\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  [HEADER] () {\n    if (this.type === 'Directory' && this.portable)\n      this.noMtime = true\n\n    this.header = new Header({\n      path: this.path,\n      linkpath: this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null :\n        this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime\n    })\n\n    if (this.header.encode() && !this.noPax)\n      this.write(new Pax({\n        atime: this.portable ? null : this.header.atime,\n        ctime: this.portable ? null : this.header.ctime,\n        gid: this.portable ? null : this.header.gid,\n        mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n        path: this.path,\n        linkpath: this.linkpath,\n        size: this.header.size,\n        uid: this.portable ? null : this.header.uid,\n        uname: this.portable ? null : this.header.uname,\n        dev: this.portable ? null : this.stat.dev,\n        ino: this.portable ? null : this.stat.ino,\n        nlink: this.portable ? null : this.stat.nlink\n      }).encode())\n    this.write(this.header.block)\n  }\n\n  [DIRECTORY] () {\n    if (this.path.substr(-1) !== '/')\n      this.path += '/'\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [SYMLINK] () {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONREADLINK](linkpath)\n    })\n  }\n\n  [ONREADLINK] (linkpath) {\n    this.linkpath = linkpath.replace(/\\\\/g, '/')\n    this[HEADER]()\n    this.end()\n  }\n\n  [HARDLINK] (linkpath) {\n    this.type = 'Link'\n    this.linkpath = path.relative(this.cwd, linkpath).replace(/\\\\/g, '/')\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [FILE] () {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey)\n        if (linkpath.indexOf(this.cwd) === 0)\n          return this[HARDLINK](linkpath)\n      }\n      this.linkCache.set(linkKey, this.absolute)\n    }\n\n    this[HEADER]()\n    if (this.stat.size === 0)\n      return this.end()\n\n    this[OPENFILE]()\n  }\n\n  [OPENFILE] () {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONOPENFILE](fd)\n    })\n  }\n\n  [ONOPENFILE] (fd) {\n    const blockLen = 512 * Math.ceil(this.stat.size / 512)\n    const bufLen = Math.min(blockLen, this.maxReadSize)\n    const buf = Buffer.allocUnsafe(bufLen)\n    this[READ](fd, buf, 0, buf.length, 0, this.stat.size, blockLen)\n  }\n\n  [READ] (fd, buf, offset, length, pos, remain, blockRemain) {\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        return this[CLOSE](fd, () => this.emit('error', er))\n      }\n      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead)\n    })\n  }\n\n  [CLOSE] (fd, cb) {\n    fs.close(fd, cb)\n  }\n\n  [ONREAD] (fd, buf, offset, length, pos, remain, blockRemain, bytesRead) {\n    if (bytesRead <= 0 && remain > 0) {\n      const er = new Error('encountered unexpected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](fd, () => this.emit('error', er))\n    }\n\n    if (bytesRead > remain) {\n      const er = new Error('did not encounter expected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](fd, () => this.emit('error', er))\n    }\n\n    // null out the rest of the buffer, if we could fit the block padding\n    if (bytesRead === remain) {\n      for (let i = bytesRead; i < length && bytesRead < blockRemain; i++) {\n        buf[i + offset] = 0\n        bytesRead ++\n        remain ++\n      }\n    }\n\n    const writeBuf = offset === 0 && bytesRead === buf.length ?\n      buf : buf.slice(offset, offset + bytesRead)\n    remain -= bytesRead\n    blockRemain -= bytesRead\n    pos += bytesRead\n    offset += bytesRead\n\n    this.write(writeBuf)\n\n    if (!remain) {\n      if (blockRemain)\n        this.write(Buffer.alloc(blockRemain))\n      return this[CLOSE](fd, er => er ? this.emit('error', er) : this.end())\n    }\n\n    if (offset >= length) {\n      buf = Buffer.allocUnsafe(length)\n      offset = 0\n    }\n    length = buf.length - offset\n    this[READ](fd, buf, offset, length, pos, remain, blockRemain)\n  }\n})\n\nclass WriteEntrySync extends WriteEntry {\n  constructor (path, opt) {\n    super(path, opt)\n  }\n\n  [LSTAT] () {\n    this[ONLSTAT](fs.lstatSync(this.absolute))\n  }\n\n  [SYMLINK] () {\n    this[ONREADLINK](fs.readlinkSync(this.absolute))\n  }\n\n  [OPENFILE] () {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))\n  }\n\n  [READ] (fd, buf, offset, length, pos, remain, blockRemain) {\n    let threw = true\n    try {\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos)\n      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead)\n      threw = false\n    } finally {\n      // ignoring the error from close(2) is a bad practice, but at\n      // this point we already have an error, don't need another one\n      if (threw)\n        try { this[CLOSE](fd, () => {}) } catch (er) {}\n    }\n  }\n\n  [CLOSE] (fd, cb) {\n    fs.closeSync(fd)\n    cb()\n  }\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends MiniPass {\n  constructor (readEntry, opt) {\n    opt = opt || {}\n    super(opt)\n    this.preservePaths = !!opt.preservePaths\n    this.portable = !!opt.portable\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n\n    this.readEntry = readEntry\n    this.type = readEntry.type\n    if (this.type === 'Directory' && this.portable)\n      this.noMtime = true\n\n    this.path = readEntry.path\n    this.mode = this[MODE](readEntry.mode)\n    this.uid = this.portable ? null : readEntry.uid\n    this.gid = this.portable ? null : readEntry.gid\n    this.uname = this.portable ? null : readEntry.uname\n    this.gname = this.portable ? null : readEntry.gname\n    this.size = readEntry.size\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime\n    this.atime = this.portable ? null : readEntry.atime\n    this.ctime = this.portable ? null : readEntry.ctime\n    this.linkpath = readEntry.linkpath\n\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    let pathWarn = false\n    if (path.isAbsolute(this.path) && !this.preservePaths) {\n      const parsed = path.parse(this.path)\n      pathWarn = parsed.root\n      this.path = this.path.substr(parsed.root.length)\n    }\n\n    this.remain = readEntry.size\n    this.blockRemain = readEntry.startBlockSize\n\n    this.header = new Header({\n      path: this.path,\n      linkpath: this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime\n    })\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.header.encode() && !this.noPax)\n      super.write(new Pax({\n        atime: this.portable ? null : this.atime,\n        ctime: this.portable ? null : this.ctime,\n        gid: this.portable ? null : this.gid,\n        mtime: this.noMtime ? null : this.mtime,\n        path: this.path,\n        linkpath: this.linkpath,\n        size: this.size,\n        uid: this.portable ? null : this.uid,\n        uname: this.portable ? null : this.uname,\n        dev: this.portable ? null : this.readEntry.dev,\n        ino: this.portable ? null : this.readEntry.ino,\n        nlink: this.portable ? null : this.readEntry.nlink\n      }).encode())\n\n    super.write(this.header.block)\n    readEntry.pipe(this)\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain)\n      throw new Error('writing more to entry than is appropriate')\n    this.blockRemain -= writeLen\n    return super.write(data)\n  }\n\n  end () {\n    if (this.blockRemain)\n      this.write(Buffer.alloc(this.blockRemain))\n    return super.end()\n  }\n})\n\nWriteEntry.Sync = WriteEntrySync\nWriteEntry.Tar = WriteEntryTar\n\nconst getType = stat =>\n  stat.isFile() ? 'File'\n  : stat.isDirectory() ? 'Directory'\n  : stat.isSymbolicLink() ? 'SymbolicLink'\n  : 'Unsupported'\n\nmodule.exports = WriteEntry\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tar/lib/write-entry.js?");

/***/ }),

/***/ "./node_modules/traverse/index.js":
/*!****************************************!*\
  !*** ./node_modules/traverse/index.js ***!
  \****************************************/
/***/ ((module) => {

eval("module.exports = Traverse;\nfunction Traverse (obj) {\n    if (!(this instanceof Traverse)) return new Traverse(obj);\n    this.value = obj;\n}\n\nTraverse.prototype.get = function (ps) {\n    var node = this.value;\n    for (var i = 0; i < ps.length; i ++) {\n        var key = ps[i];\n        if (!Object.hasOwnProperty.call(node, key)) {\n            node = undefined;\n            break;\n        }\n        node = node[key];\n    }\n    return node;\n};\n\nTraverse.prototype.set = function (ps, value) {\n    var node = this.value;\n    for (var i = 0; i < ps.length - 1; i ++) {\n        var key = ps[i];\n        if (!Object.hasOwnProperty.call(node, key)) node[key] = {};\n        node = node[key];\n    }\n    node[ps[i]] = value;\n    return value;\n};\n\nTraverse.prototype.map = function (cb) {\n    return walk(this.value, cb, true);\n};\n\nTraverse.prototype.forEach = function (cb) {\n    this.value = walk(this.value, cb, false);\n    return this.value;\n};\n\nTraverse.prototype.reduce = function (cb, init) {\n    var skip = arguments.length === 1;\n    var acc = skip ? this.value : init;\n    this.forEach(function (x) {\n        if (!this.isRoot || !skip) {\n            acc = cb.call(this, acc, x);\n        }\n    });\n    return acc;\n};\n\nTraverse.prototype.deepEqual = function (obj) {\n    if (arguments.length !== 1) {\n        throw new Error(\n            'deepEqual requires exactly one object to compare against'\n        );\n    }\n    \n    var equal = true;\n    var node = obj;\n    \n    this.forEach(function (y) {\n        var notEqual = (function () {\n            equal = false;\n            //this.stop();\n            return undefined;\n        }).bind(this);\n        \n        //if (node === undefined || node === null) return notEqual();\n        \n        if (!this.isRoot) {\n        /*\n            if (!Object.hasOwnProperty.call(node, this.key)) {\n                return notEqual();\n            }\n        */\n            if (typeof node !== 'object') return notEqual();\n            node = node[this.key];\n        }\n        \n        var x = node;\n        \n        this.post(function () {\n            node = x;\n        });\n        \n        var toS = function (o) {\n            return Object.prototype.toString.call(o);\n        };\n        \n        if (this.circular) {\n            if (Traverse(obj).get(this.circular.path) !== x) notEqual();\n        }\n        else if (typeof x !== typeof y) {\n            notEqual();\n        }\n        else if (x === null || y === null || x === undefined || y === undefined) {\n            if (x !== y) notEqual();\n        }\n        else if (x.__proto__ !== y.__proto__) {\n            notEqual();\n        }\n        else if (x === y) {\n            // nop\n        }\n        else if (typeof x === 'function') {\n            if (x instanceof RegExp) {\n                // both regexps on account of the __proto__ check\n                if (x.toString() != y.toString()) notEqual();\n            }\n            else if (x !== y) notEqual();\n        }\n        else if (typeof x === 'object') {\n            if (toS(y) === '[object Arguments]'\n            || toS(x) === '[object Arguments]') {\n                if (toS(x) !== toS(y)) {\n                    notEqual();\n                }\n            }\n            else if (x instanceof Date || y instanceof Date) {\n                if (!(x instanceof Date) || !(y instanceof Date)\n                || x.getTime() !== y.getTime()) {\n                    notEqual();\n                }\n            }\n            else {\n                var kx = Object.keys(x);\n                var ky = Object.keys(y);\n                if (kx.length !== ky.length) return notEqual();\n                for (var i = 0; i < kx.length; i++) {\n                    var k = kx[i];\n                    if (!Object.hasOwnProperty.call(y, k)) {\n                        notEqual();\n                    }\n                }\n            }\n        }\n    });\n    \n    return equal;\n};\n\nTraverse.prototype.paths = function () {\n    var acc = [];\n    this.forEach(function (x) {\n        acc.push(this.path); \n    });\n    return acc;\n};\n\nTraverse.prototype.nodes = function () {\n    var acc = [];\n    this.forEach(function (x) {\n        acc.push(this.node);\n    });\n    return acc;\n};\n\nTraverse.prototype.clone = function () {\n    var parents = [], nodes = [];\n    \n    return (function clone (src) {\n        for (var i = 0; i < parents.length; i++) {\n            if (parents[i] === src) {\n                return nodes[i];\n            }\n        }\n        \n        if (typeof src === 'object' && src !== null) {\n            var dst = copy(src);\n            \n            parents.push(src);\n            nodes.push(dst);\n            \n            Object.keys(src).forEach(function (key) {\n                dst[key] = clone(src[key]);\n            });\n            \n            parents.pop();\n            nodes.pop();\n            return dst;\n        }\n        else {\n            return src;\n        }\n    })(this.value);\n};\n\nfunction walk (root, cb, immutable) {\n    var path = [];\n    var parents = [];\n    var alive = true;\n    \n    return (function walker (node_) {\n        var node = immutable ? copy(node_) : node_;\n        var modifiers = {};\n        \n        var state = {\n            node : node,\n            node_ : node_,\n            path : [].concat(path),\n            parent : parents.slice(-1)[0],\n            key : path.slice(-1)[0],\n            isRoot : path.length === 0,\n            level : path.length,\n            circular : null,\n            update : function (x) {\n                if (!state.isRoot) {\n                    state.parent.node[state.key] = x;\n                }\n                state.node = x;\n            },\n            'delete' : function () {\n                delete state.parent.node[state.key];\n            },\n            remove : function () {\n                if (Array.isArray(state.parent.node)) {\n                    state.parent.node.splice(state.key, 1);\n                }\n                else {\n                    delete state.parent.node[state.key];\n                }\n            },\n            before : function (f) { modifiers.before = f },\n            after : function (f) { modifiers.after = f },\n            pre : function (f) { modifiers.pre = f },\n            post : function (f) { modifiers.post = f },\n            stop : function () { alive = false }\n        };\n        \n        if (!alive) return state;\n        \n        if (typeof node === 'object' && node !== null) {\n            state.isLeaf = Object.keys(node).length == 0;\n            \n            for (var i = 0; i < parents.length; i++) {\n                if (parents[i].node_ === node_) {\n                    state.circular = parents[i];\n                    break;\n                }\n            }\n        }\n        else {\n            state.isLeaf = true;\n        }\n        \n        state.notLeaf = !state.isLeaf;\n        state.notRoot = !state.isRoot;\n        \n        // use return values to update if defined\n        var ret = cb.call(state, state.node);\n        if (ret !== undefined && state.update) state.update(ret);\n        if (modifiers.before) modifiers.before.call(state, state.node);\n        \n        if (typeof state.node == 'object'\n        && state.node !== null && !state.circular) {\n            parents.push(state);\n            \n            var keys = Object.keys(state.node);\n            keys.forEach(function (key, i) {\n                path.push(key);\n                \n                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);\n                \n                var child = walker(state.node[key]);\n                if (immutable && Object.hasOwnProperty.call(state.node, key)) {\n                    state.node[key] = child.node;\n                }\n                \n                child.isLast = i == keys.length - 1;\n                child.isFirst = i == 0;\n                \n                if (modifiers.post) modifiers.post.call(state, child);\n                \n                path.pop();\n            });\n            parents.pop();\n        }\n        \n        if (modifiers.after) modifiers.after.call(state, state.node);\n        \n        return state;\n    })(root).node;\n}\n\nObject.keys(Traverse.prototype).forEach(function (key) {\n    Traverse[key] = function (obj) {\n        var args = [].slice.call(arguments, 1);\n        var t = Traverse(obj);\n        return t[key].apply(t, args);\n    };\n});\n\nfunction copy (src) {\n    if (typeof src === 'object' && src !== null) {\n        var dst;\n        \n        if (Array.isArray(src)) {\n            dst = [];\n        }\n        else if (src instanceof Date) {\n            dst = new Date(src);\n        }\n        else if (src instanceof Boolean) {\n            dst = new Boolean(src);\n        }\n        else if (src instanceof Number) {\n            dst = new Number(src);\n        }\n        else if (src instanceof String) {\n            dst = new String(src);\n        }\n        else {\n            dst = Object.create(Object.getPrototypeOf(src));\n        }\n        \n        Object.keys(src).forEach(function (key) {\n            dst[key] = src[key];\n        });\n        return dst;\n    }\n    else return src;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/traverse/index.js?");

/***/ }),

/***/ "./src/attach.ts":
/*!***********************!*\
  !*** ./src/attach.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst neovim_1 = __webpack_require__(/*! @chemzqm/neovim */ \"./node_modules/@chemzqm/neovim/lib/index.js\");\nconst log4js_1 = tslib_1.__importDefault(__webpack_require__(/*! log4js */ \"./node_modules/log4js/lib/log4js.js\"));\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ./events */ \"./src/events.ts\"));\nconst plugin_1 = tslib_1.__importDefault(__webpack_require__(/*! ./plugin */ \"./src/plugin.ts\"));\nconst semver_1 = tslib_1.__importDefault(__webpack_require__(/*! semver */ \"./node_modules/semver/index.js\"));\nconst is_1 = __webpack_require__(/*! ./util/is */ \"./src/util/is.ts\");\n__webpack_require__(/*! ./util/extensions */ \"./src/util/extensions.ts\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst logger = __webpack_require__(/*! ./util/logger */ \"./src/util/logger.ts\")('attach');\nconst isTest = global.hasOwnProperty('__TEST__');\nexports.default = (opts, requestApi = true) => {\n    const nvim = neovim_1.attach(opts, log4js_1.default.getLogger('node-client'), requestApi);\n    if (!global.hasOwnProperty('__TEST__')) {\n        nvim.call('coc#util#path_replace_patterns').then(prefixes => {\n            if (is_1.objectLiteral(prefixes)) {\n                const old_uri = vscode_uri_1.URI.file;\n                vscode_uri_1.URI.file = (path) => {\n                    path = path.replace(/\\\\/g, '/');\n                    Object.keys(prefixes).forEach(k => path = path.replace(new RegExp('^' + k), prefixes[k]));\n                    return old_uri(path);\n                };\n            }\n        }).logError();\n    }\n    nvim.setVar('coc_process_pid', process.pid, true);\n    const plugin = new plugin_1.default(nvim);\n    let clientReady = false;\n    let initialized = false;\n    nvim.on('notification', async (method, args) => {\n        switch (method) {\n            case 'VimEnter': {\n                if (!initialized && clientReady) {\n                    initialized = true;\n                    await plugin.init();\n                }\n                break;\n            }\n            case 'TaskExit':\n            case 'TaskStderr':\n            case 'TaskStdout':\n            case 'GlobalChange':\n            case 'PromptInsert':\n            case 'InputChar':\n            case 'MenuInput':\n            case 'OptionSet':\n            case 'FloatBtnClick':\n                await events_1.default.fire(method, args);\n                break;\n            case 'CocAutocmd':\n                logger.debug('Notification autocmd:', ...args);\n                await events_1.default.fire(args[0], args.slice(1));\n                break;\n            default: {\n                let exists = plugin.hasAction(method);\n                if (!exists) {\n                    if (global.hasOwnProperty('__TEST__'))\n                        return;\n                    console.error(`action \"${method}\" not registered`);\n                    return;\n                }\n                try {\n                    if (!plugin.isReady) {\n                        logger.warn(`Plugin not ready when received \"${method}\"`, args);\n                    }\n                    else {\n                        logger.info('receive notification:', method, args);\n                    }\n                    await plugin.ready;\n                    await plugin.cocAction(method, ...args);\n                }\n                catch (e) {\n                    console.error(`Error on notification \"${method}\": ${e.message || e.toString()}`);\n                    logger.error(`Notification error:`, method, args, e);\n                }\n            }\n        }\n    });\n    nvim.on('request', async (method, args, resp) => {\n        if (method != 'redraw') {\n            logger.info('receive request:', method, args);\n        }\n        let timer = setTimeout(() => {\n            logger.error('Request cost more than 3s', method, args);\n        }, 3000);\n        try {\n            if (method == 'CocAutocmd') {\n                logger.debug('Request autocmd:', ...args);\n                await events_1.default.fire(args[0], args.slice(1));\n                resp.send();\n            }\n            else {\n                if (!plugin.isReady) {\n                    logger.warn(`Plugin not ready when received \"${method}\"`, args);\n                }\n                let res = await plugin.cocAction(method, ...args);\n                resp.send(res);\n            }\n            clearTimeout(timer);\n        }\n        catch (e) {\n            clearTimeout(timer);\n            resp.send(e.message || e.toString(), true);\n            logger.error(`Request error:`, method, args, e);\n        }\n    });\n    nvim.channelId.then(async (channelId) => {\n        clientReady = true;\n        // Used for test client on vim side\n        if (isTest)\n            nvim.command(`let g:coc_node_channel_id = ${channelId}`, true);\n        let json = __webpack_require__(/*! ../package.json */ \"./package.json\");\n        let { major, minor, patch } = semver_1.default.parse(json.version);\n        nvim.setClientInfo('coc', { major, minor, patch }, 'remote', {}, {});\n        let entered = await nvim.getVvar('vim_did_enter');\n        if (entered && !initialized) {\n            initialized = true;\n            await plugin.init();\n        }\n    }).catch(e => {\n        console.error(`Channel create error: ${e.message}`);\n    });\n    return plugin;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./src/attach.ts?");

/***/ }),

/***/ "./src/channels.ts":
/*!*************************!*\
  !*** ./src/channels.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Channels = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst outputChannel_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/outputChannel */ \"./src/model/outputChannel.ts\"));\nconst outputChannels = new Map();\nclass Channels {\n    /**\n     * Get text document provider\n     */\n    getProvider(nvim) {\n        let provider = {\n            onDidChange: null,\n            provideTextDocumentContent: async (uri) => {\n                let channel = this.get(uri.path.slice(1));\n                if (!channel)\n                    return '';\n                nvim.pauseNotification();\n                nvim.command('setlocal nospell nofoldenable nowrap noswapfile', true);\n                nvim.command('setlocal buftype=nofile bufhidden=hide', true);\n                nvim.command('setfiletype log', true);\n                await nvim.resumeNotification();\n                return channel.content;\n            }\n        };\n        return provider;\n    }\n    get names() {\n        return Array.from(outputChannels.keys());\n    }\n    get(channelName) {\n        return outputChannels.get(channelName);\n    }\n    create(name, nvim) {\n        if (outputChannels.has(name))\n            return outputChannels.get(name);\n        if (!/^[\\w\\s-.]+$/.test(name))\n            throw new Error(`Invalid channel name \"${name}\", only word characters and white space allowed.`);\n        let channel = new outputChannel_1.default(name, nvim);\n        outputChannels.set(name, channel);\n        return channel;\n    }\n    show(name, preserveFocus) {\n        let channel = outputChannels.get(name);\n        if (!channel)\n            return;\n        channel.show(preserveFocus);\n    }\n    dispose() {\n        for (let channel of outputChannels.values()) {\n            channel.dispose();\n        }\n        outputChannels.clear();\n    }\n}\nexports.Channels = Channels;\nexports.default = new Channels();\n\n\n//# sourceURL=webpack://coc.nvim/./src/channels.ts?");

/***/ }),

/***/ "./src/commands.ts":
/*!*************************!*\
  !*** ./src/commands.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CommandManager = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./diagnostic/manager */ \"./src/diagnostic/manager.ts\"));\nconst manager_2 = tslib_1.__importDefault(__webpack_require__(/*! ./snippets/manager */ \"./src/snippets/manager.ts\"));\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/util/index.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ./workspace */ \"./src/workspace.ts\"));\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ./window */ \"./src/window.ts\"));\nconst logger = __webpack_require__(/*! ./util/logger */ \"./src/util/logger.ts\")('commands');\nclass CommandItem {\n    constructor(id, impl, thisArg, internal = false) {\n        this.id = id;\n        this.impl = impl;\n        this.thisArg = thisArg;\n        this.internal = internal;\n    }\n    execute(...args) {\n        let { impl, thisArg } = this;\n        return impl.apply(thisArg, args || []);\n    }\n    dispose() {\n        this.thisArg = null;\n        this.impl = null;\n    }\n}\nclass CommandManager {\n    constructor() {\n        this.commands = new Map();\n        this.titles = new Map();\n    }\n    init(nvim, plugin) {\n        this.mru = workspace_1.default.createMru('commands');\n        this.register({\n            id: 'vscode.open',\n            execute: async (url) => {\n                nvim.call('coc#util#open_url', url.toString(), true);\n            }\n        }, true);\n        this.register({\n            id: 'workbench.action.reloadWindow',\n            execute: async () => {\n                await nvim.command('edit');\n            }\n        }, true);\n        this.register({\n            id: 'editor.action.insertSnippet',\n            execute: async (edit) => {\n                nvim.call('coc#_cancel', [], true);\n                return await manager_2.default.insertSnippet(edit.newText, true, edit.range);\n            }\n        }, true);\n        this.register({\n            id: 'editor.action.doCodeAction',\n            execute: async (action) => {\n                await plugin.cocAction('doCodeAction', action);\n            }\n        }, true);\n        this.register({\n            id: 'editor.action.triggerSuggest',\n            execute: async () => {\n                await util_1.wait(60);\n                nvim.call('coc#start', [], true);\n            }\n        }, true);\n        this.register({\n            id: 'editor.action.triggerParameterHints',\n            execute: async () => {\n                await util_1.wait(60);\n                await plugin.cocAction('showSignatureHelp');\n            }\n        }, true);\n        this.register({\n            id: 'editor.action.addRanges',\n            execute: async (ranges) => {\n                await plugin.cocAction('addRanges', ranges);\n            }\n        }, true);\n        this.register({\n            id: 'editor.action.restart',\n            execute: async () => {\n                await util_1.wait(30);\n                nvim.command('CocRestart', true);\n            }\n        }, true);\n        this.register({\n            id: 'editor.action.showReferences',\n            execute: async (_filepath, _position, references) => {\n                await workspace_1.default.showLocations(references);\n            }\n        }, true);\n        this.register({\n            id: 'editor.action.rename',\n            execute: async (uri, position) => {\n                await workspace_1.default.jumpTo(uri, position);\n                await plugin.cocAction('rename');\n            }\n        }, true);\n        this.register({\n            id: 'editor.action.format',\n            execute: async () => {\n                await plugin.cocAction('format');\n            }\n        }, true);\n        this.register({\n            id: 'workspace.diffDocument',\n            execute: async () => {\n                let document = await workspace_1.default.document;\n                if (!document)\n                    return;\n                await nvim.call('coc#util#diff_content', [document.getLines()]);\n            }\n        });\n        this.register({\n            id: 'workspace.clearWatchman',\n            execute: async () => {\n                let res = await window_1.default.runTerminalCommand('watchman watch-del-all');\n                if (res.success)\n                    window_1.default.showMessage('Cleared watchman watching directories.');\n            }\n        }, false, 'run watch-del-all for watchman to free up memory.');\n        this.register({\n            id: 'workspace.workspaceFolders',\n            execute: async () => {\n                let folders = workspace_1.default.workspaceFolders;\n                let lines = folders.map(folder => vscode_uri_1.URI.parse(folder.uri).fsPath);\n                await window_1.default.echoLines(lines);\n            }\n        }, false, 'show opened workspaceFolders.');\n        this.register({\n            id: 'workspace.renameCurrentFile',\n            execute: async () => {\n                await workspace_1.default.renameCurrent();\n            }\n        }, false, 'change current filename to a new name and reload it.');\n        this.register({\n            id: 'extensions.toggleAutoUpdate',\n            execute: async () => {\n                let config = workspace_1.default.getConfiguration('coc.preferences');\n                let interval = config.get('extensionUpdateCheck', 'daily');\n                if (interval == 'never') {\n                    config.update('extensionUpdateCheck', 'daily', true);\n                    window_1.default.showMessage('Extension auto update enabled.', 'more');\n                }\n                else {\n                    config.update('extensionUpdateCheck', 'never', true);\n                    window_1.default.showMessage('Extension auto update disabled.', 'more');\n                }\n            }\n        }, false, 'toggle auto update of extensions.');\n        this.register({\n            id: 'workspace.diagnosticRelated',\n            execute: () => manager_1.default.jumpRelated()\n        }, false, 'jump to related locations of current diagnostic.');\n        this.register({\n            id: 'workspace.showOutput',\n            execute: async (name) => {\n                if (name) {\n                    window_1.default.showOutputChannel(name);\n                }\n                else {\n                    let names = workspace_1.default.channelNames;\n                    if (names.length == 0)\n                        return;\n                    if (names.length == 1) {\n                        window_1.default.showOutputChannel(names[0]);\n                    }\n                    else {\n                        let idx = await window_1.default.showQuickpick(names);\n                        if (idx == -1)\n                            return;\n                        let name = names[idx];\n                        window_1.default.showOutputChannel(name);\n                    }\n                }\n            }\n        }, false, 'open output buffer to show output from languageservers or extensions.');\n        this.register({\n            id: 'document.echoFiletype',\n            execute: async () => {\n                let bufnr = await nvim.call('bufnr', '%');\n                let doc = workspace_1.default.getDocument(bufnr);\n                if (!doc)\n                    return;\n                await window_1.default.echoLines([doc.filetype]);\n            }\n        }, false, 'echo the mapped filetype of the current buffer');\n        this.register({\n            id: 'document.renameCurrentWord',\n            execute: async () => {\n                let bufnr = await nvim.call('bufnr', '%');\n                let doc = workspace_1.default.getDocument(bufnr);\n                if (!doc)\n                    return;\n                let edit = await plugin.cocAction('getWordEdit');\n                if (!edit) {\n                    window_1.default.showMessage('Invalid position', 'warning');\n                    return;\n                }\n                let ranges = [];\n                let { changes, documentChanges } = edit;\n                if (changes) {\n                    let edits = changes[doc.uri];\n                    if (edits)\n                        ranges = edits.map(e => e.range);\n                }\n                else if (documentChanges) {\n                    for (let c of documentChanges) {\n                        if (vscode_languageserver_protocol_1.TextDocumentEdit.is(c) && c.textDocument.uri == doc.uri) {\n                            ranges = c.edits.map(e => e.range);\n                        }\n                    }\n                }\n                if (ranges.length) {\n                    await plugin.cocAction('addRanges', ranges);\n                }\n            }\n        }, false, 'rename word under cursor in current buffer by use multiple cursors.');\n        this.register({\n            id: 'document.jumpToNextSymbol',\n            execute: async () => {\n                let doc = await workspace_1.default.document;\n                if (!doc)\n                    return;\n                let ranges = await plugin.cocAction('symbolRanges');\n                if (!ranges)\n                    return;\n                let { textDocument } = doc;\n                let offset = await window_1.default.getOffset();\n                ranges.sort((a, b) => {\n                    if (a.start.line != b.start.line) {\n                        return a.start.line - b.start.line;\n                    }\n                    return a.start.character - b.start.character;\n                });\n                for (let i = 0; i <= ranges.length - 1; i++) {\n                    if (textDocument.offsetAt(ranges[i].start) > offset) {\n                        await window_1.default.moveTo(ranges[i].start);\n                        return;\n                    }\n                }\n                await window_1.default.moveTo(ranges[0].start);\n            }\n        }, false, 'Jump to next symbol highlight position.');\n        this.register({\n            id: 'document.jumpToPrevSymbol',\n            execute: async () => {\n                let doc = await workspace_1.default.document;\n                if (!doc)\n                    return;\n                let ranges = await plugin.cocAction('symbolRanges');\n                if (!ranges)\n                    return;\n                let { textDocument } = doc;\n                let offset = await window_1.default.getOffset();\n                ranges.sort((a, b) => {\n                    if (a.start.line != b.start.line) {\n                        return a.start.line - b.start.line;\n                    }\n                    return a.start.character - b.start.character;\n                });\n                for (let i = ranges.length - 1; i >= 0; i--) {\n                    if (textDocument.offsetAt(ranges[i].end) < offset) {\n                        await window_1.default.moveTo(ranges[i].start);\n                        return;\n                    }\n                }\n                await window_1.default.moveTo(ranges[ranges.length - 1].start);\n            }\n        }, false, 'Jump to previous symbol highlight position.');\n    }\n    get commandList() {\n        let res = [];\n        for (let item of this.commands.values()) {\n            if (!item.internal)\n                res.push(item);\n        }\n        return res;\n    }\n    dispose() {\n        for (const registration of this.commands.values()) {\n            registration.dispose();\n        }\n        this.commands.clear();\n    }\n    execute(command) {\n        let args = [command.command];\n        let arr = command.arguments;\n        if (arr)\n            args.push(...arr);\n        this.executeCommand.apply(this, args);\n    }\n    register(command, internal = false, description) {\n        for (const id of Array.isArray(command.id) ? command.id : [command.id]) {\n            this.registerCommand(id, command.execute, command, internal);\n            if (description)\n                this.titles.set(id, description);\n        }\n        return command;\n    }\n    has(id) {\n        return this.commands.has(id);\n    }\n    unregister(id) {\n        let item = this.commands.get(id);\n        if (!item)\n            return;\n        item.dispose();\n        this.commands.delete(id);\n    }\n    /**\n     * Registers a command that can be invoked via a keyboard shortcut,\n     * a menu item, an action, or directly.\n     *\n     * Registering a command with an existing command identifier twice\n     * will cause an error.\n     *\n     * @param command A unique identifier for the command.\n     * @param impl A command handler function.\n     * @param thisArg The `this` context used when invoking the handler function.\n     * @return Disposable which unregisters this command on disposal.\n     */\n    registerCommand(id, impl, thisArg, internal = false) {\n        if (id.startsWith(\"_\"))\n            internal = true;\n        this.commands.set(id, new CommandItem(id, impl, thisArg, internal));\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.commands.delete(id);\n        });\n    }\n    /**\n     * Executes the command denoted by the given command identifier.\n     *\n     * * *Note 1:* When executing an editor command not all types are allowed to\n     * be passed as arguments. Allowed are the primitive types `string`, `boolean`,\n     * `number`, `undefined`, and `null`, as well as [`Position`](#Position), [`Range`](#Range), [`URI`](#URI) and [`Location`](#Location).\n     * * *Note 2:* There are no restrictions when executing commands that have been contributed\n     * by extensions.\n     *\n     * @param command Identifier of the command to execute.\n     * @param rest Parameters passed to the command function.\n     * @return A promise that resolves to the returned value of the given command. `undefined` when\n     * the command handler function doesn't return anything.\n     */\n    executeCommand(command, ...rest) {\n        let cmd = this.commands.get(command);\n        if (!cmd) {\n            window_1.default.showMessage(`Command: ${command} not found`, 'error');\n            return;\n        }\n        return Promise.resolve(cmd.execute.apply(cmd, rest)).catch(e => {\n            window_1.default.showMessage(`Command error: ${e.message}`, 'error');\n            logger.error(e.stack);\n        });\n    }\n    async addRecent(cmd) {\n        await this.mru.add(cmd);\n        await workspace_1.default.nvim.command(`silent! call repeat#set(\"\\\\<Plug>(coc-command-repeat)\", -1)`);\n    }\n    async repeatCommand() {\n        let mruList = await this.mru.load();\n        let first = mruList[0];\n        if (first) {\n            await this.executeCommand(first);\n            await workspace_1.default.nvim.command(`silent! call repeat#set(\"\\\\<Plug>(coc-command-repeat)\", -1)`);\n        }\n    }\n}\nexports.CommandManager = CommandManager;\nexports.default = new CommandManager();\n\n\n//# sourceURL=webpack://coc.nvim/./src/commands.ts?");

/***/ }),

/***/ "./src/completion/complete.ts":
/*!************************************!*\
  !*** ./src/completion/complete.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst fuzzy_1 = __webpack_require__(/*! ../util/fuzzy */ \"./src/util/fuzzy.ts\");\nconst string_1 = __webpack_require__(/*! ../util/string */ \"./src/util/string.ts\");\nconst match_1 = __webpack_require__(/*! ./match */ \"./src/completion/match.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('completion-complete');\n// first time completion\nconst FIRST_TIMEOUT = 500;\nclass Complete {\n    constructor(option, document, recentScores, config, sources, nvim) {\n        this.option = option;\n        this.document = document;\n        this.config = config;\n        this.sources = sources;\n        this.nvim = nvim;\n        // identify this complete\n        this.results = [];\n        this.completing = new Set();\n        this._canceled = false;\n        this.tokenSources = new Map();\n        this._onDidComplete = new vscode_languageserver_protocol_1.Emitter();\n        this.onDidComplete = this._onDidComplete.event;\n        Object.defineProperty(this, 'recentScores', {\n            get: () => recentScores || {}\n        });\n    }\n    get isCompleting() {\n        return this.completing.size > 0;\n    }\n    get isCanceled() {\n        return this._canceled;\n    }\n    get isEmpty() {\n        return this.results.length == 0;\n    }\n    get startcol() {\n        return this.option.col || 0;\n    }\n    get input() {\n        return this.option.input;\n    }\n    get isIncomplete() {\n        return this.results.findIndex(o => o.isIncomplete) !== -1;\n    }\n    async completeSource(source) {\n        let { col } = this.option;\n        // new option for each source\n        let opt = Object.assign({}, this.option);\n        let timeout = this.config.timeout;\n        timeout = Math.max(Math.min(timeout, 15000), 500);\n        try {\n            if (typeof source.shouldComplete === 'function') {\n                let shouldRun = await Promise.resolve(source.shouldComplete(opt));\n                if (!shouldRun)\n                    return null;\n            }\n            let start = Date.now();\n            let oldSource = this.tokenSources.get(source.name);\n            if (oldSource)\n                oldSource.cancel();\n            let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n            this.tokenSources.set(source.name, tokenSource);\n            await new Promise((resolve, reject) => {\n                let { name } = source;\n                let timer = setTimeout(() => {\n                    this.nvim.command(`echohl WarningMsg| echom 'source ${source.name} timeout after ${timeout}ms'|echohl None`, true);\n                    tokenSource.cancel();\n                }, timeout);\n                let cancelled = false;\n                let called = false;\n                let empty = false;\n                let ft = setTimeout(() => {\n                    if (called)\n                        return;\n                    empty = true;\n                    resolve(undefined);\n                }, FIRST_TIMEOUT);\n                let onFinished = () => {\n                    if (called)\n                        return;\n                    called = true;\n                    disposable.dispose();\n                    clearTimeout(ft);\n                    clearTimeout(timer);\n                    this.tokenSources.delete(name);\n                };\n                let disposable = tokenSource.token.onCancellationRequested(() => {\n                    disposable.dispose();\n                    this.completing.delete(name);\n                    cancelled = true;\n                    onFinished();\n                    logger.debug(`Source \"${name}\" cancelled`);\n                    resolve(undefined);\n                });\n                this.completing.add(name);\n                Promise.resolve(source.doComplete(opt, tokenSource.token)).then(result => {\n                    this.completing.delete(name);\n                    if (cancelled)\n                        return;\n                    onFinished();\n                    let dt = Date.now() - start;\n                    logger.debug(`Source \"${name}\" takes ${dt}ms`);\n                    if (result && result.items && result.items.length) {\n                        result.priority = source.priority;\n                        result.source = name;\n                        // lazy completed items\n                        if (empty && result.startcol && result.startcol != col) {\n                            this.results = [result];\n                        }\n                        else {\n                            let { results } = this;\n                            let idx = results.findIndex(o => o.source == name);\n                            if (idx != -1) {\n                                results.splice(idx, 1, result);\n                            }\n                            else {\n                                results.push(result);\n                            }\n                        }\n                        if (empty)\n                            this._onDidComplete.fire();\n                        resolve(undefined);\n                    }\n                    else {\n                        resolve(undefined);\n                    }\n                }, err => {\n                    this.completing.delete(name);\n                    onFinished();\n                    reject(err);\n                });\n            });\n        }\n        catch (err) {\n            this.nvim.command(`echoerr 'Complete ${source.name} error: ${err.message.replace(/'/g, \"''\")}'`, true);\n            logger.error('Complete error:', source.name, err);\n        }\n    }\n    async completeInComplete(resumeInput) {\n        let { results, document } = this;\n        let remains = results.filter(res => !res.isIncomplete);\n        remains.forEach(res => {\n            res.items.forEach(item => delete item.user_data);\n        });\n        let arr = results.filter(res => res.isIncomplete);\n        let names = arr.map(o => o.source);\n        let { input, colnr, linenr } = this.option;\n        Object.assign(this.option, {\n            input: resumeInput,\n            line: document.getline(linenr - 1),\n            colnr: colnr + (resumeInput.length - input.length),\n            triggerCharacter: null,\n            triggerForInComplete: true\n        });\n        let sources = this.sources.filter(s => names.includes(s.name));\n        await Promise.all(sources.map(s => this.completeSource(s)));\n        return this.filterResults(resumeInput, Math.floor(Date.now() / 1000));\n    }\n    filterResults(input, cid = 0) {\n        let { results } = this;\n        results.sort((a, b) => {\n            if (a.source == 'tabnine')\n                return 1;\n            if (b.source == 'tabnine')\n                return -1;\n            return b.priority - a.priority;\n        });\n        let now = Date.now();\n        let { bufnr } = this.option;\n        let { snippetIndicator, removeDuplicateItems, fixInsertedWord, asciiCharactersOnly } = this.config;\n        let followPart = (!fixInsertedWord || cid == 0) ? '' : this.getFollowPart();\n        if (results.length == 0)\n            return [];\n        let arr = [];\n        let codes = fuzzy_1.getCharCodes(input);\n        let words = new Set();\n        for (let i = 0, l = results.length; i < l; i++) {\n            let res = results[i];\n            let { items, source, priority } = res;\n            for (let idx = 0; idx < items.length; idx++) {\n                let item = items[idx];\n                if (!item || typeof item.word !== 'string') {\n                    continue;\n                }\n                let { word } = item;\n                // eslint-disable-next-line no-control-regex\n                if (asciiCharactersOnly && !/^[\\x00-\\x7F]*$/.test(word)) {\n                    continue;\n                }\n                if (!item.dup && words.has(word))\n                    continue;\n                if (removeDuplicateItems && !item.isSnippet && words.has(word) && item.line == undefined)\n                    continue;\n                let filterText = item.filterText || item.word;\n                item.filterText = filterText;\n                if (filterText.length < input.length)\n                    continue;\n                let score = item.kind && filterText == input ? 64 : match_1.matchScore(filterText, codes);\n                if (input.length && score == 0)\n                    continue;\n                if (followPart.length && !item.isSnippet) {\n                    if (item.word.endsWith(followPart)) {\n                        let { word } = item;\n                        item.word = item.word.slice(0, -followPart.length);\n                        item.abbr = item.abbr || word;\n                    }\n                }\n                if (!item.user_data) {\n                    let user_data = { cid, source };\n                    user_data.index = item.index || idx;\n                    if (item.isSnippet) {\n                        let abbr = item.abbr || item.word;\n                        if (!abbr.endsWith(snippetIndicator)) {\n                            item.abbr = `${item.abbr || item.word}${snippetIndicator}`;\n                        }\n                    }\n                    if (item.signature)\n                        user_data.signature = item.signature;\n                    item.user_data = JSON.stringify(user_data);\n                    item.source = source;\n                    let recentScore = this.recentScores[`${bufnr}|${word}`];\n                    if (recentScore && now - recentScore < 60 * 1000) {\n                        item.recentScore = recentScore;\n                    }\n                    else {\n                        item.recentScore = 0;\n                    }\n                }\n                item.priority = priority;\n                item.abbr = item.abbr || item.word;\n                item.score = input.length ? score * (item.sourceScore || 1) : 0;\n                item.localBonus = this.localBonus ? this.localBonus.get(filterText) || 0 : 0;\n                words.add(word);\n                if (item.isSnippet && item.word == input) {\n                    item.preselect = true;\n                }\n                arr.push(item);\n            }\n        }\n        arr.sort((a, b) => {\n            let sa = a.sortText;\n            let sb = b.sortText;\n            let wa = a.filterText;\n            let wb = b.filterText;\n            if (a.score != b.score)\n                return b.score - a.score;\n            if (a.priority != b.priority)\n                return b.priority - a.priority;\n            if (sa && sb && sa != sb)\n                return sa < sb ? -1 : 1;\n            if (a.recentScore != b.recentScore)\n                return b.recentScore - a.recentScore;\n            if (a.localBonus != b.localBonus) {\n                if (a.localBonus && b.localBonus && wa != wb) {\n                    if (wa.startsWith(wb))\n                        return 1;\n                    if (wb.startsWith(wa))\n                        return -1;\n                }\n                return b.localBonus - a.localBonus;\n            }\n            // Default sort method\n            switch (this.config.defaultSortMethod) {\n                case 'alphabetical':\n                    return a.filterText.localeCompare(b.filterText);\n                case 'length':\n                default: // Fallback on length\n                    return a.filterText.length - b.filterText.length;\n            }\n        });\n        return this.limitCompleteItems(arr.slice(0, this.config.maxItemCount));\n    }\n    limitCompleteItems(items) {\n        let { highPrioritySourceLimit, lowPrioritySourceLimit } = this.config;\n        if (!highPrioritySourceLimit && !lowPrioritySourceLimit)\n            return items;\n        let counts = new Map();\n        return items.filter(item => {\n            let { priority, source } = item;\n            let isLow = priority < 90;\n            let curr = counts.get(source) || 0;\n            if ((lowPrioritySourceLimit && isLow && curr == lowPrioritySourceLimit)\n                || (highPrioritySourceLimit && !isLow && curr == highPrioritySourceLimit)) {\n                return false;\n            }\n            counts.set(source, curr + 1);\n            return true;\n        });\n    }\n    hasMatch(input) {\n        let { results } = this;\n        if (!results)\n            return false;\n        let codes = fuzzy_1.getCharCodes(input);\n        for (let i = 0, l = results.length; i < l; i++) {\n            let items = results[i].items;\n            let idx = items.findIndex(item => fuzzy_1.fuzzyMatch(codes, item.filterText || item.word));\n            if (idx !== -1)\n                return true;\n        }\n        return false;\n    }\n    async doComplete() {\n        let opts = this.option;\n        let { line, colnr, linenr, col } = this.option;\n        if (this.config.localityBonus) {\n            let line = linenr - 1;\n            this.localBonus = this.document.getLocalifyBonus(vscode_languageserver_protocol_1.Position.create(line, opts.col - 1), vscode_languageserver_protocol_1.Position.create(line, colnr));\n        }\n        else {\n            this.localBonus = new Map();\n        }\n        await Promise.all(this.sources.map(s => this.completeSource(s)));\n        let { results } = this;\n        if (results.length == 0)\n            return [];\n        let engrossResult = results.find(r => r.startcol != null && r.startcol != col);\n        if (engrossResult) {\n            let { startcol } = engrossResult;\n            opts.col = startcol;\n            opts.input = string_1.byteSlice(line, startcol, colnr - 1);\n            this.results = [engrossResult];\n        }\n        logger.info(`Results from: ${this.results.map(s => s.source).join(',')}`);\n        return this.filterResults(opts.input, Math.floor(Date.now() / 1000));\n    }\n    resolveCompletionItem(item) {\n        let { results } = this;\n        if (!results)\n            return null;\n        try {\n            if (item.user_data) {\n                let { source } = JSON.parse(item.user_data);\n                let result = results.find(res => res.source == source);\n                return result.items.find(o => o.user_data == item.user_data);\n            }\n            for (let result of results) {\n                let res = result.items.find(o => o.abbr == item.abbr && o.info == item.info);\n                if (res)\n                    return res;\n            }\n            return null;\n        }\n        catch (e) {\n            return null;\n        }\n    }\n    getFollowPart() {\n        let { colnr, line } = this.option;\n        let idx = string_1.characterIndex(line, colnr - 1);\n        if (idx == line.length)\n            return '';\n        let part = line.slice(idx - line.length);\n        return part.match(/^\\S?[\\w-]*/)[0];\n    }\n    dispose() {\n        if (this._canceled)\n            return;\n        this._onDidComplete.dispose();\n        this._canceled = true;\n        for (let tokenSource of this.tokenSources.values()) {\n            tokenSource.cancel();\n        }\n        this.tokenSources.clear();\n        this.sources = [];\n        this.results = [];\n    }\n}\nexports.default = Complete;\n\n\n//# sourceURL=webpack://coc.nvim/./src/completion/complete.ts?");

/***/ }),

/***/ "./src/completion/floating.ts":
/*!************************************!*\
  !*** ./src/completion/floating.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst markdown_1 = __webpack_require__(/*! ../markdown */ \"./src/markdown/index.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('floating');\nclass Floating {\n    constructor(nvim, isVim) {\n        this.nvim = nvim;\n        this.isVim = isVim;\n        this.winid = 0;\n        this.bufnr = 0;\n    }\n    async show(docs, bounding, config, token) {\n        let { nvim } = this;\n        docs = docs.filter(o => o.content.trim().length > 0);\n        let { lines, codes, highlights } = markdown_1.parseDocuments(docs);\n        if (lines.length == 0) {\n            this.close();\n            return;\n        }\n        let res = await nvim.call('coc#float#create_pum_float', [this.winid, this.bufnr, lines, {\n                codes,\n                highlights,\n                maxWidth: config.maxPreviewWidth,\n                pumbounding: bounding,\n            }]);\n        if (this.isVim)\n            nvim.command('redraw', true);\n        if (!res || res.length == 0)\n            return;\n        this.winid = res[0];\n        this.bufnr = res[1];\n        if (token.isCancellationRequested) {\n            this.close();\n            return;\n        }\n    }\n    close() {\n        let { winid, nvim } = this;\n        this.winid = 0;\n        if (!winid)\n            return;\n        nvim.call('coc#float#close', [winid], true);\n        if (this.isVim)\n            nvim.command('redraw', true);\n    }\n}\nexports.default = Floating;\n\n\n//# sourceURL=webpack://coc.nvim/./src/completion/floating.ts?");

/***/ }),

/***/ "./src/completion/index.ts":
/*!*********************************!*\
  !*** ./src/completion/index.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Completion = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nconst sources_1 = tslib_1.__importDefault(__webpack_require__(/*! ../sources */ \"./src/sources.ts\"));\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst complete_1 = tslib_1.__importDefault(__webpack_require__(/*! ./complete */ \"./src/completion/complete.ts\"));\nconst floating_1 = tslib_1.__importDefault(__webpack_require__(/*! ./floating */ \"./src/completion/floating.ts\"));\nconst throttle_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/throttle */ \"./src/util/throttle.ts\"));\nconst object_1 = __webpack_require__(/*! ../util/object */ \"./src/util/object.ts\");\nconst string_1 = __webpack_require__(/*! ../util/string */ \"./src/util/string.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('completion');\nconst completeItemKeys = ['abbr', 'menu', 'info', 'kind', 'icase', 'dup', 'empty', 'user_data'];\nclass Completion {\n    constructor() {\n        // current input string\n        this.activated = false;\n        this.disposables = [];\n        this.complete = null;\n        this.recentScores = {};\n        this.changedTick = 0;\n        this.insertCharTs = 0;\n        this.insertLeaveTs = 0;\n    }\n    init() {\n        this.config = this.getCompleteConfig();\n        this.floating = new floating_1.default(workspace_1.default.nvim, workspace_1.default.env.isVim);\n        events_1.default.on(['InsertCharPre', 'MenuPopupChanged', 'TextChangedI', 'CursorMovedI', 'InsertLeave'], () => {\n            if (this.triggerTimer) {\n                clearTimeout(this.triggerTimer);\n                this.triggerTimer = null;\n            }\n        }, this, this.disposables);\n        events_1.default.on('InsertCharPre', this.onInsertCharPre, this, this.disposables);\n        events_1.default.on('InsertLeave', this.onInsertLeave, this, this.disposables);\n        events_1.default.on('InsertEnter', this.onInsertEnter, this, this.disposables);\n        events_1.default.on('TextChangedP', this.onTextChangedP, this, this.disposables);\n        events_1.default.on('TextChangedI', this.onTextChangedI, this, this.disposables);\n        let fn = throttle_1.default(this.onPumChange.bind(this), workspace_1.default.isVim ? 200 : 100);\n        events_1.default.on('CompleteDone', async (item) => {\n            this.currItem = null;\n            this.cancelResolve();\n            this.floating.close();\n            await this.onCompleteDone(item);\n        }, this, this.disposables);\n        events_1.default.on('MenuPopupChanged', ev => {\n            if (!this.activated || this.isCommandLine)\n                return;\n            let { completed_item } = ev;\n            let item = completed_item.hasOwnProperty('word') ? completed_item : null;\n            if (object_1.equals(item, this.currItem))\n                return;\n            this.cancelResolve();\n            this.currItem = item;\n            fn(ev);\n        }, this, this.disposables);\n        workspace_1.default.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('suggest')) {\n                this.config = this.getCompleteConfig();\n            }\n        }, null, this.disposables);\n    }\n    get nvim() {\n        return workspace_1.default.nvim;\n    }\n    get option() {\n        if (!this.complete)\n            return null;\n        return this.complete.option;\n    }\n    get isCommandLine() {\n        var _a;\n        return (_a = this.document) === null || _a === void 0 ? void 0 : _a.uri.endsWith('%5BCommand%20Line%5D');\n    }\n    addRecent(word, bufnr) {\n        if (!word)\n            return;\n        this.recentScores[`${bufnr}|${word}`] = Date.now();\n    }\n    get isActivated() {\n        return this.activated;\n    }\n    get document() {\n        if (!this.option)\n            return null;\n        return workspace_1.default.getDocument(this.option.bufnr);\n    }\n    getCompleteConfig() {\n        let suggest = workspace_1.default.getConfiguration('suggest');\n        function getConfig(key, defaultValue) {\n            return suggest.get(key, defaultValue);\n        }\n        let keepCompleteopt = getConfig('keepCompleteopt', false);\n        let autoTrigger = getConfig('autoTrigger', 'always');\n        if (keepCompleteopt && autoTrigger != 'none') {\n            let { completeOpt } = workspace_1.default;\n            if (!completeOpt.includes('noinsert') && !completeOpt.includes('noselect')) {\n                autoTrigger = 'none';\n            }\n        }\n        let floatEnable = workspace_1.default.floatSupported && getConfig('floatEnable', true);\n        let acceptSuggestionOnCommitCharacter = workspace_1.default.env.pumevent && getConfig('acceptSuggestionOnCommitCharacter', false);\n        return {\n            autoTrigger,\n            floatEnable,\n            keepCompleteopt,\n            defaultSortMethod: getConfig('defaultSortMethod', 'length'),\n            removeDuplicateItems: getConfig('removeDuplicateItems', false),\n            disableMenuShortcut: getConfig('disableMenuShortcut', false),\n            acceptSuggestionOnCommitCharacter,\n            disableKind: getConfig('disableKind', false),\n            disableMenu: getConfig('disableMenu', false),\n            previewIsKeyword: getConfig('previewIsKeyword', '@,48-57,_192-255'),\n            enablePreview: getConfig('enablePreview', false),\n            enablePreselect: getConfig('enablePreselect', false),\n            maxPreviewWidth: getConfig('maxPreviewWidth', 80),\n            triggerCompletionWait: getConfig('triggerCompletionWait', 100),\n            labelMaxLength: getConfig('labelMaxLength', 200),\n            triggerAfterInsertEnter: getConfig('triggerAfterInsertEnter', false),\n            noselect: getConfig('noselect', true),\n            numberSelect: getConfig('numberSelect', false),\n            maxItemCount: getConfig('maxCompleteItemCount', 50),\n            timeout: getConfig('timeout', 500),\n            minTriggerInputLength: getConfig('minTriggerInputLength', 1),\n            snippetIndicator: getConfig('snippetIndicator', '~'),\n            fixInsertedWord: getConfig('fixInsertedWord', true),\n            localityBonus: getConfig('localityBonus', true),\n            highPrioritySourceLimit: getConfig('highPrioritySourceLimit', null),\n            lowPrioritySourceLimit: getConfig('lowPrioritySourceLimit', null),\n            asciiCharactersOnly: getConfig('asciiCharactersOnly', false)\n        };\n    }\n    async startCompletion(option) {\n        this.pretext = string_1.byteSlice(option.line, 0, option.colnr - 1);\n        try {\n            await this._doComplete(option);\n        }\n        catch (e) {\n            this.stop(false);\n            logger.error('Complete error:', e.stack);\n        }\n    }\n    async resumeCompletion(force = false) {\n        let { document, complete } = this;\n        if (!document\n            || complete.isCanceled\n            || !complete.results\n            || complete.results.length == 0)\n            return;\n        let search = this.getResumeInput();\n        if (search == this.input && !force)\n            return;\n        if (!search || search.endsWith(' ') || !search.startsWith(complete.input)) {\n            this.stop();\n            return;\n        }\n        this.input = search;\n        let items = [];\n        if (complete.isIncomplete) {\n            await document.patchChange();\n            let { changedtick } = document;\n            items = await complete.completeInComplete(search);\n            if (complete.isCanceled || document.changedtick != changedtick)\n                return;\n        }\n        else {\n            items = complete.filterResults(search);\n        }\n        if (!complete.isCompleting && items.length === 0) {\n            this.stop();\n            return;\n        }\n        await this.showCompletion(complete.option.col, items);\n    }\n    hasSelected() {\n        if (workspace_1.default.env.pumevent)\n            return this.currItem != null;\n        if (!this.config.noselect)\n            return true;\n        return false;\n    }\n    async showCompletion(col, items) {\n        let { nvim, document, option } = this;\n        let { numberSelect, disableKind, labelMaxLength, disableMenuShortcut, disableMenu } = this.config;\n        let preselect = this.config.enablePreselect ? items.findIndex(o => o.preselect) : -1;\n        if (numberSelect && option.input.length && !/^\\d/.test(option.input)) {\n            items = items.map((item, i) => {\n                let idx = i + 1;\n                if (i < 9) {\n                    return Object.assign({}, item, {\n                        abbr: item.abbr ? `${idx} ${item.abbr}` : `${idx} ${item.word}`\n                    });\n                }\n                return item;\n            });\n            nvim.call('coc#_map', [], true);\n        }\n        this.changedTick = document.changedtick;\n        let validKeys = completeItemKeys.slice();\n        if (disableKind)\n            validKeys = validKeys.filter(s => s != 'kind');\n        if (disableMenu)\n            validKeys = validKeys.filter(s => s != 'menu');\n        let vimItems = items.map(item => {\n            let obj = { word: item.word, equal: 1 };\n            for (let key of validKeys) {\n                if (item.hasOwnProperty(key)) {\n                    if (disableMenuShortcut && key == 'menu') {\n                        obj[key] = item[key].replace(/\\[.+\\]$/, '');\n                    }\n                    else if (key == 'abbr' && item[key].length > labelMaxLength) {\n                        obj[key] = item[key].slice(0, labelMaxLength);\n                    }\n                    else {\n                        obj[key] = item[key];\n                    }\n                }\n            }\n            return obj;\n        });\n        nvim.call('coc#_do_complete', [col, vimItems, preselect], true);\n    }\n    async _doComplete(option) {\n        let { source } = option;\n        let { nvim, config } = this;\n        let doc = workspace_1.default.getDocument(option.bufnr);\n        if (!doc || !doc.attached)\n            return;\n        // use fixed filetype\n        option.filetype = doc.filetype;\n        // current input\n        this.input = option.input;\n        let arr = [];\n        if (source == null) {\n            arr = sources_1.default.getCompleteSources(option);\n        }\n        else {\n            let s = sources_1.default.getSource(source);\n            if (s)\n                arr.push(s);\n        }\n        if (!arr.length)\n            return;\n        await doc.patchChange();\n        // document get changed, not complete\n        if (doc.changedtick != option.changedtick)\n            return;\n        let complete = new complete_1.default(option, doc, this.recentScores, config, arr, nvim);\n        this.start(complete);\n        let items = await this.complete.doComplete();\n        if (complete.isCanceled)\n            return;\n        if (items.length == 0 && !complete.isCompleting) {\n            this.stop();\n            return;\n        }\n        complete.onDidComplete(async () => {\n            if (this.currItem != null)\n                return;\n            let search = this.getResumeInput();\n            if (complete.isCanceled || search == null)\n                return;\n            let { input } = this.option;\n            if (search == input) {\n                let items = complete.filterResults(search, Math.floor(Date.now() / 1000));\n                await this.showCompletion(option.col, items);\n            }\n            else {\n                await this.resumeCompletion();\n            }\n        });\n        if (items.length) {\n            let search = this.getResumeInput();\n            if (search == option.input) {\n                await this.showCompletion(option.col, items);\n            }\n            else {\n                await this.resumeCompletion(true);\n            }\n        }\n    }\n    async onTextChangedP(bufnr, info) {\n        let { option, document } = this;\n        let pretext = this.pretext = info.pre;\n        // avoid trigger filter on pumvisible\n        if (!option || option.bufnr != bufnr || info.changedtick == this.changedTick)\n            return;\n        let hasInsert = this.latestInsert != null;\n        this.lastInsert = null;\n        if (info.pre.match(/^\\s*/)[0] !== option.line.match(/^\\s*/)[0]) {\n            // Can't handle indent change\n            logger.warn('Complete stopped by indent change.');\n            this.stop();\n            return;\n        }\n        // not handle when not triggered by character insert\n        if (!hasInsert || !pretext)\n            return;\n        if (sources_1.default.shouldTrigger(pretext, document.filetype)) {\n            await this.triggerCompletion(document, pretext);\n        }\n        else {\n            await this.resumeCompletion();\n        }\n    }\n    async onTextChangedI(bufnr, info) {\n        let { nvim, latestInsertChar, option } = this;\n        let noChange = this.pretext == info.pre;\n        let pretext = this.pretext = info.pre;\n        this.lastInsert = null;\n        let doc = workspace_1.default.getDocument(bufnr);\n        if (!doc)\n            return;\n        // try trigger on character type\n        if (!this.activated) {\n            if (!latestInsertChar)\n                return;\n            let triggerSources = sources_1.default.getTriggerSources(pretext, doc.filetype);\n            if (triggerSources.length) {\n                await this.triggerCompletion(doc, this.pretext);\n                return;\n            }\n            this.triggerTimer = setTimeout(async () => {\n                await this.triggerCompletion(doc, pretext);\n            }, this.config.triggerCompletionWait);\n            return;\n        }\n        // Ignore change with other buffer\n        if (!option || bufnr != option.bufnr)\n            return;\n        if (option.linenr != info.lnum || option.col >= info.col - 1) {\n            this.stop();\n            return;\n        }\n        // Completion is canceled by <C-e>\n        if (noChange && !latestInsertChar) {\n            this.stop(false);\n            return;\n        }\n        // Check commit character\n        if (pretext\n            && this.currItem\n            && this.config.acceptSuggestionOnCommitCharacter\n            && latestInsertChar) {\n            let resolvedItem = this.getCompleteItem(this.currItem);\n            let last = pretext[pretext.length - 1];\n            if (sources_1.default.shouldCommit(resolvedItem, last)) {\n                let { linenr, col, line, colnr } = this.option;\n                this.stop();\n                let { word } = resolvedItem;\n                let newLine = `${line.slice(0, col)}${word}${latestInsertChar}${line.slice(colnr - 1)}`;\n                await nvim.call('coc#util#setline', [linenr, newLine]);\n                let curcol = col + word.length + 2;\n                await nvim.call('cursor', [linenr, curcol]);\n                await doc.patchChange();\n                return;\n            }\n        }\n        // prefer trigger completion\n        if (sources_1.default.shouldTrigger(pretext, doc.filetype)) {\n            await this.triggerCompletion(doc, pretext);\n        }\n        else {\n            await this.resumeCompletion();\n        }\n    }\n    async triggerCompletion(doc, pre) {\n        if (!doc || !doc.attached) {\n            logger.warn('Document not attached, suggest disabled.');\n            return;\n        }\n        // check trigger\n        let shouldTrigger = this.shouldTrigger(doc, pre);\n        if (!shouldTrigger)\n            return;\n        if (doc.getVar('suggest_disable')) {\n            logger.warn(`Suggest disabled by b:coc_suggest_disable`);\n            return;\n        }\n        await doc.patchChange();\n        let [disabled, option] = await this.nvim.eval('[get(b:,\"coc_suggest_disable\",0),coc#util#get_complete_option()]');\n        if (disabled == 1) {\n            logger.warn(`Suggest disabled by b:coc_suggest_disable`);\n            return;\n        }\n        if (option.blacklist && option.blacklist.includes(option.input)) {\n            logger.warn(`Suggest disabled by b:coc_suggest_blacklist`, option.blacklist);\n            return;\n        }\n        if (pre.length) {\n            option.triggerCharacter = pre.slice(-1);\n        }\n        logger.debug('trigger completion with', option);\n        await this.startCompletion(option);\n    }\n    async onCompleteDone(item) {\n        let { document, isActivated } = this;\n        if (!isActivated || !document || !item.hasOwnProperty('word'))\n            return;\n        let opt = Object.assign({}, this.option);\n        let resolvedItem = this.getCompleteItem(item);\n        this.stop(false);\n        if (!resolvedItem)\n            return;\n        let timestamp = this.insertCharTs;\n        let insertLeaveTs = this.insertLeaveTs;\n        try {\n            await sources_1.default.doCompleteResolve(resolvedItem, (new vscode_languageserver_protocol_1.CancellationTokenSource()).token);\n            this.addRecent(resolvedItem.word, document.bufnr);\n            // Wait possible TextChangedI\n            await util_1.wait(50);\n            if (this.insertCharTs != timestamp\n                || this.insertLeaveTs != insertLeaveTs)\n                return;\n            let [visible, lnum, pre] = await this.nvim.eval(`[pumvisible(),line('.'),strpart(getline('.'), 0, col('.') - 1)]`);\n            if (visible || lnum != opt.linenr || this.activated || !pre.endsWith(resolvedItem.word))\n                return;\n            await document.patchChange();\n            await sources_1.default.doCompleteDone(resolvedItem, opt);\n        }\n        catch (e) {\n            logger.error(`error on complete done`, e.stack);\n        }\n    }\n    async onInsertLeave() {\n        this.insertLeaveTs = Date.now();\n        this.stop(false);\n    }\n    async onInsertEnter(bufnr) {\n        if (!this.config.triggerAfterInsertEnter || this.config.autoTrigger !== 'always')\n            return;\n        let doc = workspace_1.default.getDocument(bufnr);\n        if (!doc)\n            return;\n        let pre = await this.nvim.eval(`strpart(getline('.'), 0, col('.') - 1)`);\n        if (!pre)\n            return;\n        await this.triggerCompletion(doc, pre);\n    }\n    async onInsertCharPre(character) {\n        this.lastInsert = {\n            character,\n            timestamp: Date.now(),\n        };\n        this.insertCharTs = this.lastInsert.timestamp;\n    }\n    get latestInsert() {\n        let { lastInsert } = this;\n        if (!lastInsert || Date.now() - lastInsert.timestamp > 500) {\n            return null;\n        }\n        return lastInsert;\n    }\n    get latestInsertChar() {\n        let { latestInsert } = this;\n        if (!latestInsert)\n            return '';\n        return latestInsert.character;\n    }\n    shouldTrigger(document, pre) {\n        if (pre.length == 0 || /\\s/.test(pre[pre.length - 1]))\n            return false;\n        let autoTrigger = this.config.autoTrigger;\n        if (autoTrigger == 'none')\n            return false;\n        if (sources_1.default.shouldTrigger(pre, document.filetype))\n            return true;\n        if (autoTrigger !== 'always' || this.isActivated)\n            return false;\n        let last = pre.slice(-1);\n        if (last && (document.isWord(pre.slice(-1)) || last.codePointAt(0) > 255)) {\n            let minLength = this.config.minTriggerInputLength;\n            if (minLength == 1)\n                return true;\n            let input = this.getInput(document, pre);\n            return input.length >= minLength;\n        }\n        return false;\n    }\n    async onPumChange(ev) {\n        if (!this.activated)\n            return;\n        let { completed_item, col, row, height, width, scrollbar } = ev;\n        let bounding = { col, row, height, width, scrollbar };\n        let resolvedItem = this.getCompleteItem(completed_item);\n        if (!resolvedItem) {\n            this.floating.close();\n            return;\n        }\n        let source = this.resolveTokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n        let { token } = source;\n        await sources_1.default.doCompleteResolve(resolvedItem, token);\n        this.resolveTokenSource = null;\n        if (token.isCancellationRequested)\n            return;\n        let docs = resolvedItem.documentation;\n        if (!docs && resolvedItem.info) {\n            let { info } = resolvedItem;\n            let isText = /^[\\w-\\s.,\\t]+$/.test(info);\n            docs = [{ filetype: isText ? 'txt' : this.document.filetype, content: info }];\n        }\n        if (!this.isActivated)\n            return;\n        if (!docs || docs.length == 0) {\n            this.floating.close();\n        }\n        else {\n            if (this.config.floatEnable) {\n                await this.floating.show(docs, bounding, { maxPreviewWidth: this.config.maxPreviewWidth }, token);\n            }\n            if (!this.isActivated) {\n                this.floating.close();\n            }\n        }\n    }\n    start(complete) {\n        let { activated } = this;\n        this.activated = true;\n        if (activated) {\n            this.complete.dispose();\n        }\n        this.complete = complete;\n        if (!this.config.keepCompleteopt) {\n            this.nvim.command(`noa set completeopt=${this.completeOpt}`, true);\n        }\n    }\n    cancelResolve() {\n        if (this.resolveTokenSource) {\n            this.resolveTokenSource.cancel();\n            this.resolveTokenSource = null;\n        }\n    }\n    stop(hide = true) {\n        let { nvim } = this;\n        if (!this.activated)\n            return;\n        this.cancelResolve();\n        this.currItem = null;\n        this.activated = false;\n        if (this.complete) {\n            this.complete.dispose();\n            this.complete = null;\n        }\n        nvim.pauseNotification();\n        if (hide) {\n            nvim.call('coc#_hide', [], true);\n        }\n        this.floating.close();\n        if (this.config.numberSelect) {\n            nvim.call('coc#_unmap', [], true);\n        }\n        if (!this.config.keepCompleteopt) {\n            this.nvim.command(`noa set completeopt=${workspace_1.default.completeOpt}`, true);\n        }\n        nvim.command(`let g:coc#_context['candidates'] = []`, true);\n        nvim.call('coc#_cancel', [], true);\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        nvim.resumeNotification(false, true);\n    }\n    getInput(document, pre) {\n        let input = '';\n        for (let i = pre.length - 1; i >= 0; i--) {\n            let ch = i == 0 ? null : pre[i - 1];\n            if (!ch || !document.isWord(ch)) {\n                input = pre.slice(i, pre.length);\n                break;\n            }\n        }\n        return input;\n    }\n    getResumeInput() {\n        let { option, pretext } = this;\n        if (!option)\n            return null;\n        let buf = Buffer.from(pretext, 'utf8');\n        if (buf.length < option.col)\n            return null;\n        let input = buf.slice(option.col).toString('utf8');\n        if (option.blacklist && option.blacklist.includes(input))\n            return null;\n        return input;\n    }\n    get completeOpt() {\n        let { noselect, enablePreview } = this.config;\n        let preview = enablePreview && !workspace_1.default.env.pumevent ? ',preview' : '';\n        if (noselect)\n            return `noselect,menuone${preview}`;\n        return `noinsert,menuone${preview}`;\n    }\n    getCompleteItem(item) {\n        if (!this.complete || item == null)\n            return null;\n        return this.complete.resolveCompletionItem(item);\n    }\n    dispose() {\n        util_1.disposeAll(this.disposables);\n    }\n}\nexports.Completion = Completion;\nexports.default = new Completion();\n\n\n//# sourceURL=webpack://coc.nvim/./src/completion/index.ts?");

/***/ }),

/***/ "./src/completion/match.ts":
/*!*********************************!*\
  !*** ./src/completion/match.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.matchScore = void 0;\nconst fuzzy_1 = __webpack_require__(/*! ../util/fuzzy */ \"./src/util/fuzzy.ts\");\nfunction nextWordIndex(start = 0, codes) {\n    for (let i = start; i < codes.length; i++) {\n        if (isWordIndex(i, codes)) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction upperCase(code) {\n    return code >= 65 && code <= 90;\n}\nfunction isWordIndex(index, codes) {\n    if (index == 0)\n        return true;\n    let curr = codes[index];\n    if (!fuzzy_1.wordChar(curr))\n        return false;\n    let pre = codes[index - 1];\n    if (!fuzzy_1.wordChar(pre))\n        return true;\n    if (upperCase(curr) && !upperCase(pre))\n        return true;\n    return false;\n}\n/**\n * Rules:\n * - First strict 5, first case match 2.5\n * - First word character strict 2.5, first word character case 2\n * - First fuzzy match strict 1, first fuzzy case 0.5\n * - Follow strict 1, follow case 0.5\n * - Follow word start 1, follow word case 0.75\n * - First fuzzy strict 0.1, first fuzzy case 0.05\n *\n * @public\n * @param {string} word\n * @param {number[]} input\n * @returns {number}\n */\nfunction matchScore(word, input) {\n    if (input.length == 0 || word.length < input.length)\n        return 0;\n    let codes = fuzzy_1.getCharCodes(word);\n    let curr = codes[0];\n    let score = 0;\n    let first = input[0];\n    let idx = 1;\n    let allowFuzzy = true;\n    if (fuzzy_1.caseMatch(first, curr)) {\n        score = first == curr ? 5 : 2.5;\n        idx = 1;\n    }\n    else {\n        // first word 2.5/2\n        let next = nextWordIndex(1, codes);\n        if (next != -1) {\n            if (fuzzy_1.caseMatch(first, codes[next])) {\n                score = first == codes[next] ? 2.5 : 2;\n                idx = next + 1;\n            }\n        }\n        if (score == 0) {\n            // first fuzzy 1/0.5\n            for (let i = 1; i < codes.length; i++) {\n                if (fuzzy_1.caseMatch(first, codes[i])) {\n                    score = first == codes[i] ? 1 : 0.5;\n                    idx = i + 1;\n                    allowFuzzy = false;\n                }\n            }\n        }\n    }\n    if (input.length == 1 || score == 0)\n        return score;\n    let next = nextScore(codes, idx, input.slice(1), allowFuzzy);\n    return next == 0 ? 0 : score + next;\n}\nexports.matchScore = matchScore;\nfunction nextScore(codes, index, inputCodes, allowFuzzy = true) {\n    if (index >= codes.length)\n        return 0;\n    let scores = [];\n    let input = inputCodes[0];\n    let len = codes.length;\n    let isFinal = inputCodes.length == 1;\n    if (!fuzzy_1.wordChar(input)) {\n        for (let i = index; i < len; i++) {\n            if (codes[i] == input) {\n                if (isFinal)\n                    return 1;\n                let next = nextScore(codes, i + 1, inputCodes.slice(1), allowFuzzy);\n                return next == 0 ? 0 : 1 + next;\n            }\n        }\n        return 0;\n    }\n    let curr = codes[index];\n    let match = fuzzy_1.caseMatch(input, curr);\n    if (match) {\n        let score = input == curr ? 1 : 0.5;\n        if (!isFinal) {\n            let next = nextScore(codes, index + 1, inputCodes.slice(1), allowFuzzy);\n            score = next == 0 ? 0 : score + next;\n        }\n        scores.push(score);\n    }\n    // should not find if current is word index\n    if (fuzzy_1.wordChar(input) && !isWordIndex(index, codes)) {\n        let idx = nextWordIndex(index + 1, codes);\n        if (idx !== -1) {\n            let next = codes[idx];\n            if (fuzzy_1.caseMatch(input, next)) {\n                let score = input == next ? 1 : 0.75;\n                if (!isFinal) {\n                    let next = nextScore(codes, idx + 1, inputCodes.slice(1), allowFuzzy);\n                    score = next == 0 ? 0 : score + next;\n                }\n                scores.push(score);\n            }\n        }\n    }\n    // find fuzzy\n    if (!match && allowFuzzy) {\n        for (let i = index + 1; i < len; i++) {\n            let code = codes[i];\n            if (fuzzy_1.caseMatch(input, code)) {\n                let score = input == code ? 0.1 : 0.05;\n                if (!isFinal) {\n                    let next = nextScore(codes, i + 1, inputCodes.slice(1), false);\n                    score = next == 0 ? 0 : score + next;\n                }\n                scores.push(score);\n            }\n        }\n    }\n    if (!scores.length)\n        return 0;\n    return Math.max(...scores);\n}\n\n\n//# sourceURL=webpack://coc.nvim/./src/completion/match.ts?");

/***/ }),

/***/ "./src/configuration/configuration.ts":
/*!********************************************!*\
  !*** ./src/configuration/configuration.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Configuration = void 0;\nconst model_1 = __webpack_require__(/*! ./model */ \"./src/configuration/model.ts\");\nclass Configuration {\n    constructor(_defaultConfiguration, _userConfiguration, _workspaceConfiguration, _memoryConfiguration = new model_1.ConfigurationModel()) {\n        this._defaultConfiguration = _defaultConfiguration;\n        this._userConfiguration = _userConfiguration;\n        this._workspaceConfiguration = _workspaceConfiguration;\n        this._memoryConfiguration = _memoryConfiguration;\n    }\n    getConsolidateConfiguration() {\n        if (!this._consolidateConfiguration) {\n            this._consolidateConfiguration = this._defaultConfiguration.merge(this._userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);\n            this._consolidateConfiguration = this._consolidateConfiguration.freeze();\n        }\n        return this._consolidateConfiguration;\n    }\n    getValue(section) {\n        let configuration = this.getConsolidateConfiguration();\n        return configuration.getValue(section);\n    }\n    inspect(key) {\n        const consolidateConfigurationModel = this.getConsolidateConfiguration();\n        const { _workspaceConfiguration, _memoryConfiguration } = this;\n        return {\n            default: this._defaultConfiguration.freeze().getValue(key),\n            user: this._userConfiguration.freeze().getValue(key),\n            workspace: _workspaceConfiguration.freeze().getValue(key),\n            memory: _memoryConfiguration.freeze().getValue(key),\n            value: consolidateConfigurationModel.getValue(key)\n        };\n    }\n    get defaults() {\n        return this._defaultConfiguration;\n    }\n    get user() {\n        return this._userConfiguration;\n    }\n    get workspace() {\n        return this._workspaceConfiguration;\n    }\n    toData() {\n        return {\n            defaults: {\n                contents: this._defaultConfiguration.contents\n            },\n            user: {\n                contents: this._userConfiguration.contents\n            },\n            workspace: {\n                contents: this._workspaceConfiguration.contents\n            }\n        };\n    }\n}\nexports.Configuration = Configuration;\n\n\n//# sourceURL=webpack://coc.nvim/./src/configuration/configuration.ts?");

/***/ }),

/***/ "./src/configuration/index.ts":
/*!************************************!*\
  !*** ./src/configuration/index.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst os_1 = tslib_1.__importDefault(__webpack_require__(/*! os */ \"os\"));\nconst fs_1 = tslib_1.__importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./src/types.ts\");\nconst object_1 = __webpack_require__(/*! ../util/object */ \"./src/util/object.ts\");\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst configuration_1 = __webpack_require__(/*! ./configuration */ \"./src/configuration/configuration.ts\");\nconst model_1 = __webpack_require__(/*! ./model */ \"./src/configuration/model.ts\");\nconst util_2 = __webpack_require__(/*! ./util */ \"./src/configuration/util.ts\");\nconst is_1 = __webpack_require__(/*! ../util/is */ \"./src/util/is.ts\");\nconst fs_2 = __webpack_require__(/*! ../util/fs */ \"./src/util/fs.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('configurations');\nfunction lookUp(tree, key) {\n    if (key) {\n        if (tree && tree.hasOwnProperty(key))\n            return tree[key];\n        const parts = key.split('.');\n        let node = tree;\n        for (let i = 0; node && i < parts.length; i++) {\n            node = node[parts[i]];\n        }\n        return node;\n    }\n    return tree;\n}\nclass Configurations {\n    constructor(userConfigFile, _proxy) {\n        this.userConfigFile = userConfigFile;\n        this._proxy = _proxy;\n        this._errorItems = [];\n        this._folderConfigurations = new Map();\n        this._onError = new vscode_languageserver_protocol_1.Emitter();\n        this._onChange = new vscode_languageserver_protocol_1.Emitter();\n        this.disposables = [];\n        this.onError = this._onError.event;\n        this.onDidChange = this._onChange.event;\n        let user = this.parseContentFromFile(userConfigFile);\n        let data = {\n            defaults: util_2.loadDefaultConfigurations(),\n            user,\n            workspace: { contents: {} }\n        };\n        this._configuration = Configurations.parse(data);\n        this.watchFile(userConfigFile, types_1.ConfigurationTarget.User);\n        let folderConfigFile = path_1.default.join(process.cwd(), `.vim/${util_1.CONFIG_FILE_NAME}`);\n        if (folderConfigFile != userConfigFile && fs_1.default.existsSync(folderConfigFile)) {\n            this.addFolderFile(folderConfigFile);\n        }\n    }\n    parseContentFromFile(filepath) {\n        if (!filepath)\n            return { contents: {} };\n        let uri = vscode_uri_1.URI.file(filepath).toString();\n        this._errorItems = this._errorItems.filter(o => o.location.uri != uri);\n        let res = util_2.parseContentFromFile(filepath, errors => {\n            this._errorItems.push(...errors);\n        });\n        this._onError.fire(this._errorItems);\n        return res;\n    }\n    get errorItems() {\n        return this._errorItems;\n    }\n    get foldConfigurations() {\n        return this._folderConfigurations;\n    }\n    // used for extensions, no change event fired\n    extendsDefaults(props) {\n        let { defaults } = this._configuration;\n        let { contents } = defaults;\n        contents = object_1.deepClone(contents);\n        Object.keys(props).forEach(key => {\n            util_2.addToValueTree(contents, key, props[key], msg => {\n                logger.error(msg);\n            });\n        });\n        let data = {\n            defaults: { contents },\n            user: this._configuration.user,\n            workspace: this._configuration.workspace\n        };\n        this._configuration = Configurations.parse(data);\n    }\n    // change user configuration, without change file\n    updateUserConfig(props) {\n        if (!props || Object.keys(props).length == 0)\n            return;\n        let { user } = this._configuration;\n        let model = user.clone();\n        Object.keys(props).forEach(key => {\n            let val = props[key];\n            if (val === undefined) {\n                model.removeValue(key);\n            }\n            else if (is_1.objectLiteral(val)) {\n                for (let k of Object.keys(val)) {\n                    model.setValue(`${key}.${k}`, val[k]);\n                }\n            }\n            else {\n                model.setValue(key, val);\n            }\n        });\n        this.changeConfiguration(types_1.ConfigurationTarget.User, model);\n    }\n    get defaults() {\n        return this._configuration.defaults;\n    }\n    get user() {\n        return this._configuration.user;\n    }\n    get workspace() {\n        return this._configuration.workspace;\n    }\n    addFolderFile(filepath) {\n        let { _folderConfigurations } = this;\n        if (_folderConfigurations.has(filepath))\n            return;\n        if (path_1.default.resolve(filepath, '../..') == os_1.default.homedir())\n            return;\n        let model = this.parseContentFromFile(filepath);\n        this.watchFile(filepath, types_1.ConfigurationTarget.Workspace);\n        this.changeConfiguration(types_1.ConfigurationTarget.Workspace, model, filepath);\n    }\n    watchFile(filepath, target) {\n        if (!fs_1.default.existsSync(filepath) || global.hasOwnProperty('__TEST__'))\n            return;\n        let disposable = util_1.watchFile(filepath, () => {\n            let model = this.parseContentFromFile(filepath);\n            this.changeConfiguration(target, model, filepath);\n        });\n        this.disposables.push(disposable);\n    }\n    // create new configuration and fire change event\n    changeConfiguration(target, model, configFile) {\n        let { defaults, user, workspace } = this._configuration;\n        let { workspaceConfigFile } = this;\n        let data = {\n            defaults: target == types_1.ConfigurationTarget.Global ? model : defaults,\n            user: target == types_1.ConfigurationTarget.User ? model : user,\n            workspace: target == types_1.ConfigurationTarget.Workspace ? model : workspace,\n        };\n        let configuration = Configurations.parse(data);\n        let changed = util_2.getChangedKeys(this._configuration.getValue(), configuration.getValue());\n        if (target == types_1.ConfigurationTarget.Workspace && configFile) {\n            this._folderConfigurations.set(configFile, new model_1.ConfigurationModel(model.contents));\n            this.workspaceConfigFile = configFile;\n        }\n        if (changed.length == 0)\n            return;\n        this._configuration = configuration;\n        this._onChange.fire({\n            affectsConfiguration: (section, resource) => {\n                if (!resource || target != types_1.ConfigurationTarget.Workspace)\n                    return changed.includes(section);\n                let u = vscode_uri_1.URI.parse(resource);\n                if (u.scheme !== 'file')\n                    return changed.includes(section);\n                let filepath = u.fsPath;\n                let preRoot = workspaceConfigFile ? path_1.default.resolve(workspaceConfigFile, '../..') : '';\n                if (configFile && !fs_2.isParentFolder(preRoot, filepath, true) && !fs_2.isParentFolder(path_1.default.resolve(configFile, '../..'), filepath)) {\n                    return false;\n                }\n                return changed.includes(section);\n            }\n        });\n    }\n    setFolderConfiguration(uri) {\n        let u = vscode_uri_1.URI.parse(uri);\n        if (u.scheme != 'file')\n            return;\n        let filepath = u.fsPath;\n        for (let [configFile, model] of this.foldConfigurations) {\n            let root = path_1.default.resolve(configFile, '../..');\n            if (fs_2.isParentFolder(root, filepath, true) && this.workspaceConfigFile != configFile) {\n                this.changeConfiguration(types_1.ConfigurationTarget.Workspace, model, configFile);\n                break;\n            }\n        }\n    }\n    hasFolderConfiguration(filepath) {\n        let { folders } = this;\n        return folders.findIndex(f => fs_2.isParentFolder(f, filepath, true)) !== -1;\n    }\n    getConfigFile(target) {\n        if (target == types_1.ConfigurationTarget.Global)\n            return null;\n        if (target == types_1.ConfigurationTarget.User)\n            return this.userConfigFile;\n        return this.workspaceConfigFile;\n    }\n    get folders() {\n        let res = [];\n        let { _folderConfigurations } = this;\n        for (let folder of _folderConfigurations.keys()) {\n            res.push(path_1.default.resolve(folder, '../..'));\n        }\n        return res;\n    }\n    get configuration() {\n        return this._configuration;\n    }\n    /**\n     * getConfiguration\n     *\n     * @public\n     * @param {string} section\n     * @returns {WorkspaceConfiguration}\n     */\n    getConfiguration(section, resource) {\n        let configuration;\n        if (resource) {\n            let { defaults, user } = this._configuration;\n            configuration = new configuration_1.Configuration(defaults, user, this.getFolderConfiguration(resource));\n        }\n        else {\n            configuration = this._configuration;\n        }\n        const config = Object.freeze(lookUp(configuration.getValue(null), section));\n        const result = {\n            has(key) {\n                return typeof lookUp(config, key) !== 'undefined';\n            },\n            get: (key, defaultValue) => {\n                let result = lookUp(config, key);\n                if (result == null)\n                    return defaultValue;\n                return result;\n            },\n            update: (key, value, isUser = false) => {\n                let s = section ? `${section}.${key}` : key;\n                let target = isUser ? types_1.ConfigurationTarget.User : types_1.ConfigurationTarget.Workspace;\n                let model = target == types_1.ConfigurationTarget.User ? this.user.clone() : this.workspace.clone();\n                if (value == undefined) {\n                    model.removeValue(s);\n                }\n                else {\n                    model.setValue(s, value);\n                }\n                if (target == types_1.ConfigurationTarget.Workspace && !this.workspaceConfigFile && this._proxy) {\n                    let file = this.workspaceConfigFile = this._proxy.workspaceConfigFile;\n                    if (!fs_1.default.existsSync(file)) {\n                        let folder = path_1.default.dirname(file);\n                        if (!fs_1.default.existsSync(folder))\n                            fs_1.default.mkdirSync(folder);\n                        fs_1.default.writeFileSync(file, '{}', { encoding: 'utf8' });\n                    }\n                }\n                this.changeConfiguration(target, model, target == types_1.ConfigurationTarget.Workspace ? this.workspaceConfigFile : this.userConfigFile);\n                if (this._proxy && !global.hasOwnProperty('__TEST__')) {\n                    if (value == undefined) {\n                        this._proxy.$removeConfigurationOption(target, s);\n                    }\n                    else {\n                        this._proxy.$updateConfigurationOption(target, s, value);\n                    }\n                }\n            },\n            inspect: (key) => {\n                key = section ? `${section}.${key}` : key;\n                const config = this._configuration.inspect(key);\n                if (config) {\n                    return {\n                        key,\n                        defaultValue: config.default,\n                        globalValue: config.user,\n                        workspaceValue: config.workspace,\n                    };\n                }\n                return undefined;\n            }\n        };\n        Object.defineProperty(result, 'has', {\n            enumerable: false\n        });\n        Object.defineProperty(result, 'get', {\n            enumerable: false\n        });\n        Object.defineProperty(result, 'update', {\n            enumerable: false\n        });\n        Object.defineProperty(result, 'inspect', {\n            enumerable: false\n        });\n        if (typeof config === 'object') {\n            object_1.mixin(result, config, false);\n        }\n        return object_1.deepFreeze(result);\n    }\n    getFolderConfiguration(uri) {\n        let u = vscode_uri_1.URI.parse(uri);\n        if (u.scheme != 'file')\n            return new model_1.ConfigurationModel();\n        let filepath = u.fsPath;\n        for (let [configFile, model] of this.foldConfigurations) {\n            let root = path_1.default.resolve(configFile, '../..');\n            if (fs_2.isParentFolder(root, filepath, true))\n                return model;\n        }\n        return new model_1.ConfigurationModel();\n    }\n    checkFolderConfiguration(uri) {\n        let u = vscode_uri_1.URI.parse(uri);\n        if (u.scheme != 'file')\n            return;\n        let rootPath = path_1.default.dirname(u.fsPath);\n        if (!this.hasFolderConfiguration(rootPath)) {\n            let folder = fs_2.findUp('.vim', rootPath);\n            if (folder && folder != os_1.default.homedir()) {\n                let file = path_1.default.join(folder, util_1.CONFIG_FILE_NAME);\n                if (fs_1.default.existsSync(file)) {\n                    this.addFolderFile(file);\n                }\n            }\n        }\n        else {\n            this.setFolderConfiguration(uri);\n        }\n    }\n    static parse(data) {\n        const defaultConfiguration = new model_1.ConfigurationModel(data.defaults.contents);\n        const userConfiguration = new model_1.ConfigurationModel(data.user.contents);\n        const workspaceConfiguration = new model_1.ConfigurationModel(data.workspace.contents);\n        return new configuration_1.Configuration(defaultConfiguration, userConfiguration, workspaceConfiguration, new model_1.ConfigurationModel());\n    }\n    dispose() {\n        util_1.disposeAll(this.disposables);\n    }\n}\nexports.default = Configurations;\n\n\n//# sourceURL=webpack://coc.nvim/./src/configuration/index.ts?");

/***/ }),

/***/ "./src/configuration/model.ts":
/*!************************************!*\
  !*** ./src/configuration/model.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConfigurationModel = void 0;\nconst is_1 = __webpack_require__(/*! ../util/is */ \"./src/util/is.ts\");\nconst object_1 = __webpack_require__(/*! ../util/object */ \"./src/util/object.ts\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/configuration/util.ts\");\nclass ConfigurationModel {\n    constructor(_contents = {}) {\n        this._contents = _contents;\n    }\n    get contents() {\n        return this._contents;\n    }\n    clone() {\n        return new ConfigurationModel(object_1.deepClone(this._contents));\n    }\n    getValue(section) {\n        let res = section\n            ? util_1.getConfigurationValue(this.contents, section)\n            : this.contents;\n        return res;\n    }\n    merge(...others) {\n        const contents = object_1.deepClone(this.contents);\n        for (const other of others) {\n            this.mergeContents(contents, other.contents);\n        }\n        return new ConfigurationModel(contents);\n    }\n    freeze() {\n        if (!Object.isFrozen(this._contents)) {\n            Object.freeze(this._contents);\n        }\n        return this;\n    }\n    mergeContents(source, target) {\n        for (const key of Object.keys(target)) {\n            if (key in source) {\n                if (is_1.objectLiteral(source[key]) && is_1.objectLiteral(target[key])) {\n                    this.mergeContents(source[key], target[key]);\n                    continue;\n                }\n            }\n            source[key] = object_1.deepClone(target[key]);\n        }\n    }\n    // Update methods\n    setValue(key, value) {\n        util_1.addToValueTree(this.contents, key, value, message => {\n            console.error(message);\n        });\n    }\n    removeValue(key) {\n        util_1.removeFromValueTree(this.contents, key);\n    }\n}\nexports.ConfigurationModel = ConfigurationModel;\n\n\n//# sourceURL=webpack://coc.nvim/./src/configuration/model.ts?");

/***/ }),

/***/ "./src/configuration/shape.ts":
/*!************************************!*\
  !*** ./src/configuration/shape.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst fs_1 = tslib_1.__importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst jsonc_parser_1 = __webpack_require__(/*! jsonc-parser */ \"./node_modules/jsonc-parser/lib/esm/main.js\");\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('configuration-shape');\nclass ConfigurationProxy {\n    constructor(workspace) {\n        this.workspace = workspace;\n    }\n    get nvim() {\n        return this.workspace.nvim;\n    }\n    async modifyConfiguration(target, key, value) {\n        let { nvim, workspace } = this;\n        let file = workspace.getConfigFile(target);\n        if (!file)\n            return;\n        let formattingOptions = { tabSize: 2, insertSpaces: true };\n        let content = fs_1.default.readFileSync(file, 'utf8');\n        value = value == null ? undefined : value;\n        let edits = jsonc_parser_1.modify(content, [key], value, { formattingOptions });\n        content = jsonc_parser_1.applyEdits(content, edits);\n        fs_1.default.writeFileSync(file, content, 'utf8');\n        let doc = workspace.getDocument(vscode_uri_1.URI.file(file).toString());\n        if (doc)\n            nvim.command('checktime', true);\n        return;\n    }\n    get workspaceConfigFile() {\n        let folder = path_1.default.join(this.workspace.root, '.vim');\n        return path_1.default.join(folder, util_1.CONFIG_FILE_NAME);\n    }\n    $updateConfigurationOption(target, key, value) {\n        this.modifyConfiguration(target, key, value).logError();\n    }\n    $removeConfigurationOption(target, key) {\n        this.modifyConfiguration(target, key).logError();\n    }\n}\nexports.default = ConfigurationProxy;\n\n\n//# sourceURL=webpack://coc.nvim/./src/configuration/shape.ts?");

/***/ }),

/***/ "./src/configuration/util.ts":
/*!***********************************!*\
  !*** ./src/configuration/util.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getChangedKeys = exports.getKeys = exports.loadDefaultConfigurations = exports.getConfigurationValue = exports.removeFromValueTree = exports.addToValueTree = exports.convertErrors = exports.parseConfiguration = exports.parseContentFromFile = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst vscode_languageserver_textdocument_1 = __webpack_require__(/*! vscode-languageserver-textdocument */ \"./node_modules/vscode-languageserver-textdocument/lib/esm/main.js\");\nconst jsonc_parser_1 = __webpack_require__(/*! jsonc-parser */ \"./node_modules/jsonc-parser/lib/esm/main.js\");\nconst is_1 = __webpack_require__(/*! ../util/is */ \"./src/util/is.ts\");\nconst object_1 = __webpack_require__(/*! ../util/object */ \"./src/util/object.ts\");\nconst fs_1 = tslib_1.__importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('configuration-util');\nconst isWebpack = typeof __webpack_require__ === \"function\";\nconst pluginRoot = isWebpack ? path_1.default.dirname(__dirname) : path_1.default.resolve(__dirname, '../..');\nfunction parseContentFromFile(filepath, onError) {\n    if (!filepath || !fs_1.default.existsSync(filepath))\n        return { contents: {} };\n    let content;\n    let uri = vscode_uri_1.URI.file(filepath).toString();\n    try {\n        content = fs_1.default.readFileSync(filepath, 'utf8');\n    }\n    catch (_e) {\n        content = '';\n    }\n    let [errors, contents] = parseConfiguration(content);\n    if (errors && errors.length) {\n        onError(convertErrors(uri, content, errors));\n    }\n    return { contents };\n}\nexports.parseContentFromFile = parseContentFromFile;\nfunction parseConfiguration(content) {\n    if (content.length == 0)\n        return [[], {}];\n    let errors = [];\n    let data = jsonc_parser_1.parse(content, errors, { allowTrailingComma: true });\n    function addProperty(current, key, remains, value) {\n        if (remains.length == 0) {\n            current[key] = convert(value);\n        }\n        else {\n            if (!current[key])\n                current[key] = {};\n            let o = current[key];\n            let first = remains.shift();\n            addProperty(o, first, remains, value);\n        }\n    }\n    function convert(obj, split = false) {\n        if (!is_1.objectLiteral(obj))\n            return obj;\n        if (is_1.emptyObject(obj))\n            return {};\n        let dest = {};\n        for (let key of Object.keys(obj)) {\n            if (split && key.includes('.')) {\n                let parts = key.split('.');\n                let first = parts.shift();\n                addProperty(dest, first, parts, obj[key]);\n            }\n            else {\n                dest[key] = convert(obj[key]);\n            }\n        }\n        return dest;\n    }\n    return [errors, convert(data, true)];\n}\nexports.parseConfiguration = parseConfiguration;\nfunction convertErrors(uri, content, errors) {\n    let items = [];\n    let document = vscode_languageserver_textdocument_1.TextDocument.create(uri, 'json', 0, content);\n    for (let err of errors) {\n        let msg = 'parse error';\n        switch (err.error) {\n            case 2:\n                msg = 'invalid number';\n                break;\n            case 8:\n                msg = 'close brace expected';\n                break;\n            case 5:\n                msg = 'colon expected';\n                break;\n            case 6:\n                msg = 'comma expected';\n                break;\n            case 9:\n                msg = 'end of file expected';\n                break;\n            case 16:\n                msg = 'invaliad character';\n                break;\n            case 10:\n                msg = 'invalid commment token';\n                break;\n            case 15:\n                msg = 'invalid escape character';\n                break;\n            case 1:\n                msg = 'invalid symbol';\n                break;\n            case 14:\n                msg = 'invalid unicode';\n                break;\n            case 3:\n                msg = 'property name expected';\n                break;\n            case 13:\n                msg = 'unexpected end of number';\n                break;\n            case 12:\n                msg = 'unexpected end of string';\n                break;\n            case 11:\n                msg = 'unexpected end of comment';\n                break;\n            case 4:\n                msg = 'value expected';\n                break;\n            default:\n                msg = 'Unknwn error';\n                break;\n        }\n        let range = {\n            start: document.positionAt(err.offset),\n            end: document.positionAt(err.offset + err.length),\n        };\n        let loc = vscode_languageserver_protocol_1.Location.create(uri, range);\n        items.push({ location: loc, message: msg });\n    }\n    return items;\n}\nexports.convertErrors = convertErrors;\nfunction addToValueTree(settingsTreeRoot, key, value, conflictReporter) {\n    const segments = key.split('.');\n    const last = segments.pop();\n    let curr = settingsTreeRoot;\n    for (let i = 0; i < segments.length; i++) {\n        let s = segments[i];\n        let obj = curr[s];\n        switch (typeof obj) {\n            case 'function': {\n                obj = curr[s] = {};\n                break;\n            }\n            case 'undefined': {\n                obj = curr[s] = {};\n                break;\n            }\n            case 'object':\n                break;\n            default:\n                conflictReporter(`Ignoring ${key} as ${segments\n                    .slice(0, i + 1)\n                    .join('.')} is ${JSON.stringify(obj)}`);\n                return;\n        }\n        curr = obj;\n    }\n    if (typeof curr === 'object') {\n        curr[last] = value; // workaround https://github.com/Microsoft/vscode/issues/13606\n    }\n    else {\n        conflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);\n    }\n}\nexports.addToValueTree = addToValueTree;\nfunction removeFromValueTree(valueTree, key) {\n    const segments = key.split('.');\n    doRemoveFromValueTree(valueTree, segments);\n}\nexports.removeFromValueTree = removeFromValueTree;\nfunction doRemoveFromValueTree(valueTree, segments) {\n    const first = segments.shift();\n    if (segments.length === 0) {\n        // Reached last segment\n        delete valueTree[first];\n        return;\n    }\n    if (Object.keys(valueTree).includes(first)) {\n        const value = valueTree[first];\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            doRemoveFromValueTree(value, segments);\n            if (Object.keys(value).length === 0) {\n                delete valueTree[first];\n            }\n        }\n    }\n}\nfunction getConfigurationValue(config, settingPath, defaultValue) {\n    function accessSetting(config, path) {\n        let current = config;\n        for (let i = 0; i < path.length; i++) {\n            if (typeof current !== 'object' || current === null) {\n                return undefined;\n            }\n            current = current[path[i]];\n        }\n        return current;\n    }\n    const path = settingPath.split('.');\n    const result = accessSetting(config, path);\n    return typeof result === 'undefined' ? defaultValue : result;\n}\nexports.getConfigurationValue = getConfigurationValue;\nfunction loadDefaultConfigurations() {\n    let file = path_1.default.join(pluginRoot, 'data/schema.json');\n    if (!fs_1.default.existsSync(file)) {\n        console.error('schema.json not found, reinstall coc.nvim to fix this!');\n        return { contents: {} };\n    }\n    let content = fs_1.default.readFileSync(file, 'utf8');\n    let { properties } = JSON.parse(content);\n    let config = {};\n    Object.keys(properties).forEach(key => {\n        let value = properties[key].default;\n        if (value !== undefined) {\n            addToValueTree(config, key, value, message => {\n                logger.error(message);\n            });\n        }\n    });\n    return { contents: config };\n}\nexports.loadDefaultConfigurations = loadDefaultConfigurations;\nfunction getKeys(obj, curr) {\n    let keys = [];\n    for (let key of Object.keys(obj)) {\n        let val = obj[key];\n        let newKey = curr ? `${curr}.${key}` : key;\n        keys.push(newKey);\n        if (is_1.objectLiteral(val)) {\n            keys.push(...getKeys(val, newKey));\n        }\n    }\n    return keys;\n}\nexports.getKeys = getKeys;\nfunction getChangedKeys(from, to) {\n    let keys = [];\n    let fromKeys = getKeys(from);\n    let toKeys = getKeys(to);\n    const added = toKeys.filter(key => !fromKeys.includes(key));\n    const removed = fromKeys.filter(key => !toKeys.includes(key));\n    keys.push(...added);\n    keys.push(...removed);\n    for (const key of fromKeys) {\n        if (!toKeys.includes(key))\n            continue;\n        const value1 = getConfigurationValue(from, key);\n        const value2 = getConfigurationValue(to, key);\n        if (!object_1.equals(value1, value2)) {\n            keys.push(key);\n        }\n    }\n    return keys;\n}\nexports.getChangedKeys = getChangedKeys;\n\n\n//# sourceURL=webpack://coc.nvim/./src/configuration/util.ts?");

/***/ }),

/***/ "./src/cursors/index.ts":
/*!******************************!*\
  !*** ./src/cursors/index.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ \"./node_modules/vscode-languageserver-types/lib/esm/main.js\");\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nconst position_1 = __webpack_require__(/*! ../util/position */ \"./src/util/position.ts\");\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst session_1 = tslib_1.__importDefault(__webpack_require__(/*! ./session */ \"./src/cursors/session.ts\"));\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/cursors/util.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('cursors');\nclass Cursors {\n    constructor(nvim) {\n        this.nvim = nvim;\n        this.sessionsMap = new Map();\n        this.disposables = [];\n        this.loadConfig();\n        workspace_1.default.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cursors')) {\n                this.loadConfig();\n            }\n        }, null, this.disposables);\n        events_1.default.on('BufUnload', bufnr => {\n            let session = this.getSession(bufnr);\n            if (!session)\n                return;\n            session.dispose();\n            this.sessionsMap.delete(bufnr);\n        }, null, this.disposables);\n    }\n    loadConfig() {\n        let config = workspace_1.default.getConfiguration('cursors');\n        this.config = {\n            nextKey: config.get('nextKey', '<C-n>'),\n            previousKey: config.get('previousKey', '<C-p>'),\n            cancelKey: config.get('cancelKey', '<esc>')\n        };\n    }\n    getSession(bufnr) {\n        return this.sessionsMap.get(bufnr);\n    }\n    async isActivated() {\n        let bufnr = await this.nvim.call('bufnr', ['%']);\n        return this.sessionsMap.get(bufnr) != null;\n    }\n    async select(bufnr, kind, mode) {\n        let doc = workspace_1.default.getDocument(bufnr);\n        if (!doc || !doc.attached) {\n            window_1.default.showMessage(`buffer ${bufnr} not attached.`);\n            return;\n        }\n        let { nvim } = this;\n        let session = this.createSession(doc);\n        let pos = await window_1.default.getCursorPosition();\n        let range;\n        if (kind == 'operator') {\n            await nvim.command(`normal! ${mode == 'line' ? `'[` : '`['}`);\n            let start = await window_1.default.getCursorPosition();\n            await nvim.command(`normal! ${mode == 'line' ? `']` : '`]'}`);\n            let end = await window_1.default.getCursorPosition();\n            await window_1.default.moveTo(pos);\n            let relative = position_1.comparePosition(start, end);\n            // do nothing for empty range\n            if (relative == 0)\n                return;\n            if (relative >= 0)\n                [start, end] = [end, start];\n            // include end character\n            let line = doc.getline(end.line);\n            if (end.character < line.length) {\n                end.character = end.character + 1;\n            }\n            let ranges = util_1.splitRange(doc, vscode_languageserver_types_1.Range.create(start, end));\n            for (let r of ranges) {\n                let text = doc.textDocument.getText(r);\n                session.addRange(r, text);\n            }\n        }\n        else if (kind == 'word') {\n            range = doc.getWordRangeAtPosition(pos);\n            if (!range) {\n                let line = doc.getline(pos.line);\n                if (pos.character == line.length) {\n                    range = vscode_languageserver_types_1.Range.create(pos.line, Math.max(0, line.length - 1), pos.line, line.length);\n                }\n                else {\n                    range = vscode_languageserver_types_1.Range.create(pos.line, pos.character, pos.line, pos.character + 1);\n                }\n            }\n            let line = doc.getline(pos.line);\n            let text = line.slice(range.start.character, range.end.character);\n            session.addRange(range, text);\n        }\n        else if (kind == 'position') {\n            // make sure range contains character for highlight\n            let line = doc.getline(pos.line);\n            if (pos.character >= line.length) {\n                range = vscode_languageserver_types_1.Range.create(pos.line, line.length - 1, pos.line, line.length);\n            }\n            else {\n                range = vscode_languageserver_types_1.Range.create(pos.line, pos.character, pos.line, pos.character + 1);\n            }\n            session.addRange(range, line.slice(range.start.character, range.end.character));\n        }\n        else if (kind == 'range') {\n            await nvim.call('eval', 'feedkeys(\"\\\\<esc>\", \"in\")');\n            let range = await workspace_1.default.getSelectedRange(mode, doc);\n            if (!range || position_1.comparePosition(range.start, range.end) == 0)\n                return;\n            let ranges = mode == '\\x16' ? util_1.getVisualRanges(doc, range) : util_1.splitRange(doc, range);\n            for (let r of ranges) {\n                let text = doc.textDocument.getText(r);\n                session.addRange(r, text);\n            }\n        }\n        else {\n            window_1.default.showMessage(`${kind} not supported`, 'error');\n            return;\n        }\n        if (kind == 'word' || kind == 'position') {\n            await nvim.command(`silent! call repeat#set(\"\\\\<Plug>(coc-cursors-${kind})\", -1)`);\n        }\n    }\n    createSession(doc) {\n        let session = this.getSession(doc.bufnr);\n        if (session)\n            return session;\n        session = new session_1.default(this.nvim, doc, this.config);\n        this.sessionsMap.set(doc.bufnr, session);\n        session.onDidCancel(() => {\n            session.dispose();\n            this.sessionsMap.delete(doc.bufnr);\n        });\n        return session;\n    }\n    // Add ranges to current document\n    async addRanges(ranges) {\n        let { nvim } = this;\n        let bufnr = await nvim.call('bufnr', ['%']);\n        let doc = workspace_1.default.getDocument(bufnr);\n        if (!doc || !doc.attached) {\n            window_1.default.showMessage('Document not attached', 'error');\n            return false;\n        }\n        let session = this.createSession(doc);\n        return session.addRanges(ranges);\n    }\n    reset() {\n        for (let session of this.sessionsMap.values()) {\n            session.cancel();\n        }\n        this.sessionsMap.clear();\n    }\n    dispose() {\n        for (let session of this.sessionsMap.values()) {\n            session.dispose();\n        }\n        this.sessionsMap.clear();\n        for (let disposable of this.disposables) {\n            disposable.dispose();\n        }\n    }\n}\nexports.default = Cursors;\n\n\n//# sourceURL=webpack://coc.nvim/./src/cursors/index.ts?");

/***/ }),

/***/ "./src/cursors/range.ts":
/*!******************************!*\
  !*** ./src/cursors/range.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ \"./node_modules/vscode-languageserver-types/lib/esm/main.js\");\nconst position_1 = __webpack_require__(/*! ../util/position */ \"./src/util/position.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('cursors-range');\n// edit range\nclass TextRange {\n    constructor(line, start, end, text, \n    // range count at this line before, shuld be updated on range add\n    preCount) {\n        this.line = line;\n        this.start = start;\n        this.end = end;\n        this.text = text;\n        this.preCount = preCount;\n        this.currStart = start;\n        this.currEnd = end;\n    }\n    add(offset, add) {\n        let { text, preCount } = this;\n        let pre = offset == 0 ? '' : text.slice(0, offset);\n        let post = text.slice(offset);\n        this.text = `${pre}${add}${post}`;\n        this.currStart = this.currStart + preCount * add.length;\n        this.currEnd = this.currEnd + (preCount + 1) * add.length;\n    }\n    replace(begin, end, add = '') {\n        let { text, preCount } = this;\n        let pre = begin == 0 ? '' : text.slice(0, begin);\n        let post = text.slice(end);\n        this.text = pre + add + post;\n        let l = end - begin - add.length;\n        this.currStart = this.currStart - preCount * l;\n        this.currEnd = this.currEnd - (preCount + 1) * l;\n    }\n    get range() {\n        return vscode_languageserver_types_1.Range.create(this.line, this.start, this.line, this.end);\n    }\n    get currRange() {\n        return vscode_languageserver_types_1.Range.create(this.line, this.currStart, this.line, this.currEnd);\n    }\n    applyEdit(edit) {\n        let { range, newText } = edit;\n        let start = range.start.character;\n        let end = range.end.character;\n        let isAdd = start == end;\n        if (isAdd) {\n            this.add(start - this.currStart, newText);\n        }\n        else {\n            this.replace(start - this.currStart, end - this.currStart, newText);\n        }\n    }\n    /**\n     * Adjust from textEdit that not overlap\n     */\n    adjustFromEdit(edit) {\n        let { range, newText } = edit;\n        // no change if edit after current range\n        if (position_1.comparePosition(range.start, vscode_languageserver_types_1.Position.create(this.line, this.currEnd)) > 0) {\n            return;\n        }\n        let newLines = newText.split('\\n');\n        let changeCount = newLines.length - (range.end.line - range.start.line + 1);\n        this.line = this.line + changeCount;\n        if (range.end.line == this.line) {\n            let remove = range.start.line == range.end.line ? range.end.character - range.start.character : range.end.character;\n            if (newLines.length > 1 && range.start.line == range.end.line) {\n                remove = remove + range.start.character;\n            }\n            let add = 0;\n            if (newLines.length > 1) {\n                add = newLines[newLines.length - 1].length;\n            }\n            else {\n                if (range.start.line == range.end.line) {\n                    add = newText.length;\n                }\n                else {\n                    add = range.start.character + newText.length;\n                }\n            }\n            let delta = add - remove;\n            for (let key of ['start', 'end', 'currStart', 'currEnd']) {\n                this[key] += delta;\n            }\n        }\n    }\n    sync() {\n        this.start = this.currStart;\n        this.end = this.currEnd;\n    }\n    get textEdit() {\n        return {\n            range: this.range,\n            newText: this.text\n        };\n    }\n}\nexports.default = TextRange;\n\n\n//# sourceURL=webpack://coc.nvim/./src/cursors/range.ts?");

/***/ }),

/***/ "./src/cursors/session.ts":
/*!********************************!*\
  !*** ./src/cursors/session.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst fast_diff_1 = tslib_1.__importDefault(__webpack_require__(/*! fast-diff */ \"./node_modules/fast-diff/diff.js\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst vscode_languageserver_textdocument_1 = __webpack_require__(/*! vscode-languageserver-textdocument */ \"./node_modules/vscode-languageserver-textdocument/lib/esm/main.js\");\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nconst position_1 = __webpack_require__(/*! ../util/position */ \"./src/util/position.ts\");\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst range_1 = tslib_1.__importDefault(__webpack_require__(/*! ./range */ \"./src/cursors/range.ts\"));\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/cursors/util.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('cursors-session');\n/**\n * Cursor session for single buffer\n */\nclass CursorSession {\n    constructor(nvim, doc, config) {\n        this.nvim = nvim;\n        this.doc = doc;\n        this.config = config;\n        this._onDidCancel = new vscode_languageserver_protocol_1.Emitter();\n        this.onDidCancel = this._onDidCancel.event;\n        this.disposables = [];\n        this.ranges = [];\n        this.activated = true;\n        this.changing = false;\n        this.changed = false;\n        this.doc.forceSync();\n        this.textDocument = this.doc.textDocument;\n        this.buffer.setVar('coc_cursors_activated', 1, true);\n        let { cancelKey, nextKey, previousKey } = this.config;\n        this.disposables.push(workspace_1.default.registerLocalKeymap('n', cancelKey, () => {\n            this.cancel();\n        }, true));\n        this.disposables.push(workspace_1.default.registerLocalKeymap('n', nextKey, async () => {\n            if (!this.activated)\n                return;\n            let ranges = this.ranges.map(o => o.currRange);\n            let curr = await window_1.default.getCursorPosition();\n            for (let r of ranges) {\n                if (position_1.comparePosition(r.start, curr) > 0) {\n                    await window_1.default.moveTo(r.start);\n                    return;\n                }\n            }\n            if (ranges.length)\n                await window_1.default.moveTo(ranges[0].start);\n        }, true));\n        this.disposables.push(workspace_1.default.registerLocalKeymap('n', previousKey, async () => {\n            if (!this.activated)\n                return;\n            let ranges = this.ranges.map(o => o.currRange);\n            ranges.reverse();\n            let curr = await window_1.default.getCursorPosition();\n            for (let r of ranges) {\n                if (position_1.comparePosition(r.end, curr) < 0) {\n                    await window_1.default.moveTo(r.start);\n                    return;\n                }\n            }\n            if (ranges.length)\n                await window_1.default.moveTo(ranges[ranges.length - 1].start);\n        }, true));\n        this.doc.onDocumentChange(this.onChange, this, this.disposables);\n    }\n    async onChange(e) {\n        if (!this.activated || this.ranges.length == 0)\n            return;\n        if (this.changing)\n            return;\n        let change = e.contentChanges[0];\n        let { text, range } = change;\n        let intersect = this.ranges.some(r => position_1.rangeIntersect(range, r.currRange));\n        let begin = this.ranges[0].currRange.start;\n        if (text.endsWith('\\n') && position_1.comparePosition(begin, range.end) == 0) {\n            // prepend lines\n            intersect = false;\n        }\n        if (!intersect) {\n            this.ranges.forEach(r => {\n                r.adjustFromEdit({ range, newText: text });\n            });\n            this.doHighlights();\n            this.textDocument = this.doc.textDocument;\n            return;\n        }\n        this.changed = true;\n        // get range from edit\n        let textRange = this.getTextRange(range, text);\n        if (textRange) {\n            await this.applySingleEdit(textRange, { range, newText: text });\n        }\n        else {\n            this.applyComposedEdit(e.original, { range, newText: text });\n            if (this.activated) {\n                this.ranges.forEach(r => {\n                    r.sync();\n                });\n                this.textDocument = this.doc.textDocument;\n            }\n        }\n    }\n    doHighlights() {\n        let { nvim, buffer, ranges } = this;\n        buffer.clearNamespace('cursors');\n        let arr = ranges.map(o => o.currRange);\n        buffer.highlightRanges('cursors', 'CocCursorRange', arr);\n        nvim.command('redraw', true);\n    }\n    addRanges(ranges) {\n        let { nvim, doc } = this;\n        if (this.changed) {\n            window_1.default.showMessage(`Can't add ranges after range change.`);\n            return false;\n        }\n        // filter overlap ranges\n        this.ranges = this.ranges.filter(r => {\n            let { currRange } = r;\n            return !ranges.some(range => position_1.rangeOverlap(range, currRange));\n        });\n        let { textDocument } = doc;\n        for (let range of ranges) {\n            let { line } = range.start;\n            let textRange = new range_1.default(line, range.start.character, range.end.character, textDocument.getText(range), 0);\n            this.ranges.push(textRange);\n        }\n        this.ranges.sort((a, b) => position_1.comparePosition(a.range.start, b.range.start));\n        // fix preCount\n        let preCount = 0;\n        let currline = -1;\n        for (let range of this.ranges) {\n            let { line } = range;\n            if (line != currline) {\n                preCount = 0;\n            }\n            range.preCount = preCount;\n            preCount = preCount + 1;\n            currline = line;\n        }\n        nvim.pauseNotification();\n        this.doHighlights();\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        nvim.resumeNotification(false, true);\n        return true;\n    }\n    /**\n     * Cancel session and highlights\n     */\n    cancel() {\n        if (!this.activated)\n            return;\n        let { nvim } = this;\n        this.activated = false;\n        let { cancelKey, nextKey, previousKey } = this.config;\n        nvim.pauseNotification();\n        this.buffer.clearNamespace('cursors');\n        this.buffer.setVar('coc_cursors_activated', 0, true);\n        nvim.command('redraw', true);\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        nvim.resumeNotification(false, true);\n        this._onDidCancel.fire();\n    }\n    /**\n     * Called on buffer unload or cancel\n     */\n    dispose() {\n        if (!this.doc)\n            return;\n        this._onDidCancel.dispose();\n        for (let disposable of this.disposables) {\n            disposable.dispose();\n        }\n        this.ranges = [];\n        this.doc = null;\n        this.textDocument = null;\n    }\n    get buffer() {\n        return this.nvim.createBuffer(this.doc.bufnr);\n    }\n    /**\n     * Find changed range from edit\n     */\n    getTextRange(range, text) {\n        let { ranges } = this;\n        if (text.indexOf('\\n') !== -1 || range.start.line != range.end.line) {\n            return null;\n        }\n        ranges.sort((a, b) => {\n            if (a.line != b.line)\n                return a.line - b.line;\n            return a.currRange.start.character - b.currRange.start.character;\n        });\n        for (let i = 0; i < ranges.length; i++) {\n            let r = ranges[i];\n            if (position_1.rangeInRange(range, r.currRange)) {\n                return r;\n            }\n            if (r.line != range.start.line) {\n                continue;\n            }\n            if (text.length && range.start.character == r.currRange.end.character) {\n                // end add\n                let next = ranges[i + 1];\n                if (!next)\n                    return r;\n                return position_1.positionInRange(next.currRange.start, range) ? null : r;\n            }\n        }\n        return null;\n    }\n    /**\n     * Adjust change for current ranges\n     */\n    adjustRanges(textRange, range, text) {\n        let { ranges } = this;\n        if (range.start.character == range.end.character) {\n            // add\n            let isEnd = textRange.currRange.end.character == range.start.character;\n            if (isEnd) {\n                ranges.forEach(r => {\n                    r.add(r.text.length, text);\n                });\n            }\n            else {\n                let d = range.start.character - textRange.currRange.start.character;\n                ranges.forEach(r => {\n                    r.add(Math.min(r.text.length, d), text);\n                });\n            }\n        }\n        else {\n            // replace\n            let d = range.end.character - range.start.character;\n            let isEnd = textRange.currRange.end.character == range.end.character;\n            if (isEnd) {\n                if (textRange.currRange.start.character == range.start.character) {\n                    // changed both start and end\n                    if (text.includes(textRange.text)) {\n                        let idx = text.indexOf(textRange.text);\n                        let pre = idx == 0 ? '' : text.slice(0, idx);\n                        let post = text.slice(idx + textRange.text.length);\n                        if (pre)\n                            ranges.forEach(r => r.add(0, pre));\n                        if (post)\n                            ranges.forEach(r => r.add(r.text.length, post));\n                    }\n                    else if (textRange.text.includes(text)) {\n                        // delete\n                        let idx = textRange.text.indexOf(text);\n                        let offset = textRange.text.length - (idx + text.length);\n                        if (idx != 0)\n                            ranges.forEach(r => r.replace(0, idx));\n                        if (offset > 0)\n                            ranges.forEach(r => r.replace(r.text.length - offset, r.text.length));\n                    }\n                    else {\n                        this.cancel();\n                    }\n                }\n                else {\n                    ranges.forEach(r => {\n                        let l = r.text.length;\n                        r.replace(Math.max(0, l - d), l, text);\n                    });\n                }\n            }\n            else {\n                let start = range.start.character - textRange.currRange.start.character;\n                ranges.forEach(r => {\n                    let l = r.text.length;\n                    r.replace(start, Math.min(start + d, l), text);\n                });\n            }\n        }\n    }\n    addRange(range, text) {\n        if (this.changed) {\n            window_1.default.showMessage(`Can't add range after range change.`);\n            return;\n        }\n        let { ranges } = this;\n        let idx = ranges.findIndex(o => position_1.rangeIntersect(o.range, range));\n        // remove range when intersect\n        if (idx !== -1) {\n            ranges.splice(idx, 1);\n            // adjust preCount after\n            for (let r of ranges) {\n                if (r.line == range.start.line && r.start > range.start.character) {\n                    r.preCount = r.preCount - 1;\n                }\n            }\n        }\n        else {\n            let preCount = 0;\n            let idx = 0;\n            let { line } = range.start;\n            // idx & preCount\n            for (let r of ranges) {\n                if (r.line > line || (r.line == line && r.start > range.end.character)) {\n                    break;\n                }\n                if (r.line == line)\n                    preCount++;\n                idx++;\n            }\n            let created = new range_1.default(line, range.start.character, range.end.character, text, preCount);\n            ranges.splice(idx, 0, created);\n            // adjust preCount after\n            for (let r of ranges) {\n                if (r.line == range.start.line && r.start > range.start.character) {\n                    r.preCount = r.preCount + 1;\n                }\n            }\n        }\n        if (this.ranges.length == 0) {\n            this.cancel();\n        }\n        else {\n            this.doHighlights();\n        }\n    }\n    async applySingleEdit(textRange, edit) {\n        // single range change, calculate & apply changes for all ranges\n        let { range, newText } = edit;\n        let { doc } = this;\n        this.adjustRanges(textRange, range, newText);\n        if (this.ranges.length == 1) {\n            this.doHighlights();\n            return;\n        }\n        let edits = this.ranges.map(o => o.textEdit);\n        let content = vscode_languageserver_textdocument_1.TextDocument.applyEdits(this.textDocument, edits);\n        let newLines = content.split('\\n');\n        let changedLnum = new Set();\n        let arr = [];\n        for (let r of this.ranges) {\n            if (!changedLnum.has(r.line)) {\n                changedLnum.add(r.line);\n                arr.push([r.line, newLines[r.line]]);\n            }\n        }\n        let { nvim } = this;\n        this.changing = true;\n        await doc.changeLines(arr);\n        this.changing = false;\n        if (this.activated) {\n            this.ranges.forEach(r => {\n                r.sync();\n            });\n            this.textDocument = this.doc.textDocument;\n        }\n        // apply changes\n        nvim.pauseNotification();\n        let { cursor } = events_1.default;\n        if (textRange.preCount > 0 && cursor.bufnr == doc.bufnr && textRange.line + 1 == cursor.lnum) {\n            let changed = textRange.preCount * (newText.length - (range.end.character - range.start.character));\n            nvim.call('cursor', [cursor.lnum, cursor.col + changed], true);\n        }\n        this.doHighlights();\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        nvim.resumeNotification(false, true);\n    }\n    applyComposedEdit(original, edit) {\n        // check complex edit\n        let { range, newText } = edit;\n        let { ranges } = this;\n        let doc = vscode_languageserver_textdocument_1.TextDocument.create('file:///1', '', 0, original);\n        let edits = [];\n        let diffs = fast_diff_1.default(original, newText);\n        let offset = 0;\n        for (let i = 0; i < diffs.length; i++) {\n            let diff = diffs[i];\n            let pos = util_1.adjustPosition(range.start, doc.positionAt(offset));\n            if (diff[0] == fast_diff_1.default.EQUAL) {\n                offset = offset + diff[1].length;\n            }\n            else if (diff[0] == fast_diff_1.default.DELETE) {\n                let end = util_1.adjustPosition(range.start, doc.positionAt(offset + diff[1].length));\n                if (diffs[i + 1] && diffs[i + 1][0] == fast_diff_1.default.INSERT) {\n                    // change\n                    edits.push({ range: vscode_languageserver_protocol_1.Range.create(pos, end), newText: diffs[i + 1][1] });\n                    i = i + 1;\n                }\n                else {\n                    // delete\n                    edits.push({ range: vscode_languageserver_protocol_1.Range.create(pos, end), newText: '' });\n                }\n                offset = offset + diff[1].length;\n            }\n            else if (diff[0] == fast_diff_1.default.INSERT) {\n                edits.push({ range: vscode_languageserver_protocol_1.Range.create(pos, pos), newText: diff[1] });\n            }\n        }\n        if (edits.some(edit => edit.newText.includes('\\n') || edit.range.start.line != edit.range.end.line)) {\n            this.cancel();\n            return;\n        }\n        if (edits.length == ranges.length) {\n            let last;\n            for (let i = 0; i < edits.length; i++) {\n                let edit = edits[i];\n                let textRange = this.ranges[i];\n                if (!position_1.rangeIntersect(textRange.currRange, edit.range)) {\n                    this.cancel();\n                    return;\n                }\n                if (last && !util_1.equalEdit(edit, last)) {\n                    this.cancel();\n                    return;\n                }\n                textRange.applyEdit(edit);\n                last = edit;\n            }\n        }\n        else if (edits.length == ranges.length * 2) {\n            for (let i = 0; i < edits.length - 1; i = i + 2) {\n                let edit = edits[i];\n                let next = edits[i + 1];\n                if (edit.newText.length == 0 && next.newText.length == 0) {\n                    // remove begin & end\n                    let textRange = this.ranges[i / 2];\n                    if (position_1.comparePosition(textRange.currRange.end, next.range.end) != 0) {\n                        this.cancel();\n                        return;\n                    }\n                    let start = edit.range.start.character - textRange.currRange.start.character;\n                    textRange.replace(start, edit.range.end.character - edit.range.start.character, '');\n                    let offset = next.range.end.character - next.range.start.character;\n                    let len = textRange.text.length;\n                    textRange.replace(len - offset, len);\n                }\n                else if (position_1.emptyRange(edit.range) && position_1.emptyRange(next.range)) {\n                    // add begin & end\n                    let textRange = this.ranges[i / 2];\n                    if (position_1.comparePosition(textRange.currRange.end, next.range.start) != 0) {\n                        this.cancel();\n                        return;\n                    }\n                    let start = edit.range.start.character - textRange.currRange.start.character;\n                    textRange.add(start, edit.newText);\n                    let len = textRange.text.length;\n                    textRange.add(len, next.newText);\n                }\n                else {\n                    this.cancel();\n                    return;\n                }\n            }\n        }\n        else {\n            this.cancel();\n            return;\n        }\n        this.doHighlights();\n    }\n}\nexports.default = CursorSession;\n\n\n//# sourceURL=webpack://coc.nvim/./src/cursors/session.ts?");

/***/ }),

/***/ "./src/cursors/util.ts":
/*!*****************************!*\
  !*** ./src/cursors/util.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.equalEdit = exports.adjustPosition = exports.getVisualRanges = exports.splitRange = void 0;\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\n/**\n * Split to single line ranges\n */\nfunction splitRange(doc, range) {\n    let splited = [];\n    for (let i = range.start.line; i <= range.end.line; i++) {\n        let curr = doc.getline(i) || '';\n        let sc = i == range.start.line ? range.start.character : 0;\n        let ec = i == range.end.line ? range.end.character : curr.length;\n        if (sc == ec)\n            continue;\n        splited.push(vscode_languageserver_protocol_1.Range.create(i, sc, i, ec));\n    }\n    return splited;\n}\nexports.splitRange = splitRange;\n/**\n * Get ranges of visual block\n */\nfunction getVisualRanges(doc, range) {\n    let { start, end } = range;\n    if (start.line > end.line) {\n        [start, end] = [end, start];\n    }\n    let sc = start.character < end.character ? start.character : end.character;\n    let ec = start.character < end.character ? end.character : start.character;\n    let ranges = [];\n    for (let i = start.line; i <= end.line; i++) {\n        let line = doc.getline(i);\n        ranges.push(vscode_languageserver_protocol_1.Range.create(i, sc, i, Math.min(line.length, ec)));\n    }\n    return ranges;\n}\nexports.getVisualRanges = getVisualRanges;\nfunction adjustPosition(position, delta) {\n    let { line, character } = delta;\n    return vscode_languageserver_protocol_1.Position.create(position.line + line, line == 0 ? position.character + character : character);\n}\nexports.adjustPosition = adjustPosition;\nfunction equalEdit(one, two) {\n    if (one.newText.length != two.newText.length)\n        return false;\n    let { range } = one;\n    if (range.end.character - range.start.character != two.range.end.character - two.range.start.character) {\n        return false;\n    }\n    return true;\n}\nexports.equalEdit = equalEdit;\n\n\n//# sourceURL=webpack://coc.nvim/./src/cursors/util.ts?");

/***/ }),

/***/ "./src/diagnostic/buffer.ts":
/*!**********************************!*\
  !*** ./src/diagnostic/buffer.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DiagnosticBuffer = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst debounce_1 = tslib_1.__importDefault(__webpack_require__(/*! debounce */ \"./node_modules/debounce/index.js\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/diagnostic/util.ts\");\nconst object_1 = __webpack_require__(/*! ../util/object */ \"./src/util/object.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('diagnostic-buffer');\nconst signGroup = 'CocDiagnostic';\n/**\n * Manage diagnostics of buffer, including:\n *\n * - highlights\n * - variable\n * - signs\n * - location list\n * - virtual text\n */\nclass DiagnosticBuffer {\n    constructor(nvim, bufnr, uri, config, onRefresh) {\n        this.nvim = nvim;\n        this.bufnr = bufnr;\n        this.uri = uri;\n        this.config = config;\n        this.onRefresh = onRefresh;\n        this.diagnostics = [];\n        this._disposed = false;\n        this.refresh = debounce_1.default((diagnostics) => {\n            this._refresh(diagnostics).logError();\n        }, 300);\n    }\n    get displayByAle() {\n        return this.config.displayByAle;\n    }\n    onChange() {\n        this.refresh.clear();\n    }\n    /**\n     * Refresh diagnostics without debounce\n     */\n    forceRefresh(diagnostics) {\n        this.refresh.clear();\n        this._refresh(diagnostics).logError();\n    }\n    refreshAle(diagnostics) {\n        let collections = getCollections(this.diagnostics);\n        this.diagnostics = diagnostics;\n        let map = new Map();\n        diagnostics.forEach(o => {\n            let exists = map.get(o.collection) || [];\n            exists.push(o);\n            map.set(o.collection, exists);\n        });\n        // clear old collection.\n        for (let name of collections) {\n            if (!map.has(name)) {\n                map.set(name, []);\n            }\n        }\n        this.nvim.pauseNotification();\n        for (let [collection, diagnostics] of map.entries()) {\n            let aleItems = diagnostics.map(o => {\n                let range = o.range || vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0);\n                return {\n                    text: o.message,\n                    code: o.code,\n                    lnum: range.start.line + 1,\n                    col: range.start.character + 1,\n                    end_lnum: range.end.line + 1,\n                    end_col: range.end.character,\n                    type: util_1.getSeverityType(o.severity)\n                };\n            });\n            let method = global.hasOwnProperty('__TEST__') ? 'MockAleResults' : 'ale#other_source#ShowResults';\n            this.nvim.call(method, [this.bufnr, collection, aleItems], true);\n        }\n        this.nvim.resumeNotification().then(res => {\n            if (Array.isArray(res) && res[1] != null) {\n                logger.error(`Error on displayByAle:`, res[1][2]);\n            }\n        }).logError();\n    }\n    async _refresh(diagnostics) {\n        if (object_1.equals(this.diagnostics, diagnostics))\n            return;\n        let { refreshOnInsertMode } = this.config;\n        let { nvim } = this;\n        let arr = await nvim.eval(`[coc#util#check_refresh(${this.bufnr}),mode(),line(\".\"),getloclist(bufwinid(${this.bufnr}),{'title':1})]`);\n        if (arr[0] == 0 || this._disposed)\n            return;\n        let mode = arr[1];\n        if (!refreshOnInsertMode && mode.startsWith('i') && diagnostics.length)\n            return;\n        if (this.displayByAle) {\n            this.refreshAle(diagnostics);\n        }\n        else {\n            this.diagnostics = diagnostics;\n            let lnum = arr[2];\n            nvim.pauseNotification();\n            this.setDiagnosticInfo(diagnostics);\n            this.addSigns(diagnostics);\n            this.addHighlight(diagnostics);\n            this.updateLocationList(arr[3], diagnostics);\n            this.showVirtualText(diagnostics, lnum);\n            if (workspace_1.default.isVim)\n                this.nvim.command('redraw', true);\n            let res = await this.nvim.resumeNotification();\n            if (Array.isArray(res) && res[1])\n                throw new Error(res[1]);\n        }\n        this.onRefresh(diagnostics);\n    }\n    updateLocationList(curr, diagnostics) {\n        if (!this.config.locationlistUpdate)\n            return;\n        if (!curr || curr.title !== 'Diagnostics of coc')\n            return;\n        let items = [];\n        for (let diagnostic of diagnostics) {\n            let item = util_1.getLocationListItem(this.bufnr, diagnostic);\n            items.push(item);\n        }\n        this.nvim.call('setloclist', [0, [], 'r', { title: 'Diagnostics of coc', items }], true);\n    }\n    addSigns(diagnostics) {\n        if (!this.config.enableSign)\n            return;\n        this.clearSigns();\n        let { nvim, bufnr } = this;\n        for (let diagnostic of diagnostics) {\n            let { range, severity } = diagnostic;\n            let line = range.start.line;\n            let name = util_1.getNameFromSeverity(severity);\n            nvim.call('sign_place', [0, signGroup, name, bufnr, { lnum: line + 1, priority: 14 - severity }], true);\n        }\n    }\n    clearSigns() {\n        let { nvim, bufnr } = this;\n        nvim.call('sign_unplace', [signGroup, { buffer: bufnr }], true);\n    }\n    setDiagnosticInfo(diagnostics) {\n        let lnums = [0, 0, 0, 0];\n        let info = { error: 0, warning: 0, information: 0, hint: 0, lnums };\n        for (let diagnostic of diagnostics) {\n            switch (diagnostic.severity) {\n                case vscode_languageserver_protocol_1.DiagnosticSeverity.Warning:\n                    info.warning = info.warning + 1;\n                    lnums[1] = lnums[1] || diagnostic.range.start.line + 1;\n                    break;\n                case vscode_languageserver_protocol_1.DiagnosticSeverity.Information:\n                    info.information = info.information + 1;\n                    lnums[2] = lnums[2] || diagnostic.range.start.line + 1;\n                    break;\n                case vscode_languageserver_protocol_1.DiagnosticSeverity.Hint:\n                    info.hint = info.hint + 1;\n                    lnums[3] = lnums[3] || diagnostic.range.start.line + 1;\n                    break;\n                default:\n                    lnums[0] = lnums[0] || diagnostic.range.start.line + 1;\n                    info.error = info.error + 1;\n            }\n        }\n        this.nvim.call('coc#util#set_buf_var', [this.bufnr, 'coc_diagnostic_info', info], true);\n        this.nvim.call('coc#util#do_autocmd', ['CocDiagnosticChange'], true);\n    }\n    showVirtualText(diagnostics, lnum) {\n        let { buffer, config } = this;\n        if (!config.virtualText)\n            return;\n        let srcId = this.config.virtualTextSrcId;\n        let prefix = this.config.virtualTextPrefix;\n        if (this.config.virtualTextCurrentLineOnly) {\n            diagnostics = diagnostics.filter(d => {\n                let { start, end } = d.range;\n                return start.line <= lnum - 1 && end.line >= lnum - 1;\n            });\n        }\n        buffer.clearNamespace(srcId);\n        for (let diagnostic of diagnostics) {\n            let { line } = diagnostic.range.start;\n            let highlight = util_1.getNameFromSeverity(diagnostic.severity) + 'VirtualText';\n            let msg = diagnostic.message.split(/\\n/)\n                .map((l) => l.trim())\n                .filter((l) => l.length > 0)\n                .slice(0, this.config.virtualTextLines)\n                .join(this.config.virtualTextLineSeparator);\n            buffer.setVirtualText(srcId, line, [[prefix + msg, highlight]], {}).logError();\n        }\n    }\n    addHighlight(diagnostics) {\n        if (workspace_1.default.isVim && !workspace_1.default.env.textprop)\n            return;\n        this.clearHighlight();\n        if (diagnostics.length == 0)\n            return;\n        // can't add highlight for old vim\n        // TODO support DiagnosticTag, fade unnecessary ranges.\n        const highlights = new Map();\n        for (let diagnostic of diagnostics) {\n            let { range, severity } = diagnostic;\n            let ranges = highlights.get(severity) || [];\n            ranges.push(range);\n            highlights.set(severity, ranges);\n        }\n        for (let severity of [vscode_languageserver_protocol_1.DiagnosticSeverity.Hint, vscode_languageserver_protocol_1.DiagnosticSeverity.Information, vscode_languageserver_protocol_1.DiagnosticSeverity.Warning, vscode_languageserver_protocol_1.DiagnosticSeverity.Error]) {\n            let ranges = highlights.get(severity) || [];\n            let hlGroup = util_1.getNameFromSeverity(severity) + 'Highlight';\n            this.buffer.highlightRanges('diagnostic', hlGroup, ranges);\n        }\n    }\n    clearHighlight() {\n        this.buffer.clearNamespace('diagnostic');\n    }\n    get buffer() {\n        return this.nvim.createBuffer(this.bufnr);\n    }\n    /**\n     * Clear all diagnostics from UI.\n     */\n    clear() {\n        this.refresh.clear();\n        let { nvim } = this;\n        if (this.displayByAle) {\n            let collections = getCollections(this.diagnostics);\n            this.diagnostics = [];\n            if (collections.size > 0) {\n                for (let collection of collections) {\n                    let method = global.hasOwnProperty('__TEST__') ? 'MockAleResults' : 'ale#other_source#ShowResults';\n                    this.nvim.call(method, [this.bufnr, collection, []], true);\n                }\n            }\n        }\n        else {\n            this.diagnostics = [];\n            nvim.pauseNotification();\n            this.clearHighlight();\n            if (this.config.enableSign) {\n                this.clearSigns();\n            }\n            if (this.config.virtualText) {\n                this.buffer.clearNamespace(this.config.virtualTextSrcId);\n            }\n            this.setDiagnosticInfo([]);\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            nvim.resumeNotification(false, true);\n        }\n    }\n    dispose() {\n        this._disposed = true;\n        this.clear();\n    }\n}\nexports.DiagnosticBuffer = DiagnosticBuffer;\nfunction getCollections(diagnostics) {\n    let res = new Set();\n    diagnostics.forEach(o => {\n        res.add(o.collection);\n    });\n    return res;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./src/diagnostic/buffer.ts?");

/***/ }),

/***/ "./src/diagnostic/collection.ts":
/*!**************************************!*\
  !*** ./src/diagnostic/collection.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst position_1 = __webpack_require__(/*! ../util/position */ \"./src/util/position.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('diagnostic-collection');\nclass Collection {\n    constructor(owner) {\n        this.diagnosticsMap = new Map();\n        this._onDispose = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidDiagnosticsChange = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidDiagnosticsClear = new vscode_languageserver_protocol_1.Emitter();\n        this.onDispose = this._onDispose.event;\n        this.onDidDiagnosticsChange = this._onDidDiagnosticsChange.event;\n        this.onDidDiagnosticsClear = this._onDidDiagnosticsClear.event;\n        this.name = owner;\n    }\n    set(entries, diagnostics) {\n        let diagnosticsPerFile = new Map();\n        if (!Array.isArray(entries)) {\n            let doc = workspace_1.default.getDocument(entries);\n            let uri = doc ? doc.uri : entries;\n            diagnosticsPerFile.set(uri, diagnostics || []);\n        }\n        else {\n            for (let item of entries) {\n                let [uri, diagnostics] = item;\n                let doc = workspace_1.default.getDocument(uri);\n                uri = doc ? doc.uri : uri;\n                if (diagnostics == null) {\n                    // clear previous diagnostics if entry contains null\n                    diagnostics = [];\n                }\n                else {\n                    diagnostics = (diagnosticsPerFile.get(uri) || []).concat(diagnostics);\n                }\n                diagnosticsPerFile.set(uri, diagnostics);\n            }\n        }\n        for (let item of diagnosticsPerFile) {\n            let [uri, diagnostics] = item;\n            uri = vscode_uri_1.URI.parse(uri).toString();\n            diagnostics.forEach(o => {\n                o.range = o.range || vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0);\n                o.message = o.message || 'Empty error message';\n                if (position_1.emptyRange(o.range)) {\n                    o.range.end = {\n                        line: o.range.end.line,\n                        character: o.range.end.character + 1\n                    };\n                }\n                let { start, end } = o.range;\n                // fix empty diagnostic at the and of line\n                if (end.character == 0 && end.line - start.line == 1 && start.character > 0) {\n                    // add last character when start character is end\n                    let doc = workspace_1.default.getDocument(uri);\n                    if (doc) {\n                        let line = doc.getline(start.line);\n                        if (start.character == line.length) {\n                            o.range.start.character = start.character - 1;\n                        }\n                    }\n                }\n                o.source = o.source || this.name;\n            });\n            this.diagnosticsMap.set(uri, diagnostics);\n            this._onDidDiagnosticsChange.fire(uri);\n        }\n        return;\n    }\n    delete(uri) {\n        this.diagnosticsMap.delete(uri);\n    }\n    clear() {\n        let uris = Array.from(this.diagnosticsMap.keys());\n        this.diagnosticsMap.clear();\n        this._onDidDiagnosticsClear.fire(uris);\n    }\n    forEach(callback, thisArg) {\n        for (let uri of this.diagnosticsMap.keys()) {\n            let diagnostics = this.diagnosticsMap.get(uri);\n            callback.call(thisArg, uri, diagnostics, this);\n        }\n    }\n    get(uri) {\n        let arr = this.diagnosticsMap.get(uri);\n        return arr == null ? [] : arr;\n    }\n    has(uri) {\n        return this.diagnosticsMap.has(uri);\n    }\n    dispose() {\n        this.clear();\n        this._onDispose.fire(void 0);\n        this._onDispose.dispose();\n        this._onDidDiagnosticsClear.dispose();\n        this._onDidDiagnosticsChange.dispose();\n    }\n}\nexports.default = Collection;\n\n\n//# sourceURL=webpack://coc.nvim/./src/diagnostic/collection.ts?");

/***/ }),

/***/ "./src/diagnostic/manager.ts":
/*!***********************************!*\
  !*** ./src/diagnostic/manager.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DiagnosticManager = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst debounce_1 = tslib_1.__importDefault(__webpack_require__(/*! debounce */ \"./node_modules/debounce/index.js\"));\nconst semver_1 = tslib_1.__importDefault(__webpack_require__(/*! semver */ \"./node_modules/semver/index.js\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nconst floatFactory_1 = tslib_1.__importDefault(__webpack_require__(/*! ../model/floatFactory */ \"./src/model/floatFactory.ts\"));\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst position_1 = __webpack_require__(/*! ../util/position */ \"./src/util/position.ts\");\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst buffer_1 = __webpack_require__(/*! ./buffer */ \"./src/diagnostic/buffer.ts\");\nconst collection_1 = tslib_1.__importDefault(__webpack_require__(/*! ./collection */ \"./src/diagnostic/collection.ts\"));\nconst util_2 = __webpack_require__(/*! ./util */ \"./src/diagnostic/util.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('diagnostic-manager');\nclass DiagnosticManager {\n    constructor() {\n        this.enabled = true;\n        this._onDidRefresh = new vscode_languageserver_protocol_1.Emitter();\n        this.onDidRefresh = this._onDidRefresh.event;\n        this.lastMessage = '';\n        this.collections = [];\n        this.disposables = [];\n    }\n    init() {\n        this.setConfiguration();\n        workspace_1.default.onDidChangeConfiguration(e => {\n            this.setConfiguration(e);\n        }, null, this.disposables);\n        this.floatFactory = new floatFactory_1.default(this.nvim);\n        this.buffers = workspace_1.default.registerBufferSync(doc => {\n            if (doc.buftype !== '')\n                return undefined;\n            let buf = new buffer_1.DiagnosticBuffer(this.nvim, doc.bufnr, doc.uri, this.config, diagnostics => {\n                this._onDidRefresh.fire({ diagnostics, uri: buf.uri, bufnr: buf.bufnr });\n                if (['never', 'jump'].includes(this.config.enableMessage)) {\n                    return;\n                }\n                this.echoMessage(true).logError();\n            });\n            let diagnostics = this.getDiagnostics(doc.uri);\n            if (this.enabled)\n                buf.forceRefresh(diagnostics);\n            return buf;\n        });\n        events_1.default.on('CursorMoved', bufnr => {\n            if (this.config.enableMessage != 'always')\n                return;\n            if (this.timer)\n                clearTimeout(this.timer);\n            if (bufnr == this.floatFactory.bufnr)\n                return;\n            this.timer = setTimeout(async () => {\n                await this.echoMessage(true);\n            }, this.config.messageDelay);\n        }, null, this.disposables);\n        let fn = debounce_1.default((bufnr, cursor) => {\n            if (!this.config.virtualText || !this.config.virtualTextCurrentLineOnly) {\n                return;\n            }\n            let buf = this.buffers.getItem(bufnr);\n            if (buf) {\n                let diagnostics = this.getDiagnostics(buf.uri);\n                buf.showVirtualText(diagnostics, cursor[0]);\n            }\n        }, 100);\n        events_1.default.on('CursorMoved', fn, null, this.disposables);\n        this.disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {\n            fn.clear();\n        }));\n        events_1.default.on('InsertLeave', async (bufnr) => {\n            if (!this.config.refreshOnInsertMode) {\n                this.refreshBuffer(bufnr);\n            }\n        }, null, this.disposables);\n        events_1.default.on('BufEnter', async () => {\n            if (this.timer)\n                clearTimeout(this.timer);\n        }, null, this.disposables);\n        this.setConfigurationErrors(true);\n        workspace_1.default.configurations.onError(() => {\n            this.setConfigurationErrors();\n        }, null, this.disposables);\n    }\n    defineSigns() {\n        let { nvim } = this;\n        let { enableHighlightLineNumber, enableSign } = this.config;\n        if (!enableSign)\n            return;\n        nvim.pauseNotification();\n        for (let kind of ['Error', 'Warning', 'Info', 'Hint']) {\n            let signText = this.config[kind.toLowerCase() + 'Sign'];\n            let cmd = `sign define Coc${kind} linehl=Coc${kind}Line`;\n            if (signText)\n                cmd += ` texthl=Coc${kind}Sign text=${signText}`;\n            if (enableHighlightLineNumber)\n                cmd += ` numhl=Coc${kind}Sign`;\n            nvim.command(cmd, true);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        nvim.resumeNotification(false, true);\n    }\n    /**\n     * Fill location list with diagnostics\n     */\n    async setLocationlist(bufnr) {\n        let buf = this.buffers.getItem(bufnr);\n        let diagnostics = buf ? this.getDiagnostics(buf.uri) : [];\n        let items = [];\n        for (let diagnostic of diagnostics) {\n            let item = util_2.getLocationListItem(bufnr, diagnostic);\n            items.push(item);\n        }\n        let curr = await this.nvim.call('getloclist', [0, { title: 1 }]);\n        let action = curr.title && curr.title.indexOf('Diagnostics of coc') != -1 ? 'r' : ' ';\n        await this.nvim.call('setloclist', [0, [], action, { title: 'Diagnostics of coc', items }]);\n    }\n    setConfigurationErrors(init) {\n        let collections = this.collections;\n        let collection = collections.find(o => o.name == 'config');\n        if (!collection) {\n            collection = this.create('config');\n        }\n        else {\n            collection.clear();\n        }\n        let { errorItems } = workspace_1.default.configurations;\n        if (errorItems && errorItems.length) {\n            if (init)\n                window_1.default.showMessage(`settings file parse error, run ':CocList diagnostics'`, 'error');\n            let entries = new Map();\n            for (let item of errorItems) {\n                let { uri } = item.location;\n                let diagnostics = entries.get(uri) || [];\n                diagnostics.push(vscode_languageserver_protocol_1.Diagnostic.create(item.location.range, item.message, vscode_languageserver_protocol_1.DiagnosticSeverity.Error));\n                entries.set(uri, diagnostics);\n            }\n            collection.set(Array.from(entries));\n        }\n    }\n    /**\n     * Create collection by name\n     */\n    create(name) {\n        let collection = this.getCollectionByName(name);\n        if (collection)\n            return collection;\n        collection = new collection_1.default(name);\n        this.collections.push(collection);\n        collection.onDidDiagnosticsChange(uri => {\n            this.refreshBuffer(uri);\n        });\n        collection.onDidDiagnosticsClear(uris => {\n            for (let uri of uris) {\n                this.refreshBuffer(uri, true);\n            }\n        });\n        collection.onDispose(() => {\n            let idx = this.collections.findIndex(o => o == collection);\n            if (idx !== -1)\n                this.collections.splice(idx, 1);\n        });\n        return collection;\n    }\n    /**\n     * Get diagnostics ranges from document\n     */\n    getSortedRanges(uri, severity) {\n        let collections = this.getCollections(uri);\n        let res = [];\n        let level = severity ? util_2.severityLevel(severity) : 0;\n        for (let collection of collections) {\n            let diagnostics = collection.get(uri);\n            if (level)\n                diagnostics = diagnostics.filter(o => o.severity == level);\n            let ranges = diagnostics.map(o => o.range);\n            res.push(...ranges);\n        }\n        res.sort((a, b) => {\n            if (a.start.line != b.start.line) {\n                return a.start.line - b.start.line;\n            }\n            return a.start.character - b.start.character;\n        });\n        return res;\n    }\n    /**\n     * Get readonly diagnostics for a buffer\n     */\n    getDiagnostics(uri) {\n        let collections = this.getCollections(uri);\n        let { level, showUnused, showDeprecated } = this.config;\n        let res = [];\n        for (let collection of collections) {\n            let items = collection.get(uri);\n            if (!items)\n                continue;\n            items = items.filter(d => {\n                var _a, _b;\n                if (level && level < vscode_languageserver_protocol_1.DiagnosticSeverity.Hint && d.severity && d.severity > level) {\n                    return false;\n                }\n                if (!showUnused && ((_a = d.tags) === null || _a === void 0 ? void 0 : _a.includes(vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary))) {\n                    return false;\n                }\n                if (!showDeprecated && ((_b = d.tags) === null || _b === void 0 ? void 0 : _b.includes(vscode_languageserver_protocol_1.DiagnosticTag.Deprecated))) {\n                    return false;\n                }\n                return true;\n            });\n            items.forEach(item => {\n                res.push(Object.assign({ collection: collection.name }, item));\n            });\n        }\n        res.sort((a, b) => {\n            if (a.severity == b.severity) {\n                let d = position_1.comparePosition(a.range.start, b.range.start);\n                if (d != 0)\n                    return d;\n                if (a.source == b.source)\n                    return a.message > b.message ? 1 : -1;\n                return a.source > b.source ? 1 : -1;\n            }\n            return a.severity - b.severity;\n        });\n        return res;\n    }\n    getDiagnosticsInRange(document, range) {\n        let collections = this.getCollections(document.uri);\n        let res = [];\n        for (let collection of collections) {\n            let items = collection.get(document.uri);\n            if (!items)\n                continue;\n            for (let item of items) {\n                if (position_1.rangeIntersect(item.range, range)) {\n                    res.push(item);\n                }\n            }\n        }\n        return res;\n    }\n    /**\n     * Show diagnostics under curosr in preview window\n     */\n    async preview() {\n        let [bufnr, cursor] = await this.nvim.eval('[bufnr(\"%\"),coc#util#cursor()]');\n        let { nvim } = this;\n        let diagnostics = this.getDiagnosticsAt(bufnr, cursor);\n        if (diagnostics.length == 0) {\n            nvim.command('pclose', true);\n            window_1.default.showMessage(`Empty diagnostics`, 'warning');\n            return;\n        }\n        let lines = [];\n        for (let diagnostic of diagnostics) {\n            let { source, code, severity, message } = diagnostic;\n            let s = util_2.getSeverityName(severity)[0];\n            lines.push(`[${source}${code ? ' ' + code : ''}] [${s}]`);\n            lines.push(...message.split(/\\r?\\n/));\n            lines.push('');\n        }\n        lines = lines.slice(0, -1);\n        // let content = lines.join('\\n').trim()\n        nvim.call('coc#util#preview_info', [lines, 'txt'], true);\n    }\n    /**\n     * Jump to previous diagnostic position\n     */\n    async jumpPrevious(severity) {\n        let buffer = await this.nvim.buffer;\n        let document = workspace_1.default.getDocument(buffer.id);\n        if (!document)\n            return;\n        let curpos = await window_1.default.getCursorPosition();\n        let ranges = this.getSortedRanges(document.uri, severity);\n        if (ranges.length == 0) {\n            window_1.default.showMessage('Empty diagnostics', 'warning');\n            return;\n        }\n        let pos;\n        for (let i = ranges.length - 1; i >= 0; i--) {\n            let end = ranges[i].end;\n            if (position_1.comparePosition(end, curpos) < 0) {\n                pos = ranges[i].start;\n                break;\n            }\n            else if (i == 0) {\n                let wrapscan = await this.nvim.getOption('wrapscan');\n                if (wrapscan)\n                    pos = ranges[ranges.length - 1].start;\n            }\n        }\n        if (pos) {\n            await window_1.default.moveTo(pos);\n            if (this.config.enableMessage == 'never')\n                return;\n            await this.echoMessage(false);\n        }\n    }\n    /**\n     * Jump to next diagnostic position\n     */\n    async jumpNext(severity) {\n        let buffer = await this.nvim.buffer;\n        let document = workspace_1.default.getDocument(buffer.id);\n        let curpos = await window_1.default.getCursorPosition();\n        let ranges = this.getSortedRanges(document.uri, severity);\n        if (ranges.length == 0) {\n            window_1.default.showMessage('Empty diagnostics', 'warning');\n            return;\n        }\n        let pos;\n        for (let i = 0; i <= ranges.length - 1; i++) {\n            let start = ranges[i].start;\n            if (position_1.comparePosition(start, curpos) > 0) {\n                pos = ranges[i].start;\n                break;\n            }\n            else if (i == ranges.length - 1) {\n                let wrapscan = await this.nvim.getOption('wrapscan');\n                if (wrapscan)\n                    pos = ranges[0].start;\n            }\n        }\n        if (pos) {\n            await window_1.default.moveTo(pos);\n            if (this.config.enableMessage == 'never')\n                return;\n            await this.echoMessage(false);\n        }\n    }\n    /**\n     * All diagnostics of current workspace\n     */\n    getDiagnosticList() {\n        let res = [];\n        const { level, showUnused, showDeprecated } = this.config;\n        for (let collection of this.collections) {\n            collection.forEach((uri, diagnostics) => {\n                var _a, _b;\n                let file = vscode_uri_1.URI.parse(uri).fsPath;\n                for (let diagnostic of diagnostics) {\n                    if (diagnostic.severity && diagnostic.severity > level) {\n                        continue;\n                    }\n                    if (!showUnused && ((_a = diagnostic.tags) === null || _a === void 0 ? void 0 : _a.includes(vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary))) {\n                        continue;\n                    }\n                    if (!showDeprecated && ((_b = diagnostic.tags) === null || _b === void 0 ? void 0 : _b.includes(vscode_languageserver_protocol_1.DiagnosticTag.Deprecated))) {\n                        continue;\n                    }\n                    let { start } = diagnostic.range;\n                    let o = {\n                        file,\n                        lnum: start.line + 1,\n                        col: start.character + 1,\n                        code: diagnostic.code,\n                        source: diagnostic.source || collection.name,\n                        message: diagnostic.message,\n                        severity: util_2.getSeverityName(diagnostic.severity),\n                        level: diagnostic.severity || 0,\n                        location: vscode_languageserver_protocol_1.Location.create(uri, diagnostic.range)\n                    };\n                    res.push(o);\n                }\n            });\n        }\n        res.sort((a, b) => {\n            if (a.level !== b.level) {\n                return a.level - b.level;\n            }\n            if (a.file !== b.file) {\n                return a.file > b.file ? 1 : -1;\n            }\n            else {\n                if (a.lnum != b.lnum) {\n                    return a.lnum - b.lnum;\n                }\n                return a.col - b.col;\n            }\n        });\n        return res;\n    }\n    getDiagnosticsAt(bufnr, cursor) {\n        let pos = vscode_languageserver_protocol_1.Position.create(cursor[0], cursor[1]);\n        let buffer = this.buffers.getItem(bufnr);\n        if (!buffer)\n            return [];\n        let diagnostics = this.getDiagnostics(buffer.uri);\n        let { checkCurrentLine } = this.config;\n        if (checkCurrentLine) {\n            diagnostics = diagnostics.filter(o => position_1.lineInRange(pos.line, o.range));\n        }\n        else {\n            diagnostics = diagnostics.filter(o => position_1.positionInRange(pos, o.range) == 0);\n        }\n        diagnostics.sort((a, b) => a.severity - b.severity);\n        return diagnostics;\n    }\n    async getCurrentDiagnostics() {\n        let [bufnr, cursor] = await this.nvim.eval('[bufnr(\"%\"),coc#util#cursor()]');\n        return this.getDiagnosticsAt(bufnr, cursor);\n    }\n    /**\n     * Echo diagnostic message of currrent position\n     */\n    async echoMessage(truncate = false) {\n        const config = this.config;\n        if (!this.enabled || config.displayByAle)\n            return;\n        if (this.timer)\n            clearTimeout(this.timer);\n        let useFloat = config.messageTarget == 'float';\n        let [bufnr, cursor, filetype, mode] = await this.nvim.eval('[bufnr(\"%\"),coc#util#cursor(),&filetype,mode()]');\n        if (mode != 'n')\n            return;\n        let diagnostics = this.getDiagnosticsAt(bufnr, cursor);\n        if (diagnostics.length == 0) {\n            if (useFloat) {\n                this.floatFactory.close();\n            }\n            else {\n                let echoLine = await this.nvim.call('coc#util#echo_line');\n                if (this.lastMessage && echoLine.startsWith(this.lastMessage)) {\n                    this.nvim.command('echo \"\"', true);\n                }\n            }\n            return;\n        }\n        if (truncate && workspace_1.default.insertMode)\n            return;\n        let docs = [];\n        let ft = '';\n        if (Object.keys(config.filetypeMap).length > 0) {\n            const defaultFiletype = config.filetypeMap['default'] || '';\n            ft = config.filetypeMap[filetype] || (defaultFiletype == 'bufferType' ? filetype : defaultFiletype);\n        }\n        diagnostics.forEach(diagnostic => {\n            let { source, code, severity, message } = diagnostic;\n            let s = util_2.getSeverityName(severity)[0];\n            const codeStr = code ? ' ' + code : '';\n            const str = config.format.replace('%source', source).replace('%code', codeStr).replace('%severity', s).replace('%message', message);\n            let filetype = 'Error';\n            if (ft === '') {\n                switch (severity) {\n                    case vscode_languageserver_protocol_1.DiagnosticSeverity.Hint:\n                        filetype = 'Hint';\n                        break;\n                    case vscode_languageserver_protocol_1.DiagnosticSeverity.Warning:\n                        filetype = 'Warning';\n                        break;\n                    case vscode_languageserver_protocol_1.DiagnosticSeverity.Information:\n                        filetype = 'Info';\n                        break;\n                }\n            }\n            else {\n                filetype = ft;\n            }\n            docs.push({ filetype, content: str });\n        });\n        if (useFloat) {\n            let { maxWindowHeight, maxWindowWidth } = this.config;\n            await this.floatFactory.show(docs, { maxWidth: maxWindowWidth, maxHeight: maxWindowHeight, modes: ['n'] });\n        }\n        else {\n            let lines = docs.map(d => d.content).join('\\n').split(/\\r?\\n/);\n            if (lines.length) {\n                await this.nvim.command('echo \"\"');\n                this.lastMessage = lines[0].slice(0, 30);\n                await window_1.default.echoLines(lines, truncate);\n            }\n        }\n    }\n    async jumpRelated() {\n        let diagnostics = await this.getCurrentDiagnostics();\n        if (!diagnostics)\n            return;\n        let diagnostic = diagnostics.find(o => o.relatedInformation != null);\n        if (!diagnostic)\n            return;\n        let locations = diagnostic.relatedInformation.map(o => o.location);\n        if (locations.length == 1) {\n            await workspace_1.default.jumpTo(locations[0].uri, locations[0].range.start);\n        }\n        else if (locations.length > 1) {\n            await workspace_1.default.showLocations(locations);\n        }\n    }\n    reset() {\n        if (this.timer) {\n            clearTimeout(this.timer);\n        }\n        this.buffers.reset();\n        for (let collection of this.collections) {\n            collection.dispose();\n        }\n        this.collections = [];\n    }\n    dispose() {\n        var _a;\n        this.buffers.dispose();\n        if (this.timer) {\n            clearTimeout(this.timer);\n        }\n        for (let collection of this.collections) {\n            collection.dispose();\n        }\n        (_a = this.floatFactory) === null || _a === void 0 ? void 0 : _a.close();\n        this.collections = [];\n        util_1.disposeAll(this.disposables);\n    }\n    get nvim() {\n        return workspace_1.default.nvim;\n    }\n    setConfiguration(event) {\n        if (event && !event.affectsConfiguration('diagnostic'))\n            return;\n        let config = workspace_1.default.getConfiguration('diagnostic');\n        let messageTarget = config.get('messageTarget', 'float');\n        if (messageTarget == 'float' && !workspace_1.default.env.floating && !workspace_1.default.env.textprop) {\n            messageTarget = 'echo';\n        }\n        let enableHighlightLineNumber = config.get('enableHighlightLineNumber', true);\n        if (!workspace_1.default.isNvim || semver_1.default.lt(workspace_1.default.env.version, 'v0.3.2')) {\n            enableHighlightLineNumber = false;\n        }\n        this.config = {\n            messageTarget,\n            enableHighlightLineNumber,\n            virtualTextSrcId: workspace_1.default.createNameSpace('diagnostic-virtualText'),\n            checkCurrentLine: config.get('checkCurrentLine', false),\n            enableSign: workspace_1.default.env.sign && config.get('enableSign', true),\n            locationlistUpdate: config.get('locationlistUpdate', true),\n            maxWindowHeight: config.get('maxWindowHeight', 10),\n            maxWindowWidth: config.get('maxWindowWidth', 80),\n            enableMessage: config.get('enableMessage', 'always'),\n            messageDelay: config.get('messageDelay', 200),\n            virtualText: config.get('virtualText', false) && this.nvim.hasFunction('nvim_buf_set_virtual_text'),\n            virtualTextCurrentLineOnly: config.get('virtualTextCurrentLineOnly', true),\n            virtualTextPrefix: config.get('virtualTextPrefix', \" \"),\n            virtualTextLineSeparator: config.get('virtualTextLineSeparator', \" \\\\ \"),\n            virtualTextLines: config.get('virtualTextLines', 3),\n            displayByAle: config.get('displayByAle', false),\n            level: util_2.severityLevel(config.get('level', 'hint')),\n            signPriority: config.get('signPriority', 10),\n            errorSign: config.get('errorSign', '>>'),\n            warningSign: config.get('warningSign', '>>'),\n            infoSign: config.get('infoSign', '>>'),\n            hintSign: config.get('hintSign', '>>'),\n            refreshOnInsertMode: config.get('refreshOnInsertMode', false),\n            filetypeMap: config.get('filetypeMap', {}),\n            showUnused: config.get('showUnused', true),\n            showDeprecated: config.get('showDeprecated', true),\n            format: config.get('format', '[%source%code] [%severity] %message'),\n        };\n        this.enabled = config.get('enable', true);\n        this.defineSigns();\n    }\n    getCollectionByName(name) {\n        return this.collections.find(o => o.name == name);\n    }\n    getCollections(uri) {\n        return this.collections.filter(c => c.has(uri));\n    }\n    toggleDiagnostic() {\n        let { enabled } = this;\n        this.enabled = !enabled;\n        for (let buf of this.buffers.items) {\n            if (this.enabled) {\n                let diagnostics = this.getDiagnostics(buf.uri);\n                buf.forceRefresh(diagnostics);\n            }\n            else {\n                buf.clear();\n            }\n        }\n    }\n    /**\n     * Refresh diagnostics by uri or bufnr\n     */\n    refreshBuffer(uri, force = false) {\n        if (!this.enabled)\n            return false;\n        let buf = this.buffers.getItem(uri);\n        if (!buf)\n            return false;\n        let diagnostics = this.getDiagnostics(buf.uri);\n        if (force) {\n            buf.forceRefresh(diagnostics);\n        }\n        else {\n            buf.refresh(diagnostics);\n        }\n        return true;\n    }\n}\nexports.DiagnosticManager = DiagnosticManager;\nexports.default = new DiagnosticManager();\n\n\n//# sourceURL=webpack://coc.nvim/./src/diagnostic/manager.ts?");

/***/ }),

/***/ "./src/diagnostic/util.ts":
/*!********************************!*\
  !*** ./src/diagnostic/util.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getLocationListItem = exports.getNameFromSeverity = exports.severityLevel = exports.getSeverityType = exports.getSeverityName = void 0;\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nfunction getSeverityName(severity) {\n    switch (severity) {\n        case vscode_languageserver_protocol_1.DiagnosticSeverity.Error:\n            return 'Error';\n        case vscode_languageserver_protocol_1.DiagnosticSeverity.Warning:\n            return 'Warning';\n        case vscode_languageserver_protocol_1.DiagnosticSeverity.Information:\n            return 'Information';\n        case vscode_languageserver_protocol_1.DiagnosticSeverity.Hint:\n            return 'Hint';\n        default:\n            return 'Error';\n    }\n}\nexports.getSeverityName = getSeverityName;\nfunction getSeverityType(severity) {\n    switch (severity) {\n        case vscode_languageserver_protocol_1.DiagnosticSeverity.Error:\n            return 'E';\n        case vscode_languageserver_protocol_1.DiagnosticSeverity.Warning:\n            return 'W';\n        case vscode_languageserver_protocol_1.DiagnosticSeverity.Information:\n            return 'I';\n        case vscode_languageserver_protocol_1.DiagnosticSeverity.Hint:\n            return 'I';\n        default:\n            return 'Error';\n    }\n}\nexports.getSeverityType = getSeverityType;\nfunction severityLevel(level) {\n    switch (level) {\n        case 'hint':\n            return vscode_languageserver_protocol_1.DiagnosticSeverity.Hint;\n        case 'information':\n            return vscode_languageserver_protocol_1.DiagnosticSeverity.Information;\n        case 'warning':\n            return vscode_languageserver_protocol_1.DiagnosticSeverity.Warning;\n        case 'error':\n            return vscode_languageserver_protocol_1.DiagnosticSeverity.Error;\n        default:\n            return vscode_languageserver_protocol_1.DiagnosticSeverity.Hint;\n    }\n}\nexports.severityLevel = severityLevel;\nfunction getNameFromSeverity(severity) {\n    switch (severity) {\n        case vscode_languageserver_protocol_1.DiagnosticSeverity.Error:\n            return 'CocError';\n        case vscode_languageserver_protocol_1.DiagnosticSeverity.Warning:\n            return 'CocWarning';\n        case vscode_languageserver_protocol_1.DiagnosticSeverity.Information:\n            return 'CocInfo';\n        case vscode_languageserver_protocol_1.DiagnosticSeverity.Hint:\n            return 'CocHint';\n        default:\n            return 'CocError';\n    }\n}\nexports.getNameFromSeverity = getNameFromSeverity;\nfunction getLocationListItem(bufnr, diagnostic) {\n    let { start } = diagnostic.range;\n    let owner = diagnostic.source || 'coc.nvim';\n    let msg = diagnostic.message.split('\\n')[0];\n    let type = getSeverityName(diagnostic.severity).slice(0, 1).toUpperCase();\n    return {\n        bufnr,\n        lnum: start.line + 1,\n        col: start.character + 1,\n        text: `[${owner}${diagnostic.code ? ' ' + diagnostic.code : ''}] ${msg} [${type}]`,\n        type\n    };\n}\nexports.getLocationListItem = getLocationListItem;\n\n\n//# sourceURL=webpack://coc.nvim/./src/diagnostic/util.ts?");

/***/ }),

/***/ "./src/events.ts":
/*!***********************!*\
  !*** ./src/events.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/util/index.ts\");\nconst object_1 = __webpack_require__(/*! ./util/object */ \"./src/util/object.ts\");\nconst logger = __webpack_require__(/*! ./util/logger */ \"./src/util/logger.ts\")('events');\nclass Events {\n    constructor() {\n        this.handlers = new Map();\n        this.insertMode = false;\n    }\n    get cursor() {\n        return this._cursor;\n    }\n    async fire(event, args) {\n        let cbs = this.handlers.get(event);\n        if (event == 'InsertEnter') {\n            this.insertMode = true;\n        }\n        else if (event == 'InsertLeave') {\n            this.insertMode = false;\n        }\n        else if (!this.insertMode && (event == 'CursorHoldI' || event == 'CursorMovedI')) {\n            this.insertMode = true;\n            await this.fire('InsertEnter', [args[0]]);\n        }\n        else if (this.insertMode && (event == 'CursorHold' || event == 'CursorMoved')) {\n            this.insertMode = false;\n            await this.fire('InsertLeave', [args[0]]);\n        }\n        if (event == 'CursorMoved' || event == 'CursorMovedI') {\n            let cursor = {\n                bufnr: args[0],\n                lnum: args[1][0],\n                col: args[1][1],\n                insert: event == 'CursorMovedI'\n            };\n            // not handle CursorMoved when it's not moved at all\n            if (this._cursor && object_1.equals(this._cursor, cursor))\n                return;\n            this._cursor = cursor;\n        }\n        if (cbs) {\n            try {\n                await Promise.all(cbs.map(fn => fn(args)));\n            }\n            catch (e) {\n                if (e.message && e.message.indexOf('transport disconnected') == -1) {\n                    console.error(`Error on ${event}: ${e.message}${e.stack ? '\\n' + e.stack : ''} `);\n                }\n                logger.error(`Handler Error on ${event}`, e.stack);\n            }\n        }\n    }\n    on(event, handler, thisArg, disposables) {\n        if (Array.isArray(event)) {\n            let arr = disposables || [];\n            for (let ev of event) {\n                this.on(ev, handler, thisArg, arr);\n            }\n            return vscode_languageserver_protocol_1.Disposable.create(() => {\n                util_1.disposeAll(arr);\n            });\n        }\n        else {\n            let arr = this.handlers.get(event) || [];\n            let stack = Error().stack;\n            let wrappedhandler = args => new Promise((resolve, reject) => {\n                let timer;\n                try {\n                    Promise.resolve(handler.apply(thisArg || null, args)).then(() => {\n                        if (timer)\n                            clearTimeout(timer);\n                        resolve(undefined);\n                    }, e => {\n                        if (timer)\n                            clearTimeout(timer);\n                        reject(e);\n                    });\n                    timer = setTimeout(() => {\n                        logger.warn(`Handler of ${event} blocked more than 2s:`, stack);\n                    }, 2000);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n            arr.push(wrappedhandler);\n            this.handlers.set(event, arr);\n            let disposable = vscode_languageserver_protocol_1.Disposable.create(() => {\n                let idx = arr.indexOf(wrappedhandler);\n                if (idx !== -1) {\n                    arr.splice(idx, 1);\n                }\n            });\n            if (disposables) {\n                disposables.push(disposable);\n            }\n            return disposable;\n        }\n    }\n}\nexports.default = new Events();\n\n\n//# sourceURL=webpack://coc.nvim/./src/events.ts?");

/***/ }),

/***/ "./src/extensions.ts":
/*!***************************!*\
  !*** ./src/extensions.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Extensions = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst debounce_1 = __webpack_require__(/*! debounce */ \"./node_modules/debounce/index.js\");\nconst fs_extra_1 = tslib_1.__importDefault(__webpack_require__(/*! fs-extra */ \"./node_modules/fs-extra/lib/index.js\"));\nconst isuri_1 = tslib_1.__importDefault(__webpack_require__(/*! isuri */ \"./node_modules/isuri/index.js\"));\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst semver_1 = tslib_1.__importDefault(__webpack_require__(/*! semver */ \"./node_modules/semver/index.js\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst which_1 = tslib_1.__importDefault(__webpack_require__(/*! which */ \"./node_modules/which/which.js\"));\nconst commands_1 = tslib_1.__importDefault(__webpack_require__(/*! ./commands */ \"./src/commands.ts\"));\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ./events */ \"./src/events.ts\"));\nconst db_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/db */ \"./src/model/db.ts\"));\nconst floatFactory_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/floatFactory */ \"./src/model/floatFactory.ts\"));\nconst installBuffer_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/installBuffer */ \"./src/model/installBuffer.ts\"));\nconst installer_1 = __webpack_require__(/*! ./model/installer */ \"./src/model/installer.ts\");\nconst memos_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/memos */ \"./src/model/memos.ts\"));\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/types.ts\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/util/index.ts\");\nconst array_1 = __webpack_require__(/*! ./util/array */ \"./src/util/array.ts\");\n__webpack_require__(/*! ./util/extensions */ \"./src/util/extensions.ts\");\nconst factory_1 = __webpack_require__(/*! ./util/factory */ \"./src/util/factory.ts\");\nconst fs_1 = __webpack_require__(/*! ./util/fs */ \"./src/util/fs.ts\");\nconst is_1 = __webpack_require__(/*! ./util/is */ \"./src/util/is.ts\");\nconst watchman_1 = tslib_1.__importDefault(__webpack_require__(/*! ./watchman */ \"./src/watchman.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ./workspace */ \"./src/workspace.ts\"));\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ./window */ \"./src/window.ts\"));\nconst createLogger = __webpack_require__(/*! ./util/logger */ \"./src/util/logger.ts\");\nconst logger = createLogger('extensions');\nfunction loadJson(file) {\n    try {\n        let content = fs_extra_1.default.readFileSync(file, 'utf8');\n        return JSON.parse(content);\n    }\n    catch (e) {\n        return null;\n    }\n}\n// global local file native\nclass Extensions {\n    constructor() {\n        this.extensions = new Map();\n        this.disabled = new Set();\n        this._onDidLoadExtension = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidActiveExtension = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidUnloadExtension = new vscode_languageserver_protocol_1.Emitter();\n        this._additionalSchemes = {};\n        this.activated = false;\n        this.disposables = [];\n        this.ready = true;\n        this.onDidLoadExtension = this._onDidLoadExtension.event;\n        this.onDidActiveExtension = this._onDidActiveExtension.event;\n        this.onDidUnloadExtension = this._onDidUnloadExtension.event;\n        let folder = global.hasOwnProperty('__TEST__') ? path_1.default.join(__dirname, '__tests__') : process.env.COC_DATA_HOME;\n        let root = this.root = path_1.default.join(folder, 'extensions');\n        if (!fs_extra_1.default.existsSync(root)) {\n            fs_extra_1.default.mkdirpSync(root);\n        }\n        let jsonFile = path_1.default.join(root, 'package.json');\n        if (!fs_extra_1.default.existsSync(jsonFile)) {\n            fs_extra_1.default.writeFileSync(jsonFile, '{\"dependencies\":{}}', 'utf8');\n        }\n        let filepath = path_1.default.join(root, 'db.json');\n        this.db = new db_1.default(filepath);\n    }\n    async init() {\n        let data = loadJson(this.db.filepath) || {};\n        let keys = Object.keys(data.extension || {});\n        this.outputChannel = window_1.default.createOutputChannel('extensions');\n        for (let key of keys) {\n            if (data.extension[key].disabled == true) {\n                this.disabled.add(key);\n            }\n        }\n        if (process.env.COC_NO_PLUGINS)\n            return;\n        let stats = await this.globalExtensionStats();\n        let localStats = await this.localExtensionStats(stats.map(o => o.id));\n        stats = stats.concat(localStats);\n        this.memos = new memos_1.default(path_1.default.resolve(this.root, '../memos.json'));\n        stats.map(stat => {\n            let extensionType = stat.isLocal ? types_1.ExtensionType.Local : types_1.ExtensionType.Global;\n            try {\n                this.createExtension(stat.root, stat.packageJSON, extensionType);\n            }\n            catch (e) {\n                logger.error(`Error on create ${stat.root}:`, e);\n            }\n        });\n        await this.loadFileExtensions();\n        commands_1.default.register({\n            id: 'extensions.forceUpdateAll',\n            execute: async () => {\n                let arr = await this.cleanExtensions();\n                logger.info(`Force update extensions: ${arr}`);\n                await this.installExtensions(arr);\n            }\n        }, false, 'remove all global extensions and install them');\n        workspace_1.default.onDidRuntimePathChange(async (paths) => {\n            for (let p of paths) {\n                if (p && this.checkDirectory(p) === true) {\n                    await this.loadExtension(p);\n                }\n            }\n        }, null, this.disposables);\n    }\n    async activateExtensions() {\n        this.activated = true;\n        for (let item of this.extensions.values()) {\n            let { id, packageJSON } = item.extension;\n            await this.setupActiveEvents(id, packageJSON);\n        }\n        // make sure workspace.env exists\n        let floatFactory = new floatFactory_1.default(workspace_1.default.nvim);\n        events_1.default.on('CursorMoved', debounce_1.debounce(async (bufnr) => {\n            if (this.installBuffer && bufnr == this.installBuffer.bufnr) {\n                let lnum = await workspace_1.default.nvim.call('line', ['.']);\n                let msgs = this.installBuffer.getMessages(lnum - 1);\n                let docs = msgs && msgs.length ? [{ content: msgs.join('\\n'), filetype: 'txt' }] : [];\n                await floatFactory.show(docs, { modes: ['n'] });\n            }\n        }, 500));\n        if (global.hasOwnProperty('__TEST__'))\n            return;\n        // check extensions need watch & install\n        this.checkExtensions().logError();\n        let config = workspace_1.default.getConfiguration('coc.preferences');\n        let interval = config.get('extensionUpdateCheck', 'never');\n        let silent = config.get('silentAutoupdate', true);\n        if (interval != 'never') {\n            let now = new Date();\n            let day = new Date(now.getFullYear(), now.getMonth(), now.getDate() - (interval == 'daily' ? 0 : 7));\n            let ts = this.db.fetch('lastUpdate');\n            if (ts && Number(ts) > day.getTime())\n                return;\n            this.outputChannel.appendLine('Start auto update...');\n            this.updateExtensions(false, silent).logError();\n        }\n    }\n    async updateExtensions(sync, silent = false) {\n        if (!this.npm)\n            return;\n        let lockedList = await this.getLockedList();\n        let stats = await this.globalExtensionStats();\n        stats = stats.filter(o => ![...lockedList, ...this.disabled].includes(o.id));\n        this.db.push('lastUpdate', Date.now());\n        if (silent) {\n            window_1.default.showMessage('Updating extensions, checkout output:///extensions for details.', 'more');\n        }\n        let installBuffer = this.installBuffer = new installBuffer_1.default(true, sync, silent ? this.outputChannel : undefined);\n        installBuffer.setExtensions(stats.map(o => o.id));\n        await installBuffer.show(workspace_1.default.nvim);\n        let createInstaller = installer_1.createInstallerFactory(this.npm, this.modulesFolder);\n        let fn = (stat) => {\n            let { id } = stat;\n            installBuffer.startProgress([id]);\n            let url = stat.exotic ? stat.uri : null;\n            // msg => installBuffer.addMessage(id, msg)\n            let installer = createInstaller(id);\n            installer.on('message', (msg, isProgress) => {\n                installBuffer.addMessage(id, msg, isProgress);\n            });\n            return installer.update(url).then(directory => {\n                installBuffer.finishProgress(id, true);\n                if (directory) {\n                    this.loadExtension(directory).logError();\n                }\n            }, err => {\n                installBuffer.addMessage(id, err.message);\n                installBuffer.finishProgress(id, false);\n            });\n        };\n        await util_1.concurrent(stats, fn, silent ? 1 : 3);\n    }\n    async checkExtensions() {\n        let { globalExtensions } = workspace_1.default.env;\n        if (globalExtensions && globalExtensions.length) {\n            let names = this.filterGlobalExtensions(globalExtensions);\n            this.installExtensions(names).logError();\n        }\n    }\n    /**\n     * Install extensions, can be called without initialize.\n     */\n    async installExtensions(list = []) {\n        let { npm } = this;\n        if (!npm || !list.length)\n            return;\n        list = array_1.distinct(list);\n        let installBuffer = this.installBuffer = new installBuffer_1.default();\n        installBuffer.setExtensions(list);\n        await installBuffer.show(workspace_1.default.nvim);\n        let createInstaller = installer_1.createInstallerFactory(this.npm, this.modulesFolder);\n        let fn = (key) => {\n            installBuffer.startProgress([key]);\n            let installer = createInstaller(key);\n            installer.on('message', (msg, isProgress) => {\n                installBuffer.addMessage(key, msg, isProgress);\n            });\n            return installer.install().then(name => {\n                installBuffer.finishProgress(key, true);\n                let directory = path_1.default.join(this.modulesFolder, name);\n                this.loadExtension(directory).logError();\n            }, err => {\n                installBuffer.addMessage(key, err.message);\n                installBuffer.finishProgress(key, false);\n                logger.error(`Error on install ${key}`, err);\n            });\n        };\n        await util_1.concurrent(list, fn);\n    }\n    /**\n     * Get list of extensions in package.json that not installed\n     */\n    getMissingExtensions() {\n        let json = this.loadJson() || { dependencies: {} };\n        let ids = [];\n        for (let key of Object.keys(json.dependencies)) {\n            let folder = path_1.default.join(this.modulesFolder, key);\n            if (!fs_extra_1.default.existsSync(folder)) {\n                let val = json.dependencies[key];\n                if (val.startsWith('http')) {\n                    ids.push(val);\n                }\n                else {\n                    ids.push(key);\n                }\n            }\n        }\n        return ids;\n    }\n    get npm() {\n        let npm = workspace_1.default.getConfiguration('npm').get('binPath', 'npm');\n        npm = workspace_1.default.expand(npm);\n        for (let exe of [npm, 'yarnpkg', 'yarn', 'npm']) {\n            try {\n                let res = which_1.default.sync(exe);\n                return res;\n            }\n            catch (e) {\n                continue;\n            }\n        }\n        window_1.default.showMessage(`Can't find npm or yarn in your $PATH`, 'error');\n        return null;\n    }\n    /**\n     * Get all loaded extensions.\n     */\n    get all() {\n        return Array.from(this.extensions.values()).map(o => o.extension).filter(o => !this.isDisabled(o.id));\n    }\n    getExtension(id) {\n        return this.extensions.get(id);\n    }\n    getExtensionState(id) {\n        let disabled = this.isDisabled(id);\n        if (disabled)\n            return 'disabled';\n        let item = this.extensions.get(id);\n        if (!item)\n            return 'unknown';\n        let { extension } = item;\n        return extension.isActive ? 'activated' : 'loaded';\n    }\n    async getExtensionStates() {\n        let globalStats = await this.globalExtensionStats();\n        let localStats = await this.localExtensionStats([]);\n        return globalStats.concat(localStats);\n    }\n    async getLockedList() {\n        let obj = await this.db.fetch('extension');\n        obj = obj || {};\n        return Object.keys(obj).filter(id => obj[id].locked === true);\n    }\n    async toggleLock(id) {\n        let key = `extension.${id}.locked`;\n        let locked = await this.db.fetch(key);\n        if (locked) {\n            this.db.delete(key);\n        }\n        else {\n            this.db.push(key, true);\n        }\n    }\n    async toggleExtension(id) {\n        let state = this.getExtensionState(id);\n        if (state == null)\n            return;\n        if (state == 'activated') {\n            await this.deactivate(id);\n        }\n        let key = `extension.${id}.disabled`;\n        this.db.push(key, state == 'disabled' ? false : true);\n        if (state != 'disabled') {\n            this.disabled.add(id);\n            await this.unloadExtension(id);\n        }\n        else {\n            this.disabled.delete(id);\n            let folder = path_1.default.join(this.modulesFolder, id);\n            if (fs_extra_1.default.existsSync(folder)) {\n                await this.loadExtension(folder);\n            }\n        }\n        await util_1.wait(200);\n    }\n    async reloadExtension(id) {\n        let item = this.extensions.get(id);\n        if (!item) {\n            window_1.default.showMessage(`Extension ${id} not registered`, 'error');\n            return;\n        }\n        if (item.type == types_1.ExtensionType.Internal) {\n            window_1.default.showMessage(`Can't reload internal extension \"${item.id}\"`, 'warning');\n            return;\n        }\n        if (item.type == types_1.ExtensionType.SingleFile) {\n            await this.loadExtensionFile(item.filepath);\n        }\n        else if (item.directory) {\n            await this.loadExtension(item.directory);\n        }\n        else {\n            window_1.default.showMessage(`Can't reload extension ${item.id}`, 'warning');\n        }\n    }\n    /**\n     * Unload & remove all global extensions, return removed extensions.\n     */\n    async cleanExtensions() {\n        let dir = this.modulesFolder;\n        if (!fs_extra_1.default.existsSync(dir))\n            return [];\n        let ids = this.globalExtensions;\n        let res = [];\n        for (let id of ids) {\n            let directory = path_1.default.join(dir, id);\n            let stat = await fs_extra_1.default.lstat(directory);\n            if (!stat || (stat && stat.isSymbolicLink()))\n                continue;\n            await this.unloadExtension(id);\n            await fs_extra_1.default.remove(directory);\n            res.push(id);\n        }\n        return res;\n    }\n    async uninstallExtension(ids) {\n        try {\n            if (!ids.length)\n                return;\n            let [globals, filtered] = array_1.splitArray(ids, id => this.globalExtensions.includes(id));\n            if (filtered.length) {\n                window_1.default.showMessage(`Extensions ${filtered} not global extensions, can't uninstall!`, 'warning');\n            }\n            let json = this.loadJson() || { dependencies: {} };\n            for (let id of globals) {\n                await this.unloadExtension(id);\n                delete json.dependencies[id];\n                // remove directory\n                let folder = path_1.default.join(this.modulesFolder, id);\n                if (fs_extra_1.default.existsSync(folder)) {\n                    await fs_extra_1.default.remove(folder);\n                }\n            }\n            // update package.json\n            const sortedObj = { dependencies: {} };\n            Object.keys(json.dependencies).sort().forEach(k => {\n                sortedObj.dependencies[k] = json.dependencies[k];\n            });\n            let jsonFile = path_1.default.join(this.root, 'package.json');\n            fs_extra_1.default.writeFileSync(jsonFile, JSON.stringify(sortedObj, null, 2), { encoding: 'utf8' });\n            window_1.default.showMessage(`Removed: ${globals.join(' ')}`);\n        }\n        catch (e) {\n            window_1.default.showMessage(`Uninstall failed: ${e.message}`, 'error');\n        }\n    }\n    isDisabled(id) {\n        return this.disabled.has(id);\n    }\n    has(id) {\n        return this.extensions.has(id);\n    }\n    isActivated(id) {\n        let item = this.extensions.get(id);\n        if (item && item.extension.isActive) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Load extension from folder, folder should contains coc extension.\n     */\n    async loadExtension(folder) {\n        try {\n            let parentFolder = path_1.default.dirname(folder);\n            let isLocal = path_1.default.normalize(parentFolder) != path_1.default.normalize(this.modulesFolder);\n            let jsonFile = path_1.default.join(folder, 'package.json');\n            let packageJSON = JSON.parse(fs_extra_1.default.readFileSync(jsonFile, 'utf8'));\n            let { name } = packageJSON;\n            if (this.isDisabled(name))\n                return false;\n            // unload if loaded\n            await this.unloadExtension(name);\n            this.createExtension(folder, Object.freeze(packageJSON), isLocal ? types_1.ExtensionType.Local : types_1.ExtensionType.Global);\n            return true;\n        }\n        catch (e) {\n            window_1.default.showMessage(`Error on load extension from \"${folder}\": ${e.message}`, 'error');\n            logger.error(`Error on load extension from ${folder}`, e);\n            return false;\n        }\n    }\n    async loadFileExtensions() {\n        if (!process.env.COC_VIMCONFIG)\n            return;\n        let folder = path_1.default.join(process.env.COC_VIMCONFIG, 'coc-extensions');\n        if (!fs_extra_1.default.existsSync(folder))\n            return;\n        let files = await fs_extra_1.default.readdir(folder);\n        files = files.filter(f => f.endsWith('.js'));\n        for (let file of files) {\n            await this.loadExtensionFile(path_1.default.join(folder, file));\n        }\n    }\n    loadedExtensions() {\n        return Array.from(this.extensions.keys());\n    }\n    async watchExtension(id) {\n        let item = this.extensions.get(id);\n        if (!item) {\n            window_1.default.showMessage(`extension ${id} not found`, 'error');\n            return;\n        }\n        if (id.startsWith('single-')) {\n            window_1.default.showMessage(`watching ${item.filepath}`);\n            this.disposables.push(util_1.watchFile(item.filepath, async () => {\n                await this.loadExtensionFile(item.filepath);\n                window_1.default.showMessage(`reloaded ${id}`);\n            }));\n        }\n        else {\n            let watchmanPath = workspace_1.default.getWatchmanPath();\n            if (!watchmanPath) {\n                window_1.default.showMessage('watchman not found', 'error');\n                return;\n            }\n            let client = await watchman_1.default.createClient(watchmanPath, item.directory);\n            if (!client) {\n                window_1.default.showMessage(`Can't create watchman client, check output:///watchman`);\n                return;\n            }\n            window_1.default.showMessage(`watching ${item.directory}`);\n            this.disposables.push(client);\n            client.subscribe('**/*.js', async () => {\n                await this.reloadExtension(id);\n                window_1.default.showMessage(`reloaded ${id}`);\n            }).then(disposable => {\n                this.disposables.push(disposable);\n            }, e => {\n                logger.error(e);\n            });\n        }\n    }\n    /**\n     * Load single javascript file as extension.\n     */\n    async loadExtensionFile(filepath) {\n        let filename = path_1.default.basename(filepath);\n        let name = 'single-' + path_1.default.basename(filepath, '.js');\n        if (this.isDisabled(name))\n            return;\n        let root = path_1.default.dirname(filepath);\n        let packageJSON = {\n            name, main: filename, engines: { coc: '^0.0.79' }\n        };\n        await this.unloadExtension(name);\n        this.createExtension(root, packageJSON, types_1.ExtensionType.SingleFile);\n    }\n    /**\n     * Activate extension, throw error if disabled or not exists\n     * Returns true if extension successfully activated.\n     */\n    async activate(id) {\n        if (this.isDisabled(id)) {\n            throw new Error(`Extension ${id} is disabled!`);\n        }\n        let item = this.extensions.get(id);\n        if (!item) {\n            throw new Error(`Extension ${id} not registered!`);\n        }\n        let { extension } = item;\n        if (extension.isActive)\n            return true;\n        await Promise.resolve(extension.activate());\n        if (extension.isActive) {\n            this._onDidActiveExtension.fire(extension);\n            return true;\n        }\n        return false;\n    }\n    async deactivate(id) {\n        let item = this.extensions.get(id);\n        if (!item)\n            return false;\n        await Promise.resolve(item.deactivate());\n        return true;\n    }\n    async call(id, method, args) {\n        let item = this.extensions.get(id);\n        if (!item)\n            throw new Error(`extension ${id} not registered`);\n        let { extension } = item;\n        if (!extension.isActive) {\n            await this.activate(id);\n        }\n        let { exports } = extension;\n        if (!exports || !exports.hasOwnProperty(method)) {\n            throw new Error(`method ${method} not found on extension ${id}`);\n        }\n        return await Promise.resolve(exports[method].apply(null, args));\n    }\n    getExtensionApi(id) {\n        let item = this.extensions.get(id);\n        if (!item)\n            return null;\n        let { extension } = item;\n        return extension.isActive ? extension.exports : null;\n    }\n    registerExtension(extension, deactivate) {\n        let { id, packageJSON } = extension;\n        this.extensions.set(id, { id, type: types_1.ExtensionType.Internal, extension, deactivate, isLocal: true });\n        let { contributes } = packageJSON;\n        if (contributes) {\n            let { configuration } = contributes;\n            if (configuration && configuration.properties) {\n                let { properties } = configuration;\n                let props = {};\n                for (let key of Object.keys(properties)) {\n                    let val = properties[key].default;\n                    if (val != null)\n                        props[key] = val;\n                }\n                workspace_1.default.configurations.extendsDefaults(props);\n            }\n        }\n        this._onDidLoadExtension.fire(extension);\n        this.setupActiveEvents(id, packageJSON).logError();\n    }\n    get globalExtensions() {\n        let json = this.loadJson();\n        if (!json || !json.dependencies)\n            return [];\n        return Object.keys(json.dependencies);\n    }\n    async globalExtensionStats() {\n        let json = this.loadJson();\n        if (!json || !json.dependencies)\n            return [];\n        let { modulesFolder } = this;\n        let res = await Promise.all(Object.keys(json.dependencies).map(key => new Promise(async (resolve) => {\n            try {\n                let val = json.dependencies[key];\n                let root = path_1.default.join(modulesFolder, key);\n                let res = this.checkDirectory(root);\n                if (res instanceof Error) {\n                    window_1.default.showMessage(`Unable to load global extension at ${root}: ${res.message}`, 'error');\n                    logger.error(`Error on load ${root}`, res);\n                    return resolve(null);\n                }\n                let content = await fs_1.readFile(path_1.default.join(root, 'package.json'), 'utf8');\n                root = await fs_extra_1.default.realpath(root);\n                let obj = JSON.parse(content);\n                let version = obj ? obj.version || '' : '';\n                let description = obj ? obj.description || '' : '';\n                let uri = isuri_1.default.isValid(val) ? val : '';\n                resolve({\n                    id: key,\n                    isLocal: false,\n                    version,\n                    description,\n                    exotic: /^https?:/.test(val),\n                    uri: uri.replace(/\\.git(#master)?$/, ''),\n                    root,\n                    state: this.getExtensionState(key),\n                    packageJSON: Object.freeze(obj)\n                });\n            }\n            catch (e) {\n                logger.error(e);\n                resolve(null);\n            }\n        })));\n        return res.filter(info => info != null);\n    }\n    async localExtensionStats(excludes) {\n        let runtimepath = await workspace_1.default.nvim.eval('&runtimepath');\n        let paths = runtimepath.split(',');\n        let res = await Promise.all(paths.map(root => new Promise(async (resolve) => {\n            try {\n                let res = this.checkDirectory(root);\n                if (res !== true)\n                    return resolve(null);\n                let jsonFile = path_1.default.join(root, 'package.json');\n                let content = await fs_1.readFile(jsonFile, 'utf8');\n                let obj = JSON.parse(content);\n                let exist = this.extensions.get(obj.name);\n                if (exist && !exist.isLocal) {\n                    logger.info(`Extension \"${obj.name}\" in runtimepath already loaded.`);\n                    return resolve(null);\n                }\n                if (excludes.includes(obj.name)) {\n                    logger.info(`Skipped load vim plugin from \"${root}\", \"${obj.name}\" already global extension.`);\n                    return resolve(null);\n                }\n                let version = obj ? obj.version || '' : '';\n                let description = obj ? obj.description || '' : '';\n                resolve({\n                    id: obj.name,\n                    isLocal: true,\n                    version,\n                    description,\n                    exotic: false,\n                    root,\n                    state: this.getExtensionState(obj.name),\n                    packageJSON: Object.freeze(obj)\n                });\n            }\n            catch (e) {\n                logger.error(e);\n                resolve(null);\n            }\n        })));\n        return res.filter(info => info != null);\n    }\n    loadJson() {\n        let { root } = this;\n        let jsonFile = path_1.default.join(root, 'package.json');\n        if (!fs_extra_1.default.existsSync(jsonFile))\n            return null;\n        return loadJson(jsonFile);\n    }\n    get schemes() {\n        return this._additionalSchemes;\n    }\n    addSchemeProperty(key, def) {\n        this._additionalSchemes[key] = def;\n        workspace_1.default.configurations.extendsDefaults({ [key]: def.default });\n    }\n    async setupActiveEvents(id, packageJSON) {\n        let { activationEvents } = packageJSON;\n        if (!this.canActivate(id))\n            return;\n        if (!activationEvents || Array.isArray(activationEvents) && activationEvents.includes('*')) {\n            await this.activate(id).catch(e => {\n                window_1.default.showMessage(`Error on activate extension ${id}: ${e.message}`);\n                logger.error(`Error on activate extension ${id}`, e);\n            });\n            return;\n        }\n        let disposables = [];\n        let active = () => {\n            util_1.disposeAll(disposables);\n            return new Promise(resolve => {\n                if (!this.canActivate(id))\n                    return resolve();\n                let timer = setTimeout(() => {\n                    logger.warn(`Extension ${id} activate cost more than 1s`);\n                    resolve();\n                }, 1000);\n                this.activate(id).then(() => {\n                    clearTimeout(timer);\n                    resolve();\n                }, e => {\n                    clearTimeout(timer);\n                    window_1.default.showMessage(`Error on activate extension ${id}: ${e.message}`);\n                    logger.error(`Error on activate extension ${id}`, e);\n                    resolve();\n                });\n            });\n        };\n        for (let eventName of activationEvents) {\n            let parts = eventName.split(':');\n            let ev = parts[0];\n            if (ev == 'onLanguage') {\n                if (workspace_1.default.filetypes.has(parts[1])) {\n                    await active();\n                    return;\n                }\n                workspace_1.default.onDidOpenTextDocument(document => {\n                    if (document.languageId == parts[1]) {\n                        active().logError();\n                    }\n                }, null, disposables);\n            }\n            else if (ev == 'onCommand') {\n                events_1.default.on('Command', command => {\n                    if (command == parts[1]) {\n                        active().logError();\n                        // wait for service ready\n                        return new Promise(resolve => {\n                            setTimeout(resolve, 500);\n                        });\n                    }\n                }, null, disposables);\n            }\n            else if (ev == 'workspaceContains') {\n                let check = async () => {\n                    let folders = workspace_1.default.workspaceFolders.map(o => vscode_uri_1.URI.parse(o.uri).fsPath);\n                    for (let folder of folders) {\n                        if (fs_1.inDirectory(folder, parts[1].split(/\\s+/))) {\n                            await active();\n                            return true;\n                        }\n                    }\n                };\n                let res = await check();\n                if (res)\n                    return;\n                workspace_1.default.onDidChangeWorkspaceFolders(check, null, disposables);\n            }\n            else if (ev == 'onFileSystem') {\n                for (let doc of workspace_1.default.documents) {\n                    let u = vscode_uri_1.URI.parse(doc.uri);\n                    if (u.scheme == parts[1]) {\n                        await active();\n                        return;\n                    }\n                }\n                workspace_1.default.onDidOpenTextDocument(document => {\n                    let u = vscode_uri_1.URI.parse(document.uri);\n                    if (u.scheme == parts[1]) {\n                        active().logError();\n                    }\n                }, null, disposables);\n            }\n            else {\n                window_1.default.showMessage(`Unsupported event ${eventName} of ${id}`, 'error');\n            }\n        }\n    }\n    createExtension(root, packageJSON, type) {\n        let id = packageJSON.name;\n        let isActive = false;\n        let exports = null;\n        let filename = path_1.default.join(root, packageJSON.main || 'index.js');\n        let ext;\n        let subscriptions = [];\n        let extension = {\n            activate: async () => {\n                if (isActive)\n                    return exports;\n                let context = {\n                    subscriptions,\n                    extensionPath: root,\n                    globalState: this.memos.createMemento(`${id}|global`),\n                    workspaceState: this.memos.createMemento(`${id}|${workspace_1.default.rootPath}`),\n                    asAbsolutePath: relativePath => path_1.default.join(root, relativePath),\n                    storagePath: path_1.default.join(this.root, `${id}-data`),\n                    logger: createLogger(id)\n                };\n                isActive = true;\n                if (!ext) {\n                    try {\n                        let isEmpty = !(packageJSON.engines || {}).hasOwnProperty('coc');\n                        ext = factory_1.createExtension(id, filename, isEmpty);\n                    }\n                    catch (e) {\n                        logger.error(`Error on createExtension ${id} from ${filename}`, e);\n                        return;\n                    }\n                }\n                try {\n                    exports = await Promise.resolve(ext.activate(context));\n                    logger.debug('activate:', id);\n                }\n                catch (e) {\n                    isActive = false;\n                    logger.error(`Error on active extension ${id}: ${e.stack}`, e);\n                }\n                return exports;\n            }\n        };\n        Object.defineProperties(extension, {\n            id: {\n                get: () => id\n            },\n            packageJSON: {\n                get: () => packageJSON\n            },\n            extensionPath: {\n                get: () => root\n            },\n            isActive: {\n                get: () => isActive\n            },\n            exports: {\n                get: () => exports\n            }\n        });\n        this.extensions.set(id, {\n            id,\n            type,\n            isLocal: type == types_1.ExtensionType.Local,\n            extension,\n            directory: root,\n            filepath: filename,\n            deactivate: () => {\n                if (!isActive)\n                    return;\n                isActive = false;\n                util_1.disposeAll(subscriptions);\n                subscriptions.splice(0, subscriptions.length);\n                subscriptions = [];\n                if (ext && ext.deactivate) {\n                    try {\n                        return Promise.resolve(ext.deactivate()).catch(e => {\n                            logger.error(`Error on ${id} deactivate: `, e);\n                        });\n                    }\n                    catch (e) {\n                        logger.error(`Error on ${id} deactivate: `, e);\n                    }\n                }\n            }\n        });\n        let { contributes } = packageJSON;\n        if (contributes) {\n            let { configuration, rootPatterns, commands } = contributes;\n            if (configuration && configuration.properties) {\n                let { properties } = configuration;\n                let props = {};\n                for (let key of Object.keys(properties)) {\n                    let val = properties[key].default;\n                    if (val != null)\n                        props[key] = val;\n                }\n                workspace_1.default.configurations.extendsDefaults(props);\n            }\n            if (rootPatterns && rootPatterns.length) {\n                for (let item of rootPatterns) {\n                    workspace_1.default.addRootPattern(item.filetype, item.patterns);\n                }\n            }\n            if (commands && commands.length) {\n                for (let cmd of commands) {\n                    commands_1.default.titles.set(cmd.command, cmd.title);\n                }\n            }\n        }\n        this._onDidLoadExtension.fire(extension);\n        if (this.activated) {\n            this.setupActiveEvents(id, packageJSON).logError();\n        }\n    }\n    // extension must exists as folder and in package.json\n    filterGlobalExtensions(names) {\n        names = names.map(s => s.replace(/@.*$/, ''));\n        let filtered = names.filter(name => !this.disabled.has(name));\n        filtered = filtered.filter(name => !this.extensions.has(name));\n        let json = this.loadJson();\n        let urls = [];\n        let exists = [];\n        if (json && json.dependencies) {\n            for (let key of Object.keys(json.dependencies)) {\n                let val = json.dependencies[key];\n                if (typeof val !== 'string')\n                    continue;\n                if (fs_extra_1.default.existsSync(path_1.default.join(this.modulesFolder, key, 'package.json'))) {\n                    exists.push(key);\n                    if (/^https?:/.test(val)) {\n                        urls.push(val);\n                    }\n                }\n            }\n        }\n        filtered = filtered.filter(str => {\n            if (/^https?:/.test(str))\n                return !urls.some(url => url.startsWith(str));\n            return !exists.includes(str);\n        });\n        return filtered;\n    }\n    get modulesFolder() {\n        return path_1.default.join(this.root, global.hasOwnProperty('__TEST__') ? '' : 'node_modules');\n    }\n    canActivate(id) {\n        return !this.disabled.has(id) && this.extensions.has(id);\n    }\n    /**\n     * Deactive & unregist extension\n     */\n    async unloadExtension(id) {\n        let item = this.extensions.get(id);\n        if (item) {\n            await this.deactivate(id);\n            this.extensions.delete(id);\n            this._onDidUnloadExtension.fire(id);\n        }\n    }\n    /**\n     * Check if folder contains extension, return Error\n     */\n    checkDirectory(folder) {\n        try {\n            let jsonFile = path_1.default.join(folder, 'package.json');\n            if (!fs_extra_1.default.existsSync(jsonFile))\n                throw new Error('package.json not found');\n            let packageJSON = JSON.parse(fs_extra_1.default.readFileSync(jsonFile, 'utf8'));\n            let { name, engines, main } = packageJSON;\n            if (!name || !engines)\n                throw new Error(`can't find name & engines in package.json`);\n            if (!engines || !is_1.objectLiteral(engines)) {\n                throw new Error(`invalid engines in ${jsonFile}`);\n            }\n            if (main && !fs_extra_1.default.existsSync(path_1.default.join(folder, main))) {\n                throw new Error(`main file ${main} not found, you may need to build the project.`);\n            }\n            let keys = Object.keys(engines);\n            if (!keys.includes('coc') && !keys.includes('vscode')) {\n                throw new Error(`Engines in package.json doesn't have coc or vscode`);\n            }\n            if (keys.includes('coc')) {\n                let required = engines['coc'].replace(/^\\^/, '>=');\n                if (!semver_1.default.satisfies(workspace_1.default.version, required)) {\n                    throw new Error(`Please update coc.nvim, ${packageJSON.name} requires coc.nvim ${engines['coc']}`);\n                }\n            }\n            return true;\n        }\n        catch (e) {\n            return e;\n        }\n    }\n    dispose() {\n        util_1.disposeAll(this.disposables);\n    }\n}\nexports.Extensions = Extensions;\nexports.default = new Extensions();\n\n\n//# sourceURL=webpack://coc.nvim/./src/extensions.ts?");

/***/ }),

/***/ "./src/handler/codelens/buffer.ts":
/*!****************************************!*\
  !*** ./src/handler/codelens/buffer.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst debounce_1 = tslib_1.__importDefault(__webpack_require__(/*! debounce */ \"./node_modules/debounce/index.js\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../languages */ \"./src/languages.ts\"));\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../window */ \"./src/window.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../workspace */ \"./src/workspace.ts\"));\nconst commands_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../commands */ \"./src/commands.ts\"));\nconst logger = __webpack_require__(/*! ../../util/logger */ \"./src/util/logger.ts\")('codelens-buffer');\n/**\n * CodeLens buffer\n */\nclass CodeLensBuffer {\n    constructor(nvim, bufnr, config) {\n        this.nvim = nvim;\n        this.bufnr = bufnr;\n        this.config = config;\n        this._disposed = false;\n        this.fetchCodelenses = debounce_1.default(() => {\n            this._fetchCodeLenses().logError();\n        }, global.hasOwnProperty('__TEST__') ? 10 : 100);\n        this.resolveCodeLens = debounce_1.default(() => {\n            this._resolveCodeLenses().logError();\n        }, global.hasOwnProperty('__TEST__') ? 10 : 100);\n        this.forceFetch().logError();\n    }\n    async forceFetch() {\n        this.fetchCodelenses.clear();\n        await this._fetchCodeLenses();\n    }\n    get textDocument() {\n        var _a;\n        return (_a = workspace_1.default.getDocument(this.bufnr)) === null || _a === void 0 ? void 0 : _a.textDocument;\n    }\n    get hasProvider() {\n        let { textDocument } = this;\n        if (!textDocument)\n            return false;\n        return languages_1.default.hasProvider('codeLens', textDocument);\n    }\n    async _fetchCodeLenses() {\n        if (!this.config.enabled || !this.hasProvider)\n            return;\n        let { textDocument } = this;\n        let version = textDocument.version;\n        if (this.codeLenses && version == this.codeLenses.version) {\n            let res = await this._resolveCodeLenses(true);\n            if (!res)\n                this.clear();\n            return;\n        }\n        this.cancel();\n        let tokenSource = this.tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n        let token = tokenSource.token;\n        let codeLenses = await languages_1.default.getCodeLens(textDocument, token);\n        this.tokenSource = undefined;\n        if (token.isCancellationRequested)\n            return;\n        if (Array.isArray(codeLenses)) {\n            this.codeLenses = { version, codeLenses };\n            this.resolveCodeLens.clear();\n            let res = await this._resolveCodeLenses(true);\n            if (!res)\n                this.clear();\n        }\n    }\n    async _resolveCodeLenses(clear = false) {\n        if (!this.config.enabled || !this.codeLenses || this._disposed)\n            return false;\n        let { codeLenses, version } = this.codeLenses;\n        let [bufnr, start, end] = await this.nvim.eval(`[bufnr('%'),line('w0'),line('w$')]`);\n        // text changed\n        if (!this.textDocument || this.textDocument.version != version)\n            return false;\n        // only resolve current buffer\n        if (bufnr != this.bufnr)\n            return false;\n        codeLenses = codeLenses.filter(o => {\n            let lnum = o.range.start.line + 1;\n            return lnum >= start && lnum <= end;\n        });\n        if (!clear)\n            codeLenses = codeLenses.filter(o => o.command == null);\n        if (!codeLenses.length)\n            return false;\n        let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n        let token = tokenSource.token;\n        let timer = setTimeout(() => {\n            tokenSource.cancel();\n        }, 1000);\n        await Promise.all(codeLenses.map(codeLens => languages_1.default.resolveCodeLens(codeLens, token)));\n        clearTimeout(timer);\n        this.tokenSource = undefined;\n        if (token.isCancellationRequested || this._disposed)\n            return false;\n        this.srcId = await this.nvim.createNamespace('coc-codelens');\n        this.nvim.pauseNotification();\n        if (clear)\n            this.clear();\n        this.setVirtualText(codeLenses);\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        let res = await this.nvim.resumeNotification();\n        if (Array.isArray(res) && res[1] != null) {\n            logger.error(`Error on resolve codeLens`, res[1][2]);\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Attach resolved codeLens\n     */\n    setVirtualText(codeLenses) {\n        if (codeLenses.length == 0)\n            return;\n        let list = new Map();\n        for (let codeLens of codeLenses) {\n            let { range, command } = codeLens;\n            if (!command)\n                continue;\n            let { line } = range.start;\n            if (list.has(line)) {\n                list.get(line).push(codeLens);\n            }\n            else {\n                list.set(line, [codeLens]);\n            }\n        }\n        for (let lnum of list.keys()) {\n            let codeLenses = list.get(lnum);\n            let commands = codeLenses.map(codeLens => codeLens.command);\n            commands = commands.filter(c => c && c.title);\n            let chunks = [];\n            let n_commands = commands.length;\n            for (let i = 0; i < n_commands; i++) {\n                let c = commands[i];\n                chunks.push([c.title.replace(/(\\r\\n|\\r|\\n) */g, \" \"), 'CocCodeLens']);\n                if (i != n_commands - 1) {\n                    chunks.push([this.config.subseparator, 'CocCodeLens']);\n                }\n            }\n            chunks.unshift([`${this.config.separator} `, 'CocCodeLens']);\n            this.nvim.call('nvim_buf_set_virtual_text', [this.bufnr, this.srcId, lnum, chunks, {}], true);\n        }\n    }\n    clear() {\n        if (!this.srcId)\n            return;\n        let buf = this.nvim.createBuffer(this.bufnr);\n        buf.clearNamespace(this.srcId);\n    }\n    getCodelenses() {\n        var _a;\n        return (_a = this.codeLenses) === null || _a === void 0 ? void 0 : _a.codeLenses;\n    }\n    async doAction(line) {\n        let { codeLenses } = this.codeLenses;\n        if (!codeLenses || codeLenses.length == 0) {\n            window_1.default.showMessage('No codeLenses available', 'warning');\n            return;\n        }\n        let list = new Map();\n        for (let codeLens of codeLenses) {\n            let { range, command } = codeLens;\n            if (!command)\n                continue;\n            let { line } = range.start;\n            if (list.has(line)) {\n                list.get(line).push(codeLens);\n            }\n            else {\n                list.set(line, [codeLens]);\n            }\n        }\n        let current = null;\n        for (let i = line; i >= 0; i--) {\n            if (list.has(i)) {\n                current = list.get(i);\n                break;\n            }\n        }\n        if (!current) {\n            window_1.default.showMessage('No codeLenses available', 'warning');\n            return;\n        }\n        let commands = current.map(o => o.command);\n        commands = commands.filter(c => c.command != null && c.command != '');\n        if (commands.length == 0) {\n            window_1.default.showMessage('CodeLenses command not found', 'warning');\n        }\n        else if (commands.length == 1) {\n            commands_1.default.execute(commands[0]);\n        }\n        else {\n            let res = await window_1.default.showMenuPicker(commands.map(c => c.title));\n            if (res == -1)\n                return;\n            commands_1.default.execute(commands[res]);\n        }\n    }\n    cancel() {\n        if (this.tokenSource) {\n            this.tokenSource.cancel();\n            this.tokenSource.dispose();\n            this.tokenSource = null;\n        }\n    }\n    onChange() {\n        if (!this.config.enabled)\n            return;\n        this.cancel();\n        this.resolveCodeLens.clear();\n    }\n    dispose() {\n        this._disposed = true;\n        this.codeLenses = undefined;\n        this.cancel();\n        this.fetchCodelenses.clear();\n        this.resolveCodeLens.clear();\n    }\n}\nexports.default = CodeLensBuffer;\n\n\n//# sourceURL=webpack://coc.nvim/./src/handler/codelens/buffer.ts?");

/***/ }),

/***/ "./src/handler/codelens/index.ts":
/*!***************************************!*\
  !*** ./src/handler/codelens/index.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../events */ \"./src/events.ts\"));\nconst util_1 = __webpack_require__(/*! ../../util */ \"./src/util/index.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../workspace */ \"./src/workspace.ts\"));\nconst buffer_1 = tslib_1.__importDefault(__webpack_require__(/*! ./buffer */ \"./src/handler/codelens/buffer.ts\"));\nconst logger = __webpack_require__(/*! ../../util/logger */ \"./src/util/logger.ts\")('codelens');\n/**\n * Show codeLens of document, works on neovim only.\n */\nclass CodeLensManager {\n    constructor(nvim) {\n        this.nvim = nvim;\n        this.disposables = [];\n        this.setConfiguration();\n        workspace_1.default.onDidChangeConfiguration(e => {\n            this.setConfiguration(e);\n        }, null, this.disposables);\n        this.buffers = workspace_1.default.registerBufferSync(doc => {\n            if (doc.buftype != '')\n                return undefined;\n            return new buffer_1.default(nvim, doc.bufnr, this.config);\n        });\n        events_1.default.on('ready', () => {\n            this.checkProvider();\n        }, null, this.disposables);\n        events_1.default.on('CursorMoved', bufnr => {\n            let buf = this.buffers.getItem(bufnr);\n            if (buf)\n                buf.resolveCodeLens();\n        }, null, this.disposables);\n        // Refresh on CursorHold\n        let forceFetch = async (bufnr) => {\n            let buf = this.buffers.getItem(bufnr);\n            if (buf)\n                await buf.forceFetch();\n        };\n        events_1.default.on('CursorHold', forceFetch, this, this.disposables);\n    }\n    /**\n     * Check provider for buf that not fetched\n     */\n    checkProvider() {\n        for (let buf of this.buffers.items) {\n            if (buf.hasProvider) {\n                buf.fetchCodelenses();\n            }\n        }\n    }\n    setConfiguration(e) {\n        if (e && !e.affectsConfiguration('codeLens'))\n            return;\n        let config = workspace_1.default.getConfiguration('codeLens');\n        let enable = this.nvim.hasFunction('nvim_buf_set_virtual_text') && config.get('enable', false);\n        if (e && enable != this.config.enabled) {\n            for (let buf of this.buffers.items) {\n                if (enable) {\n                    buf.forceFetch().logError();\n                }\n                else {\n                    buf.clear();\n                }\n            }\n        }\n        this.config = Object.assign(this.config || {}, {\n            enabled: enable,\n            separator: config.get('separator', ''),\n            subseparator: config.get('subseparator', ' ')\n        });\n    }\n    async doAction() {\n        let { nvim } = this;\n        let bufnr = await nvim.call('bufnr', '%');\n        let line = await nvim.call('line', '.') - 1;\n        let buf = this.buffers.getItem(bufnr);\n        await (buf === null || buf === void 0 ? void 0 : buf.doAction(line));\n    }\n    dispose() {\n        this.buffers.dispose();\n        util_1.disposeAll(this.disposables);\n    }\n}\nexports.default = CodeLensManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/handler/codelens/index.ts?");

/***/ }),

/***/ "./src/handler/colors/colorBuffer.ts":
/*!*******************************************!*\
  !*** ./src/handler/colors/colorBuffer.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst debounce_1 = tslib_1.__importDefault(__webpack_require__(/*! debounce */ \"./node_modules/debounce/index.js\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../languages */ \"./src/languages.ts\"));\nconst array_1 = __webpack_require__(/*! ../../util/array */ \"./src/util/array.ts\");\nconst object_1 = __webpack_require__(/*! ../../util/object */ \"./src/util/object.ts\");\nconst position_1 = __webpack_require__(/*! ../../util/position */ \"./src/util/position.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../workspace */ \"./src/workspace.ts\"));\nconst helper_1 = __webpack_require__(/*! ../helper */ \"./src/handler/helper.ts\");\nconst logger = __webpack_require__(/*! ../../util/logger */ \"./src/util/logger.ts\")('colors-buffer');\nclass ColorBuffer {\n    // last highlight version\n    constructor(nvim, bufnr, enabled, usedColors) {\n        this.nvim = nvim;\n        this.bufnr = bufnr;\n        this.enabled = enabled;\n        this.usedColors = usedColors;\n        this._colors = [];\n        this.highlight = debounce_1.default(() => {\n            this.doHighlight().catch(e => {\n                logger.error('Error on color highlight:', e.stack);\n            });\n        }, global.hasOwnProperty('__TEST__') ? 10 : 500);\n    }\n    onChange() {\n        this.cancel();\n        this.highlight();\n    }\n    get buffer() {\n        return this.nvim.createBuffer(this.bufnr);\n    }\n    get colors() {\n        return this._colors;\n    }\n    hasColor() {\n        return this._colors.length > 0;\n    }\n    setState(enabled) {\n        this.enabled = enabled;\n        if (enabled) {\n            this.highlight();\n        }\n        else {\n            this.clearHighlight();\n        }\n    }\n    async doHighlight() {\n        let doc = workspace_1.default.getDocument(this.bufnr);\n        if (!doc || !this.enabled)\n            return;\n        try {\n            this.tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n            let { token } = this.tokenSource;\n            if (this.version && doc.version == this.version)\n                return;\n            let { version } = doc;\n            let colors;\n            colors = await languages_1.default.provideDocumentColors(doc.textDocument, token);\n            colors = colors || [];\n            if (token.isCancellationRequested)\n                return;\n            this.version = version;\n            await this.addHighlight(colors, token);\n        }\n        catch (e) {\n            logger.error('Error on highlight:', e);\n        }\n    }\n    async addHighlight(colors, token) {\n        colors = colors || [];\n        if (object_1.equals(this._colors, colors))\n            return;\n        let { nvim } = this;\n        this._colors = colors;\n        // improve performance\n        let groups = array_1.group(colors, 100);\n        nvim.pauseNotification();\n        this.buffer.clearNamespace('color');\n        this.defineColors(colors);\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        nvim.resumeNotification(false, true);\n        for (let colors of groups) {\n            if (token.isCancellationRequested) {\n                this._colors = [];\n                return;\n            }\n            nvim.pauseNotification();\n            let colorRanges = this.getColorRanges(colors);\n            for (let o of colorRanges) {\n                this.highlightColor(o.ranges, o.color);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            nvim.resumeNotification(false, true);\n        }\n        if (workspace_1.default.isVim) {\n            this.nvim.command('redraw', true);\n        }\n    }\n    highlightColor(ranges, color) {\n        let { red, green, blue } = helper_1.toHexColor(color);\n        let hlGroup = `BG${helper_1.toHexString(color)}`;\n        this.buffer.highlightRanges('color', hlGroup, ranges);\n    }\n    defineColors(colors) {\n        for (let color of colors) {\n            let hex = helper_1.toHexString(color.color);\n            if (!this.usedColors.has(hex)) {\n                this.nvim.command(`hi BG${hex} guibg=#${hex} guifg=#${helper_1.isDark(color.color) ? 'ffffff' : '000000'}`, true);\n                this.usedColors.add(hex);\n            }\n        }\n    }\n    getColorRanges(infos) {\n        let res = [];\n        for (let info of infos) {\n            let { color, range } = info;\n            let idx = res.findIndex(o => object_1.equals(helper_1.toHexColor(o.color), helper_1.toHexColor(color)));\n            if (idx == -1) {\n                res.push({\n                    color,\n                    ranges: [range]\n                });\n            }\n            else {\n                let r = res[idx];\n                r.ranges.push(range);\n            }\n        }\n        return res;\n    }\n    clearHighlight() {\n        this.highlight.clear();\n        this._colors = [];\n        this.version = null;\n        this.buffer.clearNamespace('color');\n    }\n    hasColorAtPostion(position) {\n        let { colors } = this;\n        return colors.some(o => position_1.positionInRange(position, o.range) == 0);\n    }\n    cancel() {\n        if (this.tokenSource) {\n            this.tokenSource.cancel();\n            this.tokenSource = null;\n        }\n    }\n    dispose() {\n        this.highlight.clear();\n        this.cancel();\n    }\n}\nexports.default = ColorBuffer;\n\n\n//# sourceURL=webpack://coc.nvim/./src/handler/colors/colorBuffer.ts?");

/***/ }),

/***/ "./src/handler/colors/index.ts":
/*!*************************************!*\
  !*** ./src/handler/colors/index.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst extensions_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../extensions */ \"./src/extensions.ts\"));\nconst languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../languages */ \"./src/languages.ts\"));\nconst util_1 = __webpack_require__(/*! ../../util */ \"./src/util/index.ts\");\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../window */ \"./src/window.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../workspace */ \"./src/workspace.ts\"));\nconst helper_1 = __webpack_require__(/*! ../helper */ \"./src/handler/helper.ts\");\nconst colorBuffer_1 = tslib_1.__importDefault(__webpack_require__(/*! ./colorBuffer */ \"./src/handler/colors/colorBuffer.ts\"));\nconst logger = __webpack_require__(/*! ../../util/logger */ \"./src/util/logger.ts\")('colors');\nclass Colors {\n    constructor(nvim) {\n        this.nvim = nvim;\n        this._enabled = true;\n        this.disposables = [];\n        let config = workspace_1.default.getConfiguration('coc.preferences');\n        this._enabled = config.get('colorSupport', true);\n        if (workspace_1.default.isVim && !workspace_1.default.env.textprop) {\n            this._enabled = false;\n        }\n        let usedColors = new Set();\n        this.highlighters = workspace_1.default.registerBufferSync(doc => {\n            let buf = new colorBuffer_1.default(this.nvim, doc.bufnr, this._enabled, usedColors);\n            buf.highlight();\n            return buf;\n        });\n        extensions_1.default.onDidActiveExtension(() => {\n            this.highlightAll();\n        }, null, this.disposables);\n        workspace_1.default.onDidChangeConfiguration(async (e) => {\n            if (workspace_1.default.isVim && !workspace_1.default.env.textprop)\n                return;\n            if (e.affectsConfiguration('coc.preferences.colorSupport')) {\n                let config = workspace_1.default.getConfiguration('coc.preferences');\n                let enabled = config.get('colorSupport', true);\n                if (enabled != this._enabled) {\n                    this._enabled = enabled;\n                    for (let buf of this.highlighters.items) {\n                        buf.setState(enabled);\n                    }\n                }\n            }\n        }, null, this.disposables);\n    }\n    async pickPresentation() {\n        let info = await this.currentColorInfomation();\n        if (!info)\n            return window_1.default.showMessage('Color not found at current position', 'warning');\n        let document = await workspace_1.default.document;\n        let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n        let presentations = await languages_1.default.provideColorPresentations(info, document.textDocument, tokenSource.token);\n        if (!presentations || presentations.length == 0)\n            return;\n        let res = await window_1.default.showMenuPicker(presentations.map(o => o.label), 'choose color:');\n        if (res == -1)\n            return;\n        let presentation = presentations[res];\n        let { textEdit, additionalTextEdits, label } = presentation;\n        if (!textEdit)\n            textEdit = { range: info.range, newText: label };\n        await document.applyEdits([textEdit]);\n        if (additionalTextEdits) {\n            await document.applyEdits(additionalTextEdits);\n        }\n    }\n    async pickColor() {\n        let info = await this.currentColorInfomation();\n        if (!info)\n            return window_1.default.showMessage('Color not found at current position', 'warning');\n        let { color } = info;\n        let colorArr = [(color.red * 255).toFixed(0), (color.green * 255).toFixed(0), (color.blue * 255).toFixed(0)];\n        let res = await this.nvim.call('coc#util#pick_color', [colorArr]);\n        if (res === false) {\n            // cancel\n            return;\n        }\n        if (!res || res.length != 3) {\n            window_1.default.showMessage('Failed to get color', 'warning');\n            return;\n        }\n        let hex = helper_1.toHexString({\n            red: (res[0] / 65535),\n            green: (res[1] / 65535),\n            blue: (res[2] / 65535),\n            alpha: 1\n        });\n        let document = await workspace_1.default.document;\n        await document.applyEdits([{\n                range: info.range,\n                newText: `#${hex}`\n            }]);\n    }\n    get enabled() {\n        return this._enabled;\n    }\n    clearHighlight(bufnr) {\n        let highlighter = this.highlighters.getItem(bufnr);\n        if (!highlighter)\n            return;\n        highlighter.clearHighlight();\n    }\n    hasColor(bufnr) {\n        let highlighter = this.highlighters.getItem(bufnr);\n        if (!highlighter)\n            return false;\n        return highlighter.hasColor();\n    }\n    hasColorAtPostion(bufnr, position) {\n        let highlighter = this.highlighters.getItem(bufnr);\n        if (!highlighter)\n            return false;\n        return highlighter.hasColorAtPostion(position);\n    }\n    highlightAll() {\n        for (let buf of this.highlighters.items) {\n            buf.highlight();\n        }\n    }\n    async doHighlight(bufnr) {\n        let highlighter = this.highlighters.getItem(bufnr);\n        if (!highlighter)\n            return;\n        await highlighter.doHighlight();\n    }\n    async currentColorInfomation() {\n        let bufnr = await this.nvim.call('bufnr', '%');\n        let highlighter = this.highlighters.getItem(bufnr);\n        if (!highlighter)\n            return null;\n        let position = await window_1.default.getCursorPosition();\n        for (let info of highlighter.colors) {\n            let { range } = info;\n            let { start, end } = range;\n            if (position.line == start.line\n                && position.character >= start.character\n                && position.character <= end.character) {\n                return info;\n            }\n        }\n        return null;\n    }\n    dispose() {\n        this.highlighters.dispose();\n        util_1.disposeAll(this.disposables);\n    }\n}\nexports.default = Colors;\n\n\n//# sourceURL=webpack://coc.nvim/./src/handler/colors/index.ts?");

/***/ }),

/***/ "./src/handler/format.ts":
/*!*******************************!*\
  !*** ./src/handler/format.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nconst languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ../languages */ \"./src/languages.ts\"));\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ../snippets/manager */ \"./src/snippets/manager.ts\"));\nconst helper_1 = __webpack_require__(/*! ./helper */ \"./src/handler/helper.ts\");\nconst string_1 = __webpack_require__(/*! ../util/string */ \"./src/util/string.ts\");\nconst position_1 = __webpack_require__(/*! ../util/position */ \"./src/util/position.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('handler-format');\nconst pairs = new Map([\n    ['<', '>'],\n    ['>', '<'],\n    ['{', '}'],\n    ['[', ']'],\n    ['(', ')'],\n]);\nclass FormatHandler {\n    constructor(nvim) {\n        this.nvim = nvim;\n        this.disposables = [];\n        this.requestStatusItem = window_1.default.createStatusBarItem(0, { progress: true });\n        this.loadPreferences();\n        workspace_1.default.onDidChangeConfiguration(this.loadPreferences, this, this.disposables);\n        workspace_1.default.onWillSaveTextDocument(event => {\n            let { languageId } = event.document;\n            let filetypes = this.preferences.formatOnSaveFiletypes;\n            if (filetypes.includes(languageId) || filetypes.some(item => item === '*')) {\n                let willSaveWaitUntil = async () => {\n                    if (!languages_1.default.hasFormatProvider(event.document)) {\n                        logger.warn(`Format provider not found for ${event.document.uri}`);\n                        return undefined;\n                    }\n                    let options = await workspace_1.default.getFormatOptions(event.document.uri);\n                    let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n                    let timer = setTimeout(() => {\n                        tokenSource.cancel();\n                    }, 1000);\n                    let textEdits = await languages_1.default.provideDocumentFormattingEdits(event.document, options, tokenSource.token);\n                    clearTimeout(timer);\n                    return textEdits;\n                };\n                event.waitUntil(willSaveWaitUntil());\n            }\n        }, null, this.disposables);\n        events_1.default.on(['CursorMoved', 'CursorMovedI', 'InsertEnter', 'TextChangedI', 'TextChangedP', 'TextChanged'], () => {\n            if (this.requestTokenSource) {\n                this.requestTokenSource.cancel();\n                this.requestTokenSource = null;\n            }\n        }, null, this.disposables);\n        events_1.default.on('Enter', async (bufnr) => {\n            let { bracketEnterImprove } = this.preferences;\n            await this.tryFormatOnType('\\n', bufnr);\n            if (bracketEnterImprove) {\n                let line = await nvim.call('line', '.') - 1;\n                let doc = workspace_1.default.getDocument(bufnr);\n                if (!doc)\n                    return;\n                let pre = doc.getline(line - 1);\n                let curr = doc.getline(line);\n                let prevChar = pre[pre.length - 1];\n                if (prevChar && pairs.has(prevChar)) {\n                    let nextChar = curr.trim()[0];\n                    if (nextChar && pairs.get(prevChar) == nextChar) {\n                        let edits = [];\n                        let opts = await workspace_1.default.getFormatOptions(doc.uri);\n                        let space = opts.insertSpaces ? ' '.repeat(opts.tabSize) : '\\t';\n                        let preIndent = pre.match(/^\\s*/)[0];\n                        let currIndent = curr.match(/^\\s*/)[0];\n                        let newText = '\\n' + preIndent + space;\n                        let pos = vscode_languageserver_protocol_1.Position.create(line - 1, pre.length);\n                        // make sure indent of current line\n                        if (preIndent != currIndent) {\n                            let newText = doc.filetype == 'vim' ? '  \\\\ ' + preIndent : preIndent;\n                            edits.push({ range: vscode_languageserver_protocol_1.Range.create(vscode_languageserver_protocol_1.Position.create(line, 0), vscode_languageserver_protocol_1.Position.create(line, currIndent.length)), newText });\n                        }\n                        else if (doc.filetype == 'vim') {\n                            edits.push({ range: vscode_languageserver_protocol_1.Range.create(line, currIndent.length, line, currIndent.length), newText: '  \\\\ ' });\n                        }\n                        if (doc.filetype == 'vim') {\n                            newText = newText + '\\\\ ';\n                        }\n                        edits.push({ range: vscode_languageserver_protocol_1.Range.create(pos, pos), newText });\n                        await doc.applyEdits(edits);\n                        await window_1.default.moveTo(vscode_languageserver_protocol_1.Position.create(line, newText.length - 1));\n                    }\n                }\n            }\n        }, null, this.disposables);\n        let changedTs;\n        let lastInsert;\n        events_1.default.on('InsertCharPre', async () => {\n            lastInsert = Date.now();\n        }, null, this.disposables);\n        events_1.default.on('TextChangedI', async (bufnr, info) => {\n            changedTs = Date.now();\n            if (!lastInsert || changedTs - lastInsert > 300)\n                return;\n            lastInsert = null;\n            let doc = workspace_1.default.getDocument(bufnr);\n            if (!doc)\n                return;\n            let pre = info.pre[info.pre.length - 1];\n            if (!pre || !languages_1.default.hasProvider('onTypeEdit', doc.textDocument))\n                return;\n            await this.tryFormatOnType(pre, bufnr);\n        }, null, this.disposables);\n        let lastEnterBufnr;\n        let lastEnterTs;\n        events_1.default.on('InsertEnter', bufnr => {\n            lastEnterBufnr = bufnr;\n            lastEnterTs = Date.now();\n        });\n        events_1.default.on('TextChangedI', async (bufnr, info) => {\n            if (!this.preferences.formatOnType && !/^\\s*$/.test(info.pre))\n                return;\n            if (lastEnterBufnr != bufnr || !lastEnterTs || Date.now() - lastEnterTs > 30)\n                return;\n            await this.tryFormatOnType('\\n', bufnr, true);\n        });\n    }\n    loadPreferences(e) {\n        if (!e || e.affectsConfiguration('coc.preferences')) {\n            let config = workspace_1.default.getConfiguration('coc.preferences');\n            this.preferences = {\n                formatOnType: config.get('formatOnType', false),\n                formatOnSaveFiletypes: config.get('formatOnSaveFiletypes', []),\n                formatOnTypeFiletypes: config.get('formatOnTypeFiletypes', []),\n                bracketEnterImprove: config.get('bracketEnterImprove', true),\n            };\n        }\n    }\n    async withRequestToken(name, fn) {\n        if (this.requestTokenSource) {\n            this.requestTokenSource.cancel();\n            this.requestTokenSource.dispose();\n        }\n        let statusItem = this.requestStatusItem;\n        this.requestTokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n        let { token } = this.requestTokenSource;\n        token.onCancellationRequested(() => {\n            statusItem.text = `${name} request canceled`;\n            statusItem.isProgress = false;\n            statusItem.hide();\n        });\n        statusItem.isProgress = true;\n        statusItem.text = `requesting ${name}`;\n        statusItem.show();\n        let res;\n        try {\n            res = await Promise.resolve(fn(token));\n        }\n        catch (e) {\n            window_1.default.showMessage(e.message, 'error');\n            logger.error(`Error on ${name}`, e);\n        }\n        if (this.requestTokenSource) {\n            this.requestTokenSource.dispose();\n            this.requestTokenSource = undefined;\n        }\n        if (token.isCancellationRequested)\n            return null;\n        statusItem.hide();\n        if (res == null) {\n            logger.warn(`${name} provider not found!`);\n        }\n        return res;\n    }\n    async tryFormatOnType(ch, bufnr, newLine = false) {\n        if (!ch || string_1.isWord(ch) || !this.preferences.formatOnType)\n            return;\n        if (manager_1.default.getSession(bufnr) != null)\n            return;\n        let doc = workspace_1.default.getDocument(bufnr);\n        if (!doc || !doc.attached || doc.isCommandLine)\n            return;\n        const filetypes = this.preferences.formatOnTypeFiletypes;\n        if (filetypes.length && !filetypes.includes(doc.filetype)) {\n            // Only check formatOnTypeFiletypes when set, avoid breaking change\n            return;\n        }\n        if (!languages_1.default.hasOnTypeProvider(ch, doc.textDocument))\n            return;\n        let position;\n        let edits = await this.withRequestToken('onTypeFormat ', async (token) => {\n            position = await window_1.default.getCursorPosition();\n            let origLine = doc.getline(position.line - 1);\n            // not format for empty line.\n            if (newLine && /^\\s*$/.test(origLine))\n                return;\n            let pos = newLine ? { line: position.line - 1, character: origLine.length } : position;\n            await helper_1.synchronizeDocument(doc);\n            return await languages_1.default.provideDocumentOnTypeEdits(ch, doc.textDocument, pos, token);\n        });\n        if (!edits || !edits.length)\n            return;\n        let changed = position_1.getChangedFromEdits(position, edits);\n        await doc.applyEdits(edits);\n        let to = changed ? vscode_languageserver_protocol_1.Position.create(position.line + changed.line, position.character + changed.character) : null;\n        if (to && !newLine)\n            await window_1.default.moveTo(to);\n    }\n    async documentFormat() {\n        let doc = await workspace_1.default.document;\n        if (!doc || !doc.attached)\n            return false;\n        await helper_1.synchronizeDocument(doc);\n        let options = await workspace_1.default.getFormatOptions(doc.uri);\n        let textEdits = await this.withRequestToken('format', token => {\n            return languages_1.default.provideDocumentFormattingEdits(doc.textDocument, options, token);\n        });\n        if (textEdits && textEdits.length > 0) {\n            await doc.applyEdits(textEdits);\n            return true;\n        }\n        return false;\n    }\n    async documentRangeFormat(mode) {\n        let doc = await workspace_1.default.document;\n        if (!doc || !doc.attached)\n            return -1;\n        await helper_1.synchronizeDocument(doc);\n        let range;\n        if (mode) {\n            range = await workspace_1.default.getSelectedRange(mode, doc);\n            if (!range)\n                return -1;\n        }\n        else {\n            let [lnum, count, mode] = await this.nvim.eval(\"[v:lnum,v:count,mode()]\");\n            // we can't handle\n            if (count == 0 || mode == 'i' || mode == 'R')\n                return -1;\n            range = vscode_languageserver_protocol_1.Range.create(lnum - 1, 0, lnum - 1 + count, 0);\n        }\n        let options = await workspace_1.default.getFormatOptions(doc.uri);\n        let textEdits = await this.withRequestToken('format', token => {\n            return languages_1.default.provideDocumentRangeFormattingEdits(doc.textDocument, range, options, token);\n        });\n        if (textEdits && textEdits.length > 0) {\n            await doc.applyEdits(textEdits);\n            return 0;\n        }\n        return -1;\n    }\n    dispose() {\n        util_1.disposeAll(this.disposables);\n    }\n}\nexports.default = FormatHandler;\n\n\n//# sourceURL=webpack://coc.nvim/./src/handler/format.ts?");

/***/ }),

/***/ "./src/handler/helper.ts":
/*!*******************************!*\
  !*** ./src/handler/helper.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isDark = exports.toHexColor = exports.toHexString = exports.synchronizeDocument = exports.addDocument = exports.isMarkdown = exports.isDocumentSymbols = exports.sortSymbolInformations = exports.addDoucmentSymbol = exports.sortDocumentSymbols = exports.getPreviousContainer = void 0;\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst convert_1 = __webpack_require__(/*! ../util/convert */ \"./src/util/convert.ts\");\nfunction getPreviousContainer(containerName, symbols) {\n    if (!symbols.length)\n        return null;\n    let i = symbols.length - 1;\n    let last = symbols[i];\n    if (last.text == containerName) {\n        return last;\n    }\n    while (i >= 0) {\n        let sym = symbols[i];\n        if (sym.text == containerName) {\n            return sym;\n        }\n        i--;\n    }\n    return null;\n}\nexports.getPreviousContainer = getPreviousContainer;\nfunction sortDocumentSymbols(a, b) {\n    let ra = a.selectionRange;\n    let rb = b.selectionRange;\n    if (ra.start.line < rb.start.line) {\n        return -1;\n    }\n    if (ra.start.line > rb.start.line) {\n        return 1;\n    }\n    return ra.start.character - rb.start.character;\n}\nexports.sortDocumentSymbols = sortDocumentSymbols;\nfunction addDoucmentSymbol(res, sym, level) {\n    let { name, selectionRange, kind, children, range } = sym;\n    let { start } = selectionRange;\n    res.push({\n        col: start.character + 1,\n        lnum: start.line + 1,\n        text: name,\n        level,\n        kind: convert_1.getSymbolKind(kind),\n        range,\n        selectionRange\n    });\n    if (children && children.length) {\n        children.sort(sortDocumentSymbols);\n        for (let sym of children) {\n            addDoucmentSymbol(res, sym, level + 1);\n        }\n    }\n}\nexports.addDoucmentSymbol = addDoucmentSymbol;\nfunction sortSymbolInformations(a, b) {\n    let sa = a.location.range.start;\n    let sb = b.location.range.start;\n    let d = sa.line - sb.line;\n    return d == 0 ? sa.character - sb.character : d;\n}\nexports.sortSymbolInformations = sortSymbolInformations;\nfunction isDocumentSymbol(a) {\n    return a && !a.hasOwnProperty('location');\n}\nfunction isDocumentSymbols(a) {\n    return isDocumentSymbol(a[0]);\n}\nexports.isDocumentSymbols = isDocumentSymbols;\nfunction isMarkdown(content) {\n    if (vscode_languageserver_protocol_1.MarkupContent.is(content) && content.kind == vscode_languageserver_protocol_1.MarkupKind.Markdown) {\n        return true;\n    }\n    return false;\n}\nexports.isMarkdown = isMarkdown;\nfunction addDocument(docs, text, filetype, isPreview = false) {\n    let content = text.trim();\n    if (!content.length)\n        return;\n    if (isPreview && filetype !== 'markdown') {\n        content = '``` ' + filetype + '\\n' + content + '\\n```';\n    }\n    docs.push({ content, filetype });\n}\nexports.addDocument = addDocument;\nasync function synchronizeDocument(doc) {\n    let { changedtick } = doc;\n    await doc.patchChange();\n    if (changedtick != doc.changedtick) {\n        await util_1.wait(50);\n    }\n}\nexports.synchronizeDocument = synchronizeDocument;\nfunction toHexString(color) {\n    let c = toHexColor(color);\n    return `${pad(c.red.toString(16))}${pad(c.green.toString(16))}${pad(c.blue.toString(16))}`;\n}\nexports.toHexString = toHexString;\nfunction pad(str) {\n    return str.length == 1 ? `0${str}` : str;\n}\nfunction toHexColor(color) {\n    let { red, green, blue } = color;\n    return {\n        red: Math.round(red * 255),\n        green: Math.round(green * 255),\n        blue: Math.round(blue * 255)\n    };\n}\nexports.toHexColor = toHexColor;\nfunction isDark(color) {\n    // http://www.w3.org/TR/WCAG20/#relativeluminancedef\n    let rgb = [color.red, color.green, color.blue];\n    let lum = [];\n    for (let i = 0; i < rgb.length; i++) {\n        let chan = rgb[i];\n        lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\n    }\n    let luma = 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n    return luma <= 0.5;\n}\nexports.isDark = isDark;\n\n\n//# sourceURL=webpack://coc.nvim/./src/handler/helper.ts?");

/***/ }),

/***/ "./src/handler/highlights.ts":
/*!***********************************!*\
  !*** ./src/handler/highlights.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nconst languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ../languages */ \"./src/languages.ts\"));\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('documentHighlight');\nconst namespaceKey = 'coc-highlight';\n/**\n * Highlights of symbol under cursor.\n */\nclass Highlights {\n    constructor(nvim) {\n        this.nvim = nvim;\n        this.disposables = [];\n        this.highlights = new Map();\n        events_1.default.on(['WinLeave', 'TextChanged', 'CursorMoved', 'InsertEnter'], () => {\n            this.cancel();\n        }, null, this.disposables);\n        events_1.default.on('BufUnload', bufnr => {\n            this.highlights.delete(bufnr);\n        }, null, this.disposables);\n    }\n    clearHighlight(bufnr) {\n        let { nvim } = workspace_1.default;\n        let buf = nvim.createBuffer(bufnr);\n        buf.clearNamespace(namespaceKey);\n        if (workspace_1.default.isVim)\n            nvim.command('redraw', true);\n        this.highlights.delete(bufnr);\n    }\n    async highlight() {\n        let { nvim } = this;\n        this.cancel();\n        let [bufnr, cursors] = await nvim.eval(`[bufnr('%'),get(b:,'coc_cursors_activated',0)]`);\n        let doc = workspace_1.default.getDocument(bufnr);\n        if (!doc || !doc.attached || !languages_1.default.hasProvider('documentHighlight', doc.textDocument))\n            return;\n        if (cursors) {\n            this.clearHighlight(bufnr);\n            return;\n        }\n        let position = await window_1.default.getCursorPosition();\n        let highlights = await this.getHighlights(doc, position);\n        if (!highlights) {\n            this.clearHighlight(bufnr);\n            return;\n        }\n        let groups = {};\n        for (let hl of highlights) {\n            if (!hl.range)\n                continue;\n            let hlGroup = hl.kind == vscode_languageserver_protocol_1.DocumentHighlightKind.Text\n                ? 'CocHighlightText'\n                : hl.kind == vscode_languageserver_protocol_1.DocumentHighlightKind.Read ? 'CocHighlightRead' : 'CocHighlightWrite';\n            groups[hlGroup] = groups[hlGroup] || [];\n            groups[hlGroup].push(hl.range);\n        }\n        let buffer = nvim.createBuffer(bufnr);\n        nvim.pauseNotification();\n        buffer.clearNamespace(namespaceKey);\n        for (let hlGroup of Object.keys(groups)) {\n            buffer.highlightRanges(namespaceKey, hlGroup, groups[hlGroup]);\n        }\n        if (workspace_1.default.isVim)\n            nvim.command('redraw', true);\n        let res = this.nvim.resumeNotification();\n        if (Array.isArray(res) && res[1] != null) {\n            logger.error(`Error on highlight`, res[1][2]);\n        }\n        else {\n            this.highlights.set(bufnr, highlights);\n        }\n    }\n    hasHighlights(bufnr) {\n        return this.highlights.get(bufnr) != null;\n    }\n    async getHighlights(doc, position) {\n        if (!doc || !doc.attached || doc.isCommandLine)\n            return null;\n        let line = doc.getline(position.line);\n        let ch = line[position.character];\n        if (!ch || !doc.isWord(ch))\n            return null;\n        try {\n            this.tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n            doc.forceSync();\n            let { token } = this.tokenSource;\n            let highlights = await languages_1.default.getDocumentHighLight(doc.textDocument, position, token);\n            this.tokenSource = null;\n            if (token.isCancellationRequested)\n                return null;\n            return highlights;\n        }\n        catch (_e) {\n            return null;\n        }\n    }\n    cancel() {\n        if (this.tokenSource) {\n            this.tokenSource.cancel();\n            this.tokenSource.dispose();\n            this.tokenSource = null;\n        }\n    }\n    dispose() {\n        if (this.tokenSource)\n            this.tokenSource.dispose();\n        util_1.disposeAll(this.disposables);\n    }\n}\nexports.default = Highlights;\n\n\n//# sourceURL=webpack://coc.nvim/./src/handler/highlights.ts?");

/***/ }),

/***/ "./src/handler/index.ts":
/*!******************************!*\
  !*** ./src/handler/index.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst commands_1 = tslib_1.__importDefault(__webpack_require__(/*! ../commands */ \"./src/commands.ts\"));\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ../diagnostic/manager */ \"./src/diagnostic/manager.ts\"));\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nconst languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ../languages */ \"./src/languages.ts\"));\nconst manager_2 = tslib_1.__importDefault(__webpack_require__(/*! ../list/manager */ \"./src/list/manager.ts\"));\nconst floatFactory_1 = tslib_1.__importDefault(__webpack_require__(/*! ../model/floatFactory */ \"./src/model/floatFactory.ts\"));\nconst services_1 = tslib_1.__importDefault(__webpack_require__(/*! ../services */ \"./src/services.ts\"));\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst object_1 = __webpack_require__(/*! ../util/object */ \"./src/util/object.ts\");\nconst position_1 = __webpack_require__(/*! ../util/position */ \"./src/util/position.ts\");\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst index_1 = tslib_1.__importDefault(__webpack_require__(/*! ./codelens/index */ \"./src/handler/codelens/index.ts\"));\nconst index_2 = tslib_1.__importDefault(__webpack_require__(/*! ./colors/index */ \"./src/handler/colors/index.ts\"));\nconst format_1 = tslib_1.__importDefault(__webpack_require__(/*! ./format */ \"./src/handler/format.ts\"));\nconst helper_1 = __webpack_require__(/*! ./helper */ \"./src/handler/helper.ts\");\nconst highlights_1 = tslib_1.__importDefault(__webpack_require__(/*! ./highlights */ \"./src/handler/highlights.ts\"));\nconst index_3 = tslib_1.__importDefault(__webpack_require__(/*! ./refactor/index */ \"./src/handler/refactor/index.ts\"));\nconst signature_1 = tslib_1.__importDefault(__webpack_require__(/*! ./signature */ \"./src/handler/signature.ts\"));\nconst symbols_1 = tslib_1.__importDefault(__webpack_require__(/*! ./symbols */ \"./src/handler/symbols.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('Handler');\nclass Handler {\n    constructor(nvim) {\n        this.nvim = nvim;\n        this.documentLines = [];\n        this.selectionRange = null;\n        this.disposables = [];\n        this.getPreferences();\n        this.requestStatusItem = window_1.default.createStatusBarItem(0, { progress: true });\n        workspace_1.default.onDidChangeConfiguration(() => {\n            this.getPreferences();\n        });\n        this.refactor = new index_3.default();\n        this.hoverFactory = new floatFactory_1.default(nvim);\n        this.signature = new signature_1.default(nvim);\n        this.format = new format_1.default(nvim);\n        this.symbols = new symbols_1.default(nvim);\n        events_1.default.on(['CursorMoved', 'CursorMovedI', 'InsertEnter', 'InsertSnippet', 'InsertLeave'], () => {\n            if (this.requestTokenSource) {\n                this.requestTokenSource.cancel();\n            }\n        }, null, this.disposables);\n        let provider = {\n            onDidChange: null,\n            provideTextDocumentContent: async () => {\n                nvim.pauseNotification();\n                nvim.command('setlocal conceallevel=2 nospell nofoldenable wrap', true);\n                nvim.command('setlocal bufhidden=wipe nobuflisted', true);\n                nvim.command('setfiletype markdown', true);\n                nvim.command(`if winnr('j') != winnr('k') | exe \"normal! z${Math.min(this.documentLines.length, this.preferences.previewMaxHeight)}\\\\<cr> | endif\"`, true);\n                await nvim.resumeNotification();\n                return this.documentLines.join('\\n');\n            }\n        };\n        this.disposables.push(workspace_1.default.registerTextDocumentContentProvider('coc', provider));\n        this.codeLens = new index_1.default(nvim);\n        this.colors = new index_2.default(nvim);\n        this.documentHighlighter = new highlights_1.default(nvim);\n        this.disposables.push(commands_1.default.registerCommand('editor.action.pickColor', () => {\n            return this.colors.pickColor();\n        }));\n        commands_1.default.titles.set('editor.action.pickColor', 'pick color from system color picker when possible.');\n        this.disposables.push(commands_1.default.registerCommand('editor.action.colorPresentation', () => {\n            return this.colors.pickPresentation();\n        }));\n        commands_1.default.titles.set('editor.action.colorPresentation', 'change color presentation.');\n        this.disposables.push(commands_1.default.registerCommand('editor.action.organizeImport', async (bufnr) => {\n            if (!bufnr)\n                bufnr = await nvim.call('bufnr', '%');\n            let doc = workspace_1.default.getDocument(bufnr);\n            if (!doc || !doc.attached)\n                return false;\n            await helper_1.synchronizeDocument(doc);\n            let actions = await this.getCodeActions(doc, undefined, [vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports]);\n            if (actions && actions.length) {\n                await this.applyCodeAction(actions[0]);\n                return true;\n            }\n            window_1.default.showMessage(`Organize import action not found.`, 'warning');\n            return false;\n        }));\n        commands_1.default.titles.set('editor.action.organizeImport', 'run organize import code action.');\n    }\n    async withRequestToken(name, fn, checkEmpty) {\n        if (this.requestTokenSource) {\n            this.requestTokenSource.cancel();\n            this.requestTokenSource.dispose();\n        }\n        if (this.requestTimer) {\n            clearTimeout(this.requestTimer);\n        }\n        let statusItem = this.requestStatusItem;\n        this.requestTokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n        let { token } = this.requestTokenSource;\n        token.onCancellationRequested(() => {\n            statusItem.text = `${name} request canceled`;\n            statusItem.isProgress = false;\n            this.requestTimer = setTimeout(() => {\n                statusItem.hide();\n            }, 500);\n        });\n        statusItem.isProgress = true;\n        statusItem.text = `requesting ${name}`;\n        statusItem.show();\n        let res;\n        try {\n            res = await Promise.resolve(fn(token));\n        }\n        catch (e) {\n            window_1.default.showMessage(e.message, 'error');\n            logger.error(`Error on ${name}`, e);\n        }\n        if (this.requestTokenSource) {\n            this.requestTokenSource.dispose();\n            this.requestTokenSource = undefined;\n        }\n        if (token.isCancellationRequested)\n            return null;\n        statusItem.hide();\n        if (res == null) {\n            logger.warn(`${name} provider not found!`);\n        }\n        else if (checkEmpty && Array.isArray(res) && res.length == 0) {\n            window_1.default.showMessage(`${name} not found`, 'warning');\n            return null;\n        }\n        return res;\n    }\n    async getCurrentFunctionSymbol() {\n        return await this.symbols.getCurrentFunctionSymbol();\n    }\n    /*\n     * supportedSymbols must be string values of symbolKind\n     */\n    async selectSymbolRange(inner, visualmode, supportedSymbols) {\n        return await this.symbols.selectSymbolRange(inner, visualmode, supportedSymbols);\n    }\n    async getDocumentSymbols(bufnr) {\n        return await this.symbols.getDocumentSymbols(bufnr);\n    }\n    async hasProvider(id) {\n        let bufnr = await this.nvim.call('bufnr', '%');\n        let doc = workspace_1.default.getDocument(bufnr);\n        if (!doc)\n            return false;\n        return languages_1.default.hasProvider(id, doc.textDocument);\n    }\n    async onHover(hoverTarget) {\n        let { doc, position, winid } = await this.getCurrentState();\n        if (doc == null)\n            return;\n        let target = hoverTarget !== null && hoverTarget !== void 0 ? hoverTarget : this.preferences.hoverTarget;\n        if (target == 'float') {\n            this.hoverFactory.close();\n        }\n        await helper_1.synchronizeDocument(doc);\n        let hovers = await this.withRequestToken('hover', token => {\n            return languages_1.default.getHover(doc.textDocument, position, token);\n        }, true);\n        if (hovers == null)\n            return false;\n        let hover = hovers.find(o => vscode_languageserver_protocol_1.Range.is(o.range));\n        if (hover === null || hover === void 0 ? void 0 : hover.range) {\n            let win = this.nvim.createWindow(winid);\n            let ids = await win.highlightRanges('CocHoverRange', [hover.range], 99);\n            setTimeout(() => {\n                if (ids.length)\n                    win.clearMatches(ids);\n                if (workspace_1.default.isVim)\n                    this.nvim.command('redraw', true);\n            }, 1000);\n        }\n        await this.previewHover(hovers, target);\n        return true;\n    }\n    /**\n     * Get hover text array\n     */\n    async getHover() {\n        let result = [];\n        let { doc, position } = await this.getCurrentState();\n        if (!languages_1.default.hasProvider('hover', doc.textDocument)) {\n            return result;\n        }\n        await helper_1.synchronizeDocument(doc);\n        let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n        let hovers = await languages_1.default.getHover(doc.textDocument, position, tokenSource.token);\n        if (Array.isArray(hovers)) {\n            for (let h of hovers) {\n                let { contents } = h;\n                if (Array.isArray(contents)) {\n                    contents.forEach(c => {\n                        result.push(typeof c === 'string' ? c : c.value);\n                    });\n                }\n                else if (vscode_languageserver_protocol_1.MarkupContent.is(contents)) {\n                    result.push(contents.value);\n                }\n                else {\n                    result.push(typeof contents === 'string' ? contents : contents.value);\n                }\n            }\n        }\n        result = result.filter(s => s != null && s.length > 0);\n        return result;\n    }\n    async gotoDefinition(openCommand) {\n        let { doc, position } = await this.getCurrentState();\n        if (doc == null)\n            return false;\n        await helper_1.synchronizeDocument(doc);\n        let definition = await this.withRequestToken('definition', token => {\n            return languages_1.default.getDefinition(doc.textDocument, position, token);\n        }, true);\n        if (definition == null)\n            return false;\n        await this.handleLocations(definition, openCommand);\n        return true;\n    }\n    async gotoDeclaration(openCommand) {\n        let { doc, position } = await this.getCurrentState();\n        if (doc == null)\n            return false;\n        await helper_1.synchronizeDocument(doc);\n        let definition = await this.withRequestToken('declaration', token => {\n            return languages_1.default.getDeclaration(doc.textDocument, position, token);\n        }, true);\n        if (definition == null)\n            return false;\n        await this.handleLocations(definition, openCommand);\n        return true;\n    }\n    async gotoTypeDefinition(openCommand) {\n        let { doc, position } = await this.getCurrentState();\n        if (doc == null)\n            return false;\n        await helper_1.synchronizeDocument(doc);\n        let definition = await this.withRequestToken('type definition', token => {\n            return languages_1.default.getTypeDefinition(doc.textDocument, position, token);\n        }, true);\n        if (definition == null)\n            return false;\n        await this.handleLocations(definition, openCommand);\n        return true;\n    }\n    async gotoImplementation(openCommand) {\n        let { doc, position } = await this.getCurrentState();\n        if (doc == null)\n            return false;\n        await helper_1.synchronizeDocument(doc);\n        let definition = await this.withRequestToken('implementation', token => {\n            return languages_1.default.getImplementation(doc.textDocument, position, token);\n        }, true);\n        if (definition == null)\n            return false;\n        await this.handleLocations(definition, openCommand);\n        return true;\n    }\n    async gotoReferences(openCommand, includeDeclaration = true) {\n        let { doc, position } = await this.getCurrentState();\n        if (doc == null)\n            return false;\n        await helper_1.synchronizeDocument(doc);\n        let definition = await this.withRequestToken('references', token => {\n            return languages_1.default.getReferences(doc.textDocument, { includeDeclaration }, position, token);\n        }, true);\n        if (definition == null)\n            return false;\n        await this.handleLocations(definition, openCommand);\n        return true;\n    }\n    async getWordEdit() {\n        let { doc, position } = await this.getCurrentState();\n        if (doc == null)\n            return null;\n        let range = doc.getWordRangeAtPosition(position);\n        if (!range || position_1.emptyRange(range))\n            return null;\n        let curname = doc.textDocument.getText(range);\n        if (languages_1.default.hasProvider('rename', doc.textDocument)) {\n            await helper_1.synchronizeDocument(doc);\n            let requestTokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n            let res = await languages_1.default.prepareRename(doc.textDocument, position, requestTokenSource.token);\n            if (res === false)\n                return null;\n            let edit = await languages_1.default.provideRenameEdits(doc.textDocument, position, curname, requestTokenSource.token);\n            if (edit)\n                return edit;\n        }\n        window_1.default.showMessage('Rename provider not found, extract word ranges from current buffer', 'more');\n        let ranges = doc.getSymbolRanges(curname);\n        return {\n            changes: {\n                [doc.uri]: ranges.map(r => ({ range: r, newText: curname }))\n            }\n        };\n    }\n    async rename(newName) {\n        let { doc, position } = await this.getCurrentState();\n        if (doc == null)\n            return false;\n        let { nvim } = this;\n        if (!languages_1.default.hasProvider('rename', doc.textDocument)) {\n            window_1.default.showMessage(`Rename provider not found for current document`, 'warning');\n            return false;\n        }\n        await helper_1.synchronizeDocument(doc);\n        let statusItem = this.requestStatusItem;\n        try {\n            let token = (new vscode_languageserver_protocol_1.CancellationTokenSource()).token;\n            let res = await languages_1.default.prepareRename(doc.textDocument, position, token);\n            if (res === false) {\n                statusItem.hide();\n                window_1.default.showMessage('Invalid position for rename', 'warning');\n                return false;\n            }\n            if (token.isCancellationRequested)\n                return false;\n            let curname;\n            if (!newName) {\n                if (vscode_languageserver_protocol_1.Range.is(res)) {\n                    curname = doc.textDocument.getText(res);\n                    await window_1.default.moveTo(res.start);\n                }\n                else if (res && typeof res.placeholder === 'string') {\n                    curname = res.placeholder;\n                }\n                else {\n                    curname = await nvim.eval('expand(\"<cword>\")');\n                }\n                newName = await window_1.default.requestInput('New name', curname);\n            }\n            if (!newName) {\n                statusItem.hide();\n                return false;\n            }\n            let edit = await languages_1.default.provideRenameEdits(doc.textDocument, position, newName, token);\n            if (token.isCancellationRequested)\n                return false;\n            statusItem.hide();\n            if (!edit) {\n                window_1.default.showMessage('Invalid position for rename', 'warning');\n                return false;\n            }\n            await workspace_1.default.applyEdit(edit);\n            return true;\n        }\n        catch (e) {\n            statusItem.hide();\n            window_1.default.showMessage(`Error on rename: ${e.message}`, 'error');\n            logger.error(e);\n            return false;\n        }\n    }\n    async documentFormatting() {\n        return await this.format.documentFormat();\n    }\n    async documentRangeFormatting(mode) {\n        return await this.format.documentRangeFormat(mode);\n    }\n    async getTagList() {\n        let { doc, position } = await this.getCurrentState();\n        let word = await this.nvim.call('expand', '<cword>');\n        if (!word || doc == null)\n            return null;\n        if (!languages_1.default.hasProvider('definition', doc.textDocument))\n            return null;\n        let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n        let definitions = await languages_1.default.getDefinition(doc.textDocument, position, tokenSource.token);\n        if (!definitions || !definitions.length)\n            return null;\n        return definitions.map(location => {\n            let parsedURI = vscode_uri_1.URI.parse(location.uri);\n            const filename = parsedURI.scheme == 'file' ? parsedURI.fsPath : parsedURI.toString();\n            return {\n                name: word,\n                cmd: `keepjumps ${location.range.start.line + 1} | normal ${location.range.start.character + 1}|`,\n                filename,\n            };\n        });\n    }\n    async runCommand(id, ...args) {\n        if (id) {\n            await events_1.default.fire('Command', [id]);\n            let res = await commands_1.default.executeCommand(id, ...args);\n            if (args.length == 0) {\n                await commands_1.default.addRecent(id);\n            }\n            return res;\n        }\n        else {\n            await manager_2.default.start(['commands']);\n        }\n    }\n    async getCodeActions(doc, range, only) {\n        range = range || vscode_languageserver_protocol_1.Range.create(0, 0, doc.lineCount, 0);\n        let diagnostics = manager_1.default.getDiagnosticsInRange(doc.textDocument, range);\n        let context = { diagnostics };\n        if (only && Array.isArray(only))\n            context.only = only;\n        let codeActions = await this.withRequestToken('code action', token => {\n            return languages_1.default.getCodeActions(doc.textDocument, range, context, token);\n        });\n        if (!codeActions || codeActions.length == 0)\n            return [];\n        codeActions.sort((a, b) => {\n            if (a.isPreferred && !b.isPreferred) {\n                return -1;\n            }\n            if (b.isPreferred && !a.isPreferred) {\n                return 1;\n            }\n            return 0;\n        });\n        return codeActions;\n    }\n    async doCodeAction(mode, only) {\n        let { doc } = await this.getCurrentState();\n        if (!doc)\n            return;\n        let range;\n        if (mode)\n            range = await workspace_1.default.getSelectedRange(mode, doc);\n        await helper_1.synchronizeDocument(doc);\n        let codeActions = await this.getCodeActions(doc, range, Array.isArray(only) ? only : null);\n        if (only && typeof only == 'string') {\n            codeActions = codeActions.filter(o => o.title == only || (o.command && o.command.title == only));\n        }\n        if (!codeActions || codeActions.length == 0) {\n            window_1.default.showMessage(`No${only ? ' ' + only : ''} code action available`, 'warning');\n            return;\n        }\n        let idx = await window_1.default.showMenuPicker(codeActions.map(o => o.title), 'Choose action');\n        let action = codeActions[idx];\n        if (action)\n            await this.applyCodeAction(action);\n    }\n    /**\n     * Get current codeActions\n     *\n     * @public\n     * @returns {Promise<CodeAction[]>}\n     */\n    async getCurrentCodeActions(mode, only) {\n        let { doc } = await this.getCurrentState();\n        if (!doc)\n            return [];\n        let range;\n        if (mode)\n            range = await workspace_1.default.getSelectedRange(mode, doc);\n        return await this.getCodeActions(doc, range, only);\n    }\n    /**\n     * Invoke preferred quickfix at current position, return false when failed\n     *\n     * @returns {Promise<boolean>}\n     */\n    async doQuickfix() {\n        let actions = await this.getCurrentCodeActions('n', [vscode_languageserver_protocol_1.CodeActionKind.QuickFix]);\n        if (!actions || actions.length == 0) {\n            window_1.default.showMessage('No quickfix action available', 'warning');\n            return false;\n        }\n        await this.applyCodeAction(actions[0]);\n        await this.nvim.command(`silent! call repeat#set(\"\\\\<Plug>(coc-fix-current)\", -1)`);\n        return true;\n    }\n    async applyCodeAction(action) {\n        let { command, edit } = action;\n        if (edit)\n            await workspace_1.default.applyEdit(edit);\n        if (command) {\n            if (commands_1.default.has(command.command)) {\n                commands_1.default.execute(command);\n            }\n            else {\n                let clientId = action.clientId;\n                let service = services_1.default.getService(clientId);\n                let params = {\n                    command: command.command,\n                    arguments: command.arguments\n                };\n                if (service.client) {\n                    let { client } = service;\n                    client\n                        .sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params)\n                        .then(undefined, error => {\n                        window_1.default.showMessage(`Execute '${command.command} error: ${error}'`, 'error');\n                    });\n                }\n            }\n        }\n    }\n    async doCodeLensAction() {\n        await this.codeLens.doAction();\n    }\n    async fold(kind) {\n        let { doc, winid } = await this.getCurrentState();\n        if (!doc)\n            return false;\n        await helper_1.synchronizeDocument(doc);\n        let win = this.nvim.createWindow(winid);\n        let [foldmethod, foldlevel] = await this.nvim.eval('[&foldmethod,&foldlevel]');\n        if (foldmethod != 'manual') {\n            window_1.default.showMessage('foldmethod option should be manual!', 'warning');\n            return false;\n        }\n        let ranges = await this.withRequestToken('folding range', token => {\n            return languages_1.default.provideFoldingRanges(doc.textDocument, {}, token);\n        }, true);\n        if (!ranges)\n            return false;\n        if (kind)\n            ranges = ranges.filter(o => o.kind == kind);\n        if (ranges.length) {\n            ranges.sort((a, b) => b.startLine - a.startLine);\n            this.nvim.pauseNotification();\n            for (let range of ranges) {\n                let { startLine, endLine } = range;\n                let cmd = `${startLine + 1}, ${endLine + 1}fold`;\n                this.nvim.command(cmd, true);\n            }\n            win.setOption('foldlevel', foldlevel, true);\n            await this.nvim.resumeNotification();\n            return true;\n        }\n        return false;\n    }\n    async pickColor() {\n        await this.colors.pickColor();\n    }\n    async pickPresentation() {\n        await this.colors.pickPresentation();\n    }\n    async highlight() {\n        await this.documentHighlighter.highlight();\n    }\n    async getSymbolsRanges() {\n        let { doc, position } = await this.getCurrentState();\n        let highlights = await this.documentHighlighter.getHighlights(doc, position);\n        if (!highlights)\n            return null;\n        return highlights.map(o => o.range);\n    }\n    async links() {\n        let { doc } = await this.getCurrentState();\n        if (!doc)\n            return [];\n        let links = await this.withRequestToken('links', token => {\n            return languages_1.default.getDocumentLinks(doc.textDocument, token);\n        });\n        links = links || [];\n        let res = [];\n        for (let link of links) {\n            if (link.target) {\n                res.push(link);\n            }\n            else {\n                link = await languages_1.default.resolveDocumentLink(link);\n                res.push(link);\n            }\n        }\n        return links;\n    }\n    async openLink() {\n        let { doc, position } = await this.getCurrentState();\n        let links = await this.withRequestToken('links', token => {\n            return languages_1.default.getDocumentLinks(doc.textDocument, token);\n        });\n        if (!links || links.length == 0)\n            return false;\n        for (let link of links) {\n            if (position_1.positionInRange(position, link.range)) {\n                let { target } = link;\n                if (!target) {\n                    link = await languages_1.default.resolveDocumentLink(link);\n                    target = link.target;\n                }\n                if (target) {\n                    await workspace_1.default.openResource(target);\n                    return true;\n                }\n                return false;\n            }\n        }\n        return false;\n    }\n    async getCommands() {\n        let list = commands_1.default.commandList;\n        let res = [];\n        let { titles } = commands_1.default;\n        for (let item of list) {\n            res.push({\n                id: item.id,\n                title: titles.get(item.id) || ''\n            });\n        }\n        return res;\n    }\n    async showSignatureHelp() {\n        let { doc, position } = await this.getCurrentState();\n        if (!doc)\n            return false;\n        return await this.signature.triggerSignatureHelp(doc, position);\n    }\n    /**\n     * Send custom request for locations to services.\n     */\n    async findLocations(id, method, params, openCommand) {\n        let { doc, position } = await this.getCurrentState();\n        if (!doc)\n            return null;\n        params = params || {};\n        Object.assign(params, {\n            textDocument: { uri: doc.uri },\n            position\n        });\n        let res = await services_1.default.sendRequest(id, method, params);\n        res = res || [];\n        let locations = [];\n        if (Array.isArray(res)) {\n            locations = res;\n        }\n        else if (res.hasOwnProperty('location') && res.hasOwnProperty('children')) {\n            let getLocation = (item) => {\n                locations.push(item.location);\n                if (item.children && item.children.length) {\n                    for (let loc of item.children) {\n                        getLocation(loc);\n                    }\n                }\n            };\n            getLocation(res);\n        }\n        await this.handleLocations(locations, openCommand);\n    }\n    async handleLocations(definition, openCommand) {\n        if (!definition)\n            return;\n        let locations = Array.isArray(definition) ? definition : [definition];\n        let len = locations.length;\n        if (len == 0)\n            return;\n        if (len == 1 && openCommand !== false) {\n            let location = definition[0];\n            if (vscode_languageserver_protocol_1.LocationLink.is(definition[0])) {\n                let link = definition[0];\n                location = vscode_languageserver_protocol_1.Location.create(link.targetUri, link.targetRange);\n            }\n            let { uri, range } = location;\n            await workspace_1.default.jumpTo(uri, range.start, openCommand);\n        }\n        else {\n            await workspace_1.default.showLocations(definition);\n        }\n    }\n    async getSelectionRanges() {\n        let { doc, position } = await this.getCurrentState();\n        await helper_1.synchronizeDocument(doc);\n        let selectionRanges = await this.withRequestToken('selection ranges', token => {\n            return languages_1.default.getSelectionRanges(doc.textDocument, [position], token);\n        });\n        if (selectionRanges && selectionRanges.length)\n            return selectionRanges;\n        return null;\n    }\n    async selectRange(visualmode, forward) {\n        let { nvim } = this;\n        let { doc } = await this.getCurrentState();\n        if (!doc)\n            return;\n        let positions = [];\n        if (!forward && (!this.selectionRange || !visualmode))\n            return;\n        if (visualmode) {\n            let range = await workspace_1.default.getSelectedRange(visualmode, doc);\n            positions.push(range.start, range.end);\n        }\n        else {\n            let position = await window_1.default.getCursorPosition();\n            positions.push(position);\n        }\n        if (!forward) {\n            let curr = vscode_languageserver_protocol_1.Range.create(positions[0], positions[1]);\n            let { selectionRange } = this;\n            while (selectionRange && selectionRange.parent) {\n                if (object_1.equals(selectionRange.parent.range, curr)) {\n                    break;\n                }\n                selectionRange = selectionRange.parent;\n            }\n            if (selectionRange && selectionRange.parent) {\n                await workspace_1.default.selectRange(selectionRange.range);\n            }\n            return;\n        }\n        await helper_1.synchronizeDocument(doc);\n        let selectionRanges = await this.withRequestToken('selection ranges', token => {\n            return languages_1.default.getSelectionRanges(doc.textDocument, positions, token);\n        });\n        if (!selectionRanges || selectionRanges.length == 0)\n            return;\n        let mode = await nvim.eval('mode()');\n        if (mode != 'n')\n            await nvim.eval(`feedkeys(\"\\\\<Esc>\", 'in')`);\n        let selectionRange;\n        if (selectionRanges.length == 1) {\n            selectionRange = selectionRanges[0];\n        }\n        else if (positions.length > 1) {\n            let r = vscode_languageserver_protocol_1.Range.create(positions[0], positions[1]);\n            selectionRange = selectionRanges[0];\n            while (selectionRange) {\n                if (object_1.equals(r, selectionRange.range)) {\n                    selectionRange = selectionRange.parent;\n                    continue;\n                }\n                if (position_1.positionInRange(positions[1], selectionRange.range) == 0) {\n                    break;\n                }\n                selectionRange = selectionRange.parent;\n            }\n        }\n        if (!selectionRange)\n            return;\n        this.selectionRange = selectionRanges[0];\n        await workspace_1.default.selectRange(selectionRange.range);\n    }\n    async codeActionRange(start, end, only) {\n        let { doc } = await this.getCurrentState();\n        if (!doc)\n            return;\n        await helper_1.synchronizeDocument(doc);\n        let line = doc.getline(end - 1);\n        let range = vscode_languageserver_protocol_1.Range.create(start - 1, 0, end - 1, line.length);\n        let codeActions = await this.getCodeActions(doc, range, only ? [only] : null);\n        if (!codeActions || codeActions.length == 0) {\n            window_1.default.showMessage(`No${only ? ' ' + only : ''} code action available`, 'warning');\n            return;\n        }\n        let idx = await window_1.default.showMenuPicker(codeActions.map(o => o.title), 'Choose action');\n        let action = codeActions[idx];\n        if (action)\n            await this.applyCodeAction(action);\n    }\n    /**\n     * Refactor of current symbol\n     */\n    async doRefactor() {\n        let [bufnr, cursor, filetype] = await this.nvim.eval('[bufnr(\"%\"),coc#util#cursor(),&filetype]');\n        let doc = workspace_1.default.getDocument(bufnr);\n        if (!doc || !doc.attached)\n            return;\n        await helper_1.synchronizeDocument(doc);\n        let position = { line: cursor[0], character: cursor[1] };\n        let edit = await this.withRequestToken('refactor', async (token) => {\n            let res = await languages_1.default.prepareRename(doc.textDocument, position, token);\n            if (token.isCancellationRequested)\n                return null;\n            if (res === false) {\n                window_1.default.showMessage('Invalid position', 'warning');\n                return null;\n            }\n            let edit = await languages_1.default.provideRenameEdits(doc.textDocument, position, 'NewName', token);\n            if (token.isCancellationRequested)\n                return null;\n            if (!edit) {\n                window_1.default.showMessage('Empty workspaceEdit from language server', 'warning');\n                return null;\n            }\n            return edit;\n        });\n        if (edit) {\n            await this.refactor.fromWorkspaceEdit(edit, filetype);\n        }\n    }\n    async saveRefactor(bufnr) {\n        await this.refactor.save(bufnr);\n    }\n    async search(args) {\n        await this.refactor.search(args);\n    }\n    async previewHover(hovers, target) {\n        let docs = [];\n        let isPreview = target === 'preview';\n        for (let hover of hovers) {\n            let { contents } = hover;\n            if (Array.isArray(contents)) {\n                for (let item of contents) {\n                    if (typeof item === 'string') {\n                        helper_1.addDocument(docs, item, 'markdown', isPreview);\n                    }\n                    else {\n                        helper_1.addDocument(docs, item.value, item.language, isPreview);\n                    }\n                }\n            }\n            else if (vscode_languageserver_protocol_1.MarkedString.is(contents)) {\n                if (typeof contents == 'string') {\n                    helper_1.addDocument(docs, contents, 'markdown', isPreview);\n                }\n                else {\n                    helper_1.addDocument(docs, contents.value, contents.language, isPreview);\n                }\n            }\n            else if (vscode_languageserver_protocol_1.MarkupContent.is(contents)) {\n                helper_1.addDocument(docs, contents.value, helper_1.isMarkdown(contents) ? 'markdown' : 'txt', isPreview);\n            }\n        }\n        if (target == 'float') {\n            await this.hoverFactory.show(docs, { modes: ['n'] });\n            return;\n        }\n        let lines = docs.reduce((p, c) => {\n            let arr = c.content.split(/\\r?\\n/);\n            if (p.length > 0)\n                p.push('---');\n            p.push(...arr);\n            return p;\n        }, []);\n        if (target == 'echo') {\n            const msg = lines.join('\\n').trim();\n            if (msg.length) {\n                await this.nvim.call('coc#util#echo_hover', msg);\n            }\n        }\n        else {\n            this.documentLines = lines;\n            await this.nvim.command(`noswapfile pedit coc://document`);\n        }\n    }\n    getPreferences() {\n        let config = workspace_1.default.getConfiguration('coc.preferences');\n        let hoverTarget = config.get('hoverTarget', 'float');\n        if (hoverTarget == 'float' && !workspace_1.default.floatSupported) {\n            hoverTarget = 'preview';\n        }\n        this.preferences = {\n            hoverTarget,\n            previewMaxHeight: config.get('previewMaxHeight', 12),\n            previewAutoClose: config.get('previewAutoClose', false),\n            floatActions: config.get('floatActions', true)\n        };\n    }\n    async getCurrentState() {\n        let { nvim } = this;\n        let [bufnr, [line, character], winid] = await nvim.eval(\"[bufnr('%'),coc#util#cursor(),win_getid()]\");\n        let doc = workspace_1.default.getDocument(bufnr);\n        return {\n            doc: doc && doc.attached ? doc : null,\n            position: vscode_languageserver_protocol_1.Position.create(line, character),\n            winid\n        };\n    }\n    dispose() {\n        if (this.requestTimer) {\n            clearTimeout(this.requestTimer);\n            this.requestTimer = undefined;\n        }\n        this.refactor.dispose();\n        this.signature.dispose();\n        this.symbols.dispose();\n        this.hoverFactory.dispose();\n        this.colors.dispose();\n        this.format.dispose();\n        this.documentHighlighter.dispose();\n        util_1.disposeAll(this.disposables);\n    }\n}\nexports.default = Handler;\n\n\n//# sourceURL=webpack://coc.nvim/./src/handler/index.ts?");

/***/ }),

/***/ "./src/handler/refactor/buffer.ts":
/*!****************************************!*\
  !*** ./src/handler/refactor/buffer.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SEPARATOR = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst fast_diff_1 = tslib_1.__importDefault(__webpack_require__(/*! fast-diff */ \"./node_modules/fast-diff/diff.js\"));\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst vscode_languageserver_textdocument_1 = __webpack_require__(/*! vscode-languageserver-textdocument */ \"./node_modules/vscode-languageserver-textdocument/lib/esm/main.js\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst commands_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../commands */ \"./src/commands.ts\"));\nconst highligher_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../model/highligher */ \"./src/model/highligher.ts\"));\nconst util_1 = __webpack_require__(/*! ../../util */ \"./src/util/index.ts\");\nconst fs_1 = __webpack_require__(/*! ../../util/fs */ \"./src/util/fs.ts\");\nconst mutex_1 = __webpack_require__(/*! ../../util/mutex */ \"./src/util/mutex.ts\");\nconst object_1 = __webpack_require__(/*! ../../util/object */ \"./src/util/object.ts\");\nconst string_1 = __webpack_require__(/*! ../../util/string */ \"./src/util/string.ts\");\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../window */ \"./src/window.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../workspace */ \"./src/workspace.ts\"));\nconst logger = __webpack_require__(/*! ../../util/logger */ \"./src/util/logger.ts\")('handler-refactorBuffer');\nexports.SEPARATOR = '\\u3000';\nclass RefactorBuffer {\n    constructor(bufnr, srcId, nvim, config, opts) {\n        this.bufnr = bufnr;\n        this.srcId = srcId;\n        this.nvim = nvim;\n        this.config = config;\n        this.opts = opts;\n        this.mutex = new mutex_1.Mutex();\n        this._disposed = false;\n        this.disposables = [];\n        this._fileItems = [];\n        this.matchIds = new Set();\n        this.changing = false;\n        this.disposables.push(workspace_1.default.registerLocalKeymap('n', '<CR>', this.splitOpen.bind(this), true));\n        workspace_1.default.onDidChangeTextDocument(this.onDocumentChange, this, this.disposables);\n    }\n    get fileItems() {\n        return this._fileItems;\n    }\n    onChange(e) {\n        if (this.changing)\n            return;\n        let doc = this.document;\n        let { nvim, _fileItems: fileItems } = this;\n        if (!fileItems.length)\n            return;\n        let change = e.contentChanges[0];\n        if (!('range' in change))\n            return;\n        let { original } = e;\n        if (change.range.end.line < 2)\n            return;\n        doc.buffer.setOption('modified', true, true);\n        let { range, text } = change;\n        let lines = text.split('\\n');\n        let lineChange = lines.length - (range.end.line - range.start.line) - 1;\n        if (lineChange == 0)\n            return;\n        let lineChanges = [];\n        if (text.includes('\\u3000')) {\n            let startLine = range.start.line;\n            let diffs = fast_diff_1.default(original, text);\n            let offset = 0;\n            let orig = vscode_languageserver_textdocument_1.TextDocument.create('file:///1', '', 0, original);\n            for (let i = 0; i < diffs.length; i++) {\n                let diff = diffs[i];\n                let pos = orig.positionAt(offset);\n                if (diff[0] == fast_diff_1.default.EQUAL) {\n                    offset = offset + diff[1].length;\n                }\n                else if (diff[0] == fast_diff_1.default.DELETE) {\n                    let end = orig.positionAt(offset + diff[1].length);\n                    if (diffs[i + 1] && diffs[i + 1][0] == fast_diff_1.default.INSERT) {\n                        let delta = diffs[i + 1][1].split('\\n').length - (end.line - pos.line) - 1;\n                        if (delta != 0)\n                            lineChanges.push({ delta, lnum: pos.line + startLine });\n                        i = i + 1;\n                    }\n                    else {\n                        let delta = -(end.line - pos.line);\n                        if (delta != 0)\n                            lineChanges.push({ delta, lnum: pos.line + startLine });\n                    }\n                    offset = offset + diff[1].length;\n                }\n                else if (diff[0] == fast_diff_1.default.INSERT) {\n                    let delta = diff[1].split('\\n').length - 1;\n                    if (delta != 0)\n                        lineChanges.push({ delta, lnum: pos.line + startLine });\n                }\n            }\n        }\n        else {\n            lineChanges = [{ delta: lineChange, lnum: range.start.line }];\n        }\n        let changed = false;\n        // adjust LineNr highlights\n        for (let item of fileItems) {\n            for (let range of item.ranges) {\n                let arr = lineChanges.filter(o => o.lnum < range.lnum - 1);\n                if (arr.length) {\n                    let total = arr.reduce((p, c) => p + c.delta, 0);\n                    range.lnum = range.lnum + total;\n                    changed = true;\n                }\n            }\n        }\n        if (!changed)\n            return;\n        nvim.pauseNotification();\n        this.highlightLineNr();\n        nvim.resumeNotification().then(res => {\n            if (Array.isArray(res) && res[1] != null) {\n                logger.error(`Error on highlightLineNr:`, res[1]);\n            }\n        }).logError();\n    }\n    /**\n     * Handle changes of other buffers.\n     */\n    async onDocumentChange(e) {\n        if (e.bufnr == this.bufnr || this.changing)\n            return;\n        let { uri } = e.textDocument;\n        let { range, text } = e.contentChanges[0];\n        let filepath = vscode_uri_1.URI.parse(uri).fsPath;\n        let fileItem = this._fileItems.find(o => o.filepath == filepath);\n        // not affected\n        if (!fileItem)\n            return;\n        let lineChange = text.split('\\n').length - (range.end.line - range.start.line) - 1;\n        let edits = [];\n        // 4 cases: ignore, change lineNr, reload, remove\n        for (let i = 0; i < fileItem.ranges.length; i++) {\n            let r = fileItem.ranges[i];\n            if (range.start.line >= r.end) {\n                continue;\n            }\n            if (range.end.line < r.start) {\n                if (lineChange == 0) {\n                    continue;\n                }\n                else {\n                    r.start = r.start + lineChange;\n                    r.end = r.end + lineChange;\n                }\n            }\n            else {\n                let doc = workspace_1.default.getDocument(uri);\n                let newLines = doc.getLines(r.start, r.end);\n                if (!newLines.length) {\n                    // remove this range\n                    fileItem.ranges.splice(i, 1);\n                    edits.push({\n                        range: this.getFileRangeRange(r, false),\n                        newText: ''\n                    });\n                }\n                else {\n                    r.end = r.start + newLines.length;\n                    // reload lines, reset end\n                    edits.push({\n                        range: this.getFileRangeRange(r, true),\n                        newText: newLines.join('\\n') + '\\n'\n                    });\n                }\n            }\n        }\n        // clean fileItem with empty ranges\n        this._fileItems = this._fileItems.filter(o => o.ranges && o.ranges.length > 0);\n        if (edits.length) {\n            this.changing = true;\n            await this.document.applyEdits(edits);\n            this.changing = false;\n        }\n        this.nvim.pauseNotification();\n        this.highlightLineNr();\n        this.buffer.setOption('modified', false, true);\n        await this.nvim.resumeNotification();\n    }\n    /**\n     * Current changed file ranges\n     */\n    async getFileChanges() {\n        if (this._disposed)\n            return [];\n        let changes = [];\n        let lines = await this.buffer.lines;\n        lines.push(exports.SEPARATOR);\n        // current lines\n        let arr = [];\n        let fsPath;\n        let lnum;\n        for (let i = 0; i < lines.length; i++) {\n            let line = lines[i];\n            if (line.startsWith(exports.SEPARATOR)) {\n                if (fsPath) {\n                    changes.push({\n                        filepath: fsPath,\n                        lines: arr.slice(),\n                        lnum\n                    });\n                    fsPath = undefined;\n                    arr = [];\n                }\n                if (line.length > 1) {\n                    let ms = line.match(/^\\u3000(.*)/);\n                    if (ms) {\n                        fsPath = this.getAbsolutePath(ms[1].replace(/\\s+$/, ''));\n                        lnum = i + 1;\n                        arr = [];\n                    }\n                }\n            }\n            else {\n                arr.push(line);\n            }\n        }\n        return changes;\n    }\n    /**\n     * Open line under cursor in split window\n     */\n    async splitOpen() {\n        let { nvim } = this;\n        let win = nvim.createWindow(this.opts.fromWinid);\n        let valid = await win.valid;\n        let lines = await nvim.eval('getline(1,line(\".\"))');\n        let len = lines.length;\n        for (let i = 0; i < len; i++) {\n            let line = lines[len - i - 1];\n            let ms = line.match(/^\\u3000(.+)/);\n            if (ms) {\n                let filepath = ms[1].trim();\n                let r = this.getLinesRange(len - i);\n                if (!r)\n                    return;\n                let lnum = r[0] + i - 1;\n                let bufname = this.getAbsolutePath(filepath);\n                nvim.pauseNotification();\n                if (valid) {\n                    nvim.call('win_gotoid', [this.opts.fromWinid], true);\n                    this.nvim.call('coc#util#jump', ['edit', bufname, [lnum, 1]], true);\n                }\n                else {\n                    this.nvim.call('coc#util#jump', ['belowright vs', bufname, [lnum, 1]], true);\n                }\n                nvim.command('normal! zz', true);\n                let [, err] = await nvim.resumeNotification();\n                if (err)\n                    window_1.default.showMessage(`Error on open ${filepath}: ${err}`, 'error');\n                if (!valid) {\n                    this.opts.fromWinid = await nvim.call('win_getid');\n                }\n                break;\n            }\n        }\n    }\n    /**\n     * Add FileItem to refactor buffer.\n     */\n    async addFileItems(items) {\n        if (this._disposed)\n            return;\n        let { cwd } = this.opts;\n        let { document } = this;\n        const release = await this.mutex.acquire();\n        try {\n            if (document.dirty)\n                document.forceSync();\n            for (let item of items) {\n                let fileItem = this._fileItems.find(o => o.filepath == item.filepath);\n                if (fileItem) {\n                    fileItem.ranges.push(...item.ranges);\n                }\n                else {\n                    this._fileItems.push(item);\n                }\n            }\n            let count = document.lineCount;\n            let highligher = new highligher_1.default();\n            let hlRanges = [];\n            for (let item of items) {\n                for (let range of item.ranges) {\n                    highligher.addLine(exports.SEPARATOR);\n                    highligher.addLine(exports.SEPARATOR);\n                    range.lnum = count + highligher.length;\n                    highligher.addText(`${fs_1.isParentFolder(cwd, item.filepath) ? path_1.default.relative(cwd, item.filepath) : item.filepath}`);\n                    // white spaces for conceal texts\n                    let n = String(range.start + 1).length + String(range.end).length + 4;\n                    if (!this.srcId)\n                        highligher.addText(' '.repeat(n));\n                    let base = 0 - highligher.length - count;\n                    if (range.highlights) {\n                        hlRanges.push(...range.highlights.map(r => adjustRange(r, base)));\n                    }\n                    let { lines } = range;\n                    if (!lines) {\n                        lines = await this.getLines(item.filepath, range.start, range.end);\n                        range.lines = lines;\n                    }\n                    highligher.addLines(lines);\n                }\n            }\n            let { nvim, buffer } = this;\n            this.changing = true;\n            nvim.pauseNotification();\n            highligher.render(buffer, count);\n            this.highlightLineNr();\n            buffer.setOption('modified', false, true);\n            buffer.setOption('undolevels', 1000, true);\n            if (count == 2 && hlRanges.length) {\n                let pos = hlRanges[0].start;\n                nvim.call('coc#util#jumpTo', [pos.line, pos.character], true);\n            }\n            if (workspace_1.default.isVim) {\n                nvim.command('redraw', true);\n            }\n            let [, err] = await nvim.resumeNotification();\n            if (err)\n                throw new Error(err[2]);\n            await document.patchChange();\n            this.changing = false;\n            await commands_1.default.executeCommand('editor.action.addRanges', hlRanges);\n        }\n        catch (e) {\n            this.changing = false;\n            logger.error(`Error on add file item:`, e);\n        }\n        release();\n    }\n    /**\n     * Save changes to buffers/files, return false when no change made.\n     */\n    async save() {\n        let { nvim } = this;\n        let doc = this.document;\n        let { buffer } = doc;\n        await doc.patchChange();\n        let changes = await this.getFileChanges();\n        if (!changes)\n            return;\n        changes.sort((a, b) => a.lnum - b.lnum);\n        // filter changes that not change\n        let removeList = [];\n        let deltaMap = new Map();\n        for (let i = 0; i < changes.length; i++) {\n            let change = changes[i];\n            let { filepath, lnum } = change;\n            let curr = deltaMap.get(filepath) || 0;\n            let item = this._fileItems.find(o => o.filepath == filepath);\n            let range = item ? item.ranges.find(o => o.lnum == lnum) : null;\n            if (!range || object_1.equals(range.lines, change.lines)) {\n                removeList.push(i);\n                if (curr && range) {\n                    range.start = range.start + curr;\n                    range.end = range.end + curr;\n                }\n                continue;\n            }\n            change.start = range.start;\n            change.end = range.end;\n            if (curr != 0)\n                range.start = range.start + curr;\n            if (change.lines.length != range.lines.length) {\n                let delta = change.lines.length - range.lines.length;\n                let total = delta + curr;\n                deltaMap.set(filepath, total);\n                range.end = range.end + total;\n            }\n            else {\n                range.end = range.end + curr;\n            }\n            range.lines = change.lines;\n        }\n        if (removeList.length)\n            changes = changes.filter((_, i) => !removeList.includes(i));\n        if (changes.length == 0) {\n            window_1.default.showMessage('No change.', 'more');\n            await buffer.setOption('modified', false);\n            return false;\n        }\n        let changeMap = {};\n        for (let change of changes) {\n            let uri = vscode_uri_1.URI.file(change.filepath).toString();\n            let edits = changeMap[uri] || [];\n            edits.push({\n                range: vscode_languageserver_protocol_1.Range.create(change.start, 0, change.end, 0),\n                newText: change.lines.join('\\n') + '\\n'\n            });\n            changeMap[uri] = edits;\n        }\n        this.changing = true;\n        await workspace_1.default.applyEdit({ changes: changeMap });\n        this.changing = false;\n        nvim.pauseNotification();\n        buffer.setOption('modified', false, true);\n        if (this.config.saveToFile) {\n            nvim.command('silent noa wa', true);\n        }\n        this.highlightLineNr();\n        await nvim.resumeNotification();\n        return true;\n    }\n    getFileRange(lnum) {\n        for (let item of this._fileItems) {\n            for (let r of item.ranges) {\n                if (r.lnum == lnum) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    getLinesRange(lnum) {\n        for (let item of this._fileItems) {\n            for (let range of item.ranges) {\n                if (range.lnum == lnum) {\n                    return [range.start, range.end];\n                }\n            }\n        }\n        return null;\n    }\n    async getLines(fsPath, start, end) {\n        let uri = vscode_uri_1.URI.file(fsPath).toString();\n        let doc = workspace_1.default.getDocument(uri);\n        if (doc)\n            return doc.getLines(start, end);\n        return await fs_1.readFileLines(fsPath, start, end - 1);\n    }\n    getAbsolutePath(filepath) {\n        if (path_1.default.isAbsolute(filepath))\n            return filepath;\n        return path_1.default.join(this.opts.cwd, filepath);\n    }\n    /**\n     * Edit range of FileRange\n     */\n    getFileRangeRange(range, lineOnly = true) {\n        let { document } = this;\n        if (!document)\n            return null;\n        let { lnum } = range;\n        let first = document.getline(lnum - 1);\n        if (!first.startsWith('\\u3000'))\n            return null;\n        let start = lineOnly ? lnum : lnum - 1;\n        let end = document.lineCount;\n        for (let i = lnum; i < document.lineCount; i++) {\n            let line = document.getline(i);\n            if (line.startsWith('\\u3000')) {\n                end = lineOnly ? i : i + 1;\n                break;\n            }\n        }\n        return vscode_languageserver_protocol_1.Range.create(start, 0, end, 0);\n    }\n    /**\n     * Use conceal to add lineNr\n     */\n    highlightLineNr() {\n        let { _fileItems: fileItems, nvim, srcId, bufnr } = this;\n        let { winid, cwd } = this.opts;\n        let info = {};\n        if (srcId) {\n            nvim.call('nvim_buf_clear_namespace', [bufnr, srcId, 0, -1], true);\n            for (let item of fileItems) {\n                for (let range of item.ranges) {\n                    let text = `${range.start + 1}:${range.end}`;\n                    info[range.lnum] = [range.start + 1, range.end];\n                    nvim.call('nvim_buf_set_virtual_text', [bufnr, srcId, range.lnum - 1, [[text, 'LineNr']], {}], true);\n                }\n            }\n        }\n        else {\n            if (this.matchIds.size) {\n                nvim.call('coc#highlight#clear_matches', [winid, Array.from(this.matchIds)], true);\n                this.matchIds.clear();\n            }\n            let id = 2000;\n            for (let item of fileItems) {\n                let filename = `${cwd ? path_1.default.relative(cwd, item.filepath) : item.filepath}`;\n                let col = string_1.byteLength(filename) + 1;\n                for (let range of item.ranges) {\n                    let text = `:${range.start + 1}:${range.end}`;\n                    for (let i = 0; i < text.length; i++) {\n                        let ch = text[i];\n                        this.matchIds.add(id);\n                        info[range.lnum] = [range.start + 1, range.end];\n                        nvim.call('matchaddpos', ['Conceal', [[range.lnum, col + i]], 99, id, { conceal: ch, window: winid }], true);\n                        id++;\n                    }\n                }\n            }\n        }\n        this.buffer.setVar('line_infos', info, true);\n    }\n    get valid() {\n        return this.buffer.valid;\n    }\n    get buffer() {\n        return this.nvim.createBuffer(this.bufnr);\n    }\n    get document() {\n        if (this._disposed)\n            return null;\n        return workspace_1.default.getDocument(this.bufnr);\n    }\n    dispose() {\n        this._disposed = true;\n        util_1.disposeAll(this.disposables);\n    }\n}\nexports.default = RefactorBuffer;\nfunction adjustRange(range, offset) {\n    let { start, end } = range;\n    return vscode_languageserver_protocol_1.Range.create(start.line - offset, start.character, end.line - offset, end.character);\n}\n\n\n//# sourceURL=webpack://coc.nvim/./src/handler/refactor/buffer.ts?");

/***/ }),

/***/ "./src/handler/refactor/index.ts":
/*!***************************************!*\
  !*** ./src/handler/refactor/index.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FileItem = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../workspace */ \"./src/workspace.ts\"));\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../window */ \"./src/window.ts\"));\nconst util_1 = __webpack_require__(/*! ../../util */ \"./src/util/index.ts\");\nconst buffer_1 = tslib_1.__importStar(__webpack_require__(/*! ./buffer */ \"./src/handler/refactor/buffer.ts\"));\nObject.defineProperty(exports, \"FileItem\", ({ enumerable: true, get: function () { return buffer_1.FileItem; } }));\nconst bufferSync_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../model/bufferSync */ \"./src/model/bufferSync.ts\"));\nconst fs_1 = __webpack_require__(/*! ../../util/fs */ \"./src/util/fs.ts\");\nconst search_1 = tslib_1.__importDefault(__webpack_require__(/*! ../search */ \"./src/handler/search.ts\"));\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst logger = __webpack_require__(/*! ../../util/logger */ \"./src/util/logger.ts\")('handler-refactor');\nconst name = '__coc_refactor__';\nlet refactorId = 0;\nclass Refactor {\n    constructor() {\n        this.optionsMap = new Map();\n        this.disposables = [];\n        this._onCreate = new vscode_languageserver_protocol_1.Emitter();\n        this.onCreate = this._onCreate.event;\n        this.nvim = workspace_1.default.nvim;\n        if (workspace_1.default.isNvim && this.nvim.hasFunction('nvim_buf_set_virtual_text')) {\n            this.srcId = workspace_1.default.createNameSpace('coc-refactor');\n        }\n        this.setConfiguration();\n        workspace_1.default.onDidChangeConfiguration(this.setConfiguration, this, this.disposables);\n        this.buffers = new bufferSync_1.default(doc => {\n            if (!/__coc_refactor__\\d+$/.test(doc.uri))\n                return undefined;\n            let { bufnr } = doc;\n            this._onCreate.fire(bufnr);\n            return new buffer_1.default(bufnr, this.srcId, this.nvim, this.config, this.optionsMap.get(doc.bufnr));\n        }, workspace_1.default);\n    }\n    setConfiguration(e) {\n        if (e && !e.affectsConfiguration('refactor'))\n            return;\n        let config = workspace_1.default.getConfiguration('refactor');\n        this.config = Object.assign(this.config || {}, {\n            afterContext: config.get('afterContext', 3),\n            beforeContext: config.get('beforeContext', 3),\n            openCommand: config.get('openCommand', 'edit'),\n            saveToFile: config.get('saveToFile', true)\n        });\n    }\n    async ensureBuffer(bufnr) {\n        let buf = this.getBuffer(bufnr);\n        if (buf)\n            return buf;\n        return new Promise((resolve, reject) => {\n            let timer = this.timer = setTimeout(() => {\n                reject(new Error('Document create timeout after 2s.'));\n            }, 2000);\n            this.onCreate(e => {\n                if (e == bufnr) {\n                    clearTimeout(timer);\n                    this.timer = null;\n                    // need wait\n                    setImmediate(() => {\n                        resolve(this.buffers.getItem(bufnr));\n                    });\n                }\n            });\n        });\n    }\n    getBuffer(bufnr) {\n        return this.buffers.getItem(bufnr);\n    }\n    /**\n     * Search by rg\n     */\n    async search(args) {\n        let buf = await this.createRefactorBuffer();\n        if (!buf)\n            return;\n        let cwd = await this.nvim.call('getcwd', []);\n        let search = new search_1.default(this.nvim);\n        await search.run(args, cwd, buf);\n    }\n    /**\n     * Create initialized refactor buffer\n     */\n    async createRefactorBuffer(filetype) {\n        let { nvim } = this;\n        let [fromWinid, cwd] = await nvim.eval('[win_getid(),getcwd()]');\n        let { openCommand } = this.config;\n        nvim.pauseNotification();\n        nvim.command(`${openCommand} ${name}${refactorId++}`, true);\n        nvim.command(`setl buftype=acwrite nobuflisted bufhidden=wipe nofen wrap conceallevel=2 concealcursor=n`, true);\n        nvim.command(`setl undolevels=-1 nolist nospell noswapfile foldmethod=expr foldexpr=coc#util#refactor_foldlevel(v:lnum)`, true);\n        nvim.command(`setl foldtext=coc#util#refactor_fold_text(v:foldstart)`, true);\n        nvim.call('setline', [1, ['Save current buffer to make changes', buffer_1.SEPARATOR]], true);\n        nvim.call('matchadd', ['Comment', '\\\\%1l'], true);\n        nvim.call('matchadd', ['Conceal', '^\\\\%u3000'], true);\n        nvim.call('matchadd', ['Label', '^\\\\%u3000\\\\zs\\\\S\\\\+'], true);\n        nvim.command('setl nomod', true);\n        if (filetype)\n            nvim.command(`runtime! syntax/${filetype}.vim`, true);\n        nvim.call('coc#util#do_autocmd', ['CocRefactorOpen'], true);\n        let [, err] = await nvim.resumeNotification();\n        if (err) {\n            logger.error(err);\n            window_1.default.showMessage(`Error on open refactor window: ${err}`, 'error');\n            return;\n        }\n        let [bufnr, win] = await nvim.eval('[bufnr(\"%\"),win_getid()]');\n        this.optionsMap.set(bufnr, { fromWinid, winid: win, cwd });\n        return await this.ensureBuffer(bufnr);\n    }\n    /**\n     * Create refactor buffer from lines\n     */\n    async fromLines(lines) {\n        let buf = await this.createRefactorBuffer();\n        if (buf)\n            await buf.buffer.setLines(lines, { start: 0, end: -1, strictIndexing: false });\n        return buf;\n    }\n    /**\n     * Create refactor buffer from locations\n     */\n    async fromLocations(locations, filetype) {\n        if (!locations || locations.length == 0)\n            return null;\n        let changes = {};\n        let edit = { changes };\n        for (let location of locations) {\n            let edits = changes[location.uri] || [];\n            edits.push({ range: location.range, newText: '' });\n            changes[location.uri] = edits;\n        }\n        return await this.fromWorkspaceEdit(edit, filetype);\n    }\n    /**\n     * Start refactor from workspaceEdit\n     */\n    async fromWorkspaceEdit(edit, filetype) {\n        if (!edit || emptyWorkspaceEdit(edit))\n            return undefined;\n        let items = [];\n        let { beforeContext, afterContext } = this.config;\n        let { changes, documentChanges } = edit;\n        if (!changes) {\n            changes = {};\n            for (let change of documentChanges || []) {\n                if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change)) {\n                    let { textDocument, edits } = change;\n                    if (textDocument.uri.startsWith('file:')) {\n                        changes[textDocument.uri] = edits;\n                    }\n                }\n            }\n        }\n        for (let key of Object.keys(changes)) {\n            let max = await this.getLineCount(key);\n            let edits = changes[key];\n            let ranges = [];\n            // start end highlights\n            let start = null;\n            let end = null;\n            let highlights = [];\n            edits.sort((a, b) => a.range.start.line - b.range.start.line);\n            for (let edit of edits) {\n                let { line } = edit.range.start;\n                let s = Math.max(0, line - beforeContext);\n                if (start != null && s < end) {\n                    end = Math.min(max, line + afterContext + 1);\n                    highlights.push(adjustRange(edit.range, start));\n                }\n                else {\n                    if (start != null)\n                        ranges.push({ start, end, highlights });\n                    start = s;\n                    end = Math.min(max, line + afterContext + 1);\n                    highlights = [adjustRange(edit.range, start)];\n                }\n            }\n            if (start != null)\n                ranges.push({ start, end, highlights });\n            items.push({\n                ranges,\n                filepath: vscode_uri_1.URI.parse(key).fsPath\n            });\n        }\n        let buf = await this.createRefactorBuffer(filetype);\n        await buf.addFileItems(items);\n        return buf;\n    }\n    async save(bufnr) {\n        let buf = this.buffers.getItem(bufnr);\n        if (buf)\n            return await buf.save();\n    }\n    async getLineCount(uri) {\n        let doc = workspace_1.default.getDocument(uri);\n        if (doc)\n            return doc.lineCount;\n        return await fs_1.getFileLineCount(vscode_uri_1.URI.parse(uri).fsPath);\n    }\n    reset() {\n        if (this.timer) {\n            clearTimeout(this.timer);\n        }\n        this.optionsMap.clear();\n        this.buffers.reset();\n    }\n    dispose() {\n        if (this.timer) {\n            clearTimeout(this.timer);\n        }\n        this.optionsMap.clear();\n        this._onCreate.dispose();\n        this.buffers.dispose();\n        util_1.disposeAll(this.disposables);\n    }\n}\nexports.default = Refactor;\nfunction adjustRange(range, offset) {\n    let { start, end } = range;\n    return vscode_languageserver_protocol_1.Range.create(start.line - offset, start.character, end.line - offset, end.character);\n}\nfunction emptyWorkspaceEdit(edit) {\n    let { changes, documentChanges } = edit;\n    if (documentChanges && documentChanges.length)\n        return false;\n    if (changes && Object.keys(changes).length)\n        return false;\n    return true;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./src/handler/refactor/index.ts?");

/***/ }),

/***/ "./src/handler/search.ts":
/*!*******************************!*\
  !*** ./src/handler/search.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst mutex_1 = __webpack_require__(/*! ../util/mutex */ \"./src/util/mutex.ts\");\nconst child_process_1 = __webpack_require__(/*! child_process */ \"child_process\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst readline_1 = tslib_1.__importDefault(__webpack_require__(/*! readline */ \"readline\"));\nconst vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ \"./node_modules/vscode-languageserver-types/lib/esm/main.js\");\nconst which_1 = tslib_1.__importDefault(__webpack_require__(/*! which */ \"./node_modules/which/which.js\"));\nconst highligher_1 = tslib_1.__importDefault(__webpack_require__(/*! ../model/highligher */ \"./src/model/highligher.ts\"));\nconst ansiparse_1 = __webpack_require__(/*! ../util/ansiparse */ \"./src/util/ansiparse.ts\");\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('handler-search');\nconst defaultArgs = ['--color', 'ansi', '--colors', 'path:fg:black', '--colors', 'line:fg:green', '--colors', 'match:fg:red', '--no-messages', '--heading', '-n'];\nconst controlCode = '\\x1b';\n// emit FileItem\nclass Task extends events_1.EventEmitter {\n    start(cmd, args, cwd) {\n        this.process = child_process_1.spawn(cmd, args, { cwd });\n        this.process.on('error', e => {\n            this.emit('error', e.message);\n        });\n        const rl = readline_1.default.createInterface(this.process.stdout);\n        let start;\n        let fileItem;\n        let lines = [];\n        let highlights = [];\n        let create = true;\n        rl.on('line', content => {\n            if (content.includes(controlCode)) {\n                let items = ansiparse_1.ansiparse(content);\n                if (items[0].foreground == 'black') {\n                    fileItem = { filepath: path_1.default.join(cwd, items[0].text), ranges: [] };\n                    return;\n                }\n                let normalLine = items[0].foreground == 'green';\n                if (normalLine) {\n                    let lnum = parseInt(items[0].text, 10) - 1;\n                    let padlen = items[0].text.length + 1;\n                    if (create) {\n                        start = lnum;\n                        create = false;\n                    }\n                    let line = '';\n                    for (let item of items) {\n                        if (item.foreground == 'red') {\n                            let l = lnum - start;\n                            let c = line.length - padlen;\n                            highlights.push(vscode_languageserver_types_1.Range.create(l, c, l, c + item.text.length));\n                        }\n                        line += item.text;\n                    }\n                    let currline = line.slice(padlen);\n                    lines.push(currline);\n                }\n            }\n            else {\n                let fileEnd = content.trim().length == 0;\n                if (fileItem && (fileEnd || content.trim() == '--')) {\n                    let fileRange = {\n                        lines,\n                        highlights,\n                        start,\n                        end: start + lines.length\n                    };\n                    fileItem.ranges.push(fileRange);\n                }\n                if (fileEnd) {\n                    this.emit('item', fileItem);\n                    fileItem = null;\n                }\n                lines = [];\n                highlights = [];\n                create = true;\n            }\n        });\n        rl.on('close', () => {\n            if (fileItem) {\n                if (lines.length) {\n                    let fileRange = {\n                        lines,\n                        highlights,\n                        start,\n                        end: start + lines.length\n                    };\n                    fileItem.ranges.push(fileRange);\n                }\n                this.emit('item', fileItem);\n            }\n            lines = highlights = fileItem = null;\n            this.emit('end');\n        });\n    }\n    dispose() {\n        if (this.process) {\n            this.process.kill();\n        }\n    }\n}\nclass Search {\n    constructor(nvim, cmd = 'rg') {\n        this.nvim = nvim;\n        this.cmd = cmd;\n    }\n    run(args, cwd, refactorBuf) {\n        let { nvim, cmd } = this;\n        let { afterContext, beforeContext } = refactorBuf.config;\n        let argList = ['-A', afterContext.toString(), '-B', beforeContext.toString()].concat(defaultArgs, args);\n        argList.push('--', './');\n        try {\n            cmd = which_1.default.sync(cmd);\n        }\n        catch (e) {\n            window_1.default.showMessage(`Please install ripgrep and make sure ${this.cmd} is in your $PATH`, 'error');\n            return Promise.reject(e);\n        }\n        this.task = new Task();\n        this.task.start(cmd, argList, cwd);\n        let mutex = new mutex_1.Mutex();\n        let files = 0;\n        let matches = 0;\n        let start = Date.now();\n        // remaining items\n        let fileItems = [];\n        const addFileItems = async () => {\n            if (fileItems.length == 0)\n                return;\n            let items = fileItems.slice();\n            fileItems = [];\n            const release = await mutex.acquire();\n            try {\n                await refactorBuf.addFileItems(items);\n            }\n            catch (e) {\n                logger.error(e);\n            }\n            release();\n        };\n        return new Promise((resolve, reject) => {\n            let interval = setInterval(addFileItems, 100);\n            this.task.on('item', async (fileItem) => {\n                files++;\n                matches = matches + fileItem.ranges.reduce((p, r) => p + r.highlights.length, 0);\n                fileItems.push(fileItem);\n            });\n            this.task.on('error', message => {\n                clearInterval(interval);\n                window_1.default.showMessage(`Error on command \"${cmd}\": ${message}`, 'error');\n                this.task = null;\n                reject(new Error(message));\n            });\n            this.task.on('end', async () => {\n                clearInterval(interval);\n                try {\n                    await addFileItems();\n                    const release = await mutex.acquire();\n                    release();\n                    this.task.removeAllListeners();\n                    this.task = null;\n                    let buf = refactorBuf.buffer;\n                    if (buf) {\n                        nvim.pauseNotification();\n                        if (files == 0) {\n                            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                            buf.setLines(['No match found'], { start: 1, end: 2, strictIndexing: false }, true);\n                            buf.addHighlight({ line: 1, srcId: -1, colEnd: -1, colStart: 0, hlGroup: 'Error' }).logError();\n                            buf.setOption('modified', false, true);\n                        }\n                        else {\n                            let highligher = new highligher_1.default();\n                            highligher.addText('Files', 'MoreMsg');\n                            highligher.addText(': ');\n                            highligher.addText(`${files} `, 'Number');\n                            highligher.addText('Matches', 'MoreMsg');\n                            highligher.addText(': ');\n                            highligher.addText(`${matches} `, 'Number');\n                            highligher.addText('Duration', 'MoreMsg');\n                            highligher.addText(': ');\n                            highligher.addText(`${Date.now() - start}ms`, 'Number');\n                            highligher.render(buf, 1, 2);\n                        }\n                        buf.setOption('modified', false, true);\n                        await nvim.resumeNotification(false, true);\n                    }\n                }\n                catch (e) {\n                    reject(e);\n                    return;\n                }\n                resolve();\n            });\n        });\n    }\n}\nexports.default = Search;\n\n\n//# sourceURL=webpack://coc.nvim/./src/handler/search.ts?");

/***/ }),

/***/ "./src/handler/signature.ts":
/*!**********************************!*\
  !*** ./src/handler/signature.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst floatFactory_1 = tslib_1.__importDefault(__webpack_require__(/*! ../model/floatFactory */ \"./src/model/floatFactory.ts\"));\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ../snippets/manager */ \"./src/snippets/manager.ts\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nconst string_1 = __webpack_require__(/*! ../util/string */ \"./src/util/string.ts\");\nconst languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ../languages */ \"./src/languages.ts\"));\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('handler-signature');\nclass Signature {\n    constructor(nvim) {\n        this.nvim = nvim;\n        this.disposables = [];\n        this.signatureFactory = new floatFactory_1.default(nvim);\n        this.loadConfiguration();\n        this.disposables.push(this.signatureFactory);\n        workspace_1.default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);\n        events_1.default.on('CursorMovedI', async (bufnr, cursor) => {\n            // avoid close signature for valid position.\n            if (!this.signaturePosition)\n                return;\n            let doc = workspace_1.default.getDocument(bufnr);\n            if (!doc)\n                return;\n            let { line, character } = this.signaturePosition;\n            if (cursor[0] - 1 == line) {\n                let currline = doc.getline(cursor[0] - 1);\n                let col = string_1.byteLength(currline.slice(0, character)) + 1;\n                if (cursor[1] >= col)\n                    return;\n            }\n            this.signatureFactory.close();\n        }, null, this.disposables);\n        events_1.default.on(['InsertLeave', 'BufEnter'], () => {\n            var _a;\n            (_a = this.tokenSource) === null || _a === void 0 ? void 0 : _a.cancel();\n            this.signatureFactory.close();\n        }, null, this.disposables);\n        events_1.default.on(['TextChangedI', 'TextChangedP'], async () => {\n            if (this.config.hideOnChange) {\n                this.signatureFactory.close();\n            }\n        }, null, this.disposables);\n        let lastInsert;\n        events_1.default.on('InsertCharPre', async () => {\n            lastInsert = Date.now();\n        }, null, this.disposables);\n        events_1.default.on('TextChangedI', async (bufnr, info) => {\n            if (!this.config.trigger)\n                return;\n            if (!lastInsert || Date.now() - lastInsert > 300)\n                return;\n            lastInsert = null;\n            let doc = workspace_1.default.getDocument(bufnr);\n            if (!doc || doc.isCommandLine || !doc.attached)\n                return;\n            // if (!triggerSignatureHelp && !formatOnType) return\n            let pre = info.pre[info.pre.length - 1];\n            if (!pre)\n                return;\n            if (languages_1.default.shouldTriggerSignatureHelp(doc.textDocument, pre)) {\n                await this.triggerSignatureHelp(doc, { line: info.lnum - 1, character: info.pre.length }, false);\n            }\n        }, null, this.disposables);\n    }\n    loadConfiguration(e) {\n        if (!e || e.affectsConfiguration('signature')) {\n            let config = workspace_1.default.getConfiguration('signature');\n            let target = config.get('target', 'float');\n            if (target == 'float' && !workspace_1.default.floatSupported) {\n                target = 'echo';\n            }\n            this.config = {\n                target,\n                trigger: config.get('enable', true),\n                wait: Math.max(config.get('triggerSignatureWait', 500), 200),\n                maxWindowHeight: config.get('maxWindowHeight', 80),\n                maxWindowWidth: config.get('maxWindowWidth', 80),\n                preferAbove: config.get('preferShownAbove', true),\n                hideOnChange: config.get('hideOnTextChange', false),\n            };\n        }\n    }\n    async triggerSignatureHelp(doc, position, invoke = true) {\n        var _a;\n        (_a = this.tokenSource) === null || _a === void 0 ? void 0 : _a.cancel();\n        let tokenSource = this.tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n        let token = tokenSource.token;\n        token.onCancellationRequested(() => {\n            tokenSource.dispose();\n            this.tokenSource = undefined;\n        });\n        let { target } = this.config;\n        let timer = this.timer = setTimeout(() => {\n            tokenSource.cancel();\n        }, this.config.wait);\n        let { changedtick } = doc;\n        await doc.patchChange();\n        if (changedtick != doc.changedtick) {\n            await util_1.wait(30);\n        }\n        if (token.isCancellationRequested) {\n            return false;\n        }\n        let signatureHelp = await languages_1.default.getSignatureHelp(doc.textDocument, position, token, {\n            // TODO set to true if it's placeholder jump, but can't detect by now.\n            isRetrigger: false,\n            triggerKind: invoke ? vscode_languageserver_protocol_1.SignatureHelpTriggerKind.Invoked : vscode_languageserver_protocol_1.SignatureHelpTriggerKind.TriggerCharacter\n        });\n        clearTimeout(timer);\n        if (token.isCancellationRequested)\n            return false;\n        if (!signatureHelp || signatureHelp.signatures.length == 0) {\n            this.signatureFactory.close();\n            return false;\n        }\n        let { activeSignature, signatures } = signatureHelp;\n        if (activeSignature) {\n            // make active first\n            let [active] = signatures.splice(activeSignature, 1);\n            if (active)\n                signatures.unshift(active);\n        }\n        if (target == 'echo') {\n            this.echoSignature(signatureHelp);\n        }\n        else {\n            await this.showSignatureHelp(doc, position, signatureHelp);\n        }\n    }\n    async showSignatureHelp(doc, position, signatureHelp) {\n        let { signatures, activeParameter } = signatureHelp;\n        let offset = 0;\n        let paramDoc = null;\n        let docs = signatures.reduce((p, c, idx) => {\n            var _a;\n            let activeIndexes = null;\n            let nameIndex = c.label.indexOf('(');\n            if (idx == 0 && activeParameter != null) {\n                let active = (_a = c.parameters) === null || _a === void 0 ? void 0 : _a[activeParameter];\n                if (active) {\n                    let after = c.label.slice(nameIndex == -1 ? 0 : nameIndex);\n                    paramDoc = active.documentation;\n                    if (typeof active.label === 'string') {\n                        let str = after.slice(0);\n                        let ms = str.match(new RegExp('\\\\b' + active.label.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') + '\\\\b'));\n                        let index = ms ? ms.index : str.indexOf(active.label);\n                        if (index != -1) {\n                            activeIndexes = [\n                                index + nameIndex,\n                                index + active.label.length + nameIndex\n                            ];\n                        }\n                    }\n                    else {\n                        activeIndexes = active.label;\n                    }\n                }\n            }\n            if (activeIndexes == null) {\n                activeIndexes = [nameIndex + 1, nameIndex + 1];\n            }\n            if (offset == 0) {\n                offset = activeIndexes[0] + 1;\n            }\n            p.push({\n                content: c.label,\n                filetype: doc.filetype,\n                active: activeIndexes\n            });\n            if (paramDoc) {\n                let content = typeof paramDoc === 'string' ? paramDoc : paramDoc.value;\n                if (content.trim().length) {\n                    p.push({\n                        content,\n                        filetype: isMarkdown(c.documentation) ? 'markdown' : 'txt'\n                    });\n                }\n            }\n            if (idx == 0 && c.documentation) {\n                let { documentation } = c;\n                let content = typeof documentation === 'string' ? documentation : documentation.value;\n                if (content.trim().length) {\n                    p.push({\n                        content,\n                        filetype: isMarkdown(c.documentation) ? 'markdown' : 'txt'\n                    });\n                }\n            }\n            return p;\n        }, []);\n        let session = manager_1.default.getSession(doc.bufnr);\n        if (session && session.isActive) {\n            let { value } = session.placeholder;\n            if (!value.includes('\\n'))\n                offset += value.length;\n            this.signaturePosition = vscode_languageserver_protocol_1.Position.create(position.line, position.character - value.length);\n        }\n        else {\n            this.signaturePosition = position;\n        }\n        let { preferAbove, maxWindowHeight, maxWindowWidth } = this.config;\n        await this.signatureFactory.show(docs, {\n            maxWidth: maxWindowWidth,\n            maxHeight: maxWindowHeight,\n            preferTop: preferAbove,\n            autoHide: false,\n            offsetX: offset,\n            modes: ['i', 'ic', 's']\n        });\n    }\n    echoSignature(signatureHelp) {\n        var _a;\n        let { signatures, activeParameter } = signatureHelp;\n        let columns = workspace_1.default.env.columns;\n        signatures = signatures.slice(0, workspace_1.default.env.cmdheight);\n        let signatureList = [];\n        for (let signature of signatures) {\n            let parts = [];\n            let { label } = signature;\n            label = label.replace(/\\n/g, ' ');\n            if (label.length >= columns - 16) {\n                label = label.slice(0, columns - 16) + '...';\n            }\n            let nameIndex = label.indexOf('(');\n            if (nameIndex == -1) {\n                parts = [{ text: label, type: 'Normal' }];\n            }\n            else {\n                parts.push({\n                    text: label.slice(0, nameIndex),\n                    type: 'Label'\n                });\n                let after = label.slice(nameIndex);\n                if (signatureList.length == 0 && activeParameter != null) {\n                    let active = (_a = signature.parameters) === null || _a === void 0 ? void 0 : _a[activeParameter];\n                    if (active) {\n                        let start;\n                        let end;\n                        if (typeof active.label === 'string') {\n                            let str = after.slice(0);\n                            let ms = str.match(new RegExp('\\\\b' + active.label.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') + '\\\\b'));\n                            let idx = ms ? ms.index : str.indexOf(active.label);\n                            if (idx == -1) {\n                                parts.push({ text: after, type: 'Normal' });\n                            }\n                            else {\n                                start = idx;\n                                end = idx + active.label.length;\n                            }\n                        }\n                        else {\n                            [start, end] = active.label;\n                            start = start - nameIndex;\n                            end = end - nameIndex;\n                        }\n                        if (start != null && end != null) {\n                            parts.push({ text: after.slice(0, start), type: 'Normal' });\n                            parts.push({ text: after.slice(start, end), type: 'MoreMsg' });\n                            parts.push({ text: after.slice(end), type: 'Normal' });\n                        }\n                    }\n                }\n                else {\n                    parts.push({\n                        text: after,\n                        type: 'Normal'\n                    });\n                }\n            }\n            signatureList.push(parts);\n        }\n        this.nvim.callTimer('coc#util#echo_signatures', [signatureList], true);\n    }\n    dispose() {\n        util_1.disposeAll(this.disposables);\n        if (this.timer) {\n            clearTimeout(this.timer);\n        }\n        if (this.tokenSource) {\n            this.tokenSource.cancel();\n            this.tokenSource.dispose();\n        }\n    }\n}\nexports.default = Signature;\nfunction isMarkdown(content) {\n    if (vscode_languageserver_protocol_1.MarkupContent.is(content) && content.kind == vscode_languageserver_protocol_1.MarkupKind.Markdown) {\n        return true;\n    }\n    return false;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./src/handler/signature.ts?");

/***/ }),

/***/ "./src/handler/symbols.ts":
/*!********************************!*\
  !*** ./src/handler/symbols.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst debounce_1 = tslib_1.__importDefault(__webpack_require__(/*! debounce */ \"./node_modules/debounce/index.js\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nconst languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ../languages */ \"./src/languages.ts\"));\nconst convert_1 = __webpack_require__(/*! ../util/convert */ \"./src/util/convert.ts\");\nconst index_1 = __webpack_require__(/*! ../util/index */ \"./src/util/index.ts\");\nconst object_1 = __webpack_require__(/*! ../util/object */ \"./src/util/object.ts\");\nconst position_1 = __webpack_require__(/*! ../util/position */ \"./src/util/position.ts\");\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst helper_1 = __webpack_require__(/*! ./helper */ \"./src/handler/helper.ts\");\nclass Symbols {\n    constructor(nvim) {\n        this.nvim = nvim;\n        this.disposables = [];\n        this.buffers = workspace_1.default.registerBufferSync(doc => {\n            if (doc.buftype != '')\n                return undefined;\n            let buf = new SymbolsBuffer(doc.bufnr);\n            buf.onDidUpdate(async (symbols) => {\n                await events_1.default.fire('SymbolsUpdate', [buf.bufnr, symbols]);\n            });\n            return buf;\n        });\n        events_1.default.on('CursorHold', async (bufnr) => {\n            if (!this.functionUpdate || this.buffers.getItem(bufnr) == null)\n                return;\n            await this.getCurrentFunctionSymbol(bufnr);\n        }, null, this.disposables);\n    }\n    get functionUpdate() {\n        let config = workspace_1.default.getConfiguration('coc.preferences');\n        return config.get('currentFunctionSymbolAutoUpdate', false);\n    }\n    get labels() {\n        return workspace_1.default.getConfiguration('suggest').get('completionItemKindLabels', {});\n    }\n    async getDocumentSymbols(bufnr) {\n        let buf = this.buffers.getItem(bufnr);\n        return buf === null || buf === void 0 ? void 0 : buf.getSymbols();\n    }\n    async getCurrentFunctionSymbol(bufnr) {\n        if (!bufnr)\n            bufnr = await this.nvim.call('bufnr', ['%']);\n        let position = await window_1.default.getCursorPosition();\n        let symbols = await this.getDocumentSymbols(bufnr);\n        let buffer = this.nvim.createBuffer(bufnr);\n        if (!symbols || symbols.length === 0) {\n            buffer.setVar('coc_current_function', '', true);\n            this.nvim.call('coc#util#do_autocmd', ['CocStatusChange'], true);\n            return '';\n        }\n        symbols = symbols.filter(s => [\n            'Class',\n            'Method',\n            'Function',\n            'Struct',\n        ].includes(s.kind));\n        let functionName = '';\n        for (let sym of symbols.reverse()) {\n            if (sym.range\n                && position_1.positionInRange(position, sym.range) == 0\n                && !sym.text.endsWith(') callback')) {\n                functionName = sym.text;\n                let label = this.labels[sym.kind.toLowerCase()];\n                if (label)\n                    functionName = `${label} ${functionName}`;\n                break;\n            }\n        }\n        if (this.functionUpdate) {\n            buffer.setVar('coc_current_function', functionName, true);\n            this.nvim.call('coc#util#do_autocmd', ['CocStatusChange'], true);\n        }\n        return functionName;\n    }\n    /*\n     * supportedSymbols must be string values of symbolKind\n     */\n    async selectSymbolRange(inner, visualmode, supportedSymbols) {\n        let bufnr = await this.nvim.call('bufnr', ['%']);\n        let doc = workspace_1.default.getDocument(bufnr);\n        if (!doc || !doc.attached)\n            return;\n        let range;\n        if (visualmode) {\n            range = await workspace_1.default.getSelectedRange(visualmode, doc);\n        }\n        else {\n            let pos = await window_1.default.getCursorPosition();\n            range = vscode_languageserver_protocol_1.Range.create(pos, pos);\n        }\n        let symbols = await this.getDocumentSymbols(bufnr);\n        if (!symbols || symbols.length === 0) {\n            window_1.default.showMessage('No symbols found', 'warning');\n            return;\n        }\n        let properties = symbols.filter(s => s.kind == 'Property');\n        symbols = symbols.filter(s => supportedSymbols.includes(s.kind));\n        let selectRange;\n        for (let sym of symbols.reverse()) {\n            if (sym.range && !object_1.equals(sym.range, range) && position_1.rangeInRange(range, sym.range)) {\n                selectRange = sym.range;\n                break;\n            }\n        }\n        if (!selectRange) {\n            for (let sym of properties) {\n                if (sym.range && !object_1.equals(sym.range, range) && position_1.rangeInRange(range, sym.range)) {\n                    selectRange = sym.range;\n                    break;\n                }\n            }\n        }\n        if (inner && selectRange) {\n            let { start, end } = selectRange;\n            let line = doc.getline(start.line + 1);\n            let endLine = doc.getline(end.line - 1);\n            selectRange = vscode_languageserver_protocol_1.Range.create(start.line + 1, line.match(/^\\s*/)[0].length, end.line - 1, endLine.length);\n        }\n        if (selectRange)\n            await workspace_1.default.selectRange(selectRange);\n    }\n    dispose() {\n        this.buffers.dispose();\n        index_1.disposeAll(this.disposables);\n    }\n}\nexports.default = Symbols;\nclass SymbolsBuffer {\n    constructor(bufnr) {\n        this.bufnr = bufnr;\n        this.disposables = [];\n        this.autoUpdate = false;\n        this.symbols = [];\n        this._onDidUpdate = new vscode_languageserver_protocol_1.Emitter();\n        this.onDidUpdate = this._onDidUpdate.event;\n        this.fetchSymbols = debounce_1.default(() => {\n            this._fetchSymbols().logError();\n        }, global.hasOwnProperty('__TEST__') ? 10 : 500);\n    }\n    async getSymbols() {\n        let doc = workspace_1.default.getDocument(this.bufnr);\n        if (!doc)\n            return [];\n        doc.forceSync();\n        this.autoUpdate = true;\n        if (doc.version == this.version)\n            return this.symbols;\n        this.cancel();\n        await this._fetchSymbols();\n        return this.symbols;\n    }\n    onChange() {\n        this.cancel();\n    }\n    get textDocument() {\n        var _a;\n        return (_a = workspace_1.default.getDocument(this.bufnr)) === null || _a === void 0 ? void 0 : _a.textDocument;\n    }\n    async _fetchSymbols() {\n        let { textDocument } = this;\n        if (!textDocument || textDocument.version == this.version)\n            return;\n        let { version } = textDocument;\n        let tokenSource = this.tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n        let { token } = tokenSource;\n        let symbols = await languages_1.default.getDocumentSymbol(textDocument, token);\n        this.tokenSource = undefined;\n        if (symbols == null || token.isCancellationRequested)\n            return;\n        let level = 0;\n        let res = [];\n        let pre = null;\n        if (helper_1.isDocumentSymbols(symbols)) {\n            symbols.sort(helper_1.sortDocumentSymbols);\n            symbols.forEach(s => helper_1.addDoucmentSymbol(res, s, level));\n        }\n        else {\n            symbols.sort(helper_1.sortSymbolInformations);\n            for (let sym of symbols) {\n                let { name, kind, location, containerName } = sym;\n                if (!containerName || !pre) {\n                    level = 0;\n                }\n                else {\n                    if (pre.containerName == containerName) {\n                        level = pre.level || 0;\n                    }\n                    else {\n                        let container = helper_1.getPreviousContainer(containerName, res);\n                        level = container ? container.level + 1 : 0;\n                    }\n                }\n                let { start } = location.range;\n                let o = {\n                    col: start.character + 1,\n                    lnum: start.line + 1,\n                    text: name,\n                    level,\n                    kind: convert_1.getSymbolKind(kind),\n                    range: location.range,\n                    containerName\n                };\n                res.push(o);\n                pre = o;\n            }\n        }\n        this.version = version;\n        this.symbols = res;\n        if (helper_1.isDocumentSymbols(symbols)) {\n            this._onDidUpdate.fire(symbols);\n        }\n        else {\n            this._onDidUpdate.fire(symbols.map(o => {\n                return vscode_languageserver_protocol_1.DocumentSymbol.create(o.name, '', o.kind, o.location.range, o.location.range);\n            }));\n        }\n    }\n    cancel() {\n        this.fetchSymbols.clear();\n        if (this.tokenSource) {\n            this.tokenSource.cancel();\n            this.tokenSource = null;\n        }\n    }\n    dispose() {\n        this.cancel();\n        this.symbols = undefined;\n        this._onDidUpdate.dispose();\n        index_1.disposeAll(this.disposables);\n    }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./src/handler/symbols.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.runCommand = exports.wait = exports.watchFile = exports.concurrent = exports.disposeAll = exports.Mutex = exports.BasicList = exports.listManager = exports.extensions = exports.FileSystemWatcher = exports.Document = exports.diagnosticManager = exports.languages = exports.sources = exports.commands = exports.services = exports.events = exports.snippetManager = exports.window = exports.workspace = exports.ansiparse = exports.download = exports.fetch = exports.FloatFactory = exports.Emitter = exports.Event = exports.Disposable = exports.Uri = exports.Watchman = exports.Mru = exports.Highligher = exports.Window = exports.Buffer = exports.NotificationType0 = exports.NotificationType = exports.RequestType0 = exports.RequestType = exports.TextEdit = exports.Range = exports.Position = exports.ProgressType = exports.CancellationToken = exports.CancellationTokenSource = exports.LocationLink = exports.Location = exports.InsertTextFormat = exports.CompletionItemKind = exports.DiagnosticSeverity = exports.Diagnostic = exports.Neovim = void 0;\nexports.executable = exports.isRunning = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst commands_1 = tslib_1.__importDefault(__webpack_require__(/*! ./commands */ \"./src/commands.ts\"));\nexports.commands = commands_1.default;\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ./events */ \"./src/events.ts\"));\nexports.events = events_1.default;\nconst languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ./languages */ \"./src/languages.ts\"));\nexports.languages = languages_1.default;\nconst document_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/document */ \"./src/model/document.ts\"));\nexports.Document = document_1.default;\nconst mru_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/mru */ \"./src/model/mru.ts\"));\nexports.Mru = mru_1.default;\nconst floatFactory_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/floatFactory */ \"./src/model/floatFactory.ts\"));\nexports.FloatFactory = floatFactory_1.default;\nconst fetch_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/fetch */ \"./src/model/fetch.ts\"));\nexports.fetch = fetch_1.default;\nconst download_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/download */ \"./src/model/download.ts\"));\nexports.download = download_1.default;\nconst highligher_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/highligher */ \"./src/model/highligher.ts\"));\nexports.Highligher = highligher_1.default;\nconst fileSystemWatcher_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/fileSystemWatcher */ \"./src/model/fileSystemWatcher.ts\"));\nexports.FileSystemWatcher = fileSystemWatcher_1.default;\nconst services_1 = tslib_1.__importDefault(__webpack_require__(/*! ./services */ \"./src/services.ts\"));\nexports.services = services_1.default;\nconst sources_1 = tslib_1.__importDefault(__webpack_require__(/*! ./sources */ \"./src/sources.ts\"));\nexports.sources = sources_1.default;\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ./workspace */ \"./src/workspace.ts\"));\nexports.workspace = workspace_1.default;\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ./window */ \"./src/window.ts\"));\nexports.window = window_1.default;\nconst extensions_1 = tslib_1.__importDefault(__webpack_require__(/*! ./extensions */ \"./src/extensions.ts\"));\nexports.extensions = extensions_1.default;\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./list/manager */ \"./src/list/manager.ts\"));\nexports.listManager = manager_1.default;\nconst manager_2 = tslib_1.__importDefault(__webpack_require__(/*! ./snippets/manager */ \"./src/snippets/manager.ts\"));\nexports.snippetManager = manager_2.default;\nconst basic_1 = tslib_1.__importDefault(__webpack_require__(/*! ./list/basic */ \"./src/list/basic.ts\"));\nexports.BasicList = basic_1.default;\nconst manager_3 = tslib_1.__importDefault(__webpack_require__(/*! ./diagnostic/manager */ \"./src/diagnostic/manager.ts\"));\nexports.diagnosticManager = manager_3.default;\nconst ansiparse_1 = __webpack_require__(/*! ./util/ansiparse */ \"./src/util/ansiparse.ts\");\nObject.defineProperty(exports, \"ansiparse\", ({ enumerable: true, get: function () { return ansiparse_1.ansiparse; } }));\nconst watchman_1 = tslib_1.__importDefault(__webpack_require__(/*! ./watchman */ \"./src/watchman.ts\"));\nexports.Watchman = watchman_1.default;\nconst mutex_1 = __webpack_require__(/*! ./util/mutex */ \"./src/util/mutex.ts\");\nObject.defineProperty(exports, \"Mutex\", ({ enumerable: true, get: function () { return mutex_1.Mutex; } }));\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nObject.defineProperty(exports, \"Uri\", ({ enumerable: true, get: function () { return vscode_uri_1.URI; } }));\nconst neovim_1 = __webpack_require__(/*! @chemzqm/neovim */ \"./node_modules/@chemzqm/neovim/lib/index.js\");\nObject.defineProperty(exports, \"Neovim\", ({ enumerable: true, get: function () { return neovim_1.Neovim; } }));\nObject.defineProperty(exports, \"Buffer\", ({ enumerable: true, get: function () { return neovim_1.Buffer; } }));\nObject.defineProperty(exports, \"Window\", ({ enumerable: true, get: function () { return neovim_1.Window; } }));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nObject.defineProperty(exports, \"Disposable\", ({ enumerable: true, get: function () { return vscode_languageserver_protocol_1.Disposable; } }));\nObject.defineProperty(exports, \"Position\", ({ enumerable: true, get: function () { return vscode_languageserver_protocol_1.Position; } }));\nObject.defineProperty(exports, \"Range\", ({ enumerable: true, get: function () { return vscode_languageserver_protocol_1.Range; } }));\nObject.defineProperty(exports, \"TextEdit\", ({ enumerable: true, get: function () { return vscode_languageserver_protocol_1.TextEdit; } }));\nObject.defineProperty(exports, \"RequestType\", ({ enumerable: true, get: function () { return vscode_languageserver_protocol_1.RequestType; } }));\nObject.defineProperty(exports, \"RequestType0\", ({ enumerable: true, get: function () { return vscode_languageserver_protocol_1.RequestType0; } }));\nObject.defineProperty(exports, \"NotificationType\", ({ enumerable: true, get: function () { return vscode_languageserver_protocol_1.NotificationType; } }));\nObject.defineProperty(exports, \"NotificationType0\", ({ enumerable: true, get: function () { return vscode_languageserver_protocol_1.NotificationType0; } }));\nObject.defineProperty(exports, \"Event\", ({ enumerable: true, get: function () { return vscode_languageserver_protocol_1.Event; } }));\nObject.defineProperty(exports, \"CancellationToken\", ({ enumerable: true, get: function () { return vscode_languageserver_protocol_1.CancellationToken; } }));\nObject.defineProperty(exports, \"CancellationTokenSource\", ({ enumerable: true, get: function () { return vscode_languageserver_protocol_1.CancellationTokenSource; } }));\nObject.defineProperty(exports, \"Emitter\", ({ enumerable: true, get: function () { return vscode_languageserver_protocol_1.Emitter; } }));\nObject.defineProperty(exports, \"Diagnostic\", ({ enumerable: true, get: function () { return vscode_languageserver_protocol_1.Diagnostic; } }));\nObject.defineProperty(exports, \"DiagnosticSeverity\", ({ enumerable: true, get: function () { return vscode_languageserver_protocol_1.DiagnosticSeverity; } }));\nObject.defineProperty(exports, \"CompletionItemKind\", ({ enumerable: true, get: function () { return vscode_languageserver_protocol_1.CompletionItemKind; } }));\nObject.defineProperty(exports, \"InsertTextFormat\", ({ enumerable: true, get: function () { return vscode_languageserver_protocol_1.InsertTextFormat; } }));\nObject.defineProperty(exports, \"Location\", ({ enumerable: true, get: function () { return vscode_languageserver_protocol_1.Location; } }));\nObject.defineProperty(exports, \"LocationLink\", ({ enumerable: true, get: function () { return vscode_languageserver_protocol_1.LocationLink; } }));\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/main.js\");\nObject.defineProperty(exports, \"ProgressType\", ({ enumerable: true, get: function () { return vscode_jsonrpc_1.ProgressType; } }));\ntslib_1.__exportStar(__webpack_require__(/*! ./types */ \"./src/types.ts\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./language-client */ \"./src/language-client/index.ts\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./provider */ \"./src/provider/index.ts\"), exports);\nvar util_1 = __webpack_require__(/*! ./util */ \"./src/util/index.ts\");\nObject.defineProperty(exports, \"disposeAll\", ({ enumerable: true, get: function () { return util_1.disposeAll; } }));\nObject.defineProperty(exports, \"concurrent\", ({ enumerable: true, get: function () { return util_1.concurrent; } }));\nObject.defineProperty(exports, \"watchFile\", ({ enumerable: true, get: function () { return util_1.watchFile; } }));\nObject.defineProperty(exports, \"wait\", ({ enumerable: true, get: function () { return util_1.wait; } }));\nObject.defineProperty(exports, \"runCommand\", ({ enumerable: true, get: function () { return util_1.runCommand; } }));\nObject.defineProperty(exports, \"isRunning\", ({ enumerable: true, get: function () { return util_1.isRunning; } }));\nObject.defineProperty(exports, \"executable\", ({ enumerable: true, get: function () { return util_1.executable; } }));\n\n\n//# sourceURL=webpack://coc.nvim/./src/index.ts?");

/***/ }),

/***/ "./src/language-client/client.ts":
/*!***************************************!*\
  !*** ./src/language-client/client.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseLanguageClient = exports.MessageTransports = exports.TextDocumentFeature = exports.ClientState = exports.State = exports.RevealOutputChannelOn = exports.CloseAction = exports.ErrorAction = exports.NullLogger = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* ---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/* eslint-disable */\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst commands_1 = tslib_1.__importDefault(__webpack_require__(/*! ../commands */ \"./src/commands.ts\"));\nconst languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ../languages */ \"./src/languages.ts\"));\nconst fs_1 = __webpack_require__(/*! ../util/fs */ \"./src/util/fs.ts\");\nconst Is = tslib_1.__importStar(__webpack_require__(/*! ../util/is */ \"./src/util/is.ts\"));\nconst lodash_1 = __webpack_require__(/*! ../util/lodash */ \"./src/util/lodash.ts\");\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst progressPart_1 = __webpack_require__(/*! ./progressPart */ \"./src/language-client/progressPart.ts\");\nconst async_1 = __webpack_require__(/*! ./utils/async */ \"./src/language-client/utils/async.ts\");\nconst cv = tslib_1.__importStar(__webpack_require__(/*! ./utils/converter */ \"./src/language-client/utils/converter.ts\"));\nconst UUID = tslib_1.__importStar(__webpack_require__(/*! ./utils/uuid */ \"./src/language-client/utils/uuid.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('language-client-client');\nclass ConsoleLogger {\n    error(message) {\n        logger.error(message);\n    }\n    warn(message) {\n        logger.warn(message);\n    }\n    info(message) {\n        logger.info(message);\n    }\n    log(message) {\n        logger.log(message);\n    }\n}\nclass NullLogger {\n    error(_message) {\n    }\n    warn(_message) {\n    }\n    info(_message) {\n    }\n    log(_message) {\n    }\n}\nexports.NullLogger = NullLogger;\nfunction createConnection(input, output, errorHandler, closeHandler) {\n    let logger = new ConsoleLogger();\n    let connection = vscode_languageserver_protocol_1.createProtocolConnection(input, output, logger);\n    connection.onError(data => {\n        errorHandler(data[0], data[1], data[2]);\n    });\n    connection.onClose(closeHandler);\n    let result = {\n        listen: () => connection.listen(),\n        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),\n        onRequest: (type, handler) => connection.onRequest(Is.string(type) ? type : type.method, handler),\n        sendNotification: (type, params) => connection.sendNotification(Is.string(type) ? type : type.method, params),\n        onNotification: (type, handler) => connection.onNotification(Is.string(type) ? type : type.method, handler),\n        onProgress: connection.onProgress,\n        sendProgress: connection.sendProgress,\n        trace: (value, tracer, sendNotificationOrTraceOptions) => {\n            const defaultTraceOptions = {\n                sendNotification: false,\n                traceFormat: vscode_languageserver_protocol_1.TraceFormat.Text\n            };\n            if (sendNotificationOrTraceOptions === void 0) {\n                connection.trace(value, tracer, defaultTraceOptions);\n            }\n            else if (Is.boolean(sendNotificationOrTraceOptions)) {\n                connection.trace(value, tracer, sendNotificationOrTraceOptions);\n            }\n            else {\n                connection.trace(value, tracer, sendNotificationOrTraceOptions);\n            }\n        },\n        initialize: (params) => connection.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params),\n        shutdown: () => connection.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, undefined),\n        exit: () => connection.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type),\n        onLogMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, handler),\n        onShowMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, handler),\n        onTelemetry: (handler) => connection.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, handler),\n        didChangeConfiguration: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, params),\n        didChangeWatchedFiles: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, params),\n        didOpenTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, params),\n        didChangeTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params),\n        didCloseTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, params),\n        didSaveTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, params),\n        onDiagnostics: (handler) => connection.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, handler),\n        dispose: () => connection.dispose()\n    };\n    return result;\n}\n/**\n * An action to be performed when the connection is producing errors.\n */\nvar ErrorAction;\n(function (ErrorAction) {\n    /**\n     * Continue running the server.\n     */\n    ErrorAction[ErrorAction[\"Continue\"] = 1] = \"Continue\";\n    /**\n     * Shutdown the server.\n     */\n    ErrorAction[ErrorAction[\"Shutdown\"] = 2] = \"Shutdown\";\n})(ErrorAction = exports.ErrorAction || (exports.ErrorAction = {}));\n/**\n * An action to be performed when the connection to a server got closed.\n */\nvar CloseAction;\n(function (CloseAction) {\n    /**\n     * Don't restart the server. The connection stays closed.\n     */\n    CloseAction[CloseAction[\"DoNotRestart\"] = 1] = \"DoNotRestart\";\n    /**\n     * Restart the server.\n     */\n    CloseAction[CloseAction[\"Restart\"] = 2] = \"Restart\";\n})(CloseAction = exports.CloseAction || (exports.CloseAction = {}));\nclass DefaultErrorHandler {\n    constructor(name) {\n        this.name = name;\n        this.restarts = [];\n    }\n    error(_error, _message, count) {\n        if (count && count <= 3) {\n            return ErrorAction.Continue;\n        }\n        return ErrorAction.Shutdown;\n    }\n    closed() {\n        this.restarts.push(Date.now());\n        if (this.restarts.length < 5) {\n            return CloseAction.Restart;\n        }\n        else {\n            let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];\n            if (diff <= 3 * 60 * 1000) {\n                window_1.default.showMessage(`The \"${this.name}\" server crashed 5 times in the last 3 minutes. The server will not be restarted.`, 'error');\n                return CloseAction.DoNotRestart;\n            }\n            else {\n                this.restarts.shift();\n                return CloseAction.Restart;\n            }\n        }\n    }\n}\nvar RevealOutputChannelOn;\n(function (RevealOutputChannelOn) {\n    RevealOutputChannelOn[RevealOutputChannelOn[\"Info\"] = 1] = \"Info\";\n    RevealOutputChannelOn[RevealOutputChannelOn[\"Warn\"] = 2] = \"Warn\";\n    RevealOutputChannelOn[RevealOutputChannelOn[\"Error\"] = 3] = \"Error\";\n    RevealOutputChannelOn[RevealOutputChannelOn[\"Never\"] = 4] = \"Never\";\n})(RevealOutputChannelOn = exports.RevealOutputChannelOn || (exports.RevealOutputChannelOn = {}));\nvar State;\n(function (State) {\n    State[State[\"Stopped\"] = 1] = \"Stopped\";\n    State[State[\"Running\"] = 2] = \"Running\";\n    State[State[\"Starting\"] = 3] = \"Starting\";\n})(State = exports.State || (exports.State = {}));\nvar ClientState;\n(function (ClientState) {\n    ClientState[ClientState[\"Initial\"] = 0] = \"Initial\";\n    ClientState[ClientState[\"Starting\"] = 1] = \"Starting\";\n    ClientState[ClientState[\"StartFailed\"] = 2] = \"StartFailed\";\n    ClientState[ClientState[\"Running\"] = 3] = \"Running\";\n    ClientState[ClientState[\"Stopping\"] = 4] = \"Stopping\";\n    ClientState[ClientState[\"Stopped\"] = 5] = \"Stopped\";\n})(ClientState = exports.ClientState || (exports.ClientState = {}));\nconst SupportedSymbolKinds = [\n    vscode_languageserver_protocol_1.SymbolKind.File,\n    vscode_languageserver_protocol_1.SymbolKind.Module,\n    vscode_languageserver_protocol_1.SymbolKind.Namespace,\n    vscode_languageserver_protocol_1.SymbolKind.Package,\n    vscode_languageserver_protocol_1.SymbolKind.Class,\n    vscode_languageserver_protocol_1.SymbolKind.Method,\n    vscode_languageserver_protocol_1.SymbolKind.Property,\n    vscode_languageserver_protocol_1.SymbolKind.Field,\n    vscode_languageserver_protocol_1.SymbolKind.Constructor,\n    vscode_languageserver_protocol_1.SymbolKind.Enum,\n    vscode_languageserver_protocol_1.SymbolKind.Interface,\n    vscode_languageserver_protocol_1.SymbolKind.Function,\n    vscode_languageserver_protocol_1.SymbolKind.Variable,\n    vscode_languageserver_protocol_1.SymbolKind.Constant,\n    vscode_languageserver_protocol_1.SymbolKind.String,\n    vscode_languageserver_protocol_1.SymbolKind.Number,\n    vscode_languageserver_protocol_1.SymbolKind.Boolean,\n    vscode_languageserver_protocol_1.SymbolKind.Array,\n    vscode_languageserver_protocol_1.SymbolKind.Object,\n    vscode_languageserver_protocol_1.SymbolKind.Key,\n    vscode_languageserver_protocol_1.SymbolKind.Null,\n    vscode_languageserver_protocol_1.SymbolKind.EnumMember,\n    vscode_languageserver_protocol_1.SymbolKind.Struct,\n    vscode_languageserver_protocol_1.SymbolKind.Event,\n    vscode_languageserver_protocol_1.SymbolKind.Operator,\n    vscode_languageserver_protocol_1.SymbolKind.TypeParameter\n];\nconst SupportedCompletionItemKinds = [\n    vscode_languageserver_protocol_1.CompletionItemKind.Text,\n    vscode_languageserver_protocol_1.CompletionItemKind.Method,\n    vscode_languageserver_protocol_1.CompletionItemKind.Function,\n    vscode_languageserver_protocol_1.CompletionItemKind.Constructor,\n    vscode_languageserver_protocol_1.CompletionItemKind.Field,\n    vscode_languageserver_protocol_1.CompletionItemKind.Variable,\n    vscode_languageserver_protocol_1.CompletionItemKind.Class,\n    vscode_languageserver_protocol_1.CompletionItemKind.Interface,\n    vscode_languageserver_protocol_1.CompletionItemKind.Module,\n    vscode_languageserver_protocol_1.CompletionItemKind.Property,\n    vscode_languageserver_protocol_1.CompletionItemKind.Unit,\n    vscode_languageserver_protocol_1.CompletionItemKind.Value,\n    vscode_languageserver_protocol_1.CompletionItemKind.Enum,\n    vscode_languageserver_protocol_1.CompletionItemKind.Keyword,\n    vscode_languageserver_protocol_1.CompletionItemKind.Snippet,\n    vscode_languageserver_protocol_1.CompletionItemKind.Color,\n    vscode_languageserver_protocol_1.CompletionItemKind.File,\n    vscode_languageserver_protocol_1.CompletionItemKind.Reference,\n    vscode_languageserver_protocol_1.CompletionItemKind.Folder,\n    vscode_languageserver_protocol_1.CompletionItemKind.EnumMember,\n    vscode_languageserver_protocol_1.CompletionItemKind.Constant,\n    vscode_languageserver_protocol_1.CompletionItemKind.Struct,\n    vscode_languageserver_protocol_1.CompletionItemKind.Event,\n    vscode_languageserver_protocol_1.CompletionItemKind.Operator,\n    vscode_languageserver_protocol_1.CompletionItemKind.TypeParameter\n];\nconst SupportedSymbolTags = [\n    vscode_languageserver_protocol_1.SymbolTag.Deprecated\n];\nfunction ensure(target, key) {\n    if (target[key] == null) {\n        target[key] = {};\n    }\n    return target[key];\n}\nvar DynamicFeature;\n(function (DynamicFeature) {\n    function is(value) {\n        let candidate = value;\n        return (candidate &&\n            Is.func(candidate.register) &&\n            Is.func(candidate.unregister) &&\n            Is.func(candidate.dispose) &&\n            candidate.messages !== void 0);\n    }\n    DynamicFeature.is = is;\n})(DynamicFeature || (DynamicFeature = {}));\nclass DocumentNotifiactions {\n    constructor(_client, _event, _type, _middleware, _createParams, _selectorFilter) {\n        this._client = _client;\n        this._event = _event;\n        this._type = _type;\n        this._middleware = _middleware;\n        this._createParams = _createParams;\n        this._selectorFilter = _selectorFilter;\n        this._selectors = new Map();\n    }\n    static textDocumentFilter(selectors, textDocument) {\n        for (const selector of selectors) {\n            if (workspace_1.default.match(selector, textDocument) > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    register(_message, data) {\n        if (!data.registerOptions.documentSelector) {\n            return;\n        }\n        if (!this._listener) {\n            this._listener = this._event(this.callback, this);\n        }\n        this._selectors.set(data.id, data.registerOptions.documentSelector);\n    }\n    callback(data) {\n        if (!this._selectorFilter ||\n            this._selectorFilter(this._selectors.values(), data)) {\n            if (this._middleware) {\n                this._middleware(data, data => this._client.sendNotification(this._type, this._createParams(data)));\n            }\n            else {\n                this._client.sendNotification(this._type, this._createParams(data));\n            }\n            this.notificationSent(data);\n        }\n    }\n    notificationSent(_data) { }\n    unregister(id) {\n        this._selectors.delete(id);\n        if (this._selectors.size === 0 && this._listener) {\n            this._listener.dispose();\n            this._listener = undefined;\n        }\n    }\n    dispose() {\n        this._selectors.clear();\n        if (this._listener) {\n            this._listener.dispose();\n            this._listener = undefined;\n        }\n    }\n    getProvider(document) {\n        for (const selector of this._selectors.values()) {\n            if (workspace_1.default.match(selector, document)) {\n                return {\n                    send: (data) => {\n                        this.callback(data);\n                    }\n                };\n            }\n        }\n        throw new Error(`No provider available for the given text document`);\n    }\n}\nclass DidOpenTextDocumentFeature extends DocumentNotifiactions {\n    constructor(client, _syncedDocuments) {\n        super(client, workspace_1.default.onDidOpenTextDocument, vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, client.clientOptions.middleware.didOpen, (textDocument) => {\n            return { textDocument: cv.convertToTextDocumentItem(textDocument) };\n        }, DocumentNotifiactions.textDocumentFilter);\n        this._syncedDocuments = _syncedDocuments;\n    }\n    get messages() {\n        return vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type;\n    }\n    fillClientCapabilities(capabilities) {\n        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;\n    }\n    initialize(capabilities, documentSelector) {\n        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;\n        if (documentSelector &&\n            textDocumentSyncOptions &&\n            textDocumentSyncOptions.openClose) {\n            this.register(this.messages, {\n                id: UUID.generateUuid(),\n                registerOptions: { documentSelector: documentSelector }\n            });\n        }\n    }\n    register(message, data) {\n        super.register(message, data);\n        if (!data.registerOptions.documentSelector) {\n            return;\n        }\n        let documentSelector = data.registerOptions.documentSelector;\n        workspace_1.default.textDocuments.forEach(textDocument => {\n            let uri = textDocument.uri.toString();\n            if (this._syncedDocuments.has(uri)) {\n                return;\n            }\n            if (workspace_1.default.match(documentSelector, textDocument) > 0) {\n                let middleware = this._client.clientOptions.middleware;\n                let didOpen = (textDocument) => {\n                    this._client.sendNotification(this._type, this._createParams(textDocument));\n                };\n                if (middleware.didOpen) {\n                    middleware.didOpen(textDocument, didOpen);\n                }\n                else {\n                    didOpen(textDocument);\n                }\n                this._syncedDocuments.set(uri, textDocument);\n            }\n        });\n    }\n    notificationSent(textDocument) {\n        super.notificationSent(textDocument);\n        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);\n    }\n}\nclass DidCloseTextDocumentFeature extends DocumentNotifiactions {\n    constructor(client, _syncedDocuments) {\n        super(client, workspace_1.default.onDidCloseTextDocument, vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, client.clientOptions.middleware.didClose, (textDocument) => cv.asCloseTextDocumentParams(textDocument), DocumentNotifiactions.textDocumentFilter);\n        this._syncedDocuments = _syncedDocuments;\n    }\n    get messages() {\n        return vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type;\n    }\n    fillClientCapabilities(capabilities) {\n        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;\n    }\n    initialize(capabilities, documentSelector) {\n        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;\n        if (documentSelector &&\n            textDocumentSyncOptions &&\n            textDocumentSyncOptions.openClose) {\n            this.register(this.messages, {\n                id: UUID.generateUuid(),\n                registerOptions: { documentSelector: documentSelector }\n            });\n        }\n    }\n    notificationSent(textDocument) {\n        super.notificationSent(textDocument);\n        this._syncedDocuments.delete(textDocument.uri.toString());\n    }\n    unregister(id) {\n        let selector = this._selectors.get(id);\n        // The super call removed the selector from the map\n        // of selectors.\n        super.unregister(id);\n        let selectors = this._selectors.values();\n        this._syncedDocuments.forEach(textDocument => {\n            if (workspace_1.default.match(selector, textDocument) > 0 &&\n                !this._selectorFilter(selectors, textDocument)) {\n                let middleware = this._client.clientOptions.middleware;\n                let didClose = (textDocument) => {\n                    this._client.sendNotification(this._type, this._createParams(textDocument));\n                };\n                this._syncedDocuments.delete(textDocument.uri.toString());\n                if (middleware.didClose) {\n                    middleware.didClose(textDocument, didClose);\n                }\n                else {\n                    didClose(textDocument);\n                }\n            }\n        });\n    }\n}\nclass DidChangeTextDocumentFeature {\n    constructor(_client) {\n        this._client = _client;\n        this._changeData = new Map();\n    }\n    get messages() {\n        return vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type;\n    }\n    fillClientCapabilities(capabilities) {\n        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;\n    }\n    initialize(capabilities, documentSelector) {\n        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;\n        if (documentSelector &&\n            textDocumentSyncOptions &&\n            textDocumentSyncOptions.change !== void 0 &&\n            textDocumentSyncOptions.change !== vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {\n            this.register(this.messages, {\n                id: UUID.generateUuid(),\n                registerOptions: Object.assign({}, { documentSelector: documentSelector }, { syncKind: textDocumentSyncOptions.change })\n            });\n        }\n    }\n    register(_message, data) {\n        if (!data.registerOptions.documentSelector) {\n            return;\n        }\n        if (!this._listener) {\n            this._listener = workspace_1.default.onDidChangeTextDocument(this.callback, this);\n        }\n        this._changeData.set(data.id, {\n            documentSelector: data.registerOptions.documentSelector,\n            syncKind: data.registerOptions.syncKind\n        });\n    }\n    callback(event) {\n        // Text document changes are send for dirty changes as well. We don't\n        // have dirty / undirty events in the LSP so we ignore content changes\n        // with length zero.\n        if (event.contentChanges.length === 0) {\n            return;\n        }\n        let doc = workspace_1.default.getDocument(event.textDocument.uri);\n        if (!doc)\n            return;\n        let { textDocument } = doc;\n        for (const changeData of this._changeData.values()) {\n            if (workspace_1.default.match(changeData.documentSelector, textDocument) > 0) {\n                let middleware = this._client.clientOptions.middleware;\n                if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental) {\n                    if (middleware.didChange) {\n                        middleware.didChange(event, () => this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, lodash_1.omit(event, ['bufnr', 'original'])));\n                    }\n                    else {\n                        this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, lodash_1.omit(event, ['bufnr', 'original']));\n                    }\n                }\n                else if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {\n                    let didChange = event => {\n                        let { textDocument } = workspace_1.default.getDocument(event.textDocument.uri);\n                        this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, cv.asChangeTextDocumentParams(textDocument));\n                    };\n                    if (middleware.didChange) {\n                        middleware.didChange(event, didChange);\n                    }\n                    else {\n                        didChange(event);\n                    }\n                }\n            }\n        }\n    }\n    unregister(id) {\n        this._changeData.delete(id);\n        if (this._changeData.size === 0 && this._listener) {\n            this._listener.dispose();\n            this._listener = undefined;\n        }\n    }\n    dispose() {\n        this._changeData.clear();\n        if (this._listener) {\n            this._listener.dispose();\n            this._listener = undefined;\n        }\n    }\n    getProvider(document) {\n        for (const changeData of this._changeData.values()) {\n            if (workspace_1.default.match(changeData.documentSelector, document)) {\n                return {\n                    send: (event) => {\n                        this.callback(event);\n                    }\n                };\n            }\n        }\n        throw new Error(`No provider available for the given text document`);\n    }\n}\nclass WillSaveFeature extends DocumentNotifiactions {\n    constructor(client) {\n        super(client, workspace_1.default.onWillSaveTextDocument, vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, client.clientOptions.middleware.willSave, willSaveEvent => cv.asWillSaveTextDocumentParams(willSaveEvent), (selectors, willSaveEvent) => DocumentNotifiactions.textDocumentFilter(selectors, willSaveEvent.document));\n    }\n    get messages() {\n        return vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type;\n    }\n    fillClientCapabilities(capabilities) {\n        let value = ensure(ensure(capabilities, 'textDocument'), 'synchronization');\n        value.willSave = true;\n    }\n    initialize(capabilities, documentSelector) {\n        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;\n        if (documentSelector &&\n            textDocumentSyncOptions &&\n            textDocumentSyncOptions.willSave) {\n            this.register(this.messages, {\n                id: UUID.generateUuid(),\n                registerOptions: { documentSelector: documentSelector }\n            });\n        }\n    }\n}\nclass WillSaveWaitUntilFeature {\n    constructor(_client) {\n        this._client = _client;\n        this._selectors = new Map();\n    }\n    get messages() {\n        return vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type;\n    }\n    fillClientCapabilities(capabilities) {\n        let value = ensure(ensure(capabilities, 'textDocument'), 'synchronization');\n        value.willSaveWaitUntil = true;\n    }\n    initialize(capabilities, documentSelector) {\n        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;\n        if (documentSelector &&\n            textDocumentSyncOptions &&\n            textDocumentSyncOptions.willSaveWaitUntil) {\n            this.register(this.messages, {\n                id: UUID.generateUuid(),\n                registerOptions: { documentSelector: documentSelector }\n            });\n        }\n    }\n    register(_message, data) {\n        if (!data.registerOptions.documentSelector) {\n            return;\n        }\n        if (!this._listener) {\n            this._listener = workspace_1.default.onWillSaveTextDocument(this.callback, this);\n        }\n        this._selectors.set(data.id, data.registerOptions.documentSelector);\n    }\n    callback(event) {\n        if (DocumentNotifiactions.textDocumentFilter(this._selectors.values(), event.document)) {\n            let middleware = this._client.clientOptions.middleware;\n            let willSaveWaitUntil = (event) => {\n                return this._client\n                    .sendRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, cv.asWillSaveTextDocumentParams(event))\n                    .then(edits => {\n                    return edits ? edits : [];\n                }, e => {\n                    window_1.default.showMessage(`Error on willSaveWaitUntil: ${e}`, 'error');\n                    logger.error(e);\n                    return [];\n                });\n            };\n            event.waitUntil(middleware.willSaveWaitUntil\n                ? middleware.willSaveWaitUntil(event, willSaveWaitUntil)\n                : willSaveWaitUntil(event));\n        }\n    }\n    unregister(id) {\n        this._selectors.delete(id);\n        if (this._selectors.size === 0 && this._listener) {\n            this._listener.dispose();\n            this._listener = undefined;\n        }\n    }\n    dispose() {\n        this._selectors.clear();\n        if (this._listener) {\n            this._listener.dispose();\n            this._listener = undefined;\n        }\n    }\n}\nclass DidSaveTextDocumentFeature extends DocumentNotifiactions {\n    constructor(client) {\n        super(client, workspace_1.default.onDidSaveTextDocument, vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, client.clientOptions.middleware.didSave, textDocument => cv.asSaveTextDocumentParams(textDocument, this._includeText), DocumentNotifiactions.textDocumentFilter);\n    }\n    get messages() {\n        return vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type;\n    }\n    fillClientCapabilities(capabilities) {\n        ensure(ensure(capabilities, 'textDocument'), 'synchronization').didSave = true;\n    }\n    initialize(capabilities, documentSelector) {\n        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;\n        if (documentSelector &&\n            textDocumentSyncOptions &&\n            textDocumentSyncOptions.save) {\n            this.register(this.messages, {\n                id: UUID.generateUuid(),\n                registerOptions: Object.assign({}, { documentSelector: documentSelector }, { includeText: !!textDocumentSyncOptions.save.includeText })\n            });\n        }\n    }\n    register(method, data) {\n        this._includeText = !!data.registerOptions.includeText;\n        super.register(method, data);\n    }\n}\nclass FileSystemWatcherFeature {\n    constructor(_client, _notifyFileEvent) {\n        this._notifyFileEvent = _notifyFileEvent;\n        this._watchers = new Map();\n    }\n    get messages() {\n        return vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type;\n    }\n    fillClientCapabilities(capabilities) {\n        ensure(ensure(capabilities, 'workspace'), 'didChangeWatchedFiles').dynamicRegistration = true;\n    }\n    initialize(_capabilities, _documentSelector) { }\n    register(_method, data) {\n        if (!Array.isArray(data.registerOptions.watchers)) {\n            return;\n        }\n        let disposables = [];\n        for (let watcher of data.registerOptions.watchers) {\n            if (!Is.string(watcher.globPattern)) {\n                continue;\n            }\n            let watchCreate = true, watchChange = true, watchDelete = true;\n            if (watcher.kind != null) {\n                watchCreate = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Create) !== 0;\n                watchChange = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Change) != 0;\n                watchDelete = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Delete) != 0;\n            }\n            let fileSystemWatcher = workspace_1.default.createFileSystemWatcher(watcher.globPattern, !watchCreate, !watchChange, !watchDelete);\n            this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, disposables);\n            disposables.push(fileSystemWatcher);\n        }\n        this._watchers.set(data.id, disposables);\n    }\n    registerRaw(id, fileSystemWatchers) {\n        let disposables = [];\n        for (let fileSystemWatcher of fileSystemWatchers) {\n            disposables.push(fileSystemWatcher);\n            this.hookListeners(fileSystemWatcher, true, true, true, disposables);\n        }\n        this._watchers.set(id, disposables);\n    }\n    hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {\n        if (watchCreate) {\n            fileSystemWatcher.onDidCreate(resource => this._notifyFileEvent({\n                uri: cv.asUri(resource),\n                type: vscode_languageserver_protocol_1.FileChangeType.Created\n            }), null, listeners);\n        }\n        if (watchChange) {\n            fileSystemWatcher.onDidChange(resource => this._notifyFileEvent({\n                uri: cv.asUri(resource),\n                type: vscode_languageserver_protocol_1.FileChangeType.Changed\n            }), null, listeners);\n        }\n        if (watchDelete) {\n            fileSystemWatcher.onDidDelete(resource => this._notifyFileEvent({\n                uri: cv.asUri(resource),\n                type: vscode_languageserver_protocol_1.FileChangeType.Deleted\n            }), null, listeners);\n        }\n    }\n    unregister(id) {\n        let disposables = this._watchers.get(id);\n        if (disposables) {\n            for (let disposable of disposables) {\n                disposable.dispose();\n            }\n        }\n    }\n    dispose() {\n        this._watchers.forEach(disposables => {\n            for (let disposable of disposables) {\n                disposable.dispose();\n            }\n        });\n        this._watchers.clear();\n    }\n}\nclass TextDocumentFeature {\n    constructor(_client, _message) {\n        this._client = _client;\n        this._message = _message;\n        this._registrations = new Map();\n    }\n    get messages() {\n        return this._message;\n    }\n    register(message, data) {\n        if (message.method !== this.messages.method) {\n            throw new Error(`Register called on wrong feature. Requested ${message.method} but reached feature ${this.messages.method}`);\n        }\n        if (!data.registerOptions.documentSelector) {\n            return;\n        }\n        let registration = this.registerLanguageProvider(data.registerOptions);\n        this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });\n    }\n    unregister(id) {\n        let registration = this._registrations.get(id);\n        if (registration) {\n            registration.disposable.dispose();\n        }\n    }\n    dispose() {\n        this._registrations.forEach(value => {\n            value.disposable.dispose();\n        });\n        this._registrations.clear();\n    }\n    getRegistration(documentSelector, capability) {\n        if (!capability) {\n            return [undefined, undefined];\n        }\n        else if (vscode_languageserver_protocol_1.TextDocumentRegistrationOptions.is(capability)) {\n            const id = vscode_languageserver_protocol_1.StaticRegistrationOptions.hasId(capability) ? capability.id : UUID.generateUuid();\n            const selector = capability.documentSelector || documentSelector;\n            if (selector) {\n                return [id, Object.assign({}, capability, { documentSelector: selector })];\n            }\n        }\n        else if (Is.boolean(capability) && capability === true || vscode_languageserver_protocol_1.WorkDoneProgressOptions.is(capability)) {\n            if (!documentSelector) {\n                return [undefined, undefined];\n            }\n            let options = (Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector }));\n            return [UUID.generateUuid(), options];\n        }\n        return [undefined, undefined];\n    }\n    getRegistrationOptions(documentSelector, capability) {\n        if (!documentSelector || !capability) {\n            return undefined;\n        }\n        return (Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector }));\n    }\n    getProvider(textDocument) {\n        for (const registration of this._registrations.values()) {\n            let selector = registration.data.registerOptions.documentSelector;\n            if (selector !== null && workspace_1.default.match(selector, textDocument) > 0) {\n                return registration.provider;\n            }\n        }\n        throw new Error(`The feature has no registration for the provided text document ${textDocument.uri.toString()}`);\n    }\n}\nexports.TextDocumentFeature = TextDocumentFeature;\nclass WorkspaceFeature {\n    constructor(_client, _message) {\n        this._client = _client;\n        this._message = _message;\n        this._registrations = new Map();\n    }\n    get messages() {\n        return this._message;\n    }\n    register(message, data) {\n        if (message.method !== this.messages.method) {\n            throw new Error(`Register called on wrong feature. Requested ${message.method} but reached feature ${this.messages.method}`);\n        }\n        const registration = this.registerLanguageProvider(data.registerOptions);\n        this._registrations.set(data.id, registration);\n    }\n    unregister(id) {\n        const registration = this._registrations.get(id);\n        if (registration)\n            registration.dispose();\n    }\n    dispose() {\n        this._registrations.forEach(value => {\n            value.dispose();\n        });\n        this._registrations.clear();\n    }\n}\nclass CompletionItemFeature extends TextDocumentFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.CompletionRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        let snippetSupport = this._client.clientOptions.disableSnippetCompletion !== true;\n        let completion = ensure(ensure(capabilites, 'textDocument'), 'completion');\n        completion.dynamicRegistration = true;\n        completion.contextSupport = true;\n        completion.completionItem = {\n            snippetSupport,\n            commitCharactersSupport: true,\n            documentationFormat: this._client.supporedMarkupKind,\n            deprecatedSupport: true,\n            preselectSupport: true,\n            tagSupport: { valueSet: [vscode_languageserver_protocol_1.CompletionItemTag.Deprecated] },\n        };\n        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };\n    }\n    initialize(capabilities, documentSelector) {\n        this.index = 0;\n        const options = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);\n        if (!options) {\n            return;\n        }\n        this.register(this.messages, {\n            id: UUID.generateUuid(),\n            registerOptions: options\n        });\n    }\n    registerLanguageProvider(options) {\n        let triggerCharacters = options.triggerCharacters || [];\n        let allCommitCharacters = options.allCommitCharacters || [];\n        let priority = options.priority;\n        this.index = this.index + 1;\n        const provider = {\n            provideCompletionItems: (document, position, token, context) => {\n                const client = this._client;\n                const middleware = this._client.clientOptions.middleware;\n                const provideCompletionItems = (document, position, context, token) => {\n                    return client.sendRequest(vscode_languageserver_protocol_1.CompletionRequest.type, cv.asCompletionParams(document, position, context), token).then(result => result, error => {\n                        client.logFailedRequest(vscode_languageserver_protocol_1.CompletionRequest.type, error);\n                        return Promise.resolve([]);\n                    });\n                };\n                return middleware.provideCompletionItem\n                    ? middleware.provideCompletionItem(document, position, context, token, provideCompletionItems)\n                    : provideCompletionItems(document, position, context, token);\n            },\n            resolveCompletionItem: options.resolveProvider\n                ? (item, token) => {\n                    const client = this._client;\n                    const middleware = this._client.clientOptions.middleware;\n                    const resolveCompletionItem = (item, token) => {\n                        return client.sendRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, item, token).then(res => res, error => {\n                            client.logFailedRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, error);\n                            return Promise.resolve(item);\n                        });\n                    };\n                    return middleware.resolveCompletionItem\n                        ? middleware.resolveCompletionItem(item, token, resolveCompletionItem)\n                        : resolveCompletionItem(item, token);\n                }\n                : undefined\n        };\n        const languageIds = cv.asLanguageIds(options.documentSelector);\n        const disposable = languages_1.default.registerCompletionItemProvider(this._client.id + '-' + this.index, 'LS', languageIds, provider, triggerCharacters, priority, allCommitCharacters);\n        return [disposable, provider];\n    }\n}\nclass HoverFeature extends TextDocumentFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.HoverRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        const hoverCapability = ensure(ensure(capabilites, 'textDocument'), 'hover');\n        hoverCapability.dynamicRegistration = true;\n        hoverCapability.contentFormat = this._client.supporedMarkupKind;\n    }\n    initialize(capabilities, documentSelector) {\n        const options = this.getRegistrationOptions(documentSelector, capabilities.hoverProvider);\n        if (!options) {\n            return;\n        }\n        this.register(this.messages, {\n            id: UUID.generateUuid(),\n            registerOptions: options\n        });\n    }\n    registerLanguageProvider(options) {\n        const provider = {\n            provideHover: (document, position, token) => {\n                const client = this._client;\n                const provideHover = (document, position, token) => {\n                    return client.sendRequest(vscode_languageserver_protocol_1.HoverRequest.type, cv.asTextDocumentPositionParams(document, position), token).then(res => res, error => {\n                        client.logFailedRequest(vscode_languageserver_protocol_1.HoverRequest.type, error);\n                        return Promise.resolve(null);\n                    });\n                };\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideHover\n                    ? middleware.provideHover(document, position, token, provideHover)\n                    : provideHover(document, position, token);\n            }\n        };\n        return [languages_1.default.registerHoverProvider(options.documentSelector, provider), provider];\n    }\n}\nclass SignatureHelpFeature extends TextDocumentFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.SignatureHelpRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        let config = ensure(ensure(capabilites, 'textDocument'), 'signatureHelp');\n        config.dynamicRegistration = true;\n        config.contextSupport = true;\n        config.signatureInformation = {\n            documentationFormat: this._client.supporedMarkupKind,\n            activeParameterSupport: true,\n            parameterInformation: {\n                labelOffsetSupport: true\n            }\n        };\n    }\n    initialize(capabilities, documentSelector) {\n        const options = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);\n        if (!options) {\n            return;\n        }\n        this.register(this.messages, {\n            id: UUID.generateUuid(),\n            registerOptions: options\n        });\n    }\n    registerLanguageProvider(options) {\n        const provider = {\n            provideSignatureHelp: (document, position, token, context) => {\n                const client = this._client;\n                const providerSignatureHelp = (document, position, context, token) => {\n                    return client.sendRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, cv.asSignatureHelpParams(document, position, context), token).then(res => res, error => {\n                        client.logFailedRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, error);\n                        return Promise.resolve(null);\n                    });\n                };\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideSignatureHelp\n                    ? middleware.provideSignatureHelp(document, position, context, token, providerSignatureHelp)\n                    : providerSignatureHelp(document, position, context, token);\n            }\n        };\n        const triggerCharacters = options.triggerCharacters || [];\n        const disposable = languages_1.default.registerSignatureHelpProvider(options.documentSelector, provider, triggerCharacters);\n        return [disposable, provider];\n    }\n}\nclass DefinitionFeature extends TextDocumentFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.DefinitionRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        let definitionSupport = ensure(ensure(capabilites, 'textDocument'), 'definition');\n        definitionSupport.dynamicRegistration = true;\n        // definitionSupport.linkSupport = true\n    }\n    initialize(capabilities, documentSelector) {\n        const options = this.getRegistrationOptions(documentSelector, capabilities.definitionProvider);\n        if (!options) {\n            return;\n        }\n        this.register(this.messages, {\n            id: UUID.generateUuid(),\n            registerOptions: options\n        });\n    }\n    registerLanguageProvider(options) {\n        const provider = {\n            provideDefinition: (document, position, token) => {\n                const client = this._client;\n                const provideDefinition = (document, position, token) => {\n                    return client.sendRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, cv.asTextDocumentPositionParams(document, position), token).then(res => res, error => {\n                        client.logFailedRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, error);\n                        return Promise.resolve(null);\n                    });\n                };\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideDefinition\n                    ? middleware.provideDefinition(document, position, token, provideDefinition)\n                    : provideDefinition(document, position, token);\n            }\n        };\n        return [languages_1.default.registerDefinitionProvider(options.documentSelector, provider), provider];\n    }\n}\nclass ReferencesFeature extends TextDocumentFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.ReferencesRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        ensure(ensure(capabilites, 'textDocument'), 'references').dynamicRegistration = true;\n    }\n    initialize(capabilities, documentSelector) {\n        const options = this.getRegistrationOptions(documentSelector, capabilities.referencesProvider);\n        if (!options) {\n            return;\n        }\n        this.register(this.messages, {\n            id: UUID.generateUuid(),\n            registerOptions: options\n        });\n    }\n    registerLanguageProvider(options) {\n        const provider = {\n            provideReferences: (document, position, options, token) => {\n                const client = this._client;\n                const _providerReferences = (document, position, options, token) => {\n                    return client.sendRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, cv.asReferenceParams(document, position, options), token).then(res => res, error => {\n                        client.logFailedRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, error);\n                        return Promise.resolve([]);\n                    });\n                };\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideReferences\n                    ? middleware.provideReferences(document, position, options, token, _providerReferences)\n                    : _providerReferences(document, position, options, token);\n            }\n        };\n        return [languages_1.default.registerReferencesProvider(options.documentSelector, provider), provider];\n    }\n}\nclass DocumentHighlightFeature extends TextDocumentFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.DocumentHighlightRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        ensure(ensure(capabilites, 'textDocument'), 'documentHighlight').dynamicRegistration = true;\n    }\n    initialize(capabilities, documentSelector) {\n        const options = this.getRegistrationOptions(documentSelector, capabilities.documentHighlightProvider);\n        if (!options) {\n            return;\n        }\n        this.register(this.messages, {\n            id: UUID.generateUuid(),\n            registerOptions: options\n        });\n    }\n    registerLanguageProvider(options) {\n        const provider = {\n            provideDocumentHighlights: (document, position, token) => {\n                const client = this._client;\n                const _provideDocumentHighlights = (document, position, token) => {\n                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, cv.asTextDocumentPositionParams(document, position), token).then(res => res, error => {\n                        client.logFailedRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, error);\n                        return Promise.resolve([]);\n                    });\n                };\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideDocumentHighlights\n                    ? middleware.provideDocumentHighlights(document, position, token, _provideDocumentHighlights)\n                    : _provideDocumentHighlights(document, position, token);\n            }\n        };\n        return [languages_1.default.registerDocumentHighlightProvider(options.documentSelector, provider), provider];\n    }\n}\nclass DocumentSymbolFeature extends TextDocumentFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.DocumentSymbolRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        let symbolCapabilities = ensure(ensure(capabilites, 'textDocument'), 'documentSymbol');\n        symbolCapabilities.dynamicRegistration = true;\n        symbolCapabilities.symbolKind = {\n            valueSet: SupportedSymbolKinds\n        };\n        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;\n        symbolCapabilities.tagSupport = {\n            valueSet: SupportedSymbolTags\n        };\n    }\n    initialize(capabilities, documentSelector) {\n        const options = this.getRegistrationOptions(documentSelector, capabilities.documentSymbolProvider);\n        if (!options) {\n            return;\n        }\n        this.register(this.messages, {\n            id: UUID.generateUuid(),\n            registerOptions: options\n        });\n    }\n    registerLanguageProvider(options) {\n        const provider = {\n            provideDocumentSymbols: (document, token) => {\n                const client = this._client;\n                const _provideDocumentSymbols = (document, token) => {\n                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, cv.asDocumentSymbolParams(document), token).then((data) => {\n                        if (data === null) {\n                            return undefined;\n                        }\n                        if (data.length === 0) {\n                            return [];\n                        }\n                        else {\n                            let element = data[0];\n                            if (vscode_languageserver_protocol_1.DocumentSymbol.is(element)) {\n                                return data;\n                            }\n                            else {\n                                return data;\n                            }\n                        }\n                    }, (error) => {\n                        client.logFailedRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, error);\n                        return Promise.resolve([]);\n                    });\n                };\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideDocumentSymbols\n                    ? middleware.provideDocumentSymbols(document, token, _provideDocumentSymbols)\n                    : _provideDocumentSymbols(document, token);\n            }\n        };\n        return [languages_1.default.registerDocumentSymbolProvider(options.documentSelector, provider), provider];\n    }\n}\nclass WorkspaceSymbolFeature extends WorkspaceFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        let symbolCapabilities = ensure(ensure(capabilites, 'workspace'), 'symbol');\n        symbolCapabilities.dynamicRegistration = true;\n        symbolCapabilities.symbolKind = {\n            valueSet: SupportedSymbolKinds\n        };\n        symbolCapabilities.tagSupport = {\n            valueSet: SupportedSymbolTags\n        };\n    }\n    initialize(capabilities) {\n        if (!capabilities.workspaceSymbolProvider) {\n            return;\n        }\n        this.register(this.messages, {\n            id: UUID.generateUuid(),\n            registerOptions: capabilities.workspaceSymbolProvider === true ? { workDoneProgress: false } : capabilities.workspaceSymbolProvider\n        });\n    }\n    registerLanguageProvider(_options) {\n        const provider = {\n            provideWorkspaceSymbols: (query, token) => {\n                const client = this._client;\n                const provideWorkspaceSymbols = (query, token) => {\n                    return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, { query }, token).then(res => res, error => {\n                        client.logFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, error);\n                        return Promise.resolve([]);\n                    });\n                };\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideWorkspaceSymbols\n                    ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols)\n                    : provideWorkspaceSymbols(query, token);\n            }\n        };\n        return languages_1.default.registerWorkspaceSymbolProvider(provider);\n    }\n}\nclass CodeActionFeature extends TextDocumentFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.CodeActionRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        const cap = ensure(ensure(capabilites, 'textDocument'), 'codeAction');\n        cap.dynamicRegistration = true;\n        cap.isPreferredSupport = true;\n        cap.codeActionLiteralSupport = {\n            codeActionKind: {\n                valueSet: [\n                    vscode_languageserver_protocol_1.CodeActionKind.Empty,\n                    vscode_languageserver_protocol_1.CodeActionKind.QuickFix,\n                    vscode_languageserver_protocol_1.CodeActionKind.Refactor,\n                    vscode_languageserver_protocol_1.CodeActionKind.RefactorExtract,\n                    vscode_languageserver_protocol_1.CodeActionKind.RefactorInline,\n                    vscode_languageserver_protocol_1.CodeActionKind.RefactorRewrite,\n                    vscode_languageserver_protocol_1.CodeActionKind.Source,\n                    vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports\n                ]\n            }\n        };\n    }\n    initialize(capabilities, documentSelector) {\n        const options = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);\n        if (!options) {\n            return;\n        }\n        this.register(this.messages, {\n            id: UUID.generateUuid(),\n            registerOptions: options\n        });\n    }\n    registerLanguageProvider(options) {\n        const provider = {\n            provideCodeActions: (document, range, context, token) => {\n                const client = this._client;\n                const _provideCodeActions = (document, range, context, token) => {\n                    const params = {\n                        textDocument: {\n                            uri: document.uri\n                        },\n                        range,\n                        context,\n                    };\n                    return client.sendRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, params, token).then((values) => {\n                        if (values === null) {\n                            return undefined;\n                        }\n                        return values;\n                    }, (error) => {\n                        client.logFailedRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, error);\n                        return Promise.resolve([]);\n                    });\n                };\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideCodeActions\n                    ? middleware.provideCodeActions(document, range, context, token, _provideCodeActions)\n                    : _provideCodeActions(document, range, context, token);\n            }\n        };\n        return [languages_1.default.registerCodeActionProvider(options.documentSelector, provider, this._client.id, options.codeActionKinds), provider];\n    }\n}\nclass CodeLensFeature extends TextDocumentFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.CodeLensRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        ensure(ensure(capabilites, 'textDocument'), 'codeLens').dynamicRegistration = true;\n    }\n    initialize(capabilities, documentSelector) {\n        const options = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);\n        if (!options) {\n            return;\n        }\n        this.register(this.messages, {\n            id: UUID.generateUuid(),\n            registerOptions: options\n        });\n    }\n    registerLanguageProvider(options) {\n        const provider = {\n            provideCodeLenses: (document, token) => {\n                const client = this._client;\n                const provideCodeLenses = (document, token) => {\n                    return client.sendRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, cv.asCodeLensParams(document), token).then(res => res, error => {\n                        client.logFailedRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, error);\n                        return Promise.resolve([]);\n                    });\n                };\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideCodeLenses\n                    ? middleware.provideCodeLenses(document, token, provideCodeLenses)\n                    : provideCodeLenses(document, token);\n            },\n            resolveCodeLens: (options.resolveProvider)\n                ? (codeLens, token) => {\n                    const client = this._client;\n                    const resolveCodeLens = (codeLens, token) => {\n                        return client.sendRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, codeLens, token).then(res => res, error => {\n                            client.logFailedRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, error);\n                            return codeLens;\n                        });\n                    };\n                    const middleware = client.clientOptions.middleware;\n                    return middleware.resolveCodeLens\n                        ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens)\n                        : resolveCodeLens(codeLens, token);\n                }\n                : undefined\n        };\n        return [languages_1.default.registerCodeLensProvider(options.documentSelector, provider), provider];\n    }\n}\nclass DocumentFormattingFeature extends TextDocumentFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.DocumentFormattingRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        ensure(ensure(capabilites, 'textDocument'), 'formatting').dynamicRegistration = true;\n    }\n    initialize(capabilities, documentSelector) {\n        const options = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);\n        if (!options) {\n            return;\n        }\n        this.register(this.messages, {\n            id: UUID.generateUuid(),\n            registerOptions: options\n        });\n    }\n    registerLanguageProvider(options) {\n        const provider = {\n            provideDocumentFormattingEdits: (document, options, token) => {\n                const client = this._client;\n                const provideDocumentFormattingEdits = (document, options, token) => {\n                    const params = {\n                        textDocument: { uri: document.uri },\n                        options\n                    };\n                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, params, token).then(res => res, (error) => {\n                        client.logFailedRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, error);\n                        return Promise.resolve([]);\n                    });\n                };\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideDocumentFormattingEdits\n                    ? middleware.provideDocumentFormattingEdits(document, options, token, provideDocumentFormattingEdits)\n                    : provideDocumentFormattingEdits(document, options, token);\n            }\n        };\n        return [\n            languages_1.default.registerDocumentFormatProvider(options.documentSelector, provider, this._client.clientOptions.formatterPriority),\n            provider\n        ];\n    }\n}\nclass DocumentRangeFormattingFeature extends TextDocumentFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        ensure(ensure(capabilites, 'textDocument'), 'rangeFormatting').dynamicRegistration = true;\n    }\n    initialize(capabilities, documentSelector) {\n        const options = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);\n        if (!options) {\n            return;\n        }\n        this.register(this.messages, {\n            id: UUID.generateUuid(),\n            registerOptions: options\n        });\n    }\n    registerLanguageProvider(options) {\n        const provider = {\n            provideDocumentRangeFormattingEdits: (document, range, options, token) => {\n                const client = this._client;\n                const provideDocumentRangeFormattingEdits = (document, range, options, token) => {\n                    const params = {\n                        textDocument: { uri: document.uri },\n                        range,\n                        options,\n                    };\n                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, params, token).then(res => res, error => {\n                        client.logFailedRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, error);\n                        return Promise.resolve([]);\n                    });\n                };\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideDocumentRangeFormattingEdits\n                    ? middleware.provideDocumentRangeFormattingEdits(document, range, options, token, provideDocumentRangeFormattingEdits)\n                    : provideDocumentRangeFormattingEdits(document, range, options, token);\n            }\n        };\n        return [languages_1.default.registerDocumentRangeFormatProvider(options.documentSelector, provider), provider];\n    }\n}\nclass DocumentOnTypeFormattingFeature extends TextDocumentFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        ensure(ensure(capabilites, 'textDocument'), 'onTypeFormatting').dynamicRegistration = true;\n    }\n    initialize(capabilities, documentSelector) {\n        const options = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);\n        if (!options) {\n            return;\n        }\n        this.register(this.messages, {\n            id: UUID.generateUuid(),\n            registerOptions: options\n        });\n    }\n    registerLanguageProvider(options) {\n        const provider = {\n            provideOnTypeFormattingEdits: (document, position, ch, options, token) => {\n                const client = this._client;\n                const provideOnTypeFormattingEdits = (document, position, ch, options, token) => {\n                    const params = {\n                        textDocument: cv.asVersionedTextDocumentIdentifier(document),\n                        position,\n                        ch,\n                        options\n                    };\n                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, params, token).then(res => res, (error) => {\n                        client.logFailedRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, error);\n                        return Promise.resolve([]);\n                    });\n                };\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideOnTypeFormattingEdits\n                    ? middleware.provideOnTypeFormattingEdits(document, position, ch, options, token, provideOnTypeFormattingEdits)\n                    : provideOnTypeFormattingEdits(document, position, ch, options, token);\n            }\n        };\n        const moreTriggerCharacter = options.moreTriggerCharacter || [];\n        const characters = [options.firstTriggerCharacter, ...moreTriggerCharacter];\n        return [languages_1.default.registerOnTypeFormattingEditProvider(options.documentSelector, provider, characters), provider];\n    }\n}\nclass RenameFeature extends TextDocumentFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.RenameRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        let rename = ensure(ensure(capabilites, 'textDocument'), 'rename');\n        rename.dynamicRegistration = true;\n        rename.prepareSupport = true;\n    }\n    initialize(capabilities, documentSelector) {\n        const options = this.getRegistrationOptions(documentSelector, capabilities.renameProvider);\n        if (!options) {\n            return;\n        }\n        if (Is.boolean(capabilities.renameProvider)) {\n            options.prepareProvider = false;\n        }\n        this.register(this.messages, {\n            id: UUID.generateUuid(),\n            registerOptions: options\n        });\n    }\n    registerLanguageProvider(options) {\n        const provider = {\n            provideRenameEdits: (document, position, newName, token) => {\n                const client = this._client;\n                const provideRenameEdits = (document, position, newName, token) => {\n                    const params = {\n                        textDocument: { uri: document.uri },\n                        position,\n                        newName: newName\n                    };\n                    return client.sendRequest(vscode_languageserver_protocol_1.RenameRequest.type, params, token).then(res => res, (error) => {\n                        client.logFailedRequest(vscode_languageserver_protocol_1.RenameRequest.type, error);\n                        return Promise.reject(new Error(error.message));\n                    });\n                };\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideRenameEdits\n                    ? middleware.provideRenameEdits(document, position, newName, token, provideRenameEdits)\n                    : provideRenameEdits(document, position, newName, token);\n            },\n            prepareRename: options.prepareProvider\n                ? (document, position, token) => {\n                    const client = this._client;\n                    const prepareRename = (document, position, token) => {\n                        const params = {\n                            textDocument: cv.asTextDocumentIdentifier(document),\n                            position\n                        };\n                        return client.sendRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, params, token).then((result) => {\n                            if (vscode_languageserver_protocol_1.Range.is(result)) {\n                                return result;\n                            }\n                            else if (result && vscode_languageserver_protocol_1.Range.is(result.range)) {\n                                return {\n                                    range: result.range,\n                                    placeholder: result.placeholder\n                                };\n                            }\n                            // To cancel the rename vscode API expects a rejected promise.\n                            return Promise.reject(new Error(`The element can't be renamed.`));\n                        }, (error) => {\n                            client.logFailedRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, error);\n                            return Promise.reject(new Error(error.message));\n                        });\n                    };\n                    const middleware = client.clientOptions.middleware;\n                    return middleware.prepareRename\n                        ? middleware.prepareRename(document, position, token, prepareRename)\n                        : prepareRename(document, position, token);\n                }\n                : undefined\n        };\n        return [languages_1.default.registerRenameProvider(options.documentSelector, provider), provider];\n    }\n}\nclass DocumentLinkFeature extends TextDocumentFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.DocumentLinkRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        const documentLinkCapabilities = ensure(ensure(capabilites, 'textDocument'), 'documentLink');\n        documentLinkCapabilities.dynamicRegistration = true;\n        // TODO support tooltip\n        documentLinkCapabilities.tooltipSupport = true;\n    }\n    initialize(capabilities, documentSelector) {\n        const options = this.getRegistrationOptions(documentSelector, capabilities.documentLinkProvider);\n        if (!options) {\n            return;\n        }\n        this.register(this.messages, {\n            id: UUID.generateUuid(),\n            registerOptions: options\n        });\n    }\n    registerLanguageProvider(options) {\n        const provider = {\n            provideDocumentLinks: (document, token) => {\n                const client = this._client;\n                const provideDocumentLinks = (document, token) => {\n                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, {\n                        textDocument: { uri: document.uri }\n                    }, token).then(res => res, (error) => {\n                        client.logFailedRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, error);\n                        return Promise.resolve([]);\n                    });\n                };\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideDocumentLinks\n                    ? middleware.provideDocumentLinks(document, token, provideDocumentLinks)\n                    : provideDocumentLinks(document, token);\n            },\n            resolveDocumentLink: options.resolveProvider\n                ? (link, token) => {\n                    const client = this._client;\n                    let resolveDocumentLink = (link, token) => {\n                        return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, link, token).then(res => res, (error) => {\n                            client.logFailedRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, error);\n                            return Promise.resolve(link);\n                        });\n                    };\n                    const middleware = client.clientOptions.middleware;\n                    return middleware.resolveDocumentLink\n                        ? middleware.resolveDocumentLink(link, token, resolveDocumentLink)\n                        : resolveDocumentLink(link, token);\n                }\n                : undefined\n        };\n        return [languages_1.default.registerDocumentLinkProvider(options.documentSelector, provider), provider];\n    }\n}\nclass ConfigurationFeature {\n    constructor(_client) {\n        this._client = _client;\n        this._listeners = new Map();\n    }\n    get messages() {\n        return vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type;\n    }\n    fillClientCapabilities(capabilities) {\n        ensure(ensure(capabilities, 'workspace'), 'didChangeConfiguration').dynamicRegistration = true;\n    }\n    initialize() {\n        var _a;\n        let section = (_a = this._client.clientOptions.synchronize) === null || _a === void 0 ? void 0 : _a.configurationSection;\n        if (section !== void 0) {\n            this.register(this.messages, {\n                id: UUID.generateUuid(),\n                registerOptions: {\n                    section: section\n                }\n            });\n        }\n    }\n    register(_message, data) {\n        let { section } = data.registerOptions;\n        let disposable = workspace_1.default.onDidChangeConfiguration((event) => {\n            if (typeof section == 'string' && !event.affectsConfiguration(section)) {\n                return;\n            }\n            if (Array.isArray(section) && !section.some(v => event.affectsConfiguration(v))) {\n                return;\n            }\n            if (section != null) {\n                this.onDidChangeConfiguration(data.registerOptions.section);\n            }\n        });\n        this._listeners.set(data.id, disposable);\n        if (Is.string(section) && section.endsWith('.settings')) {\n            let settings = this.getConfiguredSettings(section);\n            if (!settings || Is.emptyObject(settings))\n                return;\n        }\n        if (section != null) {\n            // Avoid server bug\n            this.onDidChangeConfiguration(data.registerOptions.section);\n        }\n    }\n    unregister(id) {\n        let disposable = this._listeners.get(id);\n        if (disposable) {\n            this._listeners.delete(id);\n            disposable.dispose();\n        }\n    }\n    dispose() {\n        for (let disposable of this._listeners.values()) {\n            disposable.dispose();\n        }\n        this._listeners.clear();\n    }\n    onDidChangeConfiguration(configurationSection) {\n        let isConfigured = typeof configurationSection === 'string' && configurationSection.startsWith('languageserver.');\n        let sections;\n        if (Is.string(configurationSection)) {\n            sections = [configurationSection];\n        }\n        else {\n            sections = configurationSection;\n        }\n        let didChangeConfiguration = (sections) => {\n            if (sections === undefined) {\n                this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: null });\n                return;\n            }\n            this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, {\n                settings: isConfigured ? this.getConfiguredSettings(sections[0]) : this.extractSettingsInformation(sections)\n            });\n        };\n        let middleware = this.getMiddleware();\n        middleware\n            ? middleware(sections, didChangeConfiguration)\n            : didChangeConfiguration(sections);\n    }\n    // for configured languageserver\n    getConfiguredSettings(key) {\n        let len = '.settings'.length;\n        let config = workspace_1.default.getConfiguration(key.slice(0, -len));\n        return config.get('settings', {});\n    }\n    extractSettingsInformation(keys) {\n        function ensurePath(config, path) {\n            let current = config;\n            for (let i = 0; i < path.length - 1; i++) {\n                let obj = current[path[i]];\n                if (!obj) {\n                    obj = Object.create(null);\n                    current[path[i]] = obj;\n                }\n                current = obj;\n            }\n            return current;\n        }\n        let result = Object.create(null);\n        for (let i = 0; i < keys.length; i++) {\n            let key = keys[i];\n            let index = key.indexOf('.');\n            let config = null;\n            if (index >= 0) {\n                config = workspace_1.default.getConfiguration(key.substr(0, index)).get(key.substr(index + 1));\n            }\n            else {\n                config = workspace_1.default.getConfiguration(key);\n            }\n            if (config) {\n                let path = keys[i].split('.');\n                ensurePath(result, path)[path[path.length - 1]] = config;\n            }\n        }\n        return result;\n    }\n    getMiddleware() {\n        let middleware = this._client.clientOptions.middleware;\n        if (middleware.workspace && middleware.workspace.didChangeConfiguration) {\n            return middleware.workspace.didChangeConfiguration;\n        }\n        else {\n            return undefined;\n        }\n    }\n}\nclass ExecuteCommandFeature {\n    constructor(_client) {\n        this._client = _client;\n        this._commands = new Map();\n    }\n    get messages() {\n        return vscode_languageserver_protocol_1.ExecuteCommandRequest.type;\n    }\n    fillClientCapabilities(capabilities) {\n        ensure(ensure(capabilities, 'workspace'), 'executeCommand').dynamicRegistration = true;\n    }\n    initialize(capabilities) {\n        if (!capabilities.executeCommandProvider) {\n            return;\n        }\n        this.register(this.messages, {\n            id: UUID.generateUuid(),\n            registerOptions: Object.assign({}, capabilities.executeCommandProvider)\n        });\n    }\n    register(_message, data) {\n        const client = this._client;\n        const middleware = client.clientOptions.middleware;\n        const executeCommand = (command, args) => {\n            const params = {\n                command,\n                arguments: args\n            };\n            return client.sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params).then(undefined, (error) => {\n                client.logFailedRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, error);\n            });\n        };\n        if (data.registerOptions.commands) {\n            let disposables = [];\n            for (const command of data.registerOptions.commands) {\n                disposables.push(commands_1.default.registerCommand(command, (...args) => {\n                    return middleware.executeCommand\n                        ? middleware.executeCommand(command, args, executeCommand)\n                        : executeCommand(command, args);\n                }, null, true));\n            }\n            this._commands.set(data.id, disposables);\n        }\n    }\n    unregister(id) {\n        let disposables = this._commands.get(id);\n        if (disposables) {\n            disposables.forEach(disposable => disposable.dispose());\n        }\n    }\n    dispose() {\n        this._commands.forEach(value => {\n            value.forEach(disposable => disposable.dispose());\n        });\n        this._commands.clear();\n    }\n}\nvar MessageTransports;\n(function (MessageTransports) {\n    function is(value) {\n        let candidate = value;\n        return (candidate &&\n            vscode_languageserver_protocol_1.MessageReader.is(value.reader) &&\n            vscode_languageserver_protocol_1.MessageWriter.is(value.writer));\n    }\n    MessageTransports.is = is;\n})(MessageTransports = exports.MessageTransports || (exports.MessageTransports = {}));\nclass OnReady {\n    constructor(_resolve, _reject) {\n        this._resolve = _resolve;\n        this._reject = _reject;\n        this._used = false;\n    }\n    get isUsed() {\n        return this._used;\n    }\n    resolve() {\n        this._used = true;\n        this._resolve();\n    }\n    reject(error) {\n        this._used = true;\n        this._reject(error);\n    }\n}\nclass BaseLanguageClient {\n    constructor(id, name, clientOptions) {\n        this._features = [];\n        this._method2Message = new Map();\n        this._dynamicFeatures = new Map();\n        this._id = id;\n        this._name = name;\n        if (clientOptions.outputChannel) {\n            this._outputChannel = clientOptions.outputChannel;\n        }\n        else {\n            this._outputChannel = undefined;\n        }\n        this._clientOptions = {\n            disableWorkspaceFolders: clientOptions.disableWorkspaceFolders,\n            disableSnippetCompletion: clientOptions.disableSnippetCompletion,\n            disableDynamicRegister: clientOptions.disableDynamicRegister,\n            disableDiagnostics: clientOptions.disableDiagnostics,\n            disableCompletion: clientOptions.disableCompletion,\n            formatterPriority: clientOptions.formatterPriority,\n            ignoredRootPaths: clientOptions.ignoredRootPaths,\n            documentSelector: clientOptions.documentSelector || [],\n            synchronize: clientOptions.synchronize || {},\n            diagnosticCollectionName: clientOptions.diagnosticCollectionName,\n            outputChannelName: clientOptions.outputChannelName || this._id,\n            revealOutputChannelOn: clientOptions.revealOutputChannelOn || RevealOutputChannelOn.Never,\n            stdioEncoding: clientOptions.stdioEncoding || 'utf8',\n            initializationOptions: clientOptions.initializationOptions,\n            initializationFailedHandler: clientOptions.initializationFailedHandler,\n            progressOnInitialization: !!clientOptions.progressOnInitialization,\n            errorHandler: clientOptions.errorHandler || new DefaultErrorHandler(this._id),\n            middleware: clientOptions.middleware || {},\n            workspaceFolder: clientOptions.workspaceFolder\n        };\n        this.state = ClientState.Initial;\n        this._connectionPromise = undefined;\n        this._resolvedConnection = undefined;\n        this._initializeResult = undefined;\n        this._listeners = undefined;\n        this._providers = undefined;\n        this._diagnostics = undefined;\n        this._fileEvents = [];\n        this._fileEventDelayer = new async_1.Delayer(250);\n        this._onReady = new Promise((resolve, reject) => {\n            this._onReadyCallbacks = new OnReady(resolve, reject);\n        });\n        this._onStop = undefined;\n        this._stateChangeEmitter = new vscode_languageserver_protocol_1.Emitter();\n        this._tracer = {\n            log: (messageOrDataObject, data) => {\n                if (Is.string(messageOrDataObject)) {\n                    this.logTrace(messageOrDataObject, data);\n                }\n                else {\n                    this.logObjectTrace(messageOrDataObject);\n                }\n            }\n        };\n        this._syncedDocuments = new Map();\n        let preferences = workspace_1.default.getConfiguration('coc.preferences');\n        this._markdownSupport = preferences.get('enableMarkdown', true);\n        this.registerBuiltinFeatures();\n    }\n    get supporedMarkupKind() {\n        if (this._markdownSupport)\n            return [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText];\n        return [vscode_languageserver_protocol_1.MarkupKind.PlainText];\n    }\n    get state() {\n        return this._state;\n    }\n    get id() {\n        return this._id;\n    }\n    get name() {\n        return this._name;\n    }\n    set state(value) {\n        let oldState = this.getPublicState();\n        this._state = value;\n        let newState = this.getPublicState();\n        if (newState !== oldState) {\n            this._stateChangeEmitter.fire({ oldState, newState });\n        }\n    }\n    getPublicState() {\n        if (this.state === ClientState.Running) {\n            return State.Running;\n        }\n        else if (this.state === ClientState.Starting) {\n            return State.Starting;\n        }\n        else {\n            return State.Stopped;\n        }\n    }\n    get initializeResult() {\n        return this._initializeResult;\n    }\n    async sendRequest(type, ...params) {\n        if (!this.isConnectionActive()) {\n            throw new Error('Language client is not ready yet');\n        }\n        try {\n            return this._resolvedConnection.sendRequest(type, ...params);\n        }\n        catch (error) {\n            this.error(`Sending request ${Is.string(type) ? type : type.method} failed.`, error);\n            throw error;\n        }\n    }\n    onRequest(type, handler) {\n        if (!this.isConnectionActive()) {\n            throw new Error('Language client is not ready yet');\n        }\n        try {\n            this._resolvedConnection.onRequest(type, handler);\n        }\n        catch (error) {\n            this.error(`Registering request handler ${Is.string(type) ? type : type.method} failed.`, error);\n            throw error;\n        }\n    }\n    sendNotification(type, params) {\n        if (!this.isConnectionActive()) {\n            throw new Error('Language client is not ready yet');\n        }\n        try {\n            this._resolvedConnection.sendNotification(type, params);\n        }\n        catch (error) {\n            this.error(`Sending notification ${Is.string(type) ? type : type.method} failed.`, error);\n            throw error;\n        }\n    }\n    onNotification(type, handler) {\n        if (!this.isConnectionActive()) {\n            throw new Error('Language client is not ready yet');\n        }\n        try {\n            this._resolvedConnection.onNotification(type, handler);\n        }\n        catch (error) {\n            this.error(`Registering notification handler ${Is.string(type) ? type : type.method} failed.`, error);\n            throw error;\n        }\n    }\n    onProgress(type, token, handler) {\n        if (!this.isConnectionActive()) {\n            throw new Error('Language client is not ready yet');\n        }\n        try {\n            if (type == vscode_languageserver_protocol_1.WorkDoneProgress.type) {\n                const handleWorkDoneProgress = this._clientOptions.middleware.handleWorkDoneProgress;\n                if (handleWorkDoneProgress !== undefined) {\n                    return this._resolvedConnection.onProgress(type, token, (params) => {\n                        handleWorkDoneProgress(token, params, () => handler(params));\n                    });\n                }\n            }\n            return this._resolvedConnection.onProgress(type, token, handler);\n        }\n        catch (error) {\n            this.error(`Registering progress handler for token ${token} failed.`, error);\n            throw error;\n        }\n    }\n    sendProgress(type, token, value) {\n        if (!this.isConnectionActive()) {\n            throw new Error('Language client is not ready yet');\n        }\n        try {\n            this._resolvedConnection.sendProgress(type, token, value);\n        }\n        catch (error) {\n            this.error(`Sending progress for token ${token} failed.`, error);\n            throw error;\n        }\n    }\n    get clientOptions() {\n        return this._clientOptions;\n    }\n    get onDidChangeState() {\n        return this._stateChangeEmitter.event;\n    }\n    get outputChannel() {\n        if (!this._outputChannel) {\n            let { outputChannelName } = this._clientOptions;\n            this._outputChannel = window_1.default.createOutputChannel(outputChannelName ? outputChannelName : this._name);\n        }\n        return this._outputChannel;\n    }\n    get diagnostics() {\n        return this._diagnostics;\n    }\n    createDefaultErrorHandler() {\n        return new DefaultErrorHandler(this._id);\n    }\n    set trace(value) {\n        this._trace = value;\n        this.onReady().then(() => {\n            this.resolveConnection().then(connection => {\n                connection.trace(this._trace, this._tracer, {\n                    sendNotification: false,\n                    traceFormat: this._traceFormat\n                });\n            });\n        }, () => { });\n    }\n    logObjectTrace(data) {\n        if (data.isLSPMessage && data.type) {\n            this.outputChannel.append(`[LSP   - ${(new Date().toLocaleTimeString())}] `);\n        }\n        else {\n            this.outputChannel.append(`[Trace - ${(new Date().toLocaleTimeString())}] `);\n        }\n        if (data) {\n            this.outputChannel.appendLine(`${JSON.stringify(data)}`);\n        }\n    }\n    data2String(data) {\n        if (data instanceof vscode_languageserver_protocol_1.ResponseError) {\n            const responseError = data;\n            return `  Message: ${responseError.message}\\n  Code: ${responseError.code} ${responseError.data ? '\\n' + responseError.data.toString() : ''}`;\n        }\n        if (data instanceof Error) {\n            if (Is.string(data.stack)) {\n                return data.stack;\n            }\n            return data.message;\n        }\n        if (Is.string(data)) {\n            return data;\n        }\n        return data.toString();\n    }\n    _appendOutput(type, message, data) {\n        let level = RevealOutputChannelOn.Error;\n        switch (type) {\n            case 'Info':\n                level = RevealOutputChannelOn.Info;\n                break;\n            case 'Warn':\n                level = RevealOutputChannelOn.Warn;\n                break;\n        }\n        this.outputChannel.appendLine(`[${type}  - ${(new Date().toLocaleTimeString())}] ${message}`);\n        let dataString;\n        if (data) {\n            dataString = this.data2String(data);\n            this.outputChannel.appendLine(dataString);\n        }\n        if (this._clientOptions.revealOutputChannelOn <= level) {\n            this.outputChannel.show(true);\n        }\n    }\n    info(message, data) {\n        this._appendOutput('Info', message, data);\n    }\n    warn(message, data) {\n        this._appendOutput('Warn', message, data);\n    }\n    error(message, data) {\n        this._appendOutput('Error', message, data);\n    }\n    logTrace(message, data) {\n        this.outputChannel.appendLine(`[Trace - ${(new Date().toLocaleTimeString())}] ${message}`);\n        if (data) {\n            this.outputChannel.appendLine(this.data2String(data));\n        }\n    }\n    needsStart() {\n        return (this.state === ClientState.Initial ||\n            this.state === ClientState.Stopping ||\n            this.state === ClientState.Stopped);\n    }\n    needsStop() {\n        return (this.state === ClientState.Starting || this.state === ClientState.Running);\n    }\n    onReady() {\n        return this._onReady;\n    }\n    get started() {\n        return this.state != ClientState.Initial;\n    }\n    isConnectionActive() {\n        return this.state === ClientState.Running && !!this._resolvedConnection;\n    }\n    start() {\n        if (this._onReadyCallbacks.isUsed) {\n            this._onReady = new Promise((resolve, reject) => {\n                this._onReadyCallbacks = new OnReady(resolve, reject);\n            });\n        }\n        this._listeners = [];\n        this._providers = [];\n        // If we restart then the diagnostics collection is reused.\n        if (!this._diagnostics) {\n            let opts = this._clientOptions;\n            let name = opts.diagnosticCollectionName ? opts.diagnosticCollectionName : this._id;\n            this._diagnostics = languages_1.default.createDiagnosticCollection(name);\n        }\n        this.state = ClientState.Starting;\n        this.resolveConnection()\n            .then(connection => {\n            connection.onLogMessage(message => {\n                let kind;\n                switch (message.type) {\n                    case vscode_languageserver_protocol_1.MessageType.Error:\n                        kind = 'error';\n                        this.error(message.message);\n                        break;\n                    case vscode_languageserver_protocol_1.MessageType.Warning:\n                        kind = 'warning';\n                        this.warn(message.message);\n                        break;\n                    case vscode_languageserver_protocol_1.MessageType.Info:\n                        kind = 'info';\n                        this.info(message.message);\n                        break;\n                    default:\n                        kind = 'log';\n                        this.outputChannel.appendLine(message.message);\n                }\n                if (global.hasOwnProperty('__TEST__')) {\n                    console.log(`[${kind}] ${message.message}`);\n                    return;\n                }\n            });\n            connection.onShowMessage(message => {\n                switch (message.type) {\n                    case vscode_languageserver_protocol_1.MessageType.Error:\n                        window_1.default.showErrorMessage(message.message);\n                        break;\n                    case vscode_languageserver_protocol_1.MessageType.Warning:\n                        window_1.default.showWarningMessage(message.message);\n                        break;\n                    case vscode_languageserver_protocol_1.MessageType.Info:\n                        window_1.default.showInformationMessage(message.message);\n                        break;\n                    default:\n                        window_1.default.showInformationMessage(message.message);\n                }\n            });\n            connection.onRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params => {\n                let messageFunc;\n                switch (params.type) {\n                    case vscode_languageserver_protocol_1.MessageType.Error:\n                        messageFunc = window_1.default.showErrorMessage.bind(window_1.default);\n                        break;\n                    case vscode_languageserver_protocol_1.MessageType.Warning:\n                        messageFunc = window_1.default.showWarningMessage.bind(window_1.default);\n                        break;\n                    case vscode_languageserver_protocol_1.MessageType.Info:\n                        messageFunc = window_1.default.showInformationMessage.bind(window_1.default);\n                        break;\n                    default:\n                        messageFunc = window_1.default.showInformationMessage.bind(window_1.default);\n                }\n                let actions = params.actions || [];\n                return messageFunc(params.message, ...actions);\n            });\n            connection.onTelemetry(_data => {\n                // ignored\n            });\n            connection.listen();\n            // Error is handled in the intialize call.\n            return this.initialize(connection);\n        }).then(undefined, error => {\n            this.state = ClientState.StartFailed;\n            this._onReadyCallbacks.reject(error);\n            this.error('Starting client failed ', error);\n        });\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            if (this.needsStop()) {\n                this.stop();\n            }\n        });\n    }\n    resolveConnection() {\n        if (!this._connectionPromise) {\n            this._connectionPromise = this.createConnection();\n        }\n        return this._connectionPromise;\n    }\n    resolveRootPath() {\n        if (this._clientOptions.workspaceFolder) {\n            return vscode_uri_1.URI.parse(this._clientOptions.workspaceFolder.uri).fsPath;\n        }\n        let { ignoredRootPaths } = this._clientOptions;\n        let config = workspace_1.default.getConfiguration(this.id);\n        let rootPatterns = config.get('rootPatterns', []);\n        let required = config.get('requireRootPattern', false);\n        let resolved;\n        if (rootPatterns && rootPatterns.length) {\n            let doc = workspace_1.default.getDocument(workspace_1.default.bufnr);\n            if (doc && doc.schema == 'file') {\n                let dir = path_1.default.dirname(vscode_uri_1.URI.parse(doc.uri).fsPath);\n                resolved = fs_1.resolveRoot(dir, rootPatterns, workspace_1.default.cwd);\n            }\n        }\n        if (required && !resolved)\n            return null;\n        let rootPath = resolved || workspace_1.default.rootPath || workspace_1.default.cwd;\n        if (ignoredRootPaths && ignoredRootPaths.indexOf(rootPath) !== -1) {\n            window_1.default.showMessage(`Ignored rootPath ${rootPath} of client \"${this._id}\"`, 'warning');\n            return null;\n        }\n        return rootPath;\n    }\n    initialize(connection) {\n        this.refreshTrace(connection, false);\n        let { initializationOptions, progressOnInitialization } = this._clientOptions;\n        let rootPath = this.resolveRootPath();\n        if (!rootPath)\n            return;\n        let initParams = {\n            processId: process.pid,\n            rootPath: rootPath ? rootPath : null,\n            rootUri: rootPath ? cv.asUri(vscode_uri_1.URI.file(rootPath)) : null,\n            capabilities: this.computeClientCapabilities(),\n            initializationOptions: Is.func(initializationOptions) ? initializationOptions() : initializationOptions,\n            trace: vscode_languageserver_protocol_1.Trace.toString(this._trace),\n            workspaceFolders: null,\n            clientInfo: {\n                name: 'coc.nvim',\n                version: workspace_1.default.version\n            }\n        };\n        this.fillInitializeParams(initParams);\n        if (progressOnInitialization) {\n            const token = UUID.generateUuid();\n            initParams.workDoneToken = token;\n            const part = new progressPart_1.ProgressPart(connection, token);\n            part.begin({ title: `initializing ${this.id}`, kind: 'begin' });\n            return this.doInitialize(connection, initParams).then((result) => {\n                part.done();\n                return result;\n            }, (error) => {\n                part.cancel();\n                throw error;\n            });\n        }\n        else {\n            return this.doInitialize(connection, initParams);\n        }\n    }\n    doInitialize(connection, initParams) {\n        return connection.initialize(initParams).then(result => {\n            this._resolvedConnection = connection;\n            this._initializeResult = result;\n            this.state = ClientState.Running;\n            let textDocumentSyncOptions = undefined;\n            if (Is.number(result.capabilities.textDocumentSync)) {\n                if (result.capabilities.textDocumentSync === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {\n                    textDocumentSyncOptions = {\n                        openClose: false,\n                        change: vscode_languageserver_protocol_1.TextDocumentSyncKind.None,\n                        save: undefined\n                    };\n                }\n                else {\n                    textDocumentSyncOptions = {\n                        openClose: true,\n                        change: result.capabilities.textDocumentSync,\n                        save: {\n                            includeText: false\n                        }\n                    };\n                }\n            }\n            else if (result.capabilities.textDocumentSync != null) {\n                textDocumentSyncOptions = result.capabilities.textDocumentSync;\n            }\n            this._capabilities = Object.assign({}, result.capabilities, {\n                resolvedTextDocumentSync: textDocumentSyncOptions\n            });\n            if (!this._clientOptions.disableDiagnostics) {\n                connection.onDiagnostics(params => this.handleDiagnostics(params));\n            }\n            connection.onRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params => this.handleRegistrationRequest(params));\n            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199\n            connection.onRequest('client/registerFeature', params => this.handleRegistrationRequest(params));\n            connection.onRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params => this.handleUnregistrationRequest(params));\n            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199\n            connection.onRequest('client/unregisterFeature', params => this.handleUnregistrationRequest(params));\n            connection.onRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params => this.handleApplyWorkspaceEdit(params));\n            connection.sendNotification(vscode_languageserver_protocol_1.InitializedNotification.type, {});\n            this.hookFileEvents(connection);\n            this.hookConfigurationChanged(connection);\n            this.initializeFeatures(connection);\n            this._onReadyCallbacks.resolve();\n            return result;\n        }).then(undefined, error => {\n            if (this._clientOptions.initializationFailedHandler) {\n                if (this._clientOptions.initializationFailedHandler(error)) {\n                    this.initialize(connection);\n                }\n                else {\n                    this.stop();\n                    this._onReadyCallbacks.reject(error);\n                }\n            }\n            else if (error instanceof vscode_languageserver_protocol_1.ResponseError &&\n                error.data &&\n                error.data.retry) {\n                window_1.default.showPrompt(error.message + ' Retry?').then(confirmed => {\n                    if (confirmed) {\n                        this.initialize(connection);\n                    }\n                    else {\n                        this.stop();\n                        this._onReadyCallbacks.reject(error);\n                    }\n                });\n            }\n            else {\n                if (error && error.message) {\n                    window_1.default.showMessage(error.message, 'error');\n                }\n                this.error('Server initialization failed.', error);\n                this.stop();\n                this._onReadyCallbacks.reject(error);\n            }\n            throw error;\n        });\n    }\n    stop() {\n        this._initializeResult = undefined;\n        if (!this._connectionPromise) {\n            this.state = ClientState.Stopped;\n            return Promise.resolve();\n        }\n        if (this.state === ClientState.Stopping && this._onStop) {\n            return this._onStop;\n        }\n        this.state = ClientState.Stopping;\n        this.cleanUp();\n        // unkook listeners\n        return (this._onStop = this.resolveConnection().then(connection => {\n            return connection.shutdown().then(() => {\n                connection.exit();\n                connection.dispose();\n                this.state = ClientState.Stopped;\n                this.cleanUpChannel();\n                this._onStop = undefined;\n                this._connectionPromise = undefined;\n                this._resolvedConnection = undefined;\n            });\n        }).catch(e => {\n            logger.error('Error on stop languageserver:', e);\n            this.state = ClientState.Stopped;\n            this.cleanUpChannel();\n            this._onStop = undefined;\n            this._connectionPromise = undefined;\n            this._resolvedConnection = undefined;\n        }));\n    }\n    cleanUp(channel = true, diagnostics = true) {\n        if (this._listeners) {\n            this._listeners.forEach(listener => listener.dispose());\n            this._listeners = undefined;\n        }\n        if (this._providers) {\n            this._providers.forEach(provider => provider.dispose());\n            this._providers = undefined;\n        }\n        for (let feature of this._features.values()) {\n            if (typeof feature.dispose === 'function') {\n                feature.dispose();\n            }\n            else {\n                logger.error(`Feature can't be disposed`, feature);\n            }\n        }\n        if (this._syncedDocuments) {\n            this._syncedDocuments.clear();\n        }\n        if (channel) {\n            this.cleanUpChannel();\n        }\n        if (this._diagnostics) {\n            if (diagnostics) {\n                this._diagnostics.dispose();\n                this._diagnostics = undefined;\n            }\n            else {\n                this._diagnostics.clear();\n            }\n        }\n    }\n    cleanUpChannel() {\n        if (this._outputChannel) {\n            this._outputChannel.dispose();\n            this._outputChannel = undefined;\n        }\n    }\n    notifyFileEvent(event) {\n        var _a;\n        const client = this;\n        function didChangeWatchedFile(event) {\n            client._fileEvents.push(event);\n            client._fileEventDelayer.trigger(() => {\n                client.onReady().then(() => {\n                    client.resolveConnection().then(connection => {\n                        if (client.isConnectionActive()) {\n                            connection.didChangeWatchedFiles({ changes: client._fileEvents });\n                        }\n                        client._fileEvents = [];\n                    });\n                }, (error) => {\n                    client.error(`Notify file events failed.`, error);\n                });\n            });\n        }\n        const workSpaceMiddleware = (_a = this.clientOptions.middleware) === null || _a === void 0 ? void 0 : _a.workspace;\n        (workSpaceMiddleware === null || workSpaceMiddleware === void 0 ? void 0 : workSpaceMiddleware.didChangeWatchedFile) ? workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile) : didChangeWatchedFile(event);\n    }\n    handleDiagnostics(params) {\n        if (!this._diagnostics) {\n            return;\n        }\n        let { uri, diagnostics } = params;\n        let middleware = this.clientOptions.middleware.handleDiagnostics;\n        if (middleware) {\n            middleware(uri, diagnostics, (uri, diagnostics) => this.setDiagnostics(uri, diagnostics));\n        }\n        else {\n            this.setDiagnostics(uri, diagnostics);\n        }\n    }\n    setDiagnostics(uri, diagnostics) {\n        var _a;\n        if (!this._diagnostics) {\n            return;\n        }\n        const separate = workspace_1.default.getConfiguration('diagnostic').get('separateRelatedInformationAsDiagnostics');\n        if (separate && diagnostics.length > 0) {\n            const entries = new Map();\n            entries.set(uri, diagnostics);\n            for (const diagnostic of diagnostics) {\n                if ((_a = diagnostic.relatedInformation) === null || _a === void 0 ? void 0 : _a.length) {\n                    let message = `${diagnostic.message}\\n\\nRelated diagnostics:\\n`;\n                    for (const info of diagnostic.relatedInformation) {\n                        const basename = path_1.default.basename(vscode_uri_1.URI.parse(info.location.uri).fsPath);\n                        const ln = info.location.range.start.line;\n                        message = `${message}\\n${basename}(line ${ln + 1}): ${info.message}`;\n                        const diags = entries.get(info.location.uri) || [];\n                        diags.push(vscode_languageserver_protocol_1.Diagnostic.create(info.location.range, info.message, vscode_languageserver_protocol_1.DiagnosticSeverity.Hint, diagnostic.code, diagnostic.source));\n                        entries.set(info.location.uri, diags);\n                    }\n                    diagnostic.message = message;\n                }\n                this._diagnostics.set(Array.from(entries));\n            }\n        }\n        else {\n            this._diagnostics.set(uri, diagnostics);\n        }\n    }\n    createConnection() {\n        let errorHandler = (error, message, count) => {\n            logger.error('connection error:', error, message);\n            this.handleConnectionError(error, message, count);\n        };\n        let closeHandler = () => {\n            this.handleConnectionClosed();\n        };\n        return this.createMessageTransports(this._clientOptions.stdioEncoding || 'utf8').then(transports => {\n            return createConnection(transports.reader, transports.writer, errorHandler, closeHandler);\n        });\n    }\n    handleConnectionClosed() {\n        // Check whether this is a normal shutdown in progress or the client stopped normally.\n        if (this.state === ClientState.Stopping ||\n            this.state === ClientState.Stopped) {\n            return;\n        }\n        try {\n            if (this._resolvedConnection) {\n                this._resolvedConnection.dispose();\n            }\n        }\n        catch (error) {\n            // Disposing a connection could fail if error cases.\n        }\n        let action = CloseAction.DoNotRestart;\n        try {\n            action = this._clientOptions.errorHandler.closed();\n        }\n        catch (error) {\n            // Ignore errors coming from the error handler.\n        }\n        this._connectionPromise = undefined;\n        this._resolvedConnection = undefined;\n        if (action === CloseAction.DoNotRestart) {\n            this.error('Connection to server got closed. Server will not be restarted.');\n            this.state = ClientState.Stopped;\n            this.cleanUp(false, true);\n        }\n        else if (action === CloseAction.Restart) {\n            this.info('Connection to server got closed. Server will restart.');\n            this.cleanUp(false, true);\n            this.state = ClientState.Initial;\n            this.start();\n        }\n    }\n    restart() {\n        this.cleanUp(true, false);\n        this.start();\n    }\n    handleConnectionError(error, message, count) {\n        let action = this._clientOptions.errorHandler.error(error, message, count);\n        if (action === ErrorAction.Shutdown) {\n            this.error('Connection to server is erroring. Shutting down server.');\n            this.stop();\n        }\n    }\n    hookConfigurationChanged(connection) {\n        workspace_1.default.onDidChangeConfiguration(() => {\n            this.refreshTrace(connection, true);\n        });\n    }\n    refreshTrace(connection, sendNotification = false) {\n        let config = workspace_1.default.getConfiguration(this._id);\n        let trace = vscode_languageserver_protocol_1.Trace.Off;\n        let traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;\n        if (config) {\n            const traceConfig = config.get('trace.server', 'off');\n            if (typeof traceConfig === 'string') {\n                trace = vscode_languageserver_protocol_1.Trace.fromString(traceConfig);\n            }\n            else {\n                trace = vscode_languageserver_protocol_1.Trace.fromString(config.get('trace.server.verbosity', 'off'));\n                traceFormat = vscode_languageserver_protocol_1.TraceFormat.fromString(config.get('trace.server.format', 'text'));\n            }\n        }\n        this._trace = trace;\n        this._traceFormat = traceFormat;\n        connection.trace(this._trace, this._tracer, {\n            sendNotification,\n            traceFormat: this._traceFormat\n        });\n    }\n    hookFileEvents(_connection) {\n        let fileEvents = this._clientOptions.synchronize.fileEvents;\n        if (!fileEvents)\n            return;\n        let watchers;\n        if (Array.isArray(fileEvents)) {\n            watchers = fileEvents;\n        }\n        else {\n            watchers = [fileEvents];\n        }\n        if (!watchers) {\n            return;\n        }\n        this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type.method).registerRaw(UUID.generateUuid(), watchers);\n    }\n    registerFeatures(features) {\n        for (let feature of features) {\n            this.registerFeature(feature);\n        }\n    }\n    registerFeature(feature) {\n        this._features.push(feature);\n        if (DynamicFeature.is(feature)) {\n            let messages = feature.messages;\n            if (Array.isArray(messages)) {\n                for (let message of messages) {\n                    this._method2Message.set(message.method, message);\n                    this._dynamicFeatures.set(message.method, feature);\n                }\n            }\n            else {\n                this._method2Message.set(messages.method, messages);\n                this._dynamicFeatures.set(messages.method, feature);\n            }\n        }\n    }\n    getFeature(request) {\n        return this._dynamicFeatures.get(request);\n    }\n    registerBuiltinFeatures() {\n        this.registerFeature(new ConfigurationFeature(this));\n        this.registerFeature(new DidOpenTextDocumentFeature(this, this._syncedDocuments));\n        this.registerFeature(new DidChangeTextDocumentFeature(this));\n        this.registerFeature(new WillSaveFeature(this));\n        this.registerFeature(new WillSaveWaitUntilFeature(this));\n        this.registerFeature(new DidSaveTextDocumentFeature(this));\n        this.registerFeature(new DidCloseTextDocumentFeature(this, this._syncedDocuments));\n        this.registerFeature(new FileSystemWatcherFeature(this, event => this.notifyFileEvent(event)));\n        if (!this._clientOptions.disableCompletion) {\n            this.registerFeature(new CompletionItemFeature(this));\n        }\n        this.registerFeature(new HoverFeature(this));\n        this.registerFeature(new SignatureHelpFeature(this));\n        this.registerFeature(new DefinitionFeature(this));\n        this.registerFeature(new ReferencesFeature(this));\n        this.registerFeature(new DocumentHighlightFeature(this));\n        this.registerFeature(new DocumentSymbolFeature(this));\n        this.registerFeature(new WorkspaceSymbolFeature(this));\n        this.registerFeature(new CodeActionFeature(this));\n        this.registerFeature(new CodeLensFeature(this));\n        this.registerFeature(new DocumentFormattingFeature(this));\n        this.registerFeature(new DocumentRangeFormattingFeature(this));\n        this.registerFeature(new DocumentOnTypeFormattingFeature(this));\n        this.registerFeature(new RenameFeature(this));\n        this.registerFeature(new DocumentLinkFeature(this));\n        this.registerFeature(new ExecuteCommandFeature(this));\n    }\n    fillInitializeParams(params) {\n        for (let feature of this._features) {\n            if (Is.func(feature.fillInitializeParams)) {\n                feature.fillInitializeParams(params);\n            }\n        }\n    }\n    computeClientCapabilities() {\n        let result = {};\n        ensure(result, 'workspace').applyEdit = true;\n        let workspaceEdit = ensure(ensure(result, 'workspace'), 'workspaceEdit');\n        workspaceEdit.documentChanges = true;\n        workspaceEdit.resourceOperations = [vscode_languageserver_protocol_1.ResourceOperationKind.Create, vscode_languageserver_protocol_1.ResourceOperationKind.Rename, vscode_languageserver_protocol_1.ResourceOperationKind.Delete];\n        workspaceEdit.failureHandling = vscode_languageserver_protocol_1.FailureHandlingKind.TextOnlyTransactional;\n        const diagnostics = ensure(ensure(result, 'textDocument'), 'publishDiagnostics');\n        diagnostics.relatedInformation = true;\n        diagnostics.versionSupport = false;\n        diagnostics.tagSupport = { valueSet: [vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary, vscode_languageserver_protocol_1.DiagnosticTag.Deprecated] };\n        for (let feature of this._features) {\n            feature.fillClientCapabilities(result);\n        }\n        return result;\n    }\n    initializeFeatures(_connection) {\n        let documentSelector = this._clientOptions.documentSelector;\n        for (let feature of this._features) {\n            feature.initialize(this._capabilities, documentSelector);\n        }\n    }\n    handleRegistrationRequest(params) {\n        if (this.clientOptions.disableDynamicRegister)\n            return Promise.resolve();\n        return new Promise((resolve, reject) => {\n            for (let registration of params.registrations) {\n                const feature = this._dynamicFeatures.get(registration.method);\n                if (!feature) {\n                    reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));\n                    return;\n                }\n                const options = registration.registerOptions || {};\n                options.documentSelector = options.documentSelector || this._clientOptions.documentSelector;\n                const data = {\n                    id: registration.id,\n                    registerOptions: options\n                };\n                feature.register(this._method2Message.get(registration.method), data);\n            }\n            resolve();\n        });\n    }\n    handleUnregistrationRequest(params) {\n        return new Promise((resolve, reject) => {\n            for (let unregistration of params.unregisterations) {\n                const feature = this._dynamicFeatures.get(unregistration.method);\n                if (!feature) {\n                    reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));\n                    return;\n                }\n                feature.unregister(unregistration.id);\n            }\n            resolve();\n        });\n    }\n    handleApplyWorkspaceEdit(params) {\n        // This is some sort of workaround since the version check should be done by VS Code in the Workspace.applyEdit.\n        // However doing it here adds some safety since the server can lag more behind then an extension.\n        let workspaceEdit = params.edit;\n        let openTextDocuments = new Map();\n        workspace_1.default.textDocuments.forEach((document) => openTextDocuments.set(document.uri.toString(), document));\n        let versionMismatch = false;\n        if (workspaceEdit.documentChanges) {\n            for (const change of workspaceEdit.documentChanges) {\n                if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {\n                    let textDocument = openTextDocuments.get(change.textDocument.uri);\n                    if (textDocument && textDocument.version !== change.textDocument.version) {\n                        versionMismatch = true;\n                        break;\n                    }\n                }\n            }\n        }\n        if (versionMismatch) {\n            return Promise.resolve({ applied: false });\n        }\n        return workspace_1.default.applyEdit(params.edit).then(value => {\n            return { applied: value };\n        });\n    }\n    logFailedRequest(type, error) {\n        // If we get a request cancel don't log anything.\n        if (error instanceof vscode_languageserver_protocol_1.ResponseError &&\n            error.code === vscode_languageserver_protocol_1.ErrorCodes.RequestCancelled) {\n            return;\n        }\n        this.error(`Request ${type.method} failed.`, error);\n    }\n}\nexports.BaseLanguageClient = BaseLanguageClient;\n\n\n//# sourceURL=webpack://coc.nvim/./src/language-client/client.ts?");

/***/ }),

/***/ "./src/language-client/colorProvider.ts":
/*!**********************************************!*\
  !*** ./src/language-client/colorProvider.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ColorProviderFeature = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ../languages */ \"./src/languages.ts\"));\nconst client_1 = __webpack_require__(/*! ./client */ \"./src/language-client/client.ts\");\nfunction ensure(target, key) {\n    if (target[key] === void 0) {\n        target[key] = {};\n    }\n    return target[key];\n}\nclass ColorProviderFeature extends client_1.TextDocumentFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.DocumentColorRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        ensure(ensure(capabilites, 'textDocument'), 'colorProvider').dynamicRegistration = true;\n    }\n    initialize(capabilities, documentSelector) {\n        let [id, options] = this.getRegistration(documentSelector, capabilities.colorProvider);\n        if (!id || !options) {\n            return;\n        }\n        this.register(this.messages, { id, registerOptions: options });\n    }\n    registerLanguageProvider(options) {\n        const provider = {\n            provideColorPresentations: (color, context, token) => {\n                const client = this._client;\n                const provideColorPresentations = (color, context, token) => {\n                    const requestParams = {\n                        color,\n                        textDocument: { uri: context.document.uri },\n                        range: context.range\n                    };\n                    return client.sendRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, requestParams, token).then(res => res, (error) => {\n                        client.logFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, error);\n                        return Promise.resolve(null);\n                    });\n                };\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideColorPresentations\n                    ? middleware.provideColorPresentations(color, context, token, provideColorPresentations)\n                    : provideColorPresentations(color, context, token);\n            },\n            provideDocumentColors: (document, token) => {\n                const client = this._client;\n                const provideDocumentColors = (document, token) => {\n                    const requestParams = {\n                        textDocument: { uri: document.uri }\n                    };\n                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, requestParams, token).then(res => res, (error) => {\n                        client.logFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, error);\n                        return Promise.resolve(null);\n                    });\n                };\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideDocumentColors\n                    ? middleware.provideDocumentColors(document, token, provideDocumentColors)\n                    : provideDocumentColors(document, token);\n            }\n        };\n        return [languages_1.default.registerDocumentColorProvider(options.documentSelector, provider), provider];\n    }\n}\nexports.ColorProviderFeature = ColorProviderFeature;\n\n\n//# sourceURL=webpack://coc.nvim/./src/language-client/colorProvider.ts?");

/***/ }),

/***/ "./src/language-client/configuration.ts":
/*!**********************************************!*\
  !*** ./src/language-client/configuration.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toJSONObject = exports.ConfigurationFeature = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('languageclient-configuration');\nclass ConfigurationFeature {\n    constructor(_client) {\n        var _a;\n        this._client = _client;\n        let section = (_a = this._client.clientOptions.synchronize) === null || _a === void 0 ? void 0 : _a.configurationSection;\n        if (typeof section === 'string' && section.startsWith('languageserver.')) {\n            this.languageserverSection = section;\n        }\n    }\n    fillClientCapabilities(capabilities) {\n        capabilities.workspace = capabilities.workspace || {};\n        capabilities.workspace.configuration = true;\n    }\n    initialize() {\n        let client = this._client;\n        client.onRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, (params, token) => {\n            let configuration = params => {\n                let result = [];\n                for (let item of params.items) {\n                    result.push(this.getConfiguration(item.scopeUri, item.section));\n                }\n                return result;\n            };\n            let middleware = client.clientOptions.middleware.workspace;\n            return middleware && middleware.configuration\n                ? middleware.configuration(params, token, configuration)\n                : configuration(params, token);\n        });\n    }\n    getConfiguration(resource, section) {\n        let result = null;\n        if (section) {\n            if (this.languageserverSection) {\n                section = `${this.languageserverSection}.${section}`;\n            }\n            let index = section.lastIndexOf('.');\n            if (index === -1) {\n                result = workspace_1.default.getConfiguration(undefined, resource).get(section, {});\n            }\n            else {\n                let config = workspace_1.default.getConfiguration(section.substr(0, index), resource);\n                if (config) {\n                    result = config.get(section.substr(index + 1));\n                }\n            }\n        }\n        else {\n            let config = workspace_1.default.getConfiguration(this.languageserverSection, resource);\n            result = {};\n            for (let key of Object.keys(config)) {\n                if (config.has(key)) {\n                    result[key] = toJSONObject(config.get(key));\n                }\n            }\n        }\n        return result;\n    }\n    dispose() {\n    }\n}\nexports.ConfigurationFeature = ConfigurationFeature;\nfunction toJSONObject(obj) {\n    if (obj) {\n        if (Array.isArray(obj)) {\n            return obj.map(toJSONObject);\n        }\n        else if (typeof obj === 'object') {\n            const res = Object.create(null);\n            for (const key in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    res[key] = toJSONObject(obj[key]);\n                }\n            }\n            return res;\n        }\n    }\n    return obj;\n}\nexports.toJSONObject = toJSONObject;\n\n\n//# sourceURL=webpack://coc.nvim/./src/language-client/configuration.ts?");

/***/ }),

/***/ "./src/language-client/declaration.ts":
/*!********************************************!*\
  !*** ./src/language-client/declaration.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DeclarationFeature = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ../languages */ \"./src/languages.ts\"));\nconst client_1 = __webpack_require__(/*! ./client */ \"./src/language-client/client.ts\");\nconst converter_1 = __webpack_require__(/*! ./utils/converter */ \"./src/language-client/utils/converter.ts\");\nfunction ensure(target, key) {\n    if (target[key] === void 0) {\n        target[key] = {};\n    }\n    return target[key];\n}\nclass DeclarationFeature extends client_1.TextDocumentFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.DeclarationRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        let declarationSupport = ensure(ensure(capabilites, 'textDocument'), 'declaration');\n        declarationSupport.dynamicRegistration = true;\n        // declarationSupport.linkSupport = true\n    }\n    initialize(capabilities, documentSelector) {\n        const [id, options] = this.getRegistration(documentSelector, capabilities.declarationProvider);\n        if (!id || !options) {\n            return;\n        }\n        this.register(this.messages, { id, registerOptions: options });\n    }\n    registerLanguageProvider(options) {\n        const provider = {\n            provideDeclaration: (document, position, token) => {\n                const client = this._client;\n                const provideDeclaration = (document, position, token) => client.sendRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, converter_1.asTextDocumentPositionParams(document, position), token).then(res => res, error => {\n                    client.logFailedRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, error);\n                    return Promise.resolve(null);\n                });\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideDeclaration\n                    ? middleware.provideDeclaration(document, position, token, provideDeclaration)\n                    : provideDeclaration(document, position, token);\n            }\n        };\n        return [languages_1.default.registerDeclarationProvider(options.documentSelector, provider), provider];\n    }\n}\nexports.DeclarationFeature = DeclarationFeature;\n\n\n//# sourceURL=webpack://coc.nvim/./src/language-client/declaration.ts?");

/***/ }),

/***/ "./src/language-client/foldingRange.ts":
/*!*********************************************!*\
  !*** ./src/language-client/foldingRange.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FoldingRangeFeature = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ../languages */ \"./src/languages.ts\"));\nconst client_1 = __webpack_require__(/*! ./client */ \"./src/language-client/client.ts\");\nfunction ensure(target, key) {\n    if (target[key] === void 0) {\n        target[key] = {};\n    }\n    return target[key];\n}\nclass FoldingRangeFeature extends client_1.TextDocumentFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.FoldingRangeRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        let capability = ensure(ensure(capabilites, 'textDocument'), 'foldingRange');\n        capability.dynamicRegistration = true;\n        capability.rangeLimit = 5000;\n        capability.lineFoldingOnly = true;\n    }\n    initialize(capabilities, documentSelector) {\n        const [id, options] = this.getRegistration(documentSelector, capabilities.foldingRangeProvider);\n        if (!id || !options) {\n            return;\n        }\n        this.register(this.messages, { id, registerOptions: options });\n    }\n    registerLanguageProvider(options) {\n        const provider = {\n            provideFoldingRanges: (document, context, token) => {\n                const client = this._client;\n                const provideFoldingRanges = (document, _, token) => {\n                    const requestParams = {\n                        textDocument: { uri: document.uri }\n                    };\n                    return client.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, requestParams, token).then(res => res, (error) => {\n                        client.logFailedRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, error);\n                        return Promise.resolve(null);\n                    });\n                };\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideFoldingRanges\n                    ? middleware.provideFoldingRanges(document, context, token, provideFoldingRanges)\n                    : provideFoldingRanges(document, context, token);\n            }\n        };\n        return [languages_1.default.registerFoldingRangeProvider(options.documentSelector, provider), provider];\n    }\n}\nexports.FoldingRangeFeature = FoldingRangeFeature;\n\n\n//# sourceURL=webpack://coc.nvim/./src/language-client/foldingRange.ts?");

/***/ }),

/***/ "./src/language-client/implementation.ts":
/*!***********************************************!*\
  !*** ./src/language-client/implementation.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImplementationFeature = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* ---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ../languages */ \"./src/languages.ts\"));\nconst client_1 = __webpack_require__(/*! ./client */ \"./src/language-client/client.ts\");\nconst cv = tslib_1.__importStar(__webpack_require__(/*! ./utils/converter */ \"./src/language-client/utils/converter.ts\"));\nfunction ensure(target, key) {\n    if (target[key] === void 0) {\n        target[key] = {};\n    }\n    return target[key];\n}\nclass ImplementationFeature extends client_1.TextDocumentFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.ImplementationRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        const implementationSupport = ensure(ensure(capabilites, 'textDocument'), 'implementation');\n        implementationSupport.dynamicRegistration = true;\n        // implementationSupport.linkSupport = true\n    }\n    initialize(capabilities, documentSelector) {\n        const [id, options] = this.getRegistration(documentSelector, capabilities.implementationProvider);\n        if (!id || !options) {\n            return;\n        }\n        this.register(this.messages, { id, registerOptions: options });\n    }\n    registerLanguageProvider(options) {\n        const provider = {\n            provideImplementation: (document, position, token) => {\n                const client = this._client;\n                const provideImplementation = (document, position, token) => client.sendRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, cv.asTextDocumentPositionParams(document, position), token).then(res => res, error => {\n                    client.logFailedRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, error);\n                    return Promise.resolve(null);\n                });\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideImplementation\n                    ? middleware.provideImplementation(document, position, token, provideImplementation)\n                    : provideImplementation(document, position, token);\n            }\n        };\n        return [languages_1.default.registerImplementationProvider(options.documentSelector, provider), provider];\n    }\n}\nexports.ImplementationFeature = ImplementationFeature;\n\n\n//# sourceURL=webpack://coc.nvim/./src/language-client/implementation.ts?");

/***/ }),

/***/ "./src/language-client/index.ts":
/*!**************************************!*\
  !*** ./src/language-client/index.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ProposedFeatures = exports.SettingMonitor = exports.LanguageClient = exports.TransportKind = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* eslint-disable no-redeclare */\nconst child_process_1 = tslib_1.__importDefault(__webpack_require__(/*! child_process */ \"child_process\"));\nconst fs_1 = tslib_1.__importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./src/types.ts\");\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst Is = tslib_1.__importStar(__webpack_require__(/*! ../util/is */ \"./src/util/is.ts\"));\nconst processes_1 = __webpack_require__(/*! ../util/processes */ \"./src/util/processes.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst client_1 = __webpack_require__(/*! ./client */ \"./src/language-client/client.ts\");\nconst colorProvider_1 = __webpack_require__(/*! ./colorProvider */ \"./src/language-client/colorProvider.ts\");\nconst configuration_1 = __webpack_require__(/*! ./configuration */ \"./src/language-client/configuration.ts\");\nconst declaration_1 = __webpack_require__(/*! ./declaration */ \"./src/language-client/declaration.ts\");\nconst foldingRange_1 = __webpack_require__(/*! ./foldingRange */ \"./src/language-client/foldingRange.ts\");\nconst implementation_1 = __webpack_require__(/*! ./implementation */ \"./src/language-client/implementation.ts\");\nconst progress_1 = __webpack_require__(/*! ./progress */ \"./src/language-client/progress.ts\");\nconst typeDefinition_1 = __webpack_require__(/*! ./typeDefinition */ \"./src/language-client/typeDefinition.ts\");\nconst workspaceFolders_1 = __webpack_require__(/*! ./workspaceFolders */ \"./src/language-client/workspaceFolders.ts\");\nconst selectionRange_1 = __webpack_require__(/*! ./selectionRange */ \"./src/language-client/selectionRange.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('language-client-index');\ntslib_1.__exportStar(__webpack_require__(/*! ./client */ \"./src/language-client/client.ts\"), exports);\nvar Executable;\n(function (Executable) {\n    function is(value) {\n        return Is.string(value.command);\n    }\n    Executable.is = is;\n})(Executable || (Executable = {}));\nvar TransportKind;\n(function (TransportKind) {\n    TransportKind[TransportKind[\"stdio\"] = 0] = \"stdio\";\n    TransportKind[TransportKind[\"ipc\"] = 1] = \"ipc\";\n    TransportKind[TransportKind[\"pipe\"] = 2] = \"pipe\";\n    TransportKind[TransportKind[\"socket\"] = 3] = \"socket\";\n})(TransportKind = exports.TransportKind || (exports.TransportKind = {}));\nvar Transport;\n(function (Transport) {\n    function isSocket(value) {\n        let candidate = value;\n        return (candidate &&\n            candidate.kind === TransportKind.socket &&\n            Is.number(candidate.port));\n    }\n    Transport.isSocket = isSocket;\n})(Transport || (Transport = {}));\nvar NodeModule;\n(function (NodeModule) {\n    function is(value) {\n        return Is.string(value.module);\n    }\n    NodeModule.is = is;\n})(NodeModule || (NodeModule = {}));\nvar StreamInfo;\n(function (StreamInfo) {\n    function is(value) {\n        let candidate = value;\n        return (candidate && candidate.writer !== void 0 && candidate.reader !== void 0);\n    }\n    StreamInfo.is = is;\n})(StreamInfo || (StreamInfo = {}));\nvar ChildProcessInfo;\n(function (ChildProcessInfo) {\n    function is(value) {\n        let candidate = value;\n        return (candidate &&\n            candidate.process !== void 0 &&\n            typeof candidate.detached === 'boolean');\n    }\n    ChildProcessInfo.is = is;\n})(ChildProcessInfo || (ChildProcessInfo = {}));\nclass LanguageClient extends client_1.BaseLanguageClient {\n    constructor(arg1, arg2, arg3, arg4, arg5) {\n        let id;\n        let name;\n        let serverOptions;\n        let clientOptions;\n        let forceDebug;\n        if (Is.string(arg2)) {\n            id = arg1;\n            name = arg2;\n            serverOptions = arg3;\n            clientOptions = arg4;\n            forceDebug = !!arg5;\n        }\n        else {\n            // first signature\n            id = arg1.toLowerCase();\n            name = arg1;\n            serverOptions = arg2;\n            clientOptions = arg3;\n            forceDebug = arg4;\n        }\n        if (forceDebug === void 0) {\n            forceDebug = false;\n        }\n        super(id, name, clientOptions);\n        this._serverOptions = serverOptions;\n        this._forceDebug = forceDebug;\n        this.registerProposedFeatures();\n    }\n    stop() {\n        return super.stop().then(() => {\n            if (this._serverProcess) {\n                let toCheck = this._serverProcess;\n                this._serverProcess = undefined;\n                if (this._isDetached === void 0 || !this._isDetached) {\n                    this.checkProcessDied(toCheck);\n                }\n                this._isDetached = undefined;\n            }\n        });\n    }\n    get serviceState() {\n        let state = this._state;\n        switch (state) {\n            case client_1.ClientState.Initial:\n                return types_1.ServiceStat.Initial;\n            case client_1.ClientState.Running:\n                return types_1.ServiceStat.Running;\n            case client_1.ClientState.StartFailed:\n                return types_1.ServiceStat.StartFailed;\n            case client_1.ClientState.Starting:\n                return types_1.ServiceStat.Starting;\n            case client_1.ClientState.Stopped:\n                return types_1.ServiceStat.Stopped;\n            case client_1.ClientState.Stopping:\n                return types_1.ServiceStat.Stopping;\n            default:\n                logger.error(`Unknown state: ${state}`);\n                return types_1.ServiceStat.Stopped;\n        }\n    }\n    static stateName(state) {\n        switch (state) {\n            case client_1.ClientState.Initial:\n                return 'Initial';\n            case client_1.ClientState.Running:\n                return 'Running';\n            case client_1.ClientState.StartFailed:\n                return 'StartFailed';\n            case client_1.ClientState.Starting:\n                return 'Starting';\n            case client_1.ClientState.Stopped:\n                return 'Stopped';\n            case client_1.ClientState.Stopping:\n                return 'Stopping';\n            default:\n                return 'Unknonw';\n        }\n    }\n    checkProcessDied(childProcess) {\n        if (!childProcess || global.hasOwnProperty('__TEST__'))\n            return;\n        if (global.hasOwnProperty('__TEST__')) {\n            process.kill(childProcess.pid, 0);\n            return;\n        }\n        setTimeout(() => {\n            // Test if the process is still alive. Throws an exception if not\n            try {\n                process.kill(childProcess.pid, 0);\n                processes_1.terminate(childProcess);\n            }\n            catch (error) {\n                // All is fine.\n            }\n        }, 2000);\n    }\n    handleConnectionClosed() {\n        this._serverProcess = undefined;\n        super.handleConnectionClosed();\n    }\n    createMessageTransports(encoding) {\n        function getEnvironment(env) {\n            if (!env)\n                return process.env;\n            return Object.assign({}, process.env, env);\n        }\n        function startedInDebugMode() {\n            let args = process.execArgv;\n            if (args) {\n                return args.some(arg => /^--debug=?/.test(arg) ||\n                    /^--debug-brk=?/.test(arg) ||\n                    /^--inspect=?/.test(arg) ||\n                    /^--inspect-brk=?/.test(arg));\n            }\n            return false;\n        }\n        let server = this._serverOptions;\n        // We got a function.\n        if (Is.func(server)) {\n            return server().then(result => {\n                if (client_1.MessageTransports.is(result)) {\n                    this._isDetached = !!result.detached;\n                    return result;\n                }\n                else if (StreamInfo.is(result)) {\n                    this._isDetached = !!result.detached;\n                    return {\n                        reader: new vscode_languageserver_protocol_1.StreamMessageReader(result.reader),\n                        writer: new vscode_languageserver_protocol_1.StreamMessageWriter(result.writer)\n                    };\n                }\n                else {\n                    let cp;\n                    if (ChildProcessInfo.is(result)) {\n                        cp = result.process;\n                        this._isDetached = result.detached;\n                    }\n                    else {\n                        cp = result;\n                        this._isDetached = false;\n                    }\n                    cp.stderr.on('data', data => this.appendOutput(data, encoding));\n                    return {\n                        reader: new vscode_languageserver_protocol_1.StreamMessageReader(cp.stdout),\n                        writer: new vscode_languageserver_protocol_1.StreamMessageWriter(cp.stdin)\n                    };\n                }\n            });\n        }\n        let json = server;\n        let runDebug = server;\n        if (runDebug.run || runDebug.debug) {\n            // We are under debugging. So use debug as well.\n            if (typeof v8debug === 'object' || this._forceDebug || startedInDebugMode()) {\n                json = runDebug.debug;\n            }\n            else {\n                json = runDebug.run;\n            }\n        }\n        else {\n            json = server;\n        }\n        return this._getServerWorkingDir(json.options).then(serverWorkingDir => {\n            if (NodeModule.is(json) && json.module) {\n                let node = json;\n                let transport = node.transport || TransportKind.stdio;\n                let args = [];\n                let options = node.options || Object.create(null);\n                let runtime = node.runtime || process.execPath;\n                if (options.execArgv)\n                    options.execArgv.forEach(element => args.push(element));\n                if (transport != TransportKind.ipc)\n                    args.push(node.module);\n                if (node.args)\n                    node.args.forEach(element => args.push(element));\n                let execOptions = Object.create(null);\n                execOptions.cwd = serverWorkingDir;\n                execOptions.env = getEnvironment(options.env);\n                let pipeName;\n                if (transport === TransportKind.ipc) {\n                    execOptions.stdio = [null, null, null];\n                    args.push('--node-ipc');\n                }\n                else if (transport === TransportKind.stdio) {\n                    args.push('--stdio');\n                }\n                else if (transport === TransportKind.pipe) {\n                    pipeName = vscode_languageserver_protocol_1.generateRandomPipeName();\n                    args.push(`--pipe=${pipeName}`);\n                }\n                else if (Transport.isSocket(transport)) {\n                    args.push(`--socket=${transport.port}`);\n                }\n                args.push(`--clientProcessId=${process.pid.toString()}`);\n                if (transport === TransportKind.ipc) {\n                    let forkOptions = {\n                        cwd: serverWorkingDir,\n                        env: getEnvironment(options.env),\n                        stdio: [null, null, null, 'ipc'],\n                        execPath: runtime,\n                        execArgv: options.execArgv || [],\n                    };\n                    let serverProcess = child_process_1.default.fork(node.module, args, forkOptions);\n                    if (!serverProcess || !serverProcess.pid) {\n                        return Promise.reject(`Launching server module \"${node.module}\" failed.`);\n                    }\n                    serverProcess.on('error', e => {\n                        logger.error(e);\n                    });\n                    logger.info(`${this.id} started with ${serverProcess.pid}`);\n                    this._serverProcess = serverProcess;\n                    serverProcess.stdout.on('data', data => this.appendOutput(data, encoding));\n                    serverProcess.stderr.on('data', data => this.appendOutput(data, encoding));\n                    return {\n                        reader: new vscode_languageserver_protocol_1.IPCMessageReader(serverProcess),\n                        writer: new vscode_languageserver_protocol_1.IPCMessageWriter(serverProcess)\n                    };\n                }\n                else if (transport === TransportKind.stdio) {\n                    let serverProcess = child_process_1.default.spawn(runtime, args, execOptions);\n                    if (!serverProcess || !serverProcess.pid) {\n                        return Promise.reject(`Launching server module \"${node.module}\" failed.`);\n                    }\n                    logger.info(`${this.id} started with ${serverProcess.pid}`);\n                    serverProcess.on('error', e => {\n                        logger.error(`Process ${runtime} error: `, e);\n                    });\n                    this._serverProcess = serverProcess;\n                    serverProcess.stderr.on('data', data => this.appendOutput(data, encoding));\n                    return {\n                        reader: new vscode_languageserver_protocol_1.StreamMessageReader(serverProcess.stdout),\n                        writer: new vscode_languageserver_protocol_1.StreamMessageWriter(serverProcess.stdin)\n                    };\n                }\n                else if (transport == TransportKind.pipe) {\n                    return Promise.resolve(vscode_languageserver_protocol_1.createClientPipeTransport(pipeName)).then(transport => {\n                        let process = child_process_1.default.spawn(runtime, args, execOptions);\n                        if (!process || !process.pid) {\n                            return Promise.reject(`Launching server module \"${node.module}\" failed.`);\n                        }\n                        logger.info(`Language server ${this.id} started with ${process.pid}`);\n                        this._serverProcess = process;\n                        process.stderr.on('data', data => this.appendOutput(data, encoding));\n                        process.stdout.on('data', data => this.appendOutput(data, encoding));\n                        return Promise.resolve(transport.onConnected()).then(protocol => ({ reader: protocol[0], writer: protocol[1] }));\n                    });\n                }\n                else if (Transport.isSocket(node.transport)) {\n                    return Promise.resolve(vscode_languageserver_protocol_1.createClientSocketTransport(node.transport.port)).then(transport => {\n                        let process = child_process_1.default.spawn(runtime, args, execOptions);\n                        if (!process || !process.pid) {\n                            return Promise.reject(`Launching server ${node.module} failed.`);\n                        }\n                        process.on('exit', code => {\n                            if (code != 0)\n                                this.error(`command \"${runtime} ${args.join(' ')}\" exited with code: ${code}`);\n                        });\n                        logger.info(`Language server ${this.id} started with ${process.pid}`);\n                        this._serverProcess = process;\n                        process.stderr.on('data', data => this.appendOutput(data, encoding));\n                        process.stdout.on('data', data => this.appendOutput(data, encoding));\n                        return Promise.resolve(transport.onConnected()).then(protocol => ({ reader: protocol[0], writer: protocol[1] }));\n                    });\n                }\n            }\n            else if (Executable.is(json) && json.command) {\n                let command = json;\n                let args = command.args || [];\n                let options = Object.assign({}, command.options);\n                options.env = options.env ? Object.assign({}, process.env, options.env) : process.env;\n                options.cwd = serverWorkingDir;\n                let cmd = workspace_1.default.expand(json.command);\n                let serverProcess = child_process_1.default.spawn(cmd, args, options);\n                serverProcess.on('error', e => {\n                    logger.error(e);\n                });\n                if (!serverProcess || !serverProcess.pid) {\n                    return Promise.reject(`Launching server \"${this.id}\" using command ${command.command} failed.`);\n                }\n                logger.info(`Language server \"${this.id}\" started with ${serverProcess.pid}`);\n                serverProcess.on('exit', code => {\n                    if (code != 0)\n                        this.error(`${command.command} exited with code: ${code}`);\n                });\n                serverProcess.stderr.on('data', data => this.appendOutput(data, encoding));\n                this._serverProcess = serverProcess;\n                this._isDetached = !!options.detached;\n                return {\n                    reader: new vscode_languageserver_protocol_1.StreamMessageReader(serverProcess.stdout),\n                    writer: new vscode_languageserver_protocol_1.StreamMessageWriter(serverProcess.stdin)\n                };\n            }\n            return Promise.reject(`Unsupported server configuration ${JSON.stringify(server, null, 2)}`);\n        });\n    }\n    registerProposedFeatures() {\n        this.registerFeatures(ProposedFeatures.createAll(this));\n    }\n    registerBuiltinFeatures() {\n        super.registerBuiltinFeatures();\n        this.registerFeature(new configuration_1.ConfigurationFeature(this));\n        this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this));\n        this.registerFeature(new implementation_1.ImplementationFeature(this));\n        this.registerFeature(new declaration_1.DeclarationFeature(this));\n        this.registerFeature(new colorProvider_1.ColorProviderFeature(this));\n        this.registerFeature(new foldingRange_1.FoldingRangeFeature(this));\n        this.registerFeature(new selectionRange_1.SelectionRangeFeature(this));\n        this.registerFeature(new progress_1.ProgressFeature(this));\n        if (!this.clientOptions.disableWorkspaceFolders) {\n            this.registerFeature(new workspaceFolders_1.WorkspaceFoldersFeature(this));\n        }\n    }\n    _getServerWorkingDir(options) {\n        let cwd = options && options.cwd;\n        if (cwd && !path_1.default.isAbsolute(cwd))\n            cwd = path_1.default.join(workspace_1.default.cwd, cwd);\n        if (!cwd)\n            cwd = workspace_1.default.cwd;\n        if (cwd) {\n            // make sure the folder exists otherwise creating the process will fail\n            return new Promise(s => {\n                fs_1.default.lstat(cwd, (err, stats) => {\n                    s(!err && stats.isDirectory() ? cwd : undefined);\n                });\n            });\n        }\n        return Promise.resolve(undefined);\n    }\n    appendOutput(data, encoding) {\n        let msg = Is.string(data) ? data : data.toString(encoding);\n        this.outputChannel.append(msg.endsWith('\\n') ? msg : msg + '\\n');\n    }\n}\nexports.LanguageClient = LanguageClient;\nclass SettingMonitor {\n    constructor(_client, _setting) {\n        this._client = _client;\n        this._setting = _setting;\n        this._listeners = [];\n    }\n    start() {\n        workspace_1.default.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration(this._setting)) {\n                this.onDidChangeConfiguration();\n            }\n        }, null, this._listeners);\n        this.onDidChangeConfiguration();\n        return {\n            dispose: () => {\n                util_1.disposeAll(this._listeners);\n                if (this._client.needsStop()) {\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                    this._client.stop();\n                }\n            }\n        };\n    }\n    onDidChangeConfiguration() {\n        let index = this._setting.indexOf('.');\n        let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;\n        let rest = index >= 0 ? this._setting.substr(index + 1) : undefined;\n        let enabled = rest\n            ? workspace_1.default.getConfiguration(primary).get(rest, true)\n            : workspace_1.default.getConfiguration(primary);\n        if (enabled && this._client.needsStart()) {\n            this._client.start();\n        }\n        else if (!enabled && this._client.needsStop()) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this._client.stop();\n        }\n    }\n}\nexports.SettingMonitor = SettingMonitor;\n// Exporting proposed protocol.\nvar ProposedFeatures;\n(function (ProposedFeatures) {\n    function createAll(_client) {\n        let result = [\n        // TODO\n        // new CallHierarchyFeature(client),\n        // new SemanticTokensFeature(client)\n        ];\n        return result;\n    }\n    ProposedFeatures.createAll = createAll;\n})(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));\n\n\n//# sourceURL=webpack://coc.nvim/./src/language-client/index.ts?");

/***/ }),

/***/ "./src/language-client/progress.ts":
/*!*****************************************!*\
  !*** ./src/language-client/progress.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ProgressFeature = void 0;\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst progressPart_1 = __webpack_require__(/*! ./progressPart */ \"./src/language-client/progressPart.ts\");\n// const logger = require('../util/logger')('language-client-progress')\nfunction ensure(target, key) {\n    if (target[key] === void 0) {\n        target[key] = Object.create(null);\n    }\n    return target[key];\n}\nclass ProgressFeature {\n    constructor(_client) {\n        this._client = _client;\n        this.activeParts = new Set();\n    }\n    fillClientCapabilities(capabilities) {\n        ensure(capabilities, 'window').workDoneProgress = true;\n    }\n    initialize() {\n        let client = this._client;\n        const deleteHandler = (part) => {\n            this.activeParts.delete(part);\n        };\n        const createHandler = (params) => {\n            this.activeParts.add(new progressPart_1.ProgressPart(this._client, params.token, deleteHandler));\n        };\n        client.onRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, createHandler);\n    }\n    dispose() {\n        for (const part of this.activeParts) {\n            part.done();\n        }\n        this.activeParts.clear();\n    }\n}\nexports.ProgressFeature = ProgressFeature;\n\n\n//# sourceURL=webpack://coc.nvim/./src/language-client/progress.ts?");

/***/ }),

/***/ "./src/language-client/progressPart.ts":
/*!*********************************************!*\
  !*** ./src/language-client/progressPart.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ProgressPart = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('language-client-progressPart');\nclass ProgressPart {\n    constructor(client, token, done) {\n        this.client = client;\n        this.token = token;\n        this.disposables = [];\n        this._cancelled = false;\n        this.statusBarItem = window_1.default.createStatusBarItem(99, { progress: true });\n        this.disposables.push(client.onProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this.token, value => {\n            switch (value.kind) {\n                case 'begin':\n                    this.begin(value);\n                    break;\n                case 'report':\n                    this.report(value);\n                    break;\n                case 'end':\n                    this.done(value.message);\n                    done && done(this);\n                    break;\n            }\n        }));\n    }\n    begin(params) {\n        if (typeof this.title === 'string')\n            return;\n        // TODO support  params.cancellable\n        this.title = params.title;\n        this.report(params);\n    }\n    report(params) {\n        let statusBarItem = this.statusBarItem;\n        let parts = [];\n        if (this.title)\n            parts.push(this.title);\n        if (typeof params.percentage == 'number')\n            parts.push(params.percentage.toFixed(0) + '%');\n        if (params.message)\n            parts.push(params.message);\n        statusBarItem.text = parts.join(' ');\n        statusBarItem.show();\n    }\n    cancel() {\n        if (this._cancelled)\n            return;\n        this._cancelled = true;\n        util_1.disposeAll(this.disposables);\n    }\n    done(message) {\n        if (this._cancelled)\n            return;\n        const statusBarItem = this.statusBarItem;\n        statusBarItem.text = `${this.title} ${message || 'finished'}`;\n        setTimeout(() => {\n            statusBarItem.dispose();\n        }, 300);\n        this.cancel();\n    }\n}\nexports.ProgressPart = ProgressPart;\n\n\n//# sourceURL=webpack://coc.nvim/./src/language-client/progressPart.ts?");

/***/ }),

/***/ "./src/language-client/selectionRange.ts":
/*!***********************************************!*\
  !*** ./src/language-client/selectionRange.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SelectionRangeFeature = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ../languages */ \"./src/languages.ts\"));\nconst client_1 = __webpack_require__(/*! ./client */ \"./src/language-client/client.ts\");\nfunction ensure(target, key) {\n    if (target[key] === void 0) {\n        target[key] = {};\n    }\n    return target[key];\n}\nclass SelectionRangeFeature extends client_1.TextDocumentFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.SelectionRangeRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        let capability = ensure(ensure(capabilites, 'textDocument'), 'selectionRange');\n        capability.dynamicRegistration = true;\n    }\n    initialize(capabilities, documentSelector) {\n        let [id, options] = this.getRegistration(documentSelector, capabilities.selectionRangeProvider);\n        if (!id || !options) {\n            return;\n        }\n        this.register(this.messages, { id, registerOptions: options });\n    }\n    registerLanguageProvider(options) {\n        const provider = {\n            provideSelectionRanges: (document, positions, token) => {\n                const client = this._client;\n                const provideSelectionRanges = (document, positions, token) => {\n                    const requestParams = {\n                        textDocument: { uri: document.uri },\n                        positions\n                    };\n                    return client.sendRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, requestParams, token).then(ranges => ranges, (error) => {\n                        client.logFailedRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, error);\n                        return Promise.resolve(null);\n                    });\n                };\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideSelectionRanges\n                    ? middleware.provideSelectionRanges(document, positions, token, provideSelectionRanges)\n                    : provideSelectionRanges(document, positions, token);\n            }\n        };\n        return [languages_1.default.registerSelectionRangeProvider(options.documentSelector, provider), provider];\n    }\n}\nexports.SelectionRangeFeature = SelectionRangeFeature;\n\n\n//# sourceURL=webpack://coc.nvim/./src/language-client/selectionRange.ts?");

/***/ }),

/***/ "./src/language-client/typeDefinition.ts":
/*!***********************************************!*\
  !*** ./src/language-client/typeDefinition.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TypeDefinitionFeature = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* ---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ../languages */ \"./src/languages.ts\"));\nconst client_1 = __webpack_require__(/*! ./client */ \"./src/language-client/client.ts\");\nconst cv = tslib_1.__importStar(__webpack_require__(/*! ./utils/converter */ \"./src/language-client/utils/converter.ts\"));\nfunction ensure(target, key) {\n    if (target[key] === void 0) {\n        target[key] = {};\n    }\n    return target[key];\n}\nclass TypeDefinitionFeature extends client_1.TextDocumentFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.TypeDefinitionRequest.type);\n    }\n    fillClientCapabilities(capabilites) {\n        const typeDefinitionSupport = ensure(ensure(capabilites, 'textDocument'), 'typeDefinition');\n        typeDefinitionSupport.dynamicRegistration = true;\n        // typeDefinitionSupport.linkSupport = true\n    }\n    initialize(capabilities, documentSelector) {\n        const [id, options] = this.getRegistration(documentSelector, capabilities.typeDefinitionProvider);\n        if (!id || !options) {\n            return;\n        }\n        this.register(this.messages, { id, registerOptions: options });\n    }\n    registerLanguageProvider(options) {\n        const provider = {\n            provideTypeDefinition: (document, position, token) => {\n                const client = this._client;\n                const provideTypeDefinition = (document, position, token) => client.sendRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, cv.asTextDocumentPositionParams(document, position), token).then(res => res, error => {\n                    client.logFailedRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, error);\n                    return Promise.resolve(null);\n                });\n                const middleware = client.clientOptions.middleware;\n                return middleware.provideTypeDefinition\n                    ? middleware.provideTypeDefinition(document, position, token, provideTypeDefinition)\n                    : provideTypeDefinition(document, position, token);\n            }\n        };\n        return [languages_1.default.registerTypeDefinitionProvider(options.documentSelector, provider), provider];\n    }\n}\nexports.TypeDefinitionFeature = TypeDefinitionFeature;\n\n\n//# sourceURL=webpack://coc.nvim/./src/language-client/typeDefinition.ts?");

/***/ }),

/***/ "./src/language-client/utils/async.ts":
/*!********************************************!*\
  !*** ./src/language-client/utils/async.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Delayer = void 0;\n/**\n * A helper to delay execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD)\n * \t\tconst letters = []\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l)\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); })\n * \t\t}\n */\nclass Delayer {\n    constructor(defaultDelay) {\n        this.defaultDelay = defaultDelay;\n        this.timeout = null;\n        this.completionPromise = null;\n        this.doResolve = null;\n        this.task = null;\n    }\n    trigger(task, delay = this.defaultDelay) {\n        this.task = task;\n        this.cancelTimeout();\n        if (!this.completionPromise) {\n            this.completionPromise = new Promise((c, e) => {\n                this.doResolve = c;\n                this.doReject = e;\n            }).then(() => {\n                this.completionPromise = null;\n                this.doResolve = null;\n                const task = this.task;\n                this.task = null;\n                return task();\n            });\n        }\n        this.timeout = setTimeout(() => {\n            this.timeout = null;\n            this.doResolve(null);\n        }, delay);\n        return this.completionPromise;\n    }\n    isTriggered() {\n        return this.timeout !== null;\n    }\n    cancel() {\n        this.cancelTimeout();\n        if (this.completionPromise) {\n            this.doReject(new Error('Canceled'));\n            this.completionPromise = null;\n        }\n    }\n    cancelTimeout() {\n        if (this.timeout !== null) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n        }\n    }\n    dispose() {\n        this.cancelTimeout();\n    }\n}\nexports.Delayer = Delayer;\n\n\n//# sourceURL=webpack://coc.nvim/./src/language-client/utils/async.ts?");

/***/ }),

/***/ "./src/language-client/utils/converter.ts":
/*!************************************************!*\
  !*** ./src/language-client/utils/converter.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.asCodeLensParams = exports.asDocumentSymbolParams = exports.asReferenceParams = exports.asTextDocumentIdentifier = exports.asSignatureHelpParams = exports.asTextDocumentPositionParams = exports.asCompletionParams = exports.asUri = exports.asSaveTextDocumentParams = exports.asVersionedTextDocumentIdentifier = exports.asWillSaveTextDocumentParams = exports.asChangeTextDocumentParams = exports.asCloseTextDocumentParams = exports.convertToTextDocumentItem = exports.asLanguageIds = void 0;\nconst lodash_1 = __webpack_require__(/*! ../../util/lodash */ \"./src/util/lodash.ts\");\nfunction asLanguageIds(documentSelector) {\n    let res = documentSelector.map(filter => {\n        if (typeof filter == 'string') {\n            return filter;\n        }\n        return filter.language;\n    });\n    res = res.filter(s => s != null);\n    return res.length == 0 ? null : res;\n}\nexports.asLanguageIds = asLanguageIds;\nfunction convertToTextDocumentItem(document) {\n    return {\n        uri: document.uri,\n        languageId: document.languageId,\n        version: document.version,\n        text: document.getText()\n    };\n}\nexports.convertToTextDocumentItem = convertToTextDocumentItem;\nfunction asCloseTextDocumentParams(document) {\n    return {\n        textDocument: {\n            uri: document.uri\n        }\n    };\n}\nexports.asCloseTextDocumentParams = asCloseTextDocumentParams;\nfunction asChangeTextDocumentParams(document) {\n    let result = {\n        textDocument: {\n            uri: document.uri,\n            version: document.version\n        },\n        contentChanges: [{ text: document.getText() }]\n    };\n    return result;\n}\nexports.asChangeTextDocumentParams = asChangeTextDocumentParams;\nfunction asWillSaveTextDocumentParams(event) {\n    return {\n        textDocument: asVersionedTextDocumentIdentifier(event.document),\n        reason: event.reason\n    };\n}\nexports.asWillSaveTextDocumentParams = asWillSaveTextDocumentParams;\nfunction asVersionedTextDocumentIdentifier(textDocument) {\n    return {\n        uri: textDocument.uri,\n        version: textDocument.version\n    };\n}\nexports.asVersionedTextDocumentIdentifier = asVersionedTextDocumentIdentifier;\nfunction asSaveTextDocumentParams(document, includeText) {\n    let result = {\n        textDocument: asVersionedTextDocumentIdentifier(document)\n    };\n    if (includeText) {\n        result.text = document.getText();\n    }\n    return result;\n}\nexports.asSaveTextDocumentParams = asSaveTextDocumentParams;\nfunction asUri(resource) {\n    return resource.toString();\n}\nexports.asUri = asUri;\nfunction asCompletionParams(textDocument, position, context) {\n    return {\n        textDocument: {\n            uri: textDocument.uri,\n        },\n        position,\n        context: lodash_1.omit(context, ['option']),\n    };\n}\nexports.asCompletionParams = asCompletionParams;\nfunction asTextDocumentPositionParams(textDocument, position) {\n    return {\n        textDocument: {\n            uri: textDocument.uri,\n        },\n        position\n    };\n}\nexports.asTextDocumentPositionParams = asTextDocumentPositionParams;\nfunction asSignatureHelpParams(textDocument, position, context) {\n    return {\n        textDocument: asTextDocumentIdentifier(textDocument),\n        position,\n        context\n    };\n}\nexports.asSignatureHelpParams = asSignatureHelpParams;\nfunction asTextDocumentIdentifier(textDocument) {\n    return {\n        uri: textDocument.uri\n    };\n}\nexports.asTextDocumentIdentifier = asTextDocumentIdentifier;\nfunction asReferenceParams(textDocument, position, options) {\n    return {\n        textDocument: {\n            uri: textDocument.uri,\n        },\n        position,\n        context: { includeDeclaration: options.includeDeclaration }\n    };\n}\nexports.asReferenceParams = asReferenceParams;\nfunction asDocumentSymbolParams(textDocument) {\n    return {\n        textDocument: {\n            uri: textDocument.uri\n        }\n    };\n}\nexports.asDocumentSymbolParams = asDocumentSymbolParams;\nfunction asCodeLensParams(textDocument) {\n    return {\n        textDocument: {\n            uri: textDocument.uri\n        }\n    };\n}\nexports.asCodeLensParams = asCodeLensParams;\n\n\n//# sourceURL=webpack://coc.nvim/./src/language-client/utils/converter.ts?");

/***/ }),

/***/ "./src/language-client/utils/uuid.ts":
/*!*******************************************!*\
  !*** ./src/language-client/utils/uuid.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.generateUuid = void 0;\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nfunction generateUuid() {\n    return uuid_1.v4();\n}\nexports.generateUuid = generateUuid;\n\n\n//# sourceURL=webpack://coc.nvim/./src/language-client/utils/uuid.ts?");

/***/ }),

/***/ "./src/language-client/workspaceFolders.ts":
/*!*************************************************!*\
  !*** ./src/language-client/workspaceFolders.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WorkspaceFoldersFeature = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst UUID = tslib_1.__importStar(__webpack_require__(/*! ./utils/uuid */ \"./src/language-client/utils/uuid.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('language-client-workspaceFolder');\nfunction access(target, key) {\n    if (target === void 0) {\n        return undefined;\n    }\n    return target[key];\n}\nfunction arrayDiff(left, right) {\n    return left.filter(element => !right.includes(element));\n}\nclass WorkspaceFoldersFeature {\n    constructor(_client) {\n        this._client = _client;\n        this._listeners = new Map();\n    }\n    get messages() {\n        return vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type;\n    }\n    asProtocol(workspaceFolder) {\n        if (workspaceFolder === void 0) {\n            return null;\n        }\n        return { uri: workspaceFolder.uri, name: workspaceFolder.name };\n    }\n    fillInitializeParams(params) {\n        const folders = workspace_1.default.workspaceFolders;\n        this._initialFolders = folders;\n        if (folders === void 0) {\n            params.workspaceFolders = null;\n        }\n        else {\n            params.workspaceFolders = folders.map(folder => this.asProtocol(folder));\n        }\n        params.workspaceFolders = workspace_1.default.workspaceFolders;\n    }\n    fillClientCapabilities(capabilities) {\n        capabilities.workspace = capabilities.workspace || {};\n        capabilities.workspace.workspaceFolders = true;\n    }\n    initialize(capabilities) {\n        let client = this._client;\n        client.onRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type, (token) => {\n            let workspaceFolders = () => {\n                let folders = workspace_1.default.workspaceFolders;\n                if (folders === void 0) {\n                    return null;\n                }\n                let result = folders.map(folder => this.asProtocol(folder));\n                return result;\n            };\n            let middleware = client.clientOptions.middleware.workspace;\n            return middleware && middleware.workspaceFolders\n                ? middleware.workspaceFolders(token, workspaceFolders)\n                : workspaceFolders(token);\n        });\n        let value = access(access(access(capabilities, 'workspace'), 'workspaceFolders'), 'changeNotifications');\n        let id;\n        if (typeof value === 'string') {\n            id = value;\n        }\n        else if (value === true) {\n            id = UUID.generateUuid();\n        }\n        if (id) {\n            this.register(this.messages, {\n                id,\n                registerOptions: undefined\n            });\n        }\n    }\n    doSendEvent(addedFolders, removedFolders) {\n        let params = {\n            event: {\n                added: addedFolders.map(folder => this.asProtocol(folder)),\n                removed: removedFolders.map(folder => this.asProtocol(folder))\n            }\n        };\n        this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, params);\n    }\n    sendInitialEvent(currentWorkspaceFolders) {\n        if (this._initialFolders && currentWorkspaceFolders) {\n            const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);\n            const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);\n            if (added.length > 0 || removed.length > 0) {\n                this.doSendEvent(added, removed);\n            }\n        }\n        else if (this._initialFolders) {\n            this.doSendEvent([], this._initialFolders);\n        }\n        else if (currentWorkspaceFolders) {\n            this.doSendEvent(currentWorkspaceFolders, []);\n        }\n    }\n    register(_message, data) {\n        let id = data.id;\n        let client = this._client;\n        let disposable = workspace_1.default.onDidChangeWorkspaceFolders(event => {\n            let didChangeWorkspaceFolders = (event) => {\n                this.doSendEvent(event.added, event.removed);\n            };\n            let middleware = client.clientOptions.middleware.workspace;\n            middleware && middleware.didChangeWorkspaceFolders\n                ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders)\n                : didChangeWorkspaceFolders(event);\n        });\n        this._listeners.set(id, disposable);\n        this.sendInitialEvent(workspace_1.default.workspaceFolders);\n    }\n    unregister(id) {\n        let disposable = this._listeners.get(id);\n        if (disposable === void 0) {\n            return;\n        }\n        this._listeners.delete(id);\n        disposable.dispose();\n    }\n    dispose() {\n        for (let disposable of this._listeners.values()) {\n            disposable.dispose();\n        }\n        this._listeners.clear();\n    }\n}\nexports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;\n\n\n//# sourceURL=webpack://coc.nvim/./src/language-client/workspaceFolders.ts?");

/***/ }),

/***/ "./src/languages.ts":
/*!**************************!*\
  !*** ./src/languages.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst commands_1 = tslib_1.__importDefault(__webpack_require__(/*! ./commands */ \"./src/commands.ts\"));\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./diagnostic/manager */ \"./src/diagnostic/manager.ts\"));\nconst codeActionmanager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./provider/codeActionmanager */ \"./src/provider/codeActionmanager.ts\"));\nconst codeLensManager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./provider/codeLensManager */ \"./src/provider/codeLensManager.ts\"));\nconst declarationManager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./provider/declarationManager */ \"./src/provider/declarationManager.ts\"));\nconst definitionManager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./provider/definitionManager */ \"./src/provider/definitionManager.ts\"));\nconst documentColorManager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./provider/documentColorManager */ \"./src/provider/documentColorManager.ts\"));\nconst documentHighlightManager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./provider/documentHighlightManager */ \"./src/provider/documentHighlightManager.ts\"));\nconst documentLinkManager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./provider/documentLinkManager */ \"./src/provider/documentLinkManager.ts\"));\nconst documentSymbolManager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./provider/documentSymbolManager */ \"./src/provider/documentSymbolManager.ts\"));\nconst foldingRangeManager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./provider/foldingRangeManager */ \"./src/provider/foldingRangeManager.ts\"));\nconst formatManager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./provider/formatManager */ \"./src/provider/formatManager.ts\"));\nconst formatRangeManager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./provider/formatRangeManager */ \"./src/provider/formatRangeManager.ts\"));\nconst hoverManager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./provider/hoverManager */ \"./src/provider/hoverManager.ts\"));\nconst implementationManager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./provider/implementationManager */ \"./src/provider/implementationManager.ts\"));\nconst onTypeFormatManager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./provider/onTypeFormatManager */ \"./src/provider/onTypeFormatManager.ts\"));\nconst selectionRangeManager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./provider/selectionRangeManager */ \"./src/provider/selectionRangeManager.ts\"));\nconst referenceManager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./provider/referenceManager */ \"./src/provider/referenceManager.ts\"));\nconst renameManager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./provider/renameManager */ \"./src/provider/renameManager.ts\"));\nconst signatureManager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./provider/signatureManager */ \"./src/provider/signatureManager.ts\"));\nconst typeDefinitionManager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./provider/typeDefinitionManager */ \"./src/provider/typeDefinitionManager.ts\"));\nconst workspaceSymbolsManager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./provider/workspaceSymbolsManager */ \"./src/provider/workspaceSymbolsManager.ts\"));\nconst manager_2 = tslib_1.__importDefault(__webpack_require__(/*! ./snippets/manager */ \"./src/snippets/manager.ts\"));\nconst sources_1 = tslib_1.__importDefault(__webpack_require__(/*! ./sources */ \"./src/sources.ts\"));\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/types.ts\");\nconst complete = tslib_1.__importStar(__webpack_require__(/*! ./util/complete */ \"./src/util/complete.ts\"));\nconst position_1 = __webpack_require__(/*! ./util/position */ \"./src/util/position.ts\");\nconst string_1 = __webpack_require__(/*! ./util/string */ \"./src/util/string.ts\");\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ./window */ \"./src/window.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ./workspace */ \"./src/workspace.ts\"));\nconst logger = __webpack_require__(/*! ./util/logger */ \"./src/util/logger.ts\")('languages');\nclass Languages {\n    constructor() {\n        this.onTypeFormatManager = new onTypeFormatManager_1.default();\n        this.documentLinkManager = new documentLinkManager_1.default();\n        this.documentColorManager = new documentColorManager_1.default();\n        this.foldingRangeManager = new foldingRangeManager_1.default();\n        this.renameManager = new renameManager_1.default();\n        this.formatManager = new formatManager_1.default();\n        this.codeActionManager = new codeActionmanager_1.default();\n        this.workspaceSymbolsManager = new workspaceSymbolsManager_1.default();\n        this.formatRangeManager = new formatRangeManager_1.default();\n        this.hoverManager = new hoverManager_1.default();\n        this.signatureManager = new signatureManager_1.default();\n        this.documentSymbolManager = new documentSymbolManager_1.default();\n        this.documentHighlightManager = new documentHighlightManager_1.default();\n        this.definitionManager = new definitionManager_1.default();\n        this.declarationManager = new declarationManager_1.default();\n        this.typeDefinitionManager = new typeDefinitionManager_1.default();\n        this.referenceManager = new referenceManager_1.default();\n        this.implementationManager = new implementationManager_1.default();\n        this.codeLensManager = new codeLensManager_1.default();\n        this.selectionRangeManager = new selectionRangeManager_1.default();\n        this.cancelTokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n    }\n    init() {\n        this.loadCompleteConfig();\n        workspace_1.default.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('suggest')) {\n                this.loadCompleteConfig();\n            }\n        }, this);\n    }\n    get nvim() {\n        return workspace_1.default.nvim;\n    }\n    get detailField() {\n        let { detailField, floatEnable } = this.completeConfig;\n        if (detailField == 'preview' && (!floatEnable || !workspace_1.default.floatSupported)) {\n            return 'menu';\n        }\n        return 'preview';\n    }\n    loadCompleteConfig() {\n        let suggest = workspace_1.default.getConfiguration('suggest');\n        let labels = suggest.get('completionItemKindLabels', {});\n        this.completionItemKindMap = new Map([\n            [vscode_languageserver_protocol_1.CompletionItemKind.Text, labels['text'] || 'v'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Method, labels['method'] || 'f'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Function, labels['function'] || 'f'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Constructor, typeof labels['constructor'] == 'function' ? 'f' : labels['con' + 'structor']],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Field, labels['field'] || 'm'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Variable, labels['variable'] || 'v'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Class, labels['class'] || 'C'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Interface, labels['interface'] || 'I'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Module, labels['module'] || 'M'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Property, labels['property'] || 'm'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Unit, labels['unit'] || 'U'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Value, labels['value'] || 'v'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Enum, labels['enum'] || 'E'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Keyword, labels['keyword'] || 'k'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Snippet, labels['snippet'] || 'S'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Color, labels['color'] || 'v'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.File, labels['file'] || 'F'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Reference, labels['reference'] || 'r'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Folder, labels['folder'] || 'F'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.EnumMember, labels['enumMember'] || 'm'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Constant, labels['constant'] || 'v'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Struct, labels['struct'] || 'S'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Event, labels['event'] || 'E'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.Operator, labels['operator'] || 'O'],\n            [vscode_languageserver_protocol_1.CompletionItemKind.TypeParameter, labels['typeParameter'] || 'T'],\n        ]);\n        // let useFloat = workspace.floatSupported && suggest.get\n        this.completeConfig = {\n            defaultKindText: labels['default'] || '',\n            priority: suggest.get('languageSourcePriority', 99),\n            echodocSupport: suggest.get('echodocSupport', false),\n            detailField: suggest.get('detailField', 'preview'),\n            detailMaxLength: suggest.get('detailMaxLength', 100),\n            floatEnable: suggest.get('floatEnable', true),\n            invalidInsertCharacters: suggest.get('invalidInsertCharacters', ['(', '<', '{', '[', '\\r', '\\n']),\n        };\n    }\n    hasFormatProvider(doc) {\n        if (this.formatManager.hasProvider(doc)) {\n            return true;\n        }\n        if (this.formatRangeManager.hasProvider(doc)) {\n            return true;\n        }\n        return false;\n    }\n    registerOnTypeFormattingEditProvider(selector, provider, triggerCharacters) {\n        return this.onTypeFormatManager.register(selector, provider, triggerCharacters);\n    }\n    registerCompletionItemProvider(name, shortcut, languageIds, provider, triggerCharacters = [], priority, allCommitCharacters) {\n        languageIds = typeof languageIds == 'string' ? [languageIds] : languageIds;\n        let source = this.createCompleteSource(name, shortcut, provider, languageIds, triggerCharacters, allCommitCharacters || [], priority);\n        sources_1.default.addSource(source);\n        logger.debug('created service source', name);\n        return {\n            dispose: () => {\n                sources_1.default.removeSource(source);\n            }\n        };\n    }\n    registerCodeActionProvider(selector, provider, clientId, codeActionKinds) {\n        return this.codeActionManager.register(selector, provider, clientId, codeActionKinds);\n    }\n    registerHoverProvider(selector, provider) {\n        return this.hoverManager.register(selector, provider);\n    }\n    registerSelectionRangeProvider(selector, provider) {\n        return this.selectionRangeManager.register(selector, provider);\n    }\n    registerSignatureHelpProvider(selector, provider, triggerCharacters) {\n        return this.signatureManager.register(selector, provider, triggerCharacters);\n    }\n    registerDocumentSymbolProvider(selector, provider) {\n        return this.documentSymbolManager.register(selector, provider);\n    }\n    registerFoldingRangeProvider(selector, provider) {\n        return this.foldingRangeManager.register(selector, provider);\n    }\n    registerDocumentHighlightProvider(selector, provider) {\n        return this.documentHighlightManager.register(selector, provider);\n    }\n    registerCodeLensProvider(selector, provider) {\n        return this.codeLensManager.register(selector, provider);\n    }\n    registerDocumentLinkProvider(selector, provider) {\n        return this.documentLinkManager.register(selector, provider);\n    }\n    registerDocumentColorProvider(selector, provider) {\n        return this.documentColorManager.register(selector, provider);\n    }\n    registerDefinitionProvider(selector, provider) {\n        return this.definitionManager.register(selector, provider);\n    }\n    registerDeclarationProvider(selector, provider) {\n        return this.declarationManager.register(selector, provider);\n    }\n    registerTypeDefinitionProvider(selector, provider) {\n        return this.typeDefinitionManager.register(selector, provider);\n    }\n    registerImplementationProvider(selector, provider) {\n        return this.implementationManager.register(selector, provider);\n    }\n    registerReferencesProvider(selector, provider) {\n        return this.referenceManager.register(selector, provider);\n    }\n    registerRenameProvider(selector, provider) {\n        return this.renameManager.register(selector, provider);\n    }\n    registerWorkspaceSymbolProvider(provider) {\n        if (arguments.length > 1 && typeof arguments[1].provideWorkspaceSymbols === 'function') {\n            provider = arguments[1];\n        }\n        return this.workspaceSymbolsManager.register(provider);\n    }\n    registerDocumentFormatProvider(selector, provider, priority = 0) {\n        return this.formatManager.register(selector, provider, priority);\n    }\n    registerDocumentRangeFormatProvider(selector, provider, priority = 0) {\n        return this.formatRangeManager.register(selector, provider, priority);\n    }\n    shouldTriggerSignatureHelp(document, triggerCharacter) {\n        return this.signatureManager.shouldTrigger(document, triggerCharacter);\n    }\n    async getHover(document, position, token) {\n        return await this.hoverManager.provideHover(document, position, token);\n    }\n    async getSignatureHelp(document, position, token, context) {\n        return await this.signatureManager.provideSignatureHelp(document, position, token, context);\n    }\n    async getDefinition(document, position, token) {\n        if (!this.definitionManager.hasProvider(document))\n            return null;\n        return await this.definitionManager.provideDefinition(document, position, token);\n    }\n    async getDeclaration(document, position, token) {\n        if (!this.declarationManager.hasProvider(document))\n            return null;\n        return await this.declarationManager.provideDeclaration(document, position, token);\n    }\n    async getTypeDefinition(document, position, token) {\n        if (!this.typeDefinitionManager.hasProvider(document))\n            return null;\n        return await this.typeDefinitionManager.provideTypeDefinition(document, position, token);\n    }\n    async getImplementation(document, position, token) {\n        if (!this.implementationManager.hasProvider(document))\n            return null;\n        return await this.implementationManager.provideReferences(document, position, token);\n    }\n    async getReferences(document, context, position, token) {\n        if (!this.referenceManager.hasProvider(document))\n            return null;\n        return await this.referenceManager.provideReferences(document, position, context, token);\n    }\n    async getDocumentSymbol(document, token) {\n        return await this.documentSymbolManager.provideDocumentSymbols(document, token);\n    }\n    async getSelectionRanges(document, positions, token) {\n        return await this.selectionRangeManager.provideSelectionRanges(document, positions, token);\n    }\n    async getWorkspaceSymbols(query, token) {\n        query = query || '';\n        return await this.workspaceSymbolsManager.provideWorkspaceSymbols(query, token);\n    }\n    async resolveWorkspaceSymbol(symbol, token) {\n        return await this.workspaceSymbolsManager.resolveWorkspaceSymbol(symbol, token);\n    }\n    async prepareRename(document, position, token) {\n        return await this.renameManager.prepareRename(document, position, token);\n    }\n    async provideRenameEdits(document, position, newName, token) {\n        return await this.renameManager.provideRenameEdits(document, position, newName, token);\n    }\n    async provideDocumentFormattingEdits(document, options, token) {\n        if (!this.formatManager.hasProvider(document)) {\n            let hasRangeFormater = this.formatRangeManager.hasProvider(document);\n            if (!hasRangeFormater)\n                return null;\n            let end = document.positionAt(document.getText().length);\n            let range = vscode_languageserver_protocol_1.Range.create(vscode_languageserver_protocol_1.Position.create(0, 0), end);\n            return await this.provideDocumentRangeFormattingEdits(document, range, options, token);\n        }\n        return await this.formatManager.provideDocumentFormattingEdits(document, options, token);\n    }\n    async provideDocumentRangeFormattingEdits(document, range, options, token) {\n        if (!this.formatRangeManager.hasProvider(document))\n            return null;\n        return await this.formatRangeManager.provideDocumentRangeFormattingEdits(document, range, options, token);\n    }\n    async getCodeActions(document, range, context, token) {\n        return await this.codeActionManager.provideCodeActions(document, range, context, token);\n    }\n    async getDocumentHighLight(document, position, token) {\n        return await this.documentHighlightManager.provideDocumentHighlights(document, position, token);\n    }\n    async getDocumentLinks(document, token) {\n        if (!this.documentLinkManager.hasProvider(document)) {\n            return null;\n        }\n        return (await this.documentLinkManager.provideDocumentLinks(document, token)) || [];\n    }\n    async resolveDocumentLink(link) {\n        return await this.documentLinkManager.resolveDocumentLink(link, this.token);\n    }\n    async provideDocumentColors(document, token) {\n        return await this.documentColorManager.provideDocumentColors(document, token);\n    }\n    async provideFoldingRanges(document, context, token) {\n        if (!this.foldingRangeManager.hasProvider(document)) {\n            return null;\n        }\n        return await this.foldingRangeManager.provideFoldingRanges(document, context, token);\n    }\n    async provideColorPresentations(color, document, token) {\n        return await this.documentColorManager.provideColorPresentations(color, document, token);\n    }\n    async getCodeLens(document, token) {\n        return await this.codeLensManager.provideCodeLenses(document, token);\n    }\n    async resolveCodeLens(codeLens, token) {\n        return await this.codeLensManager.resolveCodeLens(codeLens, token);\n    }\n    async provideDocumentOnTypeEdits(character, document, position, token) {\n        return this.onTypeFormatManager.onCharacterType(character, document, position, token);\n    }\n    hasOnTypeProvider(character, document) {\n        return this.onTypeFormatManager.getProvider(document, character) != null;\n    }\n    hasProvider(id, document) {\n        switch (id) {\n            case 'rename':\n                return this.renameManager.hasProvider(document);\n            case 'onTypeEdit':\n                return this.onTypeFormatManager.hasProvider(document);\n            case 'documentLink':\n                return this.documentLinkManager.hasProvider(document);\n            case 'documentColor':\n                return this.documentColorManager.hasProvider(document);\n            case 'foldingRange':\n                return this.foldingRangeManager.hasProvider(document);\n            case 'format':\n                return this.formatManager.hasProvider(document);\n            case 'codeAction':\n                return this.codeActionManager.hasProvider(document);\n            case 'workspaceSymbols':\n                return this.workspaceSymbolsManager.hasProvider();\n            case 'formatRange':\n                return this.formatRangeManager.hasProvider(document);\n            case 'hover':\n                return this.hoverManager.hasProvider(document);\n            case 'signature':\n                return this.signatureManager.hasProvider(document);\n            case 'documentSymbol':\n                return this.documentSymbolManager.hasProvider(document);\n            case 'documentHighlight':\n                return this.documentHighlightManager.hasProvider(document);\n            case 'definition':\n                return this.definitionManager.hasProvider(document);\n            case 'declaration':\n                return this.declarationManager.hasProvider(document);\n            case 'typeDefinition':\n                return this.typeDefinitionManager.hasProvider(document);\n            case 'reference':\n                return this.referenceManager.hasProvider(document);\n            case 'implementation':\n                return this.implementationManager.hasProvider(document);\n            case 'codeLens':\n                return this.codeLensManager.hasProvider(document);\n            case 'selectionRange':\n                return this.selectionRangeManager.hasProvider(document);\n            default:\n                throw new Error(`${id} not supported.`);\n        }\n    }\n    dispose() {\n        // noop\n    }\n    createDiagnosticCollection(owner) {\n        return manager_1.default.create(owner);\n    }\n    createCompleteSource(name, shortcut, provider, languageIds, triggerCharacters, allCommitCharacters, priority) {\n        // track them for resolve\n        let completeItems = [];\n        // line used for TextEdit\n        let hasResolve = typeof provider.resolveCompletionItem === 'function';\n        priority = priority == null ? this.completeConfig.priority : priority;\n        // index set of resolved items\n        let resolvedIndexes = new Set();\n        let source = {\n            name,\n            priority,\n            shortcut,\n            enable: true,\n            sourceType: types_1.SourceType.Service,\n            filetypes: languageIds,\n            triggerCharacters: triggerCharacters || [],\n            toggle: () => {\n                source.enable = !source.enable;\n            },\n            doComplete: async (opt, token) => {\n                let { triggerCharacter, bufnr } = opt;\n                resolvedIndexes = new Set();\n                let isTrigger = triggerCharacters && triggerCharacters.includes(triggerCharacter);\n                let triggerKind = vscode_languageserver_protocol_1.CompletionTriggerKind.Invoked;\n                if (opt.triggerForInComplete) {\n                    triggerKind = vscode_languageserver_protocol_1.CompletionTriggerKind.TriggerForIncompleteCompletions;\n                }\n                else if (isTrigger) {\n                    triggerKind = vscode_languageserver_protocol_1.CompletionTriggerKind.TriggerCharacter;\n                }\n                if (token.isCancellationRequested)\n                    return null;\n                let position = complete.getPosition(opt);\n                let context = { triggerKind, option: opt };\n                if (isTrigger)\n                    context.triggerCharacter = triggerCharacter;\n                let result;\n                try {\n                    let doc = workspace_1.default.getDocument(bufnr);\n                    result = await Promise.resolve(provider.provideCompletionItems(doc.textDocument, position, token, context));\n                }\n                catch (e) {\n                    // don't disturb user\n                    logger.error(`Complete \"${name}\" error:`, e);\n                    return null;\n                }\n                if (!result || token.isCancellationRequested)\n                    return null;\n                completeItems = Array.isArray(result) ? result : result.items;\n                if (!completeItems || completeItems.length == 0)\n                    return null;\n                let startcol = this.getStartColumn(opt.line, completeItems);\n                let option = Object.assign({}, opt);\n                let prefix;\n                if (startcol != null) {\n                    if (startcol < option.col) {\n                        prefix = string_1.byteSlice(opt.line, startcol, option.col);\n                    }\n                    option.col = startcol;\n                }\n                let items = completeItems.map((o, index) => {\n                    let item = this.convertVimCompleteItem(o, shortcut, option, prefix);\n                    item.index = index;\n                    return item;\n                });\n                return {\n                    startcol,\n                    isIncomplete: !!result.isIncomplete,\n                    items\n                };\n            },\n            onCompleteResolve: async (item, token) => {\n                let resolving = completeItems[item.index];\n                if (!resolving)\n                    return;\n                if (hasResolve && !resolvedIndexes.has(item.index)) {\n                    let resolved = await Promise.resolve(provider.resolveCompletionItem(resolving, token));\n                    if (token.isCancellationRequested)\n                        return;\n                    resolvedIndexes.add(item.index);\n                    if (resolved)\n                        Object.assign(resolving, resolved);\n                }\n                if (item.documentation == null) {\n                    let { documentation, detail } = resolving;\n                    if (!documentation && !detail)\n                        return;\n                    let docs = [];\n                    if (detail && !item.detailShown && detail != item.word) {\n                        detail = detail.replace(/\\n\\s*/g, ' ');\n                        if (detail.length) {\n                            let isText = /^[\\w-\\s.,\\t]+$/.test(detail);\n                            let filetype = isText ? 'txt' : await workspace_1.default.nvim.eval('&filetype');\n                            docs.push({ filetype: isText ? 'txt' : filetype, content: detail });\n                        }\n                    }\n                    if (documentation) {\n                        if (typeof documentation == 'string') {\n                            docs.push({\n                                filetype: 'markdown',\n                                content: documentation\n                            });\n                        }\n                        else if (documentation.value) {\n                            docs.push({\n                                filetype: documentation.kind == 'markdown' ? 'markdown' : 'txt',\n                                content: documentation.value\n                            });\n                        }\n                    }\n                    item.documentation = docs;\n                }\n            },\n            onCompleteDone: async (vimItem, opt) => {\n                let item = completeItems[vimItem.index];\n                if (!item)\n                    return;\n                let line = opt.linenr - 1;\n                if (item.insertText != null && !item.textEdit) {\n                    item.textEdit = {\n                        range: vscode_languageserver_protocol_1.Range.create(line, opt.col, line, opt.colnr - 1),\n                        newText: item.insertText\n                    };\n                }\n                if (vimItem.line)\n                    Object.assign(opt, { line: vimItem.line });\n                try {\n                    let isSnippet = await this.applyTextEdit(item, opt);\n                    let { additionalTextEdits } = item;\n                    if (additionalTextEdits && item.textEdit) {\n                        let r = item.textEdit.range;\n                        additionalTextEdits = additionalTextEdits.filter(edit => {\n                            if (position_1.rangeOverlap(r, edit.range)) {\n                                logger.error('Filtered overlap additionalTextEdit:', edit);\n                                return false;\n                            }\n                            return true;\n                        });\n                    }\n                    await this.applyAdditionalEdits(additionalTextEdits, opt.bufnr, isSnippet);\n                    if (isSnippet)\n                        await manager_2.default.selectCurrentPlaceholder();\n                    if (item.command)\n                        commands_1.default.execute(item.command);\n                }\n                catch (e) {\n                    logger.error('Error on CompleteDone:', e);\n                }\n            },\n            shouldCommit: (item, character) => {\n                let completeItem = completeItems[item.index];\n                if (!completeItem)\n                    return false;\n                let commitCharacters = completeItem.commitCharacters || allCommitCharacters;\n                return commitCharacters.includes(character);\n            }\n        };\n        return source;\n    }\n    get token() {\n        this.cancelTokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n        return this.cancelTokenSource.token;\n    }\n    async applyTextEdit(item, option) {\n        let { nvim } = this;\n        let { textEdit } = item;\n        if (!textEdit)\n            return false;\n        let { line, bufnr, linenr } = option;\n        let doc = workspace_1.default.getDocument(bufnr);\n        if (!doc)\n            return false;\n        let { range, newText } = textEdit;\n        let isSnippet = item.insertTextFormat === vscode_languageserver_protocol_1.InsertTextFormat.Snippet;\n        // replace inserted word\n        let start = line.substr(0, range.start.character);\n        let end = line.substr(range.end.character);\n        if (isSnippet) {\n            let currline = doc.getline(linenr - 1);\n            let endCharacter = currline.length - end.length;\n            let r = vscode_languageserver_protocol_1.Range.create(linenr - 1, range.start.character, linenr - 1, endCharacter);\n            // can't select, since additionalTextEdits would break selection\n            return await manager_2.default.insertSnippet(newText, false, r);\n        }\n        let newLines = `${start}${newText}${end}`.split('\\n');\n        if (newLines.length == 1) {\n            await nvim.call('coc#util#setline', [linenr, newLines[0]]);\n            await window_1.default.moveTo(vscode_languageserver_protocol_1.Position.create(linenr - 1, (start + newText).length));\n        }\n        else {\n            let buffer = nvim.createBuffer(bufnr);\n            await buffer.setLines(newLines, {\n                start: linenr - 1,\n                end: linenr,\n                strictIndexing: false\n            });\n            let line = linenr - 1 + newLines.length - 1;\n            let character = newLines[newLines.length - 1].length - end.length;\n            await window_1.default.moveTo({ line, character });\n        }\n        return false;\n    }\n    async applyAdditionalEdits(textEdits, bufnr, snippet) {\n        if (!textEdits || textEdits.length == 0)\n            return;\n        let document = workspace_1.default.getDocument(bufnr);\n        if (!document)\n            return;\n        await document.patchChange(true);\n        // move cursor after edit\n        let changed = null;\n        let pos = await window_1.default.getCursorPosition();\n        if (!snippet)\n            changed = position_1.getChangedFromEdits(pos, textEdits);\n        await document.applyEdits(textEdits);\n        if (changed)\n            await window_1.default.moveTo(vscode_languageserver_protocol_1.Position.create(pos.line + changed.line, pos.character + changed.character));\n    }\n    getStartColumn(line, items) {\n        let first = items[0];\n        if (!first.textEdit)\n            return null;\n        let { range, newText } = first.textEdit;\n        let { character } = range.start;\n        if (newText.length < range.end.character - character) {\n            return null;\n        }\n        for (let i = 0; i < 10; i++) {\n            let o = items[i];\n            if (!o)\n                break;\n            if (!o.textEdit)\n                return null;\n            if (o.textEdit.range.start.character !== character)\n                return null;\n        }\n        return string_1.byteIndex(line, character);\n    }\n    convertVimCompleteItem(item, shortcut, opt, prefix) {\n        let { echodocSupport, detailMaxLength, invalidInsertCharacters } = this.completeConfig;\n        let { detailField } = this;\n        let hasAdditionalEdit = item.additionalTextEdits && item.additionalTextEdits.length > 0;\n        let isSnippet = item.insertTextFormat === vscode_languageserver_protocol_1.InsertTextFormat.Snippet || hasAdditionalEdit;\n        let label = item.label.trim();\n        let obj = {\n            word: complete.getWord(item, opt, invalidInsertCharacters),\n            abbr: label,\n            menu: `[${shortcut}]`,\n            kind: complete.completionKindString(item.kind, this.completionItemKindMap, this.completeConfig.defaultKindText),\n            sortText: item.sortText || null,\n            sourceScore: item['score'] || null,\n            filterText: item.filterText || label,\n            isSnippet,\n            dup: item.data && item.data.dup == 0 ? 0 : 1\n        };\n        if (prefix) {\n            if (!obj.filterText.startsWith(prefix)) {\n                if (item.textEdit && item.textEdit.newText.startsWith(prefix)) {\n                    obj.filterText = item.textEdit.newText.split(/\\n/)[0];\n                }\n                else {\n                    obj.filterText = `${prefix}${obj.filterText}`;\n                }\n            }\n            if (!item.textEdit && !obj.word.startsWith(prefix)) {\n                // fix remains completeItem that should not change startcol\n                obj.word = `${prefix}${obj.word}`;\n            }\n        }\n        if (item && item.detail && detailField != 'preview') {\n            let detail = item.detail.replace(/\\n\\s*/g, ' ');\n            if (string_1.byteLength(detail) < detailMaxLength) {\n                if (detailField == 'menu') {\n                    obj.menu = `${detail} ${obj.menu}`;\n                }\n                else if (detailField == 'abbr') {\n                    obj.abbr = `${obj.abbr} - ${detail}`;\n                }\n                obj.detailShown = 1;\n            }\n        }\n        if (item.documentation) {\n            obj.info = typeof item.documentation == 'string' ? item.documentation : item.documentation.value;\n        }\n        else {\n            obj.info = '';\n        }\n        if (obj.word == '')\n            obj.empty = 1;\n        if (item.textEdit)\n            obj.line = opt.line;\n        if (item.kind == vscode_languageserver_protocol_1.CompletionItemKind.Folder && !obj.abbr.endsWith('/')) {\n            obj.abbr = obj.abbr + '/';\n        }\n        if (echodocSupport && item.kind >= 2 && item.kind <= 4) {\n            let fields = [item.detail || '', obj.abbr, obj.word];\n            for (let s of fields) {\n                if (s.includes('(')) {\n                    obj.signature = s;\n                    break;\n                }\n            }\n        }\n        if (item.preselect)\n            obj.preselect = true;\n        item.data = item.data || {};\n        if (item.data.optional)\n            obj.abbr = obj.abbr + '?';\n        return obj;\n    }\n}\nexports.default = new Languages();\n\n\n//# sourceURL=webpack://coc.nvim/./src/languages.ts?");

/***/ }),

/***/ "./src/list/basic.ts":
/*!***************************!*\
  !*** ./src/list/basic.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst fs_1 = tslib_1.__importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst readline_1 = tslib_1.__importDefault(__webpack_require__(/*! readline */ \"readline\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst fs_2 = __webpack_require__(/*! ../util/fs */ \"./src/util/fs.ts\");\nconst position_1 = __webpack_require__(/*! ../util/position */ \"./src/util/position.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst commandTask_1 = tslib_1.__importDefault(__webpack_require__(/*! ./commandTask */ \"./src/list/commandTask.ts\"));\nconst configuration_1 = tslib_1.__importDefault(__webpack_require__(/*! ./configuration */ \"./src/list/configuration.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('list-basic');\nclass BasicList {\n    constructor(nvim) {\n        this.nvim = nvim;\n        this.defaultAction = 'open';\n        this.actions = [];\n        this.options = [];\n        this.disposables = [];\n        this.config = new configuration_1.default();\n    }\n    get alignColumns() {\n        return this.config.get('alignColumns', false);\n    }\n    get hlGroup() {\n        return this.config.get('previewHighlightGroup', 'Search');\n    }\n    get previewHeight() {\n        return this.config.get('maxPreviewHeight', 12);\n    }\n    get splitRight() {\n        return this.config.get('previewSplitRight', false);\n    }\n    parseArguments(args) {\n        if (!this.optionMap) {\n            this.optionMap = new Map();\n            for (let opt of this.options) {\n                let parts = opt.name.split(/,\\s*/g).map(s => s.replace(/\\s+.*/g, ''));\n                let name = opt.key ? opt.key : parts[parts.length - 1].replace(/^-/, '');\n                for (let p of parts) {\n                    this.optionMap.set(p, { name, hasValue: opt.hasValue });\n                }\n            }\n        }\n        let res = {};\n        for (let i = 0; i < args.length; i++) {\n            let arg = args[i];\n            let def = this.optionMap.get(arg);\n            if (!def) {\n                logger.error(`Option \"${arg}\" of \"${this.name}\" not found`);\n                continue;\n            }\n            let value = true;\n            if (def.hasValue) {\n                value = args[i + 1] || '';\n                i = i + 1;\n            }\n            res[def.name] = value;\n        }\n        return res;\n    }\n    /**\n     * Get configuration of current list\n     */\n    getConfig() {\n        return workspace_1.default.getConfiguration(`list.source.${this.name}`);\n    }\n    addAction(name, fn, options) {\n        this.createAction(Object.assign({\n            name,\n            execute: fn\n        }, options || {}));\n    }\n    addMultipleAction(name, fn, options) {\n        this.createAction(Object.assign({\n            name,\n            multiple: true,\n            execute: fn\n        }, options || {}));\n    }\n    createCommandTask(opt) {\n        return new commandTask_1.default(opt);\n    }\n    addLocationActions() {\n        this.createAction({\n            name: 'preview',\n            execute: async (item, context) => {\n                let loc = await this.convertLocation(item.location);\n                await this.previewLocation(loc, context);\n            }\n        });\n        let { nvim } = this;\n        this.createAction({\n            name: 'quickfix',\n            multiple: true,\n            execute: async (items) => {\n                let quickfixItems = await Promise.all(items.map(item => this.convertLocation(item.location).then(loc => workspace_1.default.getQuickfixItem(loc))));\n                await nvim.call('setqflist', [quickfixItems]);\n                let openCommand = await nvim.getVar('coc_quickfix_open_command');\n                nvim.command(typeof openCommand === 'string' ? openCommand : 'copen', true);\n            }\n        });\n        for (let name of ['open', 'tabe', 'drop', 'vsplit', 'split']) {\n            this.createAction({\n                name,\n                execute: async (item) => {\n                    await this.jumpTo(item.location, name == 'open' ? null : name);\n                }\n            });\n        }\n    }\n    async convertLocation(location) {\n        if (typeof location == 'string')\n            return vscode_languageserver_protocol_1.Location.create(location, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0));\n        if (vscode_languageserver_protocol_1.Location.is(location))\n            return location;\n        let u = vscode_uri_1.URI.parse(location.uri);\n        if (u.scheme != 'file')\n            return vscode_languageserver_protocol_1.Location.create(location.uri, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0));\n        const rl = readline_1.default.createInterface({\n            input: fs_1.default.createReadStream(u.fsPath, { encoding: 'utf8' }),\n        });\n        let match = location.line;\n        let n = 0;\n        let resolved = false;\n        let line = await new Promise(resolve => {\n            rl.on('line', line => {\n                if (resolved)\n                    return;\n                if (line.includes(match)) {\n                    rl.removeAllListeners();\n                    rl.close();\n                    resolved = true;\n                    resolve(line);\n                    return;\n                }\n                n = n + 1;\n            });\n            rl.on('error', e => {\n                this.nvim.errWriteLine(`Read ${u.fsPath} error: ${e.message}`);\n                resolve(null);\n            });\n        });\n        if (line != null) {\n            let character = location.text ? line.indexOf(location.text) : 0;\n            if (character == 0)\n                character = line.match(/^\\s*/)[0].length;\n            let end = vscode_languageserver_protocol_1.Position.create(n, character + (location.text ? location.text.length : 0));\n            return vscode_languageserver_protocol_1.Location.create(location.uri, vscode_languageserver_protocol_1.Range.create(vscode_languageserver_protocol_1.Position.create(n, character), end));\n        }\n        return vscode_languageserver_protocol_1.Location.create(location.uri, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0));\n    }\n    async jumpTo(location, command) {\n        if (typeof location == 'string') {\n            await workspace_1.default.jumpTo(location, null, command);\n            return;\n        }\n        let { range, uri } = await this.convertLocation(location);\n        let position = range.start;\n        if (position.line == 0 && position.character == 0 && position_1.comparePosition(position, range.end) == 0) {\n            // allow plugin that remember position.\n            position = null;\n        }\n        await workspace_1.default.jumpTo(uri, position, command);\n    }\n    createAction(action) {\n        let { name } = action;\n        let idx = this.actions.findIndex(o => o.name == name);\n        // allow override\n        if (idx !== -1)\n            this.actions.splice(idx, 1);\n        this.actions.push(action);\n    }\n    async previewLocation(location, context) {\n        if (!context.listWindow)\n            return;\n        let { nvim } = this;\n        let { uri, range } = location;\n        let doc = workspace_1.default.getDocument(location.uri);\n        let u = vscode_uri_1.URI.parse(uri);\n        let lines = [];\n        if (doc) {\n            lines = doc.getLines();\n        }\n        else if (u.scheme == 'file') {\n            try {\n                let content = await fs_2.readFile(u.fsPath, 'utf8');\n                lines = content.split(/\\r?\\n/);\n            }\n            catch (e) {\n                [`Error on read file ${u.fsPath}`, e.message];\n            }\n        }\n        let config = {\n            winid: context.window.id,\n            range: position_1.emptyRange(range) ? null : range,\n            lnum: range.start.line + 1,\n            name: u.scheme == 'file' ? u.fsPath : uri,\n            filetype: doc ? doc.filetype : this.getFiletype(u.fsPath),\n            position: context.options.position,\n            maxHeight: this.previewHeight,\n            splitRight: this.splitRight,\n            hlGroup: this.hlGroup,\n            scheme: u.scheme,\n        };\n        await nvim.call('coc#list#preview', [lines, config]);\n        if (workspace_1.default.isVim)\n            nvim.command('redraw', true);\n    }\n    async preview(options, context) {\n        let { nvim } = this;\n        let { bufname, filetype, range, lines, lnum } = options;\n        let config = {\n            winid: context.window.id,\n            lnum: range ? range.start.line + 1 : lnum || 1,\n            filetype: filetype || 'txt',\n            position: context.options.position,\n            maxHeight: this.previewHeight,\n            splitRight: this.splitRight,\n            hlGroup: this.hlGroup,\n        };\n        if (bufname)\n            config.name = bufname;\n        if (range)\n            config.range = range;\n        await nvim.call('coc#list#preview', [lines, config]);\n        if (workspace_1.default.isVim)\n            nvim.command('redraw', true);\n    }\n    doHighlight() {\n        // noop\n    }\n    dispose() {\n        util_1.disposeAll(this.disposables);\n    }\n    /**\n     * Get filetype by check same extension name buffer.\n     */\n    getFiletype(filepath) {\n        let extname = path_1.default.extname(filepath);\n        if (!extname)\n            return '';\n        for (let doc of workspace_1.default.documents) {\n            let fsPath = vscode_uri_1.URI.parse(doc.uri).fsPath;\n            if (path_1.default.extname(fsPath) == extname) {\n                let { filetype } = doc;\n                // react syntax could be slow\n                if (filetype == 'javascriptreact')\n                    return 'javascript';\n                if (filetype == 'typescriptreact')\n                    return 'typescript';\n                if (filetype.indexOf('.') !== -1)\n                    return filetype.split('.')[0];\n                return filetype;\n            }\n        }\n        return '';\n    }\n}\nexports.default = BasicList;\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/basic.ts?");

/***/ }),

/***/ "./src/list/commandTask.ts":
/*!*********************************!*\
  !*** ./src/list/commandTask.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst child_process_1 = __webpack_require__(/*! child_process */ \"child_process\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst readline_1 = tslib_1.__importDefault(__webpack_require__(/*! readline */ \"readline\"));\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('list-commandTask');\nclass CommandTask extends events_1.EventEmitter {\n    // private processes: ChildProcess[] = []\n    constructor(opt) {\n        super();\n        this.opt = opt;\n        this.disposables = [];\n        this.start();\n    }\n    start() {\n        let { cmd, args, cwd, onLine } = this.opt;\n        let proc = child_process_1.spawn(cmd, args, { cwd, windowsHide: true });\n        this.disposables.push({\n            dispose: () => {\n                proc.kill();\n            }\n        });\n        proc.on('error', e => {\n            this.emit('error', e.message);\n        });\n        proc.stderr.on('data', chunk => {\n            logger.error(`[${cmd} Error]`, chunk.toString('utf8'));\n        });\n        const rl = readline_1.default.createInterface(proc.stdout);\n        rl.on('line', line => {\n            let res = onLine(line);\n            if (res)\n                this.emit('data', res);\n        });\n        rl.on('close', () => {\n            this.emit('end');\n        });\n    }\n    dispose() {\n        util_1.disposeAll(this.disposables);\n    }\n}\nexports.default = CommandTask;\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/commandTask.ts?");

/***/ }),

/***/ "./src/list/configuration.ts":
/*!***********************************!*\
  !*** ./src/list/configuration.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validKeys = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nexports.validKeys = [\n    '<esc>',\n    '<space>',\n    '<tab>',\n    '<s-tab>',\n    '<bs>',\n    '<right>',\n    '<left>',\n    '<up>',\n    '<down>',\n    '<home>',\n    '<end>',\n    '<cr>',\n    '<FocusGained>',\n    '<ScrollWheelUp>',\n    '<ScrollWheelDown>',\n    '<LeftMouse>',\n    '<LeftDrag>',\n    '<LeftRelease>',\n    '<2-LeftMouse>',\n    '<C-a>',\n    '<C-b>',\n    '<C-c>',\n    '<C-d>',\n    '<C-e>',\n    '<C-f>',\n    '<C-g>',\n    '<C-h>',\n    '<C-i>',\n    '<C-j>',\n    '<C-k>',\n    '<C-l>',\n    '<C-m>',\n    '<C-n>',\n    '<C-o>',\n    '<C-p>',\n    '<C-q>',\n    '<C-r>',\n    '<C-s>',\n    '<C-t>',\n    '<C-u>',\n    '<C-v>',\n    '<C-w>',\n    '<C-x>',\n    '<C-y>',\n    '<C-z>',\n    '<A-a>',\n    '<A-b>',\n    '<A-c>',\n    '<A-d>',\n    '<A-e>',\n    '<A-f>',\n    '<A-g>',\n    '<A-h>',\n    '<A-i>',\n    '<A-j>',\n    '<A-k>',\n    '<A-l>',\n    '<A-m>',\n    '<A-n>',\n    '<A-o>',\n    '<A-p>',\n    '<A-q>',\n    '<A-r>',\n    '<A-s>',\n    '<A-t>',\n    '<A-u>',\n    '<A-v>',\n    '<A-w>',\n    '<A-x>',\n    '<A-y>',\n    '<A-z>',\n];\nclass ListConfiguration extends events_1.EventEmitter {\n    constructor() {\n        super();\n        this.configuration = workspace_1.default.getConfiguration('list');\n        this.disposable = workspace_1.default.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('list')) {\n                this.configuration = workspace_1.default.getConfiguration('list');\n                this.emit('change');\n            }\n        });\n    }\n    get(key, defaultValue) {\n        return this.configuration.get(key, defaultValue);\n    }\n    get previousKey() {\n        return this.fixKey(this.configuration.get('previousKeymap', '<C-j>'));\n    }\n    get nextKey() {\n        return this.fixKey(this.configuration.get('nextKeymap', '<C-k>'));\n    }\n    dispose() {\n        this.disposable.dispose();\n        this.removeAllListeners();\n    }\n    fixKey(key) {\n        if (exports.validKeys.includes(key))\n            return key;\n        let find = exports.validKeys.find(s => s.toLowerCase() == key.toLowerCase());\n        if (find)\n            return find;\n        window_1.default.showMessage(`Configured key \"${key}\" not supported.`, 'error');\n        return null;\n    }\n}\nexports.default = ListConfiguration;\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/configuration.ts?");

/***/ }),

/***/ "./src/list/formatting.ts":
/*!********************************!*\
  !*** ./src/list/formatting.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.formatPath = exports.formatListItems = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nfunction formatListItems(align, list) {\n    if (list.length === 0) {\n        return [];\n    }\n    let processedList = [];\n    if (align) {\n        const maxWidths = Array(Math.min(...list.map(item => item.label.length))).fill(0);\n        for (let item of list) {\n            for (let i = 0; i < maxWidths.length; i++) {\n                maxWidths[i] = Math.max(maxWidths[i], item.label[i].length);\n            }\n        }\n        processedList = list\n            .map(item => (Object.assign(Object.assign({}, item), { label: item.label\n                .map((element, idx) => element.padEnd(maxWidths[idx]))\n                .join(\"\\t\") })));\n    }\n    else {\n        processedList = list.map(item => (Object.assign(Object.assign({}, item), { label: item.label.join(\"\\t\") })));\n    }\n    return processedList;\n}\nexports.formatListItems = formatListItems;\nfunction formatPath(format, pathToFormat) {\n    var _a;\n    if (format === \"hidden\") {\n        return \"\";\n    }\n    else if (format === \"full\") {\n        return pathToFormat;\n    }\n    else if (format === \"short\") {\n        const segments = pathToFormat.split(path_1.default.sep);\n        if (segments.length < 2) {\n            return pathToFormat;\n        }\n        const shortenedInit = segments\n            .slice(0, segments.length - 2)\n            .filter(seg => seg.length > 0)\n            .map(seg => seg[0]);\n        return [...shortenedInit, segments[segments.length - 1]].join(path_1.default.sep);\n    }\n    else {\n        const segments = pathToFormat.split(path_1.default.sep);\n        return (_a = segments[segments.length - 1]) !== null && _a !== void 0 ? _a : \"\";\n    }\n}\nexports.formatPath = formatPath;\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/formatting.ts?");

/***/ }),

/***/ "./src/list/history.ts":
/*!*****************************!*\
  !*** ./src/list/history.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst fuzzy_1 = __webpack_require__(/*! ../util/fuzzy */ \"./src/util/fuzzy.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('list-history');\nclass InputHistory {\n    constructor(prompt, name) {\n        this.prompt = prompt;\n        this.name = name;\n        this.index = -1;\n        this.loaded = [];\n        this.current = [];\n        this.db = workspace_1.default.createDatabase(`list-${name}-history`);\n        this.key = Buffer.from(workspace_1.default.cwd).toString('base64');\n    }\n    filter() {\n        let { input } = this.prompt;\n        if (input == this.curr)\n            return;\n        this.historyInput = '';\n        let codes = fuzzy_1.getCharCodes(input);\n        this.current = this.loaded.filter(s => fuzzy_1.fuzzyMatch(codes, s));\n        this.index = -1;\n    }\n    get curr() {\n        return this.index == -1 ? null : this.current[this.index];\n    }\n    load(input) {\n        let { db } = this;\n        input = input || '';\n        let arr = db.fetch(this.key);\n        if (!arr || !Array.isArray(arr)) {\n            this.loaded = [];\n        }\n        else {\n            this.loaded = arr;\n        }\n        this.index = -1;\n        this.current = this.loaded.filter(s => s.startsWith(input));\n    }\n    add() {\n        let { loaded, db, prompt } = this;\n        let { input } = prompt;\n        if (!input || input.length < 2 || input == this.historyInput)\n            return;\n        let idx = loaded.indexOf(input);\n        if (idx != -1)\n            loaded.splice(idx, 1);\n        loaded.push(input);\n        if (loaded.length > 200) {\n            loaded = loaded.slice(-200);\n        }\n        db.push(this.key, loaded);\n    }\n    previous() {\n        let { current, index } = this;\n        if (!current || !current.length)\n            return;\n        if (index <= 0) {\n            this.index = current.length - 1;\n        }\n        else {\n            this.index = index - 1;\n        }\n        this.historyInput = this.prompt.input = current[this.index] || '';\n    }\n    next() {\n        let { current, index } = this;\n        if (!current || !current.length)\n            return;\n        if (index == current.length - 1) {\n            this.index = 0;\n        }\n        else {\n            this.index = index + 1;\n        }\n        this.historyInput = this.prompt.input = current[this.index] || '';\n    }\n}\nexports.default = InputHistory;\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/history.ts?");

/***/ }),

/***/ "./src/list/manager.ts":
/*!*****************************!*\
  !*** ./src/list/manager.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ListManager = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst debounce_1 = tslib_1.__importDefault(__webpack_require__(/*! debounce */ \"./node_modules/debounce/index.js\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nconst extensions_1 = tslib_1.__importDefault(__webpack_require__(/*! ../extensions */ \"./src/extensions.ts\"));\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst configuration_1 = tslib_1.__importDefault(__webpack_require__(/*! ./configuration */ \"./src/list/configuration.ts\"));\nconst mappings_1 = tslib_1.__importDefault(__webpack_require__(/*! ./mappings */ \"./src/list/mappings.ts\"));\nconst prompt_1 = tslib_1.__importDefault(__webpack_require__(/*! ./prompt */ \"./src/list/prompt.ts\"));\nconst session_1 = tslib_1.__importDefault(__webpack_require__(/*! ./session */ \"./src/list/session.ts\"));\nconst commands_1 = tslib_1.__importDefault(__webpack_require__(/*! ./source/commands */ \"./src/list/source/commands.ts\"));\nconst diagnostics_1 = tslib_1.__importDefault(__webpack_require__(/*! ./source/diagnostics */ \"./src/list/source/diagnostics.ts\"));\nconst extensions_2 = tslib_1.__importDefault(__webpack_require__(/*! ./source/extensions */ \"./src/list/source/extensions.ts\"));\nconst folders_1 = tslib_1.__importDefault(__webpack_require__(/*! ./source/folders */ \"./src/list/source/folders.ts\"));\nconst links_1 = tslib_1.__importDefault(__webpack_require__(/*! ./source/links */ \"./src/list/source/links.ts\"));\nconst lists_1 = tslib_1.__importDefault(__webpack_require__(/*! ./source/lists */ \"./src/list/source/lists.ts\"));\nconst location_1 = tslib_1.__importDefault(__webpack_require__(/*! ./source/location */ \"./src/list/source/location.ts\"));\nconst outline_1 = tslib_1.__importDefault(__webpack_require__(/*! ./source/outline */ \"./src/list/source/outline.ts\"));\nconst services_1 = tslib_1.__importDefault(__webpack_require__(/*! ./source/services */ \"./src/list/source/services.ts\"));\nconst sources_1 = tslib_1.__importDefault(__webpack_require__(/*! ./source/sources */ \"./src/list/source/sources.ts\"));\nconst symbols_1 = tslib_1.__importDefault(__webpack_require__(/*! ./source/symbols */ \"./src/list/source/symbols.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('list-manager');\nconst mouseKeys = ['<LeftMouse>', '<LeftDrag>', '<LeftRelease>', '<2-LeftMouse>'];\nclass ListManager {\n    constructor() {\n        this.plugTs = 0;\n        this.sessionsMap = new Map();\n        this.disposables = [];\n        this.listMap = new Map();\n    }\n    init(nvim) {\n        this.nvim = nvim;\n        this.config = new configuration_1.default();\n        this.prompt = new prompt_1.default(nvim, this.config);\n        this.mappings = new mappings_1.default(this, nvim, this.config);\n        let signText = this.config.get('selectedSignText', '*');\n        nvim.command(`sign define CocSelected text=${signText} texthl=CocSelectedText linehl=CocSelectedLine`, true);\n        events_1.default.on('InputChar', this.onInputChar, this, this.disposables);\n        events_1.default.on('FocusGained', debounce_1.default(async () => {\n            let session = await this.getCurrentSession();\n            if (session)\n                this.prompt.drawPrompt();\n        }, 100), null, this.disposables);\n        let timer;\n        events_1.default.on('WinEnter', winid => {\n            let session = this.getSessionByWinid(winid);\n            if (session)\n                this.prompt.start(session.listOptions);\n        }, null, this.disposables);\n        events_1.default.on('WinLeave', winid => {\n            let session = this.getSessionByWinid(winid);\n            if (session)\n                this.prompt.cancel();\n        });\n        this.disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {\n            if (timer)\n                clearTimeout(timer);\n        }));\n        // filter history on input\n        this.prompt.onDidChangeInput(() => {\n            let { session } = this;\n            if (!session)\n                return;\n            session.onInputChange();\n            session.history.filter();\n        });\n        this.registerList(new links_1.default(nvim));\n        this.registerList(new location_1.default(nvim));\n        this.registerList(new symbols_1.default(nvim));\n        this.registerList(new outline_1.default(nvim));\n        this.registerList(new commands_1.default(nvim));\n        this.registerList(new extensions_2.default(nvim));\n        this.registerList(new diagnostics_1.default(nvim));\n        this.registerList(new sources_1.default(nvim));\n        this.registerList(new services_1.default(nvim));\n        this.registerList(new lists_1.default(nvim, this.listMap));\n        this.registerList(new folders_1.default(nvim));\n    }\n    async start(args) {\n        let res = this.parseArgs(args);\n        if (!res)\n            return;\n        let { name } = res.list;\n        let curr = this.sessionsMap.get(name);\n        if (curr)\n            curr.dispose();\n        this.prompt.start(res.options);\n        let session = new session_1.default(this.nvim, this.prompt, res.list, res.options, res.listArgs, this.config);\n        this.sessionsMap.set(name, session);\n        this.lastSession = session;\n        try {\n            await session.start(args);\n        }\n        catch (e) {\n            this.nvim.call('coc#prompt#stop_prompt', ['list'], true);\n            let msg = e instanceof Error ? e.message : e.toString();\n            window_1.default.showMessage(`Error on \"CocList ${name}\": ${msg}`, 'error');\n            logger.error(e);\n        }\n    }\n    getSessionByWinid(winid) {\n        for (let session of this.sessionsMap.values()) {\n            if (session && session.winid == winid) {\n                this.lastSession = session;\n                return session;\n            }\n        }\n        return null;\n    }\n    async getCurrentSession() {\n        let { id } = await this.nvim.window;\n        for (let session of this.sessionsMap.values()) {\n            if (session && session.winid == id) {\n                this.lastSession = session;\n                return session;\n            }\n        }\n        return null;\n    }\n    async resume(name) {\n        var _a;\n        if (!name) {\n            await ((_a = this.session) === null || _a === void 0 ? void 0 : _a.resume());\n        }\n        else {\n            let session = this.sessionsMap.get(name);\n            if (!session) {\n                window_1.default.showMessage(`Can't find exists ${name} list`);\n                return;\n            }\n            await session.resume();\n        }\n    }\n    async doAction(name) {\n        let lastSession = this.lastSession;\n        if (!lastSession)\n            return;\n        await lastSession.doAction(name);\n    }\n    async first(name) {\n        let s = this.getSession(name);\n        if (s)\n            await s.first();\n    }\n    async last(name) {\n        let s = this.getSession(name);\n        if (s)\n            await s.last();\n    }\n    async previous(name) {\n        let s = this.getSession(name);\n        if (s)\n            await s.previous();\n    }\n    async next(name) {\n        let s = this.getSession(name);\n        if (s)\n            await s.next();\n    }\n    getSession(name) {\n        if (!name)\n            return this.session;\n        return this.sessionsMap.get(name);\n    }\n    async cancel(close = true) {\n        this.prompt.cancel();\n        if (!close)\n            return;\n        if (this.session)\n            await this.session.hide();\n    }\n    /**\n     * Clear all list sessions\n     */\n    reset() {\n        this.prompt.cancel();\n        this.lastSession = undefined;\n        for (let session of this.sessionsMap.values()) {\n            session.dispose();\n        }\n        this.sessionsMap.clear();\n        this.nvim.call('coc#prompt#stop_prompt', ['list'], true);\n    }\n    switchMatcher() {\n        var _a;\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.switchMatcher();\n    }\n    async togglePreview() {\n        let { nvim } = this;\n        let winid = await nvim.call('coc#list#get_preview', [0]);\n        if (winid != -1) {\n            let win = nvim.createWindow(winid);\n            await win.close(true);\n            await nvim.command('redraw');\n        }\n        else {\n            await this.doAction('preview');\n        }\n    }\n    async chooseAction() {\n        let { lastSession } = this;\n        if (lastSession)\n            await lastSession.chooseAction();\n    }\n    parseArgs(args) {\n        let options = [];\n        let interactive = false;\n        let autoPreview = false;\n        let numberSelect = false;\n        let noQuit = false;\n        let first = false;\n        let name;\n        let input = '';\n        let matcher = 'fuzzy';\n        let position = 'bottom';\n        let listArgs = [];\n        let listOptions = [];\n        for (let arg of args) {\n            if (!name && arg.startsWith('-')) {\n                listOptions.push(arg);\n            }\n            else if (!name) {\n                if (!/^\\w+$/.test(arg)) {\n                    window_1.default.showMessage(`Invalid list option: \"${arg}\"`, 'error');\n                    return null;\n                }\n                name = arg;\n            }\n            else {\n                listArgs.push(arg);\n            }\n        }\n        name = name || 'lists';\n        let config = workspace_1.default.getConfiguration(`list.source.${name}`);\n        if (!listOptions.length && !listArgs.length)\n            listOptions = config.get('defaultOptions', []);\n        if (!listArgs.length)\n            listArgs = config.get('defaultArgs', []);\n        for (let opt of listOptions) {\n            if (opt.startsWith('--input')) {\n                input = opt.slice(8);\n            }\n            else if (opt == '--number-select' || opt == '-N') {\n                numberSelect = true;\n            }\n            else if (opt == '--auto-preview' || opt == '-A') {\n                autoPreview = true;\n            }\n            else if (opt == '--regex' || opt == '-R') {\n                matcher = 'regex';\n            }\n            else if (opt == '--strict' || opt == '-S') {\n                matcher = 'strict';\n            }\n            else if (opt == '--interactive' || opt == '-I') {\n                interactive = true;\n            }\n            else if (opt == '--top') {\n                position = 'top';\n            }\n            else if (opt == '--tab') {\n                position = 'tab';\n            }\n            else if (opt == '--ignore-case' || opt == '--normal' || opt == '--no-sort') {\n                options.push(opt.slice(2));\n            }\n            else if (opt == '--first') {\n                first = true;\n            }\n            else if (opt == '--no-quit') {\n                noQuit = true;\n            }\n            else {\n                window_1.default.showMessage(`Invalid option \"${opt}\" of list`, 'error');\n                return null;\n            }\n        }\n        let list = this.listMap.get(name);\n        if (!list) {\n            window_1.default.showMessage(`List ${name} not found`, 'error');\n            return null;\n        }\n        if (interactive && !list.interactive) {\n            window_1.default.showMessage(`Interactive mode of \"${name}\" list not supported`, 'error');\n            return null;\n        }\n        return {\n            list,\n            listArgs,\n            options: {\n                numberSelect,\n                autoPreview,\n                noQuit,\n                first,\n                input,\n                interactive,\n                matcher,\n                position,\n                ignorecase: options.includes('ignore-case') ? true : false,\n                mode: !options.includes('normal') ? 'insert' : 'normal',\n                sort: !options.includes('no-sort') ? true : false\n            },\n        };\n    }\n    async onInputChar(session, ch, charmod) {\n        if (session != 'list')\n            return;\n        let { mode } = this.prompt;\n        let now = Date.now();\n        if (ch == '<plug>' || (this.plugTs && now - this.plugTs < 20)) {\n            this.plugTs = now;\n            return;\n        }\n        if (!ch)\n            return;\n        if (ch == '<esc>') {\n            await this.cancel();\n            return;\n        }\n        try {\n            if (mode == 'insert') {\n                await this.onInsertInput(ch, charmod);\n            }\n            else {\n                await this.onNormalInput(ch, charmod);\n            }\n        }\n        catch (e) {\n            window_1.default.showMessage(`Error on input ${ch}: ${e}`);\n            logger.error(e);\n        }\n    }\n    async onInsertInput(ch, charmod) {\n        let { session } = this;\n        if (!session)\n            return;\n        if (mouseKeys.includes(ch)) {\n            await this.onMouseEvent(ch);\n            return;\n        }\n        let n = await session.doNumberSelect(ch);\n        if (n)\n            return;\n        let done = await this.mappings.doInsertKeymap(ch);\n        if (done || charmod)\n            return;\n        if (ch.startsWith('<') && ch.endsWith('>'))\n            return;\n        for (let s of ch) {\n            let code = s.codePointAt(0);\n            if (code == 65533)\n                return;\n            // exclude control character\n            if (code < 32 || code >= 127 && code <= 159)\n                return;\n            await this.prompt.acceptCharacter(s);\n        }\n    }\n    async onNormalInput(ch, _charmod) {\n        if (mouseKeys.includes(ch)) {\n            await this.onMouseEvent(ch);\n            return;\n        }\n        let used = await this.mappings.doNormalKeymap(ch);\n        if (!used)\n            await this.feedkeys(ch);\n    }\n    onMouseEvent(key) {\n        if (this.session)\n            return this.session.onMouseEvent(key);\n    }\n    async feedkeys(key, remap = true) {\n        let { nvim } = this;\n        key = key.startsWith('<') && key.endsWith('>') ? `\\\\${key}` : key;\n        await nvim.call('coc#prompt#stop_prompt', ['list']);\n        await nvim.call('eval', [`feedkeys(\"${key}\", \"${remap ? 'i' : 'in'}\")`]);\n        this.prompt.start();\n    }\n    async command(command) {\n        let { nvim } = this;\n        await nvim.call('coc#prompt#stop_prompt', ['list']);\n        await nvim.command(command);\n        this.prompt.start();\n    }\n    async normal(command, bang = true) {\n        let { nvim } = this;\n        await nvim.call('coc#prompt#stop_prompt', ['list']);\n        await nvim.command(`normal${bang ? '!' : ''} ${command}`);\n        this.prompt.start();\n    }\n    async call(fname) {\n        if (this.session)\n            return await this.session.call(fname);\n    }\n    get session() {\n        return this.lastSession;\n    }\n    registerList(list) {\n        const { name } = list;\n        let exists = this.listMap.get(name);\n        if (this.listMap.has(name)) {\n            if (exists) {\n                if (typeof exists.dispose == 'function') {\n                    exists.dispose();\n                }\n                this.listMap.delete(name);\n            }\n            window_1.default.showMessage(`list \"${name}\" recreated.`);\n        }\n        this.listMap.set(name, list);\n        extensions_1.default.addSchemeProperty(`list.source.${name}.defaultOptions`, {\n            type: 'array',\n            default: list.interactive ? ['--interactive'] : [],\n            description: `Default list options of \"${name}\" list, only used when both list option and argument are empty.`,\n            uniqueItems: true,\n            items: {\n                type: 'string',\n                enum: ['--top', '--normal', '--no-sort', '--input', '--tab',\n                    '--strict', '--regex', '--ignore-case', '--number-select',\n                    '--interactive', '--auto-preview', '--first', '--no-quit']\n            }\n        });\n        extensions_1.default.addSchemeProperty(`list.source.${name}.defaultArgs`, {\n            type: 'array',\n            default: [],\n            description: `Default argument list of \"${name}\" list, only used when list argument is empty.`,\n            uniqueItems: true,\n            items: { type: 'string' }\n        });\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            if (typeof list.dispose == 'function') {\n                list.dispose();\n            }\n            this.listMap.delete(name);\n        });\n    }\n    get names() {\n        return Array.from(this.listMap.keys());\n    }\n    get descriptions() {\n        let d = {};\n        for (let name of this.listMap.keys()) {\n            let list = this.listMap.get(name);\n            d[name] = list.description;\n        }\n        return d;\n    }\n    /**\n     * Get items of {name} list, not work with interactive list and list return task.\n     *\n     * @param {string} name\n     * @returns {Promise<any>}\n     */\n    async loadItems(name) {\n        let args = [name];\n        let res = this.parseArgs(args);\n        if (!res)\n            return;\n        let { list, options, listArgs } = res;\n        let source = new vscode_languageserver_protocol_1.CancellationTokenSource();\n        let token = source.token;\n        let arr = await this.nvim.eval('[win_getid(),bufnr(\"%\")]');\n        let items = await list.loadItems({\n            options,\n            args: listArgs,\n            input: '',\n            cwd: workspace_1.default.cwd,\n            window: this.nvim.createWindow(arr[0]),\n            buffer: this.nvim.createBuffer(arr[1]),\n            listWindow: null\n        }, token);\n        return items;\n    }\n    toggleMode() {\n        let lastSession = this.lastSession;\n        if (lastSession)\n            lastSession.toggleMode();\n    }\n    get isActivated() {\n        var _a;\n        return ((_a = this.session) === null || _a === void 0 ? void 0 : _a.winid) != null;\n    }\n    stop() {\n        let lastSession = this.lastSession;\n        if (lastSession)\n            lastSession.stop();\n    }\n    dispose() {\n        for (let session of this.sessionsMap.values()) {\n            session.dispose();\n        }\n        this.sessionsMap.clear();\n        if (this.config) {\n            this.config.dispose();\n        }\n        this.lastSession = undefined;\n        util_1.disposeAll(this.disposables);\n    }\n}\nexports.ListManager = ListManager;\nexports.default = new ListManager();\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/manager.ts?");

/***/ }),

/***/ "./src/list/mappings.ts":
/*!******************************!*\
  !*** ./src/list/mappings.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n__webpack_require__(/*! ../util/extensions */ \"./src/util/extensions.ts\");\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst configuration_1 = __webpack_require__(/*! ./configuration */ \"./src/list/configuration.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('list-mappings');\nclass Mappings {\n    constructor(manager, nvim, config) {\n        this.manager = manager;\n        this.nvim = nvim;\n        this.config = config;\n        this.insertMappings = new Map();\n        this.normalMappings = new Map();\n        this.userInsertMappings = new Map();\n        this.userNormalMappings = new Map();\n        let { prompt } = manager;\n        this.add('insert', '<C-k>', () => {\n            prompt.removeTail();\n        });\n        this.add('insert', '<C-n>', () => {\n            var _a;\n            (_a = manager.session) === null || _a === void 0 ? void 0 : _a.history.next();\n        });\n        this.add('insert', '<C-p>', () => {\n            var _a;\n            (_a = manager.session) === null || _a === void 0 ? void 0 : _a.history.previous();\n        });\n        this.add('insert', '<C-v>', async () => {\n            await prompt.paste();\n        });\n        this.add('insert', '<C-s>', () => manager.switchMatcher());\n        this.add('insert', ['<C-m>', '<cr>'], async () => {\n            await manager.doAction();\n        });\n        this.add('insert', ['<tab>', '<C-i>', '\\t'], () => manager.chooseAction());\n        this.add('insert', '<C-o>', () => {\n            manager.toggleMode();\n        });\n        this.add('insert', '<C-c>', () => {\n            manager.stop();\n            return;\n        });\n        this.add('insert', '<esc>', () => manager.cancel());\n        this.add('insert', '<C-l>', async () => {\n            var _a;\n            await ((_a = manager.session) === null || _a === void 0 ? void 0 : _a.reloadItems());\n        });\n        this.add('insert', '<left>', () => {\n            prompt.moveLeft();\n        });\n        this.add('insert', '<right>', () => {\n            prompt.moveRight();\n        });\n        this.add('insert', ['<end>', '<C-e>'], () => {\n            prompt.moveToEnd();\n        });\n        this.add('insert', ['<home>', '<C-a>'], () => {\n            prompt.moveToStart();\n        });\n        this.add('insert', ['<C-h>', '<bs>', '<backspace>'], () => {\n            prompt.onBackspace();\n        });\n        this.add('insert', '<C-w>', () => {\n            prompt.removeWord();\n        });\n        this.add('insert', '<C-u>', () => {\n            prompt.removeAhead();\n        });\n        this.add('insert', '<C-r>', () => prompt.insertRegister());\n        this.add('insert', '<C-d>', () => manager.feedkeys('<C-d>', false));\n        this.add('insert', '<PageUp>', () => manager.feedkeys('<PageUp>', false));\n        this.add('insert', '<PageDown>', () => manager.feedkeys('<PageDown>', false));\n        this.add('insert', '<down>', () => manager.normal('j'));\n        this.add('insert', '<up>', () => manager.normal('k'));\n        this.add('insert', ['<ScrollWheelUp>'], this.doScroll.bind(this, '<ScrollWheelUp>'));\n        this.add('insert', ['<ScrollWheelDown>'], this.doScroll.bind(this, '<ScrollWheelDown>'));\n        this.add('insert', ['<C-f>'], this.doScroll.bind(this, '<C-f>'));\n        this.add('insert', ['<C-b>'], this.doScroll.bind(this, '<C-b>'));\n        this.add('normal', '<C-o>', () => {\n            // do nothing, avoid buffer switch by accident\n        });\n        this.add('normal', 't', () => manager.doAction('tabe'));\n        this.add('normal', 's', () => manager.doAction('split'));\n        this.add('normal', 'd', () => manager.doAction('drop'));\n        this.add('normal', ['<cr>', '<C-m>', '\\r'], () => manager.doAction());\n        this.add('normal', '<C-a>', () => { var _a; return (_a = manager.session) === null || _a === void 0 ? void 0 : _a.ui.selectAll(); });\n        this.add('normal', ' ', () => { var _a; return (_a = manager.session) === null || _a === void 0 ? void 0 : _a.ui.toggleSelection(); });\n        this.add('normal', 'p', () => manager.togglePreview());\n        this.add('normal', ['<tab>', '\\t', '<C-i>'], () => manager.chooseAction());\n        this.add('normal', '<C-c>', () => {\n            manager.stop();\n        });\n        this.add('normal', '<esc>', () => manager.cancel());\n        this.add('normal', '<C-l>', () => { var _a; return (_a = manager.session) === null || _a === void 0 ? void 0 : _a.reloadItems(); });\n        this.add('normal', '<C-o>', () => { var _a; return (_a = manager.session) === null || _a === void 0 ? void 0 : _a.jumpBack(); });\n        this.add('normal', '<C-e>', () => this.scrollPreview('down'));\n        this.add('normal', '<C-y>', () => this.scrollPreview('up'));\n        this.add('normal', ['i', 'I', 'o', 'O', 'a', 'A'], () => manager.toggleMode());\n        this.add('normal', '?', () => { var _a; return (_a = manager.session) === null || _a === void 0 ? void 0 : _a.showHelp(); });\n        this.add('normal', ':', async () => {\n            await manager.cancel(false);\n            await nvim.eval('feedkeys(\":\")');\n        });\n        this.add('normal', ['<ScrollWheelUp>'], this.doScroll.bind(this, '<ScrollWheelUp>'));\n        this.add('normal', ['<ScrollWheelDown>'], this.doScroll.bind(this, '<ScrollWheelDown>'));\n        this.createMappings();\n        config.on('change', () => {\n            this.createMappings();\n        });\n    }\n    createMappings() {\n        let insertMappings = this.config.get('insertMappings', {});\n        this.userInsertMappings = this.fixUserMappings(insertMappings);\n        let normalMappings = this.config.get('normalMappings', {});\n        this.userNormalMappings = this.fixUserMappings(normalMappings);\n    }\n    fixUserMappings(mappings) {\n        let res = new Map();\n        for (let [key, value] of Object.entries(mappings)) {\n            if (key.length == 1) {\n                res.set(key, value);\n            }\n            else if (key.startsWith('<') && key.endsWith('>')) {\n                if (key.toLowerCase() == '<space>') {\n                    res.set(' ', value);\n                }\n                else if (key.toLowerCase() == '<backspace>') {\n                    res.set('<bs>', value);\n                }\n                else if (configuration_1.validKeys.includes(key)) {\n                    res.set(key, value);\n                }\n                else {\n                    let find = false;\n                    for (let i = 0; i < configuration_1.validKeys.length; i++) {\n                        if (configuration_1.validKeys[i].toLowerCase() == key.toLowerCase()) {\n                            find = true;\n                            res.set(configuration_1.validKeys[i], value);\n                            break;\n                        }\n                    }\n                    if (!find)\n                        window_1.default.showMessage(`Invalid list mappings key configuration: \"${key}\"`, 'warning');\n                }\n            }\n            else {\n                window_1.default.showMessage(`Invalid list mappings key configuration: \"${key}\"`, 'warning');\n            }\n        }\n        return res;\n    }\n    async doInsertKeymap(key) {\n        let nextKey = this.config.nextKey;\n        let previousKey = this.config.previousKey;\n        let { session } = this.manager;\n        if (!session)\n            return;\n        if (key == nextKey) {\n            session.ui.index = session.ui.index + 1;\n            return true;\n        }\n        if (key == previousKey) {\n            session.ui.index = session.ui.index - 1;\n            return true;\n        }\n        let expr = this.userInsertMappings.get(key);\n        if (expr) {\n            await this.evalExpression(expr, 'insert');\n            return true;\n        }\n        if (this.insertMappings.has(key)) {\n            let fn = this.insertMappings.get(key);\n            await Promise.resolve(fn());\n            return true;\n        }\n        return false;\n    }\n    async doNormalKeymap(key) {\n        let expr = this.userNormalMappings.get(key);\n        if (expr) {\n            await this.evalExpression(expr, 'normal');\n            return true;\n        }\n        if (this.normalMappings.has(key)) {\n            let fn = this.normalMappings.get(key);\n            await Promise.resolve(fn());\n            return true;\n        }\n        return false;\n    }\n    add(mode, key, fn) {\n        let mappings = mode == 'insert' ? this.insertMappings : this.normalMappings;\n        if (Array.isArray(key)) {\n            for (let k of key) {\n                mappings.set(k, fn);\n            }\n        }\n        else {\n            mappings.set(key, fn);\n        }\n    }\n    async onError(msg) {\n        let { nvim } = this;\n        await nvim.call('coc#prompt#stop_prompt', ['list']);\n        window_1.default.showMessage(msg, 'error');\n        this.manager.prompt.start();\n    }\n    async evalExpression(expr, _mode) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        if (typeof expr != 'string' || !expr.includes(':')) {\n            await this.onError(`Invalid list mapping expression: ${expr}`);\n            return;\n        }\n        let { manager } = this;\n        let { prompt } = manager;\n        let [key, action] = expr.split(':', 2);\n        if (key == 'do') {\n            switch (action.toLowerCase()) {\n                case 'switch':\n                    manager.switchMatcher();\n                    return;\n                case 'selectall':\n                    await ((_a = manager.session) === null || _a === void 0 ? void 0 : _a.ui.selectAll());\n                    return;\n                case 'help':\n                    await ((_b = manager.session) === null || _b === void 0 ? void 0 : _b.showHelp());\n                    return;\n                case 'refresh':\n                    await ((_c = manager.session) === null || _c === void 0 ? void 0 : _c.reloadItems());\n                    return;\n                case 'exit':\n                    await manager.cancel();\n                    return;\n                case 'stop':\n                    manager.stop();\n                    return;\n                case 'cancel':\n                    await manager.cancel(false);\n                    return;\n                case 'toggle':\n                    await ((_d = manager.session) === null || _d === void 0 ? void 0 : _d.ui.toggleSelection());\n                    return;\n                case 'jumpback':\n                    (_e = manager.session) === null || _e === void 0 ? void 0 : _e.jumpBack();\n                    return;\n                case 'previous':\n                    await manager.normal('k');\n                    return;\n                case 'next':\n                    await manager.normal('j');\n                    return;\n                case 'defaultaction':\n                    await manager.doAction();\n                    return;\n                case 'togglemode':\n                    return manager.toggleMode();\n                case 'previewup':\n                    return this.scrollPreview('up');\n                case 'previewdown':\n                    return this.scrollPreview('down');\n                default:\n                    await this.onError(`'${action}' not supported`);\n            }\n        }\n        else if (key == 'prompt') {\n            switch (action) {\n                case 'previous':\n                    (_f = manager.session) === null || _f === void 0 ? void 0 : _f.history.previous();\n                    return;\n                case 'next':\n                    (_g = manager.session) === null || _g === void 0 ? void 0 : _g.history.next();\n                    return;\n                case 'start':\n                    return prompt.moveToStart();\n                case 'end':\n                    return prompt.moveToEnd();\n                case 'left':\n                    return prompt.moveLeft();\n                case 'right':\n                    return prompt.moveRight();\n                case 'deleteforward':\n                    return prompt.onBackspace();\n                case 'deletebackward':\n                    return prompt.removeNext();\n                case 'removetail':\n                    return prompt.removeTail();\n                case 'removeahead':\n                    return prompt.removeAhead();\n                case 'insertregister':\n                    prompt.insertRegister();\n                    return;\n                case 'paste':\n                    await prompt.paste();\n                    return;\n                default:\n                    await this.onError(`prompt '${action}' not supported`);\n            }\n        }\n        else if (key == 'eval') {\n            await prompt.eval(action);\n        }\n        else if (key == 'command') {\n            await manager.command(action);\n        }\n        else if (key == 'action') {\n            await manager.doAction(action);\n        }\n        else if (key == 'feedkeys') {\n            await manager.feedkeys(action);\n        }\n        else if (key == 'normal') {\n            await manager.normal(action, false);\n        }\n        else if (key == 'normal!') {\n            await manager.normal(action, true);\n        }\n        else if (key == 'call') {\n            await manager.call(action);\n        }\n        else if (key == 'expr') {\n            let name = await manager.call(action);\n            if (name)\n                await manager.doAction(name);\n        }\n        else {\n            await this.onError(`Invalid expression ${expr}`);\n        }\n    }\n    async doScroll(key) {\n        await this.manager.feedkeys(key);\n    }\n    async scrollPreview(dir) {\n        let { nvim } = this;\n        nvim.pauseNotification();\n        nvim.call('coc#util#scroll_preview', [dir], true);\n        nvim.command('redraw', true);\n        await nvim.resumeNotification();\n    }\n}\nexports.default = Mappings;\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/mappings.ts?");

/***/ }),

/***/ "./src/list/prompt.ts":
/*!****************************!*\
  !*** ./src/list/prompt.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst clipboardy_1 = tslib_1.__importDefault(__webpack_require__(/*! clipboardy */ \"./node_modules/clipboardy/index.js\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('list-prompt');\nclass Prompt {\n    constructor(nvim, config) {\n        this.nvim = nvim;\n        this.config = config;\n        this.cusorIndex = 0;\n        this._input = '';\n        this._mode = 'insert';\n        this.interactive = false;\n        this.requestInput = false;\n        this._onDidChangeInput = new vscode_languageserver_protocol_1.Emitter();\n        this.onDidChangeInput = this._onDidChangeInput.event;\n    }\n    get input() {\n        return this._input;\n    }\n    set input(str) {\n        if (this._input == str)\n            return;\n        this.cusorIndex = str.length;\n        this._input = str;\n        this.drawPrompt();\n        this._onDidChangeInput.fire(this._input);\n    }\n    get mode() {\n        return this._mode;\n    }\n    set mode(val) {\n        if (val == this._mode)\n            return;\n        this._mode = val;\n        this.drawPrompt();\n    }\n    set matcher(val) {\n        this._matcher = val;\n        this.drawPrompt();\n    }\n    start(opts) {\n        if (opts) {\n            this.interactive = opts.interactive;\n            this.cusorIndex = opts.input.length;\n            this._input = opts.input;\n            this._mode = opts.mode;\n            this._matcher = opts.interactive ? '' : opts.matcher;\n        }\n        this.nvim.call('coc#prompt#start_prompt', ['list'], true);\n        this.drawPrompt();\n    }\n    cancel() {\n        let { nvim } = this;\n        nvim.call('coc#prompt#stop_prompt', ['list'], true);\n    }\n    reset() {\n        this._input = '';\n        this.cusorIndex = 0;\n    }\n    drawPrompt() {\n        let indicator = this.config.get('indicator', '>');\n        let { cusorIndex, interactive, input, _matcher } = this;\n        let cmds = ['echo \"\"'];\n        if (this.mode == 'insert') {\n            if (interactive) {\n                cmds.push(`echohl MoreMsg | echon 'INTERACTIVE ' | echohl None`);\n            }\n            else if (_matcher) {\n                cmds.push(`echohl MoreMsg | echon '${_matcher.toUpperCase()} ' | echohl None`);\n            }\n            cmds.push(`echohl Special | echon '${indicator} ' | echohl None`);\n            if (cusorIndex == input.length) {\n                cmds.push(`echon '${input.replace(/'/g, \"''\")}'`);\n                cmds.push(`echohl Cursor | echon ' ' | echohl None`);\n            }\n            else {\n                let pre = input.slice(0, cusorIndex);\n                if (pre)\n                    cmds.push(`echon '${pre.replace(/'/g, \"''\")}'`);\n                cmds.push(`echohl Cursor | echon '${input[cusorIndex].replace(/'/, \"''\")}' | echohl None`);\n                let post = input.slice(cusorIndex + 1);\n                cmds.push(`echon '${post.replace(/'/g, \"''\")}'`);\n            }\n        }\n        else {\n            cmds.push(`echohl MoreMsg | echo \"\" | echohl None`);\n        }\n        cmds.push('redraw');\n        let cmd = cmds.join('|');\n        this.nvim.command(cmd, true);\n    }\n    moveLeft() {\n        if (this.cusorIndex == 0)\n            return;\n        this.cusorIndex = this.cusorIndex - 1;\n        this.drawPrompt();\n    }\n    moveRight() {\n        if (this.cusorIndex == this._input.length)\n            return;\n        this.cusorIndex = this.cusorIndex + 1;\n        this.drawPrompt();\n    }\n    moveToEnd() {\n        if (this.cusorIndex == this._input.length)\n            return;\n        this.cusorIndex = this._input.length;\n        this.drawPrompt();\n    }\n    moveToStart() {\n        if (this.cusorIndex == 0)\n            return;\n        this.cusorIndex = 0;\n        this.drawPrompt();\n    }\n    onBackspace() {\n        let { cusorIndex, input } = this;\n        if (cusorIndex == 0)\n            return;\n        let pre = input.slice(0, cusorIndex);\n        let post = input.slice(cusorIndex);\n        this.cusorIndex = cusorIndex - 1;\n        this._input = `${pre.slice(0, pre.length - 1)}${post}`;\n        this.drawPrompt();\n        this._onDidChangeInput.fire(this._input);\n    }\n    removeNext() {\n        let { cusorIndex, input } = this;\n        if (cusorIndex == input.length - 1)\n            return;\n        let pre = input.slice(0, cusorIndex);\n        let post = input.slice(cusorIndex + 1);\n        this._input = `${pre}${post}`;\n        this.drawPrompt();\n        this._onDidChangeInput.fire(this._input);\n    }\n    removeWord() {\n        let { cusorIndex, input } = this;\n        if (cusorIndex == 0)\n            return;\n        let pre = input.slice(0, cusorIndex);\n        let post = input.slice(cusorIndex);\n        let remain = pre.replace(/[\\w$]+([^\\w$]+)?$/, '');\n        this.cusorIndex = cusorIndex - (pre.length - remain.length);\n        this._input = `${remain}${post}`;\n        this.drawPrompt();\n        this._onDidChangeInput.fire(this._input);\n    }\n    removeTail() {\n        let { cusorIndex, input } = this;\n        if (cusorIndex == input.length)\n            return;\n        let pre = input.slice(0, cusorIndex);\n        this._input = pre;\n        this.drawPrompt();\n        this._onDidChangeInput.fire(this._input);\n    }\n    removeAhead() {\n        let { cusorIndex, input } = this;\n        if (cusorIndex == 0)\n            return;\n        let post = input.slice(cusorIndex);\n        this.cusorIndex = 0;\n        this._input = post;\n        this.drawPrompt();\n        this._onDidChangeInput.fire(this._input);\n    }\n    async acceptCharacter(ch) {\n        if (this.requestInput) {\n            this.requestInput = false;\n            if (/^[0-9a-z\"%#*+/:\\-.]$/.test(ch)) {\n                let text = await this.nvim.call('getreg', ch);\n                text = text.replace(/\\n/g, ' ');\n                this.addText(text);\n            }\n        }\n        else {\n            this.addText(ch);\n        }\n    }\n    insertRegister() {\n        this.requestInput = true;\n    }\n    async paste() {\n        let text = await clipboardy_1.default.read();\n        text = text.replace(/\\n/g, '');\n        if (!text)\n            return;\n        this.addText(text);\n    }\n    async eval(expression) {\n        let text = await this.nvim.call('eval', [expression]);\n        text = text.replace(/\\n/g, '');\n        this.addText(text);\n    }\n    addText(text) {\n        let { cusorIndex, input } = this;\n        this.cusorIndex = cusorIndex + text.length;\n        let pre = input.slice(0, cusorIndex);\n        let post = input.slice(cusorIndex);\n        this._input = `${pre}${text}${post}`;\n        this.drawPrompt();\n        this._onDidChangeInput.fire(this._input);\n    }\n}\nexports.default = Prompt;\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/prompt.ts?");

/***/ }),

/***/ "./src/list/session.ts":
/*!*****************************!*\
  !*** ./src/list/session.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst debounce_1 = tslib_1.__importDefault(__webpack_require__(/*! debounce */ \"./node_modules/debounce/index.js\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst extensions_1 = tslib_1.__importDefault(__webpack_require__(/*! ../extensions */ \"./src/extensions.ts\"));\nconst highligher_1 = tslib_1.__importDefault(__webpack_require__(/*! ../model/highligher */ \"./src/model/highligher.ts\"));\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst history_1 = tslib_1.__importDefault(__webpack_require__(/*! ./history */ \"./src/list/history.ts\"));\nconst ui_1 = tslib_1.__importDefault(__webpack_require__(/*! ./ui */ \"./src/list/ui.ts\"));\nconst worker_1 = tslib_1.__importDefault(__webpack_require__(/*! ./worker */ \"./src/list/worker.ts\"));\nconst frames = ['', '', '', '', '', '', '', '', '', ''];\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('list-session');\n/**\n * Activated list session with UI and worker\n */\nclass ListSession {\n    constructor(nvim, prompt, list, listOptions, listArgs = [], config) {\n        this.nvim = nvim;\n        this.prompt = prompt;\n        this.list = list;\n        this.listOptions = listOptions;\n        this.listArgs = listArgs;\n        this.config = config;\n        this.loadingFrame = '';\n        this.hidden = false;\n        this.disposables = [];\n        /**\n         * Original list arguments.\n         */\n        this.args = [];\n        this.ui = new ui_1.default(nvim, list.name, listOptions, config);\n        this.history = new history_1.default(prompt, list.name);\n        this.worker = new worker_1.default(nvim, list, prompt, listOptions, {\n            interactiveDebounceTime: config.get('interactiveDebounceTime', 100),\n            extendedSearchMode: config.get('extendedSearchMode', true)\n        });\n        this.interactiveDebounceTime = config.get('interactiveDebounceTime', 100);\n        let debouncedChangeLine = debounce_1.default(async () => {\n            let [previewing, currwin, lnum] = await nvim.eval('[coc#list#has_preview(),win_getid(),line(\".\")]');\n            if (previewing && currwin == this.winid) {\n                await this.doPreview(lnum - 1);\n            }\n        }, 50);\n        this.disposables.push({\n            dispose: () => {\n                debouncedChangeLine.clear();\n            }\n        });\n        this.ui.onDidChangeLine(debouncedChangeLine, null, this.disposables);\n        this.ui.onDidChangeLine(this.resolveItem, this, this.disposables);\n        this.ui.onDidLineChange(this.resolveItem, this, this.disposables);\n        let debounced = debounce_1.default(async () => {\n            let { autoPreview } = this.listOptions;\n            if (!autoPreview) {\n                let [previewing, mode] = await nvim.eval('[coc#list#has_preview(),mode()]');\n                if (!previewing || mode != 'n')\n                    return;\n            }\n            await this.doAction('preview');\n        }, 50);\n        this.disposables.push({\n            dispose: () => {\n                debounced.clear();\n            }\n        });\n        this.ui.onDidLineChange(debounced, null, this.disposables);\n        this.ui.onDidLineChange(() => {\n            this.updateStatus();\n        }, null, this.disposables);\n        this.ui.onDidOpen(async () => {\n            if (typeof this.list.doHighlight == 'function') {\n                this.list.doHighlight();\n            }\n            if (this.listOptions.first) {\n                await this.doAction();\n            }\n        }, null, this.disposables);\n        this.ui.onDidClose(async () => {\n            await this.hide();\n        }, null, this.disposables);\n        this.ui.onDidDoubleClick(async () => {\n            await this.doAction();\n        }, null, this.disposables);\n        this.worker.onDidChangeItems(async ({ items, reload, append, finished }) => {\n            if (this.hidden)\n                return;\n            if (append) {\n                await this.ui.appendItems(items);\n            }\n            else {\n                let height = this.config.get('height', 10);\n                if (finished && !listOptions.interactive && listOptions.input.length == 0) {\n                    height = Math.min(items.length, height);\n                }\n                let tokenSource = this.uiTokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n                await this.ui.drawItems(items, Math.max(1, height), reload, tokenSource.token);\n            }\n        }, null, this.disposables);\n        this.worker.onDidChangeLoading(loading => {\n            if (this.hidden)\n                return;\n            if (loading) {\n                this.interval = setInterval(() => {\n                    let idx = Math.floor((new Date()).getMilliseconds() / 100);\n                    this.loadingFrame = frames[idx];\n                    this.updateStatus();\n                }, 100);\n            }\n            else {\n                if (this.interval) {\n                    this.loadingFrame = '';\n                    clearInterval(this.interval);\n                    this.interval = null;\n                }\n                this.updateStatus();\n            }\n        }, null, this.disposables);\n    }\n    async start(args) {\n        this.args = args;\n        this.cwd = workspace_1.default.cwd;\n        this.hidden = false;\n        let { listOptions, listArgs } = this;\n        let res = await this.nvim.eval('[win_getid(),bufnr(\"%\"),winheight(\"%\")]');\n        this.listArgs = listArgs;\n        this.history.load(listOptions.input || '');\n        this.window = this.nvim.createWindow(res[0]);\n        this.buffer = this.nvim.createBuffer(res[1]);\n        this.savedHeight = res[2];\n        await this.worker.loadItems(this.context);\n    }\n    async reloadItems() {\n        if (!this.window)\n            return;\n        let bufnr = await this.nvim.call('winbufnr', [this.window.id]);\n        // can't reload since window not exists\n        if (bufnr == -1)\n            return;\n        this.buffer = this.nvim.createBuffer(bufnr);\n        await this.worker.loadItems(this.context, true);\n    }\n    async call(fname) {\n        var _a, _b;\n        await this.nvim.call('coc#prompt#stop_prompt', ['list']);\n        let targets = await this.ui.getItems();\n        let context = {\n            name: this.name,\n            args: this.listArgs,\n            input: this.prompt.input,\n            winid: (_a = this.window) === null || _a === void 0 ? void 0 : _a.id,\n            bufnr: (_b = this.buffer) === null || _b === void 0 ? void 0 : _b.id,\n            targets\n        };\n        let res = await this.nvim.call(fname, [context]);\n        this.prompt.start();\n        return res;\n    }\n    async chooseAction() {\n        let { nvim } = this;\n        let { actions, defaultAction } = this.list;\n        let names = actions.map(o => o.name);\n        let idx = names.indexOf(defaultAction);\n        if (idx != -1) {\n            names.splice(idx, 1);\n            names.unshift(defaultAction);\n        }\n        let shortcuts = new Set();\n        let choices = [];\n        let invalids = [];\n        for (let name of names) {\n            let i = 0;\n            for (let ch of name) {\n                if (!shortcuts.has(ch)) {\n                    shortcuts.add(ch);\n                    choices.push(`${name.slice(0, i)}&${name.slice(i)}`);\n                    break;\n                }\n                i++;\n            }\n            if (i == name.length) {\n                invalids.push(name);\n            }\n        }\n        if (invalids.length) {\n            logger.error(`Can't create shortcut for actions: ${invalids.join(',')} of \"${this.name}\" list`);\n            names = names.filter(s => !invalids.includes(s));\n        }\n        await nvim.call('coc#prompt#stop_prompt', ['list']);\n        let n = await nvim.call('confirm', ['Choose action:', choices.join('\\n')]);\n        await util_1.wait(10);\n        this.prompt.start();\n        if (n)\n            await this.doAction(names[n - 1]);\n    }\n    async doAction(name) {\n        let { list } = this;\n        name = name || list.defaultAction;\n        let action = list.actions.find(o => o.name == name);\n        if (!action) {\n            window_1.default.showMessage(`Action ${name} not found`, 'error');\n            return;\n        }\n        let items;\n        if (name == 'preview') {\n            let item = await this.ui.item;\n            items = item ? [item] : [];\n        }\n        else {\n            items = await this.ui.getItems();\n        }\n        if (items.length)\n            await this.doItemAction(items, action);\n    }\n    async doPreview(index) {\n        let item = this.ui.getItem(index);\n        let action = this.list.actions.find(o => o.name == 'preview');\n        if (!item || !action)\n            return;\n        await this.doItemAction([item], action);\n    }\n    async first() {\n        await this.doDefaultAction(0);\n    }\n    async last() {\n        await this.doDefaultAction(this.ui.length - 1);\n    }\n    async previous() {\n        await this.doDefaultAction(this.ui.index - 1);\n    }\n    async next() {\n        await this.doDefaultAction(this.ui.index + 1);\n    }\n    async doDefaultAction(index) {\n        let { ui } = this;\n        let item = ui.getItem(index);\n        if (!item)\n            return;\n        ui.index = index;\n        await this.doItemAction([item], this.defaultAction);\n        await ui.echoMessage(item);\n    }\n    /**\n     * list name\n     */\n    get name() {\n        return this.list.name;\n    }\n    /**\n     * Window id used by list.\n     *\n     * @returns {number | undefined}\n     */\n    get winid() {\n        return this.ui.winid;\n    }\n    get length() {\n        return this.ui.length;\n    }\n    get defaultAction() {\n        let { defaultAction, actions } = this.list;\n        let action = actions.find(o => o.name == defaultAction);\n        if (!action)\n            throw new Error(`default action \"${defaultAction}\" not found`);\n        return action;\n    }\n    async hide() {\n        if (this.hidden)\n            return;\n        if (this.uiTokenSource) {\n            this.uiTokenSource.cancel();\n            this.uiTokenSource.dispose();\n            this.uiTokenSource = null;\n        }\n        let { nvim, interval } = this;\n        if (interval)\n            clearInterval(interval);\n        this.hidden = true;\n        this.worker.stop();\n        this.history.add();\n        let { winid } = this.ui;\n        this.ui.reset();\n        if (this.window && winid) {\n            await nvim.call('coc#list#hide', [this.window.id, this.savedHeight, winid]);\n            if (workspace_1.default.isVim) {\n                nvim.command('redraw', true);\n                // Needed for tabe action, don't know why.\n                await util_1.wait(10);\n            }\n        }\n        nvim.call('coc#prompt#stop_prompt', ['list'], true);\n    }\n    toggleMode() {\n        let mode = this.prompt.mode == 'normal' ? 'insert' : 'normal';\n        this.prompt.mode = mode;\n        this.listOptions.mode = mode;\n        this.updateStatus();\n    }\n    stop() {\n        this.worker.stop();\n    }\n    async resolveItem() {\n        let index = this.ui.index;\n        let item = this.ui.getItem(index);\n        if (!item || item.resolved)\n            return;\n        let { list } = this;\n        if (typeof list.resolveItem == 'function') {\n            let resolved = await Promise.resolve(list.resolveItem(item));\n            if (resolved && index == this.ui.index) {\n                await this.ui.updateItem(resolved, index);\n            }\n        }\n    }\n    async showHelp() {\n        await this.hide();\n        let { list, nvim } = this;\n        if (!list)\n            return;\n        nvim.pauseNotification();\n        nvim.command(`tabe +setl\\\\ previewwindow [LIST HELP]`, true);\n        nvim.command('setl nobuflisted noswapfile buftype=nofile bufhidden=wipe', true);\n        await nvim.resumeNotification();\n        let hasOptions = list.options && list.options.length;\n        let buf = await nvim.buffer;\n        let highligher = new highligher_1.default();\n        highligher.addLine('NAME', 'Label');\n        highligher.addLine(`  ${list.name} - ${list.description || ''}\\n`);\n        highligher.addLine('SYNOPSIS', 'Label');\n        highligher.addLine(`  :CocList [LIST OPTIONS] ${list.name}${hasOptions ? ' [ARGUMENTS]' : ''}\\n`);\n        if (list.detail) {\n            highligher.addLine('DESCRIPTION', 'Label');\n            let lines = list.detail.split('\\n').map(s => '  ' + s);\n            highligher.addLine(lines.join('\\n') + '\\n');\n        }\n        if (hasOptions) {\n            highligher.addLine('ARGUMENTS', 'Label');\n            highligher.addLine('');\n            for (let opt of list.options) {\n                highligher.addLine(opt.name, 'Special');\n                highligher.addLine(`  ${opt.description}`);\n                highligher.addLine('');\n            }\n            highligher.addLine('');\n        }\n        let config = workspace_1.default.getConfiguration(`list.source.${list.name}`);\n        if (Object.keys(config).length) {\n            highligher.addLine('CONFIGURATIONS', 'Label');\n            highligher.addLine('');\n            let props = {};\n            extensions_1.default.all.forEach(extension => {\n                let { packageJSON } = extension;\n                let { contributes } = packageJSON;\n                if (!contributes)\n                    return;\n                let { configuration } = contributes;\n                if (configuration) {\n                    let { properties } = configuration;\n                    if (properties) {\n                        for (let key of Object.keys(properties)) {\n                            props[key] = properties[key];\n                        }\n                    }\n                }\n            });\n            for (let key of Object.keys(config)) {\n                let val = config[key];\n                let name = `list.source.${list.name}.${key}`;\n                let description = props[name] && props[name].description ? props[name].description : key;\n                highligher.addLine(`  \"${name}\"`, 'MoreMsg');\n                highligher.addText(` - ${description}, current value: `);\n                highligher.addText(JSON.stringify(val), 'Special');\n            }\n            highligher.addLine('');\n        }\n        highligher.addLine('ACTIONS', 'Label');\n        highligher.addLine(`  ${list.actions.map(o => o.name).join(', ')}`);\n        highligher.addLine('');\n        highligher.addLine(`see ':h coc-list-options' for available list options.`, 'Comment');\n        nvim.pauseNotification();\n        highligher.render(buf, 0, -1);\n        nvim.command('setl nomod', true);\n        nvim.command('setl nomodifiable', true);\n        nvim.command('normal! gg', true);\n        nvim.command('nnoremap <buffer> q :bd!<CR>', true);\n        await nvim.resumeNotification();\n    }\n    switchMatcher() {\n        let { matcher, interactive } = this.listOptions;\n        if (interactive)\n            return;\n        const list = ['fuzzy', 'strict', 'regex'];\n        let idx = list.indexOf(matcher) + 1;\n        if (idx >= list.length)\n            idx = 0;\n        this.listOptions.matcher = list[idx];\n        this.prompt.matcher = list[idx];\n        this.worker.drawItems();\n    }\n    updateStatus() {\n        let { ui, list, nvim } = this;\n        if (!ui.winid)\n            return;\n        let buf = nvim.createBuffer(ui.bufnr);\n        let status = {\n            mode: this.prompt.mode.toUpperCase(),\n            args: this.args.join(' '),\n            name: list.name,\n            cwd: this.cwd,\n            loading: this.loadingFrame,\n            total: this.worker.length\n        };\n        nvim.pauseNotification();\n        buf.setVar('list_status', status, true);\n        nvim.command('redraws', true);\n        nvim.resumeNotification(false, true).logError();\n    }\n    get context() {\n        let { winid } = this.ui;\n        return {\n            options: this.listOptions,\n            args: this.listArgs,\n            input: this.prompt.input,\n            cwd: workspace_1.default.cwd,\n            window: this.window,\n            buffer: this.buffer,\n            listWindow: winid ? this.nvim.createWindow(winid) : undefined\n        };\n    }\n    redrawItems() {\n        this.worker.drawItems();\n    }\n    onMouseEvent(key) {\n        switch (key) {\n            case '<LeftMouse>':\n                return this.ui.onMouse('mouseDown');\n            case '<LeftDrag>':\n                return this.ui.onMouse('mouseDrag');\n            case '<LeftRelease>':\n                return this.ui.onMouse('mouseUp');\n            case '<2-LeftMouse>':\n                return this.ui.onMouse('doubleClick');\n        }\n    }\n    async doNumberSelect(ch) {\n        if (!this.listOptions.numberSelect)\n            return false;\n        let code = ch.charCodeAt(0);\n        if (code >= 48 && code <= 57) {\n            let n = Number(ch);\n            if (n == 0)\n                n = 10;\n            if (this.ui.length >= n) {\n                this.nvim.pauseNotification();\n                this.ui.setCursor(Number(ch), 0);\n                await this.nvim.resumeNotification();\n                await this.doAction();\n            }\n            return true;\n        }\n        return false;\n    }\n    jumpBack() {\n        let { window, nvim } = this;\n        if (window) {\n            nvim.pauseNotification();\n            nvim.call('coc#prompt#stop_prompt', ['list'], true);\n            this.nvim.call('win_gotoid', [window.id], true);\n            nvim.resumeNotification(false, true).logError();\n        }\n    }\n    async resume() {\n        if (this.winid)\n            await this.hide();\n        let res = await this.nvim.eval('[win_getid(),bufnr(\"%\"),winheight(\"%\")]');\n        this.hidden = false;\n        this.window = this.nvim.createWindow(res[0]);\n        this.buffer = this.nvim.createBuffer(res[1]);\n        this.savedHeight = res[2];\n        this.prompt.start();\n        await this.ui.resume();\n        if (this.listOptions.autoPreview) {\n            await this.doAction('preview');\n        }\n    }\n    async doItemAction(items, action) {\n        let { noQuit } = this.listOptions;\n        let { nvim } = this;\n        let persistAction = action.persist === true || action.name == 'preview';\n        let persist = this.winid && (persistAction || noQuit);\n        try {\n            if (persist) {\n                if (!persistAction) {\n                    nvim.pauseNotification();\n                    nvim.call('coc#prompt#stop_prompt', ['list'], true);\n                    nvim.call('win_gotoid', [this.context.window.id], true);\n                    await nvim.resumeNotification();\n                }\n            }\n            else {\n                await this.hide();\n            }\n            if (action.multiple) {\n                await Promise.resolve(action.execute(items, this.context));\n            }\n            else if (action.parallel) {\n                await Promise.all(items.map(item => Promise.resolve(action.execute(item, this.context))));\n            }\n            else {\n                for (let item of items) {\n                    await Promise.resolve(action.execute(item, this.context));\n                }\n            }\n            if (persist) {\n                this.ui.restoreWindow();\n            }\n            if (action.reload && persist)\n                await this.worker.loadItems(this.context, true);\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n    onInputChange() {\n        if (this.timer)\n            clearTimeout(this.timer);\n        let len = this.worker.length;\n        this.listOptions.input = this.prompt.input;\n        // reload or filter items\n        if (this.listOptions.interactive) {\n            this.worker.stop();\n            this.timer = setTimeout(async () => {\n                await this.worker.loadItems(this.context);\n            }, this.interactiveDebounceTime);\n        }\n        else if (len) {\n            let wait = Math.max(Math.min(Math.floor(len / 200), 300), 50);\n            this.timer = setTimeout(() => {\n                this.worker.drawItems();\n            }, wait);\n        }\n    }\n    dispose() {\n        if (!this.hidden) {\n            this.hidden = true;\n            if (this.uiTokenSource) {\n                this.uiTokenSource.cancel();\n                this.uiTokenSource.dispose();\n                this.uiTokenSource = null;\n            }\n            let { winid } = this.ui;\n            this.ui.reset();\n            if (this.window && winid) {\n                this.nvim.call('coc#list#hide', [this.window.id, this.savedHeight, winid], true);\n            }\n        }\n        if (this.interval) {\n            clearInterval(this.interval);\n        }\n        if (this.timer) {\n            clearTimeout(this.timer);\n        }\n        util_1.disposeAll(this.disposables);\n        this.worker.dispose();\n        this.ui.dispose();\n    }\n}\nexports.default = ListSession;\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/session.ts?");

/***/ }),

/***/ "./src/list/source/commands.ts":
/*!*************************************!*\
  !*** ./src/list/source/commands.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst commands_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../commands */ \"./src/commands.ts\"));\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../events */ \"./src/events.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../workspace */ \"./src/workspace.ts\"));\nconst basic_1 = tslib_1.__importDefault(__webpack_require__(/*! ../basic */ \"./src/list/basic.ts\"));\nconst formatting_1 = __webpack_require__(/*! ../formatting */ \"./src/list/formatting.ts\");\nclass CommandsList extends basic_1.default {\n    constructor(nvim) {\n        super(nvim);\n        this.defaultAction = 'run';\n        this.description = 'registered commands of coc.nvim';\n        this.name = 'commands';\n        this.mru = workspace_1.default.createMru('commands');\n        this.addAction('run', async (item) => {\n            let { cmd } = item.data;\n            await events_1.default.fire('Command', [cmd]);\n            commands_1.default.executeCommand(cmd).logError();\n            await commands_1.default.addRecent(cmd);\n        });\n        this.addAction('append', async (item) => {\n            let { cmd } = item.data;\n            await nvim.feedKeys(`:CocCommand ${cmd} `, 'n', false);\n        });\n    }\n    async loadItems(_context) {\n        let items = [];\n        let list = commands_1.default.commandList;\n        let { titles } = commands_1.default;\n        let mruList = await this.mru.load();\n        for (const o of list) {\n            const { id } = o;\n            items.push({\n                label: [id, ...(titles.get(id) ? [titles.get(id)] : [])],\n                filterText: id,\n                data: { cmd: id, score: score(mruList, id) }\n            });\n        }\n        items.sort((a, b) => b.data.score - a.data.score);\n        return formatting_1.formatListItems(this.alignColumns, items);\n    }\n    doHighlight() {\n        let { nvim } = this;\n        nvim.pauseNotification();\n        nvim.command('syntax match CocCommandsTitle /\\\\t.*$/ contained containedin=CocCommandsLine', true);\n        nvim.command('highlight default link CocCommandsTitle Comment', true);\n        nvim.resumeNotification().catch(_e => {\n            // noop\n        });\n    }\n}\nexports.default = CommandsList;\nfunction score(list, key) {\n    let idx = list.indexOf(key);\n    return idx == -1 ? -1 : list.length - idx;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/source/commands.ts?");

/***/ }),

/***/ "./src/list/source/diagnostics.ts":
/*!****************************************!*\
  !*** ./src/list/source/diagnostics.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../diagnostic/manager */ \"./src/diagnostic/manager.ts\"));\nconst location_1 = tslib_1.__importDefault(__webpack_require__(/*! ./location */ \"./src/list/source/location.ts\"));\nconst fs_1 = __webpack_require__(/*! ../../util/fs */ \"./src/util/fs.ts\");\nconst formatting_1 = __webpack_require__(/*! ../formatting */ \"./src/list/formatting.ts\");\nconst logger = __webpack_require__(/*! ../../util/logger */ \"./src/util/logger.ts\")('list-symbols');\nclass DiagnosticsList extends location_1.default {\n    constructor() {\n        super(...arguments);\n        this.defaultAction = 'open';\n        this.description = 'diagnostics of current workspace';\n        this.name = 'diagnostics';\n    }\n    async loadItems(context) {\n        let list = manager_1.default.getDiagnosticList();\n        let { cwd } = context;\n        const shouldIncludeCode = this.getConfig().get('includeCode', true);\n        const pathFormat = this.getConfig().get('pathFormat', \"full\");\n        const unformatted = list.map(item => {\n            const file = fs_1.isParentFolder(cwd, item.file) ? path_1.default.relative(cwd, item.file) : item.file;\n            const formattedPath = formatting_1.formatPath(pathFormat, file);\n            const formattedPosition = pathFormat !== \"hidden\" ? [`${formattedPath}:${item.lnum}`] : [];\n            const code = shouldIncludeCode ? [`[${item.source}${item.code ? '' : ']'}`, item.code ? `${item.code}]` : ''] : [];\n            return {\n                label: [...formattedPosition, ...code, item.severity, item.message],\n                location: item.location,\n            };\n        });\n        return formatting_1.formatListItems(this.alignColumns, unformatted);\n    }\n    doHighlight() {\n        let { nvim } = this;\n        nvim.pauseNotification();\n        nvim.command('syntax match CocDiagnosticsFile /\\\\v^\\\\s*\\\\S+/ contained containedin=CocDiagnosticsLine', true);\n        nvim.command('syntax match CocDiagnosticsError /\\\\tError\\\\s*\\\\t/ contained containedin=CocDiagnosticsLine', true);\n        nvim.command('syntax match CocDiagnosticsWarning /\\\\tWarning\\\\s*\\\\t/ contained containedin=CocDiagnosticsLine', true);\n        nvim.command('syntax match CocDiagnosticsInfo /\\\\tInformation\\\\s*\\\\t/ contained containedin=CocDiagnosticsLine', true);\n        nvim.command('syntax match CocDiagnosticsHint /\\\\tHint\\\\s*\\\\t/ contained containedin=CocDiagnosticsLine', true);\n        nvim.command('highlight default link CocDiagnosticsFile Comment', true);\n        nvim.command('highlight default link CocDiagnosticsError CocErrorSign', true);\n        nvim.command('highlight default link CocDiagnosticsWarning CocWarningSign', true);\n        nvim.command('highlight default link CocDiagnosticsInfo CocInfoSign', true);\n        nvim.command('highlight default link CocDiagnosticsHint CocHintSign', true);\n        nvim.resumeNotification().catch(_e => {\n            // noop\n        });\n    }\n}\nexports.default = DiagnosticsList;\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/source/diagnostics.ts?");

/***/ }),

/***/ "./src/list/source/extensions.ts":
/*!***************************************!*\
  !*** ./src/list/source/extensions.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst fs_extra_1 = tslib_1.__importDefault(__webpack_require__(/*! fs-extra */ \"./node_modules/fs-extra/lib/index.js\"));\nconst os_1 = tslib_1.__importDefault(__webpack_require__(/*! os */ \"os\"));\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst extensions_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../extensions */ \"./src/extensions.ts\"));\nconst util_1 = __webpack_require__(/*! ../../util */ \"./src/util/index.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../workspace */ \"./src/workspace.ts\"));\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../window */ \"./src/window.ts\"));\nconst basic_1 = tslib_1.__importDefault(__webpack_require__(/*! ../basic */ \"./src/list/basic.ts\"));\nconst formatting_1 = __webpack_require__(/*! ../formatting */ \"./src/list/formatting.ts\");\nconst logger = __webpack_require__(/*! ../../util/logger */ \"./src/util/logger.ts\")('list-extensions');\nclass ExtensionList extends basic_1.default {\n    constructor(nvim) {\n        super(nvim);\n        this.defaultAction = 'toggle';\n        this.description = 'manage coc extensions';\n        this.name = 'extensions';\n        this.addAction('toggle', async (item) => {\n            let { id, state } = item.data;\n            if (state == 'disabled')\n                return;\n            if (state == 'activated') {\n                await extensions_1.default.deactivate(id);\n            }\n            else {\n                await extensions_1.default.activate(id);\n            }\n            await util_1.wait(100);\n        }, { persist: true, reload: true, parallel: true });\n        this.addAction('configuration', async (item) => {\n            let { root } = item.data;\n            let jsonFile = path_1.default.join(root, 'package.json');\n            if (fs_extra_1.default.existsSync(jsonFile)) {\n                let lines = fs_extra_1.default.readFileSync(jsonFile, 'utf8').split(/\\r?\\n/);\n                let idx = lines.findIndex(s => s.includes('\"contributes\"'));\n                await workspace_1.default.jumpTo(vscode_uri_1.URI.file(jsonFile).toString(), { line: idx == -1 ? 0 : idx, character: 0 });\n            }\n        });\n        this.addAction('open', async (item) => {\n            let { root } = item.data;\n            if (workspace_1.default.env.isiTerm) {\n                nvim.call('coc#util#iterm_open', [root], true);\n            }\n            else {\n                nvim.call('coc#util#open_url', [root], true);\n            }\n        });\n        this.addAction('disable', async (item) => {\n            let { id, state } = item.data;\n            if (state !== 'disabled')\n                await extensions_1.default.toggleExtension(id);\n        }, { persist: true, reload: true, parallel: true });\n        this.addAction('enable', async (item) => {\n            let { id, state } = item.data;\n            if (state == 'disabled')\n                await extensions_1.default.toggleExtension(id);\n        }, { persist: true, reload: true, parallel: true });\n        this.addAction('lock', async (item) => {\n            let { id } = item.data;\n            await extensions_1.default.toggleLock(id);\n        }, { persist: true, reload: true });\n        this.addAction('help', async (item) => {\n            let { root } = item.data;\n            let files = await fs_extra_1.default.readdir(root);\n            let file = files.find(f => /^readme/i.test(f));\n            if (file) {\n                let escaped = await nvim.call('fnameescape', [path_1.default.join(root, file)]);\n                await workspace_1.default.callAsync('coc#util#execute', [`edit ${escaped}`]);\n            }\n        });\n        this.addAction('reload', async (item) => {\n            let { id } = item.data;\n            await extensions_1.default.reloadExtension(id);\n        }, { persist: true, reload: true });\n        this.addAction('fix', async (item) => {\n            let { root, isLocal } = item.data;\n            let { npm } = extensions_1.default;\n            if (isLocal) {\n                window_1.default.showMessage(`Can't fix for local extension.`, 'warning');\n                return;\n            }\n            if (!npm)\n                return;\n            let folder = path_1.default.join(root, 'node_modules');\n            if (fs_extra_1.default.existsSync(folder)) {\n                fs_extra_1.default.removeSync(folder);\n            }\n            let terminal = await workspace_1.default.createTerminal({\n                cwd: root\n            });\n            let shown = await terminal.show(false);\n            if (!shown)\n                return;\n            workspace_1.default.nvim.command(`startinsert`, true);\n            terminal.sendText(`${npm} install --production --ignore-scripts --no-lockfile`, true);\n        });\n        this.addMultipleAction('uninstall', async (items) => {\n            let ids = [];\n            for (let item of items) {\n                if (item.data.isLocal)\n                    continue;\n                ids.push(item.data.id);\n            }\n            extensions_1.default.uninstallExtension(ids).catch(e => {\n                logger.error(e);\n            });\n        });\n    }\n    async loadItems(_context) {\n        let items = [];\n        let list = await extensions_1.default.getExtensionStates();\n        let lockedList = await extensions_1.default.getLockedList();\n        for (let stat of list) {\n            let prefix = '+';\n            if (stat.state == 'disabled') {\n                prefix = '-';\n            }\n            else if (stat.state == 'activated') {\n                prefix = '*';\n            }\n            else if (stat.state == 'unknown') {\n                prefix = '?';\n            }\n            let root = await this.nvim.call('resolve', stat.root);\n            let locked = lockedList.includes(stat.id);\n            items.push({\n                label: [`${prefix} ${stat.id}${locked ? ' ' : ''}`, ...(stat.isLocal ? ['[RTP]'] : []), stat.version, root.replace(os_1.default.homedir(), '~')],\n                filterText: stat.id,\n                data: {\n                    id: stat.id,\n                    root,\n                    state: stat.state,\n                    isLocal: stat.isLocal,\n                    priority: getPriority(stat.state)\n                }\n            });\n        }\n        items.sort((a, b) => {\n            if (a.data.priority != b.data.priority) {\n                return b.data.priority - a.data.priority;\n            }\n            return b.data.id - a.data.id ? 1 : -1;\n        });\n        return formatting_1.formatListItems(this.alignColumns, items);\n    }\n    doHighlight() {\n        let { nvim } = this;\n        nvim.pauseNotification();\n        nvim.command('syntax match CocExtensionsActivited /\\\\v^\\\\*/ contained containedin=CocExtensionsLine', true);\n        nvim.command('syntax match CocExtensionsLoaded /\\\\v^\\\\+/ contained containedin=CocExtensionsLine', true);\n        nvim.command('syntax match CocExtensionsDisabled /\\\\v^-/ contained containedin=CocExtensionsLine', true);\n        nvim.command('syntax match CocExtensionsName /\\\\v%3c\\\\S+/ contained containedin=CocExtensionsLine', true);\n        nvim.command('syntax match CocExtensionsRoot /\\\\v\\\\t[^\\\\t]*$/ contained containedin=CocExtensionsLine', true);\n        nvim.command('syntax match CocExtensionsLocal /\\\\v\\\\[RTP\\\\]/ contained containedin=CocExtensionsLine', true);\n        nvim.command('highlight default link CocExtensionsActivited Special', true);\n        nvim.command('highlight default link CocExtensionsLoaded Normal', true);\n        nvim.command('highlight default link CocExtensionsDisabled Comment', true);\n        nvim.command('highlight default link CocExtensionsName String', true);\n        nvim.command('highlight default link CocExtensionsLocal MoreMsg', true);\n        nvim.command('highlight default link CocExtensionsRoot Comment', true);\n        nvim.resumeNotification().catch(_e => {\n            // noop\n        });\n    }\n}\nexports.default = ExtensionList;\nfunction getPriority(stat) {\n    switch (stat) {\n        case 'unknown':\n            return 2;\n        case 'activated':\n            return 1;\n        case 'disabled':\n            return -1;\n        default:\n            return 0;\n    }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/source/extensions.ts?");

/***/ }),

/***/ "./src/list/source/folders.ts":
/*!************************************!*\
  !*** ./src/list/source/folders.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst fs_extra_1 = tslib_1.__importDefault(__webpack_require__(/*! fs-extra */ \"./node_modules/fs-extra/lib/index.js\"));\nconst fs_1 = __webpack_require__(/*! ../../util/fs */ \"./src/util/fs.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../workspace */ \"./src/workspace.ts\"));\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../window */ \"./src/window.ts\"));\nconst basic_1 = tslib_1.__importDefault(__webpack_require__(/*! ../basic */ \"./src/list/basic.ts\"));\nclass FoldList extends basic_1.default {\n    constructor(nvim) {\n        super(nvim);\n        this.defaultAction = 'edit';\n        this.description = 'list of current workspace folders';\n        this.name = 'folders';\n        this.addAction('edit', async (item) => {\n            let newPath = await nvim.call('input', ['Folder: ', item.label, 'dir']);\n            let stat = await fs_1.statAsync(newPath);\n            if (!stat || !stat.isDirectory()) {\n                window_1.default.showMessage(`invalid path: ${newPath}`, 'error');\n                return;\n            }\n            workspace_1.default.renameWorkspaceFolder(item.label, newPath);\n        });\n        this.addAction('delete', async (item) => {\n            workspace_1.default.removeWorkspaceFolder(item.label);\n        }, { reload: true, persist: true });\n        this.addAction('newfile', async (item) => {\n            let file = await window_1.default.requestInput('File name', item.label + '/');\n            let dir = path_1.default.dirname(file);\n            let stat = await fs_1.statAsync(dir);\n            if (!stat || !stat.isDirectory()) {\n                let success = await fs_extra_1.default.mkdirp(dir);\n                if (!success) {\n                    window_1.default.showMessage(`Error creating new directory ${dir}`, 'error');\n                    return;\n                }\n            }\n            await workspace_1.default.createFile(file, { overwrite: false, ignoreIfExists: true });\n            await this.jumpTo(vscode_uri_1.URI.file(file).toString());\n        });\n    }\n    async loadItems(_context) {\n        return workspace_1.default.folderPaths.map(p => ({ label: p }));\n    }\n}\nexports.default = FoldList;\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/source/folders.ts?");

/***/ }),

/***/ "./src/list/source/links.ts":
/*!**********************************!*\
  !*** ./src/list/source/links.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../languages */ \"./src/languages.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../workspace */ \"./src/workspace.ts\"));\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst basic_1 = tslib_1.__importDefault(__webpack_require__(/*! ../basic */ \"./src/list/basic.ts\"));\nconst vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ \"./node_modules/vscode-languageserver-types/lib/esm/main.js\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst fs_1 = __webpack_require__(/*! ../../util/fs */ \"./src/util/fs.ts\");\nclass LinksList extends basic_1.default {\n    constructor(nvim) {\n        super(nvim);\n        this.defaultAction = 'open';\n        this.description = 'links of current buffer';\n        this.name = 'links';\n        this.addAction('open', async (item) => {\n            let { target } = item.data;\n            let uri = vscode_uri_1.URI.parse(target);\n            if (uri.scheme.startsWith('http')) {\n                await nvim.call('coc#util#open_url', target);\n            }\n            else {\n                await workspace_1.default.jumpTo(target);\n            }\n        });\n        this.addAction('jump', async (item) => {\n            let { location } = item.data;\n            await workspace_1.default.jumpTo(location.uri, location.range.start);\n        });\n    }\n    async loadItems(context, token) {\n        let buf = await context.window.buffer;\n        let doc = workspace_1.default.getDocument(buf.id);\n        if (!doc)\n            return null;\n        let items = [];\n        let links = await languages_1.default.getDocumentLinks(doc.textDocument, token);\n        if (links == null) {\n            throw new Error('Links provider not found.');\n        }\n        let res = [];\n        for (let link of links) {\n            if (link.target) {\n                items.push({\n                    label: formatUri(link.target),\n                    data: {\n                        target: link.target,\n                        location: vscode_languageserver_types_1.Location.create(doc.uri, link.range)\n                    }\n                });\n            }\n            else {\n                link = await languages_1.default.resolveDocumentLink(link);\n                if (link.target) {\n                    items.push({\n                        label: formatUri(link.target),\n                        data: {\n                            target: link.target,\n                            location: vscode_languageserver_types_1.Location.create(doc.uri, link.range)\n                        }\n                    });\n                }\n                res.push(link);\n            }\n        }\n        return items;\n    }\n}\nexports.default = LinksList;\nfunction formatUri(uri) {\n    if (!uri.startsWith('file:'))\n        return uri;\n    let filepath = vscode_uri_1.URI.parse(uri).fsPath;\n    return fs_1.isParentFolder(workspace_1.default.cwd, filepath) ? path_1.default.relative(workspace_1.default.cwd, filepath) : filepath;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/source/links.ts?");

/***/ }),

/***/ "./src/list/source/lists.ts":
/*!**********************************!*\
  !*** ./src/list/source/lists.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst basic_1 = tslib_1.__importDefault(__webpack_require__(/*! ../basic */ \"./src/list/basic.ts\"));\nconst mru_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../model/mru */ \"./src/model/mru.ts\"));\nconst formatting_1 = __webpack_require__(/*! ../formatting */ \"./src/list/formatting.ts\");\nclass LinksList extends basic_1.default {\n    constructor(nvim, listMap) {\n        super(nvim);\n        this.listMap = listMap;\n        this.name = 'lists';\n        this.defaultAction = 'open';\n        this.description = 'registered lists of coc.nvim';\n        this.mru = new mru_1.default('lists');\n        this.addAction('open', async (item) => {\n            let { name } = item.data;\n            await this.mru.add(name);\n            await nvim.command(`CocList ${name}`);\n        });\n    }\n    async loadItems(_context) {\n        let items = [];\n        let mruList = await this.mru.load();\n        for (let list of this.listMap.values()) {\n            if (list.name == 'lists')\n                continue;\n            items.push({\n                label: [list.name, ...(list.description ? [list.description] : [])],\n                data: {\n                    name: list.name,\n                    interactive: list.interactive,\n                    score: score(mruList, list.name)\n                }\n            });\n        }\n        items.sort((a, b) => b.data.score - a.data.score);\n        return formatting_1.formatListItems(this.alignColumns, items);\n    }\n    doHighlight() {\n        let { nvim } = this;\n        nvim.pauseNotification();\n        nvim.command('syntax match CocListsDesc /\\\\t.*$/ contained containedin=CocListsLine', true);\n        nvim.command('highlight default link CocListsDesc Comment', true);\n        nvim.resumeNotification().catch(_e => {\n            // noop\n        });\n    }\n}\nexports.default = LinksList;\nfunction score(list, key) {\n    let idx = list.indexOf(key);\n    return idx == -1 ? -1 : list.length - idx;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/source/lists.ts?");

/***/ }),

/***/ "./src/list/source/location.ts":
/*!*************************************!*\
  !*** ./src/list/source/location.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ \"./node_modules/vscode-languageserver-types/lib/esm/main.js\");\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst basic_1 = tslib_1.__importDefault(__webpack_require__(/*! ../basic */ \"./src/list/basic.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../workspace */ \"./src/workspace.ts\"));\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst fs_1 = __webpack_require__(/*! ../../util/fs */ \"./src/util/fs.ts\");\nconst string_1 = __webpack_require__(/*! ../../util/string */ \"./src/util/string.ts\");\nconst logger = __webpack_require__(/*! ../../util/logger */ \"./src/util/logger.ts\")('list-location');\nclass LocationList extends basic_1.default {\n    constructor(nvim) {\n        super(nvim);\n        this.defaultAction = 'open';\n        this.description = 'show locations saved by g:coc_jump_locations variable';\n        this.name = 'location';\n        this.addLocationActions();\n    }\n    async loadItems(context, token) {\n        // filename, lnum, col, text, type\n        let locs = await this.nvim.getVar('coc_jump_locations');\n        if (token.isCancellationRequested)\n            return [];\n        locs = locs || [];\n        locs.forEach(loc => {\n            if (!loc.uri) {\n                let fullpath = path_1.default.isAbsolute(loc.filename) ? loc.filename : path_1.default.join(context.cwd, loc.filename);\n                loc.uri = vscode_uri_1.URI.file(fullpath).toString();\n            }\n            if (!loc.bufnr && workspace_1.default.getDocument(loc.uri) != null) {\n                loc.bufnr = workspace_1.default.getDocument(loc.uri).bufnr;\n            }\n            if (!loc.range) {\n                let { lnum, col } = loc;\n                loc.range = vscode_languageserver_types_1.Range.create(lnum - 1, col - 1, lnum - 1, col - 1);\n            }\n            else {\n                loc.lnum = loc.lnum || loc.range.start.line + 1;\n                loc.col = loc.col || loc.range.start.character + 1;\n            }\n        });\n        let bufnr = await this.nvim.call('bufnr', '%');\n        let ignoreFilepath = locs.every(o => o.bufnr && bufnr && o.bufnr == bufnr);\n        let items = locs.map(loc => {\n            let filename = ignoreFilepath ? '' : loc.filename;\n            let filterText = `${filename}${loc.text.trim()}`;\n            if (path_1.default.isAbsolute(filename)) {\n                filename = fs_1.isParentFolder(context.cwd, filename) ? path_1.default.relative(context.cwd, filename) : filename;\n            }\n            let pre = `${filename} |${loc.type ? loc.type + ' ' : ''}${loc.lnum} col ${loc.col}| `;\n            let highlight;\n            if (loc.range && loc.range.start.line == loc.range.end.line) {\n                let start = string_1.byteLength(pre) + string_1.byteLength(loc.text.slice(0, loc.range.start.character));\n                let end = string_1.byteLength(pre) + string_1.byteLength(loc.text.slice(0, loc.range.end.character));\n                highlight = { hlGroup: 'Search', span: [start, end] };\n            }\n            let label = pre + loc.text;\n            return {\n                label,\n                location: vscode_languageserver_types_1.Location.create(loc.uri, loc.range),\n                filterText,\n                ansiHighlights: highlight ? [highlight] : undefined\n            };\n        });\n        return items;\n    }\n    doHighlight() {\n        let { nvim } = this;\n        nvim.pauseNotification();\n        nvim.command('syntax match CocLocationName /\\\\v^[^|]+/ contained containedin=CocLocationLine', true);\n        nvim.command('syntax match CocLocationPosition /\\\\v\\\\|\\\\w*\\\\s?\\\\d+\\\\scol\\\\s\\\\d+\\\\|/ contained containedin=CocLocationLine', true);\n        nvim.command('syntax match CocLocationError /Error/ contained containedin=CocLocationPosition', true);\n        nvim.command('syntax match CocLocationWarning /Warning/ contained containedin=CocLocationPosition', true);\n        nvim.command('highlight default link CocLocationName Directory', true);\n        nvim.command('highlight default link CocLocationPosition LineNr', true);\n        nvim.command('highlight default link CocLocationError Error', true);\n        nvim.command('highlight default link CocLocationWarning WarningMsg', true);\n        nvim.resumeNotification().catch(_e => {\n            // noop\n        });\n    }\n}\nexports.default = LocationList;\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/source/location.ts?");

/***/ }),

/***/ "./src/list/source/outline.ts":
/*!************************************!*\
  !*** ./src/list/source/outline.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ \"./node_modules/vscode-languageserver-types/lib/esm/main.js\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst which_1 = tslib_1.__importDefault(__webpack_require__(/*! which */ \"./node_modules/which/which.js\"));\nconst languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../languages */ \"./src/languages.ts\"));\nconst util_1 = __webpack_require__(/*! ../../util */ \"./src/util/index.ts\");\nconst fs_1 = __webpack_require__(/*! ../../util/fs */ \"./src/util/fs.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../workspace */ \"./src/workspace.ts\"));\nconst location_1 = tslib_1.__importDefault(__webpack_require__(/*! ./location */ \"./src/list/source/location.ts\"));\nconst convert_1 = __webpack_require__(/*! ../../util/convert */ \"./src/util/convert.ts\");\nconst formatting_1 = __webpack_require__(/*! ../formatting */ \"./src/list/formatting.ts\");\nconst logger = __webpack_require__(/*! ../../util/logger */ \"./src/util/logger.ts\")('list-symbols');\nfunction getFilterText(s, kind) {\n    return `${s.name}${kind ? ` ${kind}` : ''}`;\n}\nclass Outline extends location_1.default {\n    constructor() {\n        super(...arguments);\n        this.description = 'symbols of current document';\n        this.name = 'outline';\n        this.options = [{\n                name: '-k, -kind KIND',\n                hasValue: true,\n                description: 'filters also by kind',\n            }];\n    }\n    async loadItems(context, token) {\n        let buf = await context.window.buffer;\n        let document = workspace_1.default.getDocument(buf.id);\n        if (!document)\n            return null;\n        let config = this.getConfig();\n        let ctagsFilestypes = config.get('ctagsFilestypes', []);\n        let symbols;\n        let args = this.parseArguments(context.args);\n        if (!ctagsFilestypes.includes(document.filetype)) {\n            symbols = await languages_1.default.getDocumentSymbol(document.textDocument, token);\n        }\n        if (token.isCancellationRequested)\n            return [];\n        if (!symbols)\n            return await this.loadCtagsSymbols(document);\n        if (symbols.length == 0)\n            return [];\n        let filterKind = args.kind ? args.kind.toLowerCase() : null;\n        let items = [];\n        let isSymbols = !symbols[0].hasOwnProperty('location');\n        if (isSymbols) {\n            // eslint-disable-next-line no-inner-declarations\n            function addSymbols(symbols, level = 0) {\n                symbols.sort(sortSymbols);\n                for (let s of symbols) {\n                    let kind = convert_1.getSymbolKind(s.kind);\n                    let location = vscode_languageserver_types_1.Location.create(document.uri, s.selectionRange);\n                    items.push({\n                        label: [`${'| '.repeat(level)}${s.name}`, `[${kind}]`, `${s.range.start.line + 1}`],\n                        filterText: getFilterText(s, args.kind == '' ? kind : null),\n                        location,\n                        data: { kind }\n                    });\n                    if (s.children && s.children.length) {\n                        addSymbols(s.children, level + 1);\n                    }\n                }\n            }\n            addSymbols(symbols);\n            if (filterKind) {\n                items = items.filter(o => o.data.kind.toLowerCase().indexOf(filterKind) == 0);\n            }\n        }\n        else {\n            symbols.sort((a, b) => {\n                let sa = a.location.range.start;\n                let sb = b.location.range.start;\n                let d = sa.line - sb.line;\n                return d == 0 ? sa.character - sb.character : d;\n            });\n            for (let s of symbols) {\n                let kind = convert_1.getSymbolKind(s.kind);\n                if (s.name.endsWith(') callback'))\n                    continue;\n                if (filterKind && !kind.toLowerCase().startsWith(filterKind)) {\n                    continue;\n                }\n                if (s.location.uri === undefined) {\n                    s.location.uri = document.uri;\n                }\n                items.push({\n                    label: [s.name, `[${kind}]`, `${s.location.range.start.line + 1}`],\n                    filterText: getFilterText(s, args.kind == '' ? kind : null),\n                    location: s.location\n                });\n            }\n        }\n        return formatting_1.formatListItems(this.alignColumns, items);\n    }\n    doHighlight() {\n        let { nvim } = this;\n        nvim.pauseNotification();\n        nvim.command('syntax match CocOutlineName /\\\\v\\\\s?[^\\\\t]+\\\\s/ contained containedin=CocOutlineLine', true);\n        nvim.command('syntax match CocOutlineIndentLine /\\\\v\\\\|/ contained containedin=CocOutlineLine,CocOutlineName', true);\n        nvim.command('syntax match CocOutlineKind /\\\\[\\\\w\\\\+\\\\]/ contained containedin=CocOutlineLine', true);\n        nvim.command('syntax match CocOutlineLine /\\\\d\\\\+$/ contained containedin=CocOutlineLine', true);\n        nvim.command('highlight default link CocOutlineName Normal', true);\n        nvim.command('highlight default link CocOutlineIndentLine Comment', true);\n        nvim.command('highlight default link CocOutlineKind Typedef', true);\n        nvim.command('highlight default link CocOutlineLine Comment', true);\n        nvim.resumeNotification(false, true).logError();\n    }\n    async loadCtagsSymbols(document) {\n        if (!which_1.default.sync('ctags', { nothrow: true })) {\n            return [];\n        }\n        let uri = vscode_uri_1.URI.parse(document.uri);\n        let extname = path_1.default.extname(uri.fsPath);\n        let content = '';\n        let tempname = await this.nvim.call('tempname');\n        let filepath = `${tempname}.${extname}`;\n        let escaped = await this.nvim.call('fnameescape', filepath);\n        await fs_1.writeFile(escaped, document.getDocumentContent());\n        try {\n            content = await util_1.runCommand(`ctags -f - --excmd=number --language-force=${document.filetype} ${escaped}`);\n        }\n        catch (e) {\n            // noop\n        }\n        if (!content.trim().length) {\n            content = await util_1.runCommand(`ctags -f - --excmd=number ${escaped}`);\n        }\n        content = content.trim();\n        if (!content)\n            return [];\n        let lines = content.split('\\n');\n        let items = [];\n        for (let line of lines) {\n            let parts = line.split('\\t');\n            if (parts.length < 4)\n                continue;\n            let lnum = Number(parts[2].replace(/;\"$/, ''));\n            let text = document.getline(lnum - 1);\n            if (!text)\n                continue;\n            let idx = text.indexOf(parts[0]);\n            let start = idx == -1 ? 0 : idx;\n            let range = vscode_languageserver_types_1.Range.create(lnum - 1, start, lnum - 1, start + parts[0].length);\n            items.push({\n                label: `${parts[0]} [${parts[3]}] ${lnum}`,\n                filterText: parts[0],\n                location: vscode_languageserver_types_1.Location.create(document.uri, range),\n                data: { line: lnum }\n            });\n        }\n        items.sort((a, b) => a.data.line - b.data.line);\n        return items;\n    }\n}\nexports.default = Outline;\nfunction sortSymbols(a, b) {\n    let ra = a.selectionRange;\n    let rb = b.selectionRange;\n    if (ra.start.line != rb.start.line) {\n        return ra.start.line - rb.start.line;\n    }\n    return ra.start.character - rb.start.character;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/source/outline.ts?");

/***/ }),

/***/ "./src/list/source/services.ts":
/*!*************************************!*\
  !*** ./src/list/source/services.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst services_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../services */ \"./src/services.ts\"));\nconst basic_1 = tslib_1.__importDefault(__webpack_require__(/*! ../basic */ \"./src/list/basic.ts\"));\nconst util_1 = __webpack_require__(/*! ../../util */ \"./src/util/index.ts\");\nconst formatting_1 = __webpack_require__(/*! ../formatting */ \"./src/list/formatting.ts\");\nclass ServicesList extends basic_1.default {\n    constructor(nvim) {\n        super(nvim);\n        this.defaultAction = 'toggle';\n        this.description = 'registered services of coc.nvim';\n        this.name = 'services';\n        this.addAction('toggle', async (item) => {\n            let { id } = item.data;\n            await services_1.default.toggle(id);\n            await util_1.wait(100);\n        }, { persist: true, reload: true });\n    }\n    async loadItems(_context) {\n        let stats = services_1.default.getServiceStats();\n        stats.sort((a, b) => a.id > b.id ? -1 : 1);\n        return formatting_1.formatListItems(this.alignColumns, stats.map(stat => {\n            let prefix = stat.state == 'running' ? '*' : ' ';\n            return {\n                label: [prefix, stat.id, `[${stat.state}]`, stat.languageIds.join(', ')],\n                data: { id: stat.id }\n            };\n        }));\n    }\n    doHighlight() {\n        let { nvim } = this;\n        nvim.pauseNotification();\n        nvim.command('syntax match CocServicesPrefix /\\\\v^./ contained containedin=CocServicesLine', true);\n        nvim.command('syntax match CocServicesName /\\\\v%3c\\\\S+/ contained containedin=CocServicesLine', true);\n        nvim.command('syntax match CocServicesStat /\\\\v\\\\t\\\\[\\\\w+\\\\]/ contained containedin=CocServicesLine', true);\n        nvim.command('syntax match CocServicesLanguages /\\\\v(\\\\])@<=.*$/ contained containedin=CocServicesLine', true);\n        nvim.command('highlight default link CocServicesPrefix Special', true);\n        nvim.command('highlight default link CocServicesName Type', true);\n        nvim.command('highlight default link CocServicesStat Statement', true);\n        nvim.command('highlight default link CocServicesLanguages Comment', true);\n        nvim.resumeNotification().catch(_e => {\n            // noop\n        });\n    }\n}\nexports.default = ServicesList;\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/source/services.ts?");

/***/ }),

/***/ "./src/list/source/sources.ts":
/*!************************************!*\
  !*** ./src/list/source/sources.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ \"./node_modules/vscode-languageserver-types/lib/esm/main.js\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst sources_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../sources */ \"./src/sources.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../workspace */ \"./src/workspace.ts\"));\nconst basic_1 = tslib_1.__importDefault(__webpack_require__(/*! ../basic */ \"./src/list/basic.ts\"));\nconst logger = __webpack_require__(/*! ../../util/logger */ \"./src/util/logger.ts\")('list-sources');\nclass SourcesList extends basic_1.default {\n    constructor(nvim) {\n        super(nvim);\n        this.defaultAction = 'toggle';\n        this.description = 'registered completion sources';\n        this.name = 'sources';\n        this.addAction('toggle', async (item) => {\n            let { name } = item.data;\n            sources_1.default.toggleSource(name);\n        }, { persist: true, reload: true });\n        this.addAction('refresh', async (item) => {\n            let { name } = item.data;\n            await sources_1.default.refresh(name);\n        }, { persist: true, reload: true });\n        this.addAction('open', async (item) => {\n            let { location } = item;\n            if (location)\n                await this.jumpTo(location);\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async loadItems(context) {\n        let stats = sources_1.default.sourceStats();\n        let filetype = await context.buffer.getOption('filetype');\n        let map = workspace_1.default.env.disabledSources;\n        let disables = map ? map[filetype] || [] : [];\n        stats.sort((a, b) => {\n            if (a.type != b.type)\n                return a.type < b.type ? 1 : -1;\n            return a.name > b.name ? -1 : 1;\n        });\n        return stats.map(stat => {\n            let prefix = stat.disabled ? ' ' : '*';\n            if (disables && disables.includes(stat.name)) {\n                prefix = '-';\n            }\n            let location;\n            if (stat.filepath) {\n                location = vscode_languageserver_types_1.Location.create(vscode_uri_1.URI.file(stat.filepath).toString(), vscode_languageserver_types_1.Range.create(0, 0, 0, 0));\n            }\n            return {\n                label: `${prefix} ${fixWidth(stat.name, 22)} ${fixWidth('[' + stat.shortcut + ']', 10)} ${fixWidth(stat.triggerCharacters.join(''), 10)} ${fixWidth(stat.priority.toString(), 3)} ${stat.filetypes.join(',')}`,\n                location,\n                data: { name: stat.name }\n            };\n        });\n    }\n    doHighlight() {\n        let { nvim } = this;\n        nvim.pauseNotification();\n        nvim.command('syntax match CocSourcesPrefix /\\\\v^./ contained containedin=CocSourcesLine', true);\n        nvim.command('syntax match CocSourcesName /\\\\v%3c\\\\S+/ contained containedin=CocSourcesLine', true);\n        nvim.command('syntax match CocSourcesType /\\\\v%25v.*%36v/ contained containedin=CocSourcesLine', true);\n        nvim.command('syntax match CocSourcesPriority /\\\\v%46v.*%50v/ contained containedin=CocSourcesLine', true);\n        nvim.command('syntax match CocSourcesFileTypes /\\\\v\\\\S+$/ contained containedin=CocSourcesLine', true);\n        nvim.command('highlight default link CocSourcesPrefix Special', true);\n        nvim.command('highlight default link CocSourcesName Type', true);\n        nvim.command('highlight default link CocSourcesPriority Number', true);\n        nvim.command('highlight default link CocSourcesFileTypes Comment', true);\n        nvim.command('highlight default link CocSourcesType Statement', true);\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        nvim.resumeNotification(false, true);\n    }\n}\nexports.default = SourcesList;\nfunction fixWidth(str, width) {\n    if (str.length > width) {\n        return str.slice(0, width - 1) + '.';\n    }\n    return str + ' '.repeat(width - str.length);\n}\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/source/sources.ts?");

/***/ }),

/***/ "./src/list/source/symbols.ts":
/*!************************************!*\
  !*** ./src/list/source/symbols.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst minimatch_1 = tslib_1.__importDefault(__webpack_require__(/*! minimatch */ \"./node_modules/minimatch/minimatch.js\"));\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../languages */ \"./src/languages.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../workspace */ \"./src/workspace.ts\"));\nconst location_1 = tslib_1.__importDefault(__webpack_require__(/*! ./location */ \"./src/list/source/location.ts\"));\nconst convert_1 = __webpack_require__(/*! ../../util/convert */ \"./src/util/convert.ts\");\nconst fs_1 = __webpack_require__(/*! ../../util/fs */ \"./src/util/fs.ts\");\nconst fzy_1 = __webpack_require__(/*! ../../util/fzy */ \"./src/util/fzy.ts\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst formatting_1 = __webpack_require__(/*! ../formatting */ \"./src/list/formatting.ts\");\nconst logger = __webpack_require__(/*! ../../util/logger */ \"./src/util/logger.ts\")('list-symbols');\nclass Symbols extends location_1.default {\n    constructor() {\n        super(...arguments);\n        this.interactive = true;\n        this.description = 'search workspace symbols';\n        this.detail = 'Symbols list is provided by server, it works on interactive mode only.';\n        this.name = 'symbols';\n        this.options = [{\n                name: '-k, -kind KIND',\n                description: 'Filter symbols by kind.',\n                hasValue: true\n            }];\n    }\n    async loadItems(context, token) {\n        let { input } = context;\n        let args = this.parseArguments(context.args);\n        let filterKind = args.kind ? args.kind.toLowerCase() : '';\n        if (!context.options.interactive) {\n            throw new Error('Symbols only works on interactive mode');\n        }\n        let symbols = await languages_1.default.getWorkspaceSymbols(input, token);\n        if (!symbols) {\n            throw new Error('No workspace symbols provider registed');\n        }\n        let config = this.getConfig();\n        let excludes = config.get('excludes', []);\n        let items = [];\n        for (let s of symbols) {\n            let kind = convert_1.getSymbolKind(s.kind);\n            if (filterKind && kind.toLowerCase() != filterKind) {\n                continue;\n            }\n            let file = vscode_uri_1.URI.parse(s.location.uri).fsPath;\n            if (fs_1.isParentFolder(workspace_1.default.cwd, file)) {\n                file = path_1.default.relative(workspace_1.default.cwd, file);\n            }\n            if (excludes.some(p => minimatch_1.default(file, p))) {\n                continue;\n            }\n            items.push({\n                label: [s.name, `[${kind}]`, file],\n                filterText: `${s.name}`,\n                location: s.location,\n                data: { original: s, kind: s.kind, file, score: fzy_1.score(input, s.name) }\n            });\n        }\n        items.sort((a, b) => {\n            if (a.data.score != b.data.score) {\n                return b.data.score - a.data.score;\n            }\n            if (a.data.kind != b.data.kind) {\n                return a.data.kind - b.data.kind;\n            }\n            return a.data.file.length - b.data.file.length;\n        });\n        return formatting_1.formatListItems(this.alignColumns, items);\n    }\n    async resolveItem(item) {\n        let s = item.data.original;\n        if (!s)\n            return null;\n        let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n        let resolved = await languages_1.default.resolveWorkspaceSymbol(s, tokenSource.token);\n        if (!resolved)\n            return null;\n        let kind = convert_1.getSymbolKind(resolved.kind);\n        let file = vscode_uri_1.URI.parse(resolved.location.uri).fsPath;\n        if (fs_1.isParentFolder(workspace_1.default.cwd, file)) {\n            file = path_1.default.relative(workspace_1.default.cwd, file);\n        }\n        return {\n            label: `${s.name} [${kind}]\\t${file}`,\n            filterText: `${s.name}`,\n            location: s.location\n        };\n    }\n    doHighlight() {\n        let { nvim } = this;\n        nvim.pauseNotification();\n        nvim.command('syntax match CocSymbolsName /\\\\v^\\\\s*\\\\S+/ contained containedin=CocSymbolsLine', true);\n        nvim.command('syntax match CocSymbolsKind /\\\\[\\\\w\\\\+\\\\]\\\\s*\\\\t/ contained containedin=CocSymbolsLine', true);\n        nvim.command('syntax match CocSymbolsFile /\\\\S\\\\+$/ contained containedin=CocSymbolsLine', true);\n        nvim.command('highlight default link CocSymbolsName Normal', true);\n        nvim.command('highlight default link CocSymbolsKind Typedef', true);\n        nvim.command('highlight default link CocSymbolsFile Comment', true);\n        nvim.resumeNotification().catch(_e => {\n            // noop\n        });\n    }\n}\nexports.default = Symbols;\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/source/symbols.ts?");

/***/ }),

/***/ "./src/list/ui.ts":
/*!************************!*\
  !*** ./src/list/ui.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst debounce_1 = tslib_1.__importDefault(__webpack_require__(/*! debounce */ \"./node_modules/debounce/index.js\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst mutex_1 = __webpack_require__(/*! ../util/mutex */ \"./src/util/mutex.ts\");\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('list-ui');\nclass ListUI {\n    constructor(nvim, name, listOptions, config) {\n        this.nvim = nvim;\n        this.name = name;\n        this.listOptions = listOptions;\n        this.config = config;\n        this.newTab = false;\n        this.currIndex = 0;\n        this.drawCount = 0;\n        this.items = [];\n        this.disposables = [];\n        this.selected = new Set();\n        this.mutex = new mutex_1.Mutex();\n        this._onDidChangeLine = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidLineChange = new vscode_languageserver_protocol_1.Emitter();\n        this._onDoubleClick = new vscode_languageserver_protocol_1.Emitter();\n        this.onDidChangeLine = this._onDidChangeLine.event;\n        this.onDidLineChange = this._onDidLineChange.event;\n        this.onDidOpen = this._onDidOpen.event;\n        this.onDidClose = this._onDidClose.event;\n        this.onDidDoubleClick = this._onDoubleClick.event;\n        this.signOffset = config.get('signOffset');\n        this.matchHighlightGroup = config.get('matchHighlightGroup', 'Search');\n        this.newTab = listOptions.position == 'tab';\n        events_1.default.on('BufWinLeave', async (bufnr) => {\n            if (bufnr != this.bufnr || this.window == null)\n                return;\n            this.window = null;\n            this._onDidClose.fire(bufnr);\n        }, null, this.disposables);\n        events_1.default.on('CursorMoved', async (bufnr, cursor) => {\n            if (bufnr != this.bufnr)\n                return;\n            this.onLineChange(cursor[0] - 1);\n        }, null, this.disposables);\n        let debounced = debounce_1.default(async (bufnr) => {\n            if (bufnr != this.bufnr)\n                return;\n            let [winid, start, end] = await nvim.eval('[win_getid(),line(\"w0\"),line(\"w$\")]');\n            if (end < 300)\n                return;\n            if (!this.window || winid != this.window.id)\n                return;\n            // increment highlights\n            nvim.pauseNotification();\n            this.doHighlight(start - 1, end);\n            nvim.command('redraw', true);\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            nvim.resumeNotification(false, true);\n        }, 100);\n        this.disposables.push({\n            dispose: () => {\n                debounced.clear();\n            }\n        });\n        events_1.default.on('CursorMoved', debounced, null, this.disposables);\n    }\n    get limitLines() {\n        return this.config.get('limitLines', 30000);\n    }\n    onLineChange(index) {\n        if (this.currIndex == index)\n            return;\n        this.currIndex = index;\n        this._onDidChangeLine.fire(index);\n    }\n    set index(n) {\n        if (n < 0 || n >= this.items.length)\n            return;\n        let { nvim } = this;\n        nvim.pauseNotification();\n        this.setCursor(n + 1, 0);\n        nvim.command('redraw', true);\n        nvim.resumeNotification(false, true).logError();\n    }\n    get index() {\n        return this.currIndex;\n    }\n    get firstItem() {\n        return this.items[0];\n    }\n    get lastItem() {\n        return this.items[this.items.length - 1];\n    }\n    getItem(index) {\n        return this.items[index];\n    }\n    get item() {\n        let { window } = this;\n        if (!window)\n            return Promise.resolve(null);\n        return window.cursor.then(cursor => {\n            this.currIndex = cursor[0] - 1;\n            return this.items[this.currIndex];\n        }, _e => null);\n    }\n    async echoMessage(item) {\n        if (this.bufnr)\n            return;\n        let { items } = this;\n        let idx = items.indexOf(item);\n        let msg = `[${idx + 1}/${items.length}] ${item.label || ''}`;\n        this.nvim.callTimer('coc#util#echo_lines', [[msg]], true);\n    }\n    async updateItem(item, index) {\n        if (!this.bufnr || workspace_1.default.bufnr != this.bufnr)\n            return;\n        let obj = Object.assign({ resolved: true }, item);\n        if (index < this.length) {\n            this.items[index] = obj;\n            let { nvim } = this;\n            nvim.pauseNotification();\n            nvim.command('setl modifiable', true);\n            nvim.call('setline', [index + 1, obj.label], true);\n            nvim.command('setl nomodifiable', true);\n            await nvim.resumeNotification();\n        }\n    }\n    async getItems() {\n        if (this.length == 0 || !this.window)\n            return [];\n        let mode = await this.nvim.call('mode');\n        if (mode == 'v' || mode == 'V') {\n            let [start, end] = await this.getSelectedRange();\n            let res = [];\n            for (let i = start; i <= end; i++) {\n                let item = this.items[i - 1];\n                if (item)\n                    res.push(item);\n            }\n            return res;\n        }\n        let { selectedItems } = this;\n        if (selectedItems.length)\n            return selectedItems;\n        let item = await this.item;\n        return item == null ? [] : [item];\n    }\n    async onMouse(event) {\n        let { nvim, window } = this;\n        if (!window)\n            return;\n        let winid = await nvim.getVvar('mouse_winid');\n        let lnum = await nvim.getVvar('mouse_lnum');\n        let col = await nvim.getVvar('mouse_col');\n        if (event == 'mouseDown') {\n            this.mouseDown = { winid, lnum, col, current: winid == window.id };\n            return;\n        }\n        let current = winid == window.id;\n        if (current && event == 'doubleClick') {\n            this.setCursor(lnum, 0);\n            this._onDoubleClick.fire();\n        }\n        if (!this.mouseDown || this.mouseDown.winid != this.mouseDown.winid)\n            return;\n        if (current && event == 'mouseDrag') {\n            await this.selectLines(this.mouseDown.lnum, lnum);\n        }\n        else if (current && event == 'mouseUp') {\n            if (this.mouseDown.lnum == lnum) {\n                nvim.pauseNotification();\n                this.clearSelection();\n                this.setCursor(lnum, 0);\n                nvim.command('redraw', true);\n                await nvim.resumeNotification();\n            }\n            else {\n                await this.selectLines(this.mouseDown.lnum, lnum);\n            }\n        }\n        else if (!current && event == 'mouseUp') {\n            nvim.pauseNotification();\n            nvim.call('win_gotoid', winid, true);\n            nvim.call('cursor', [lnum, col], true);\n            await nvim.resumeNotification();\n        }\n    }\n    async resume() {\n        let { items, selected, nvim, signOffset } = this;\n        await this.drawItems(items, this.height, true);\n        if (selected.size > 0 && this.bufnr) {\n            nvim.pauseNotification();\n            for (let lnum of selected) {\n                nvim.command(`sign place ${signOffset + lnum} line=${lnum} name=CocSelected buffer=${this.bufnr}`, true);\n            }\n            await nvim.resumeNotification();\n        }\n    }\n    async toggleSelection() {\n        let { nvim, selected, signOffset, bufnr } = this;\n        if (workspace_1.default.bufnr != bufnr)\n            return;\n        let lnum = await nvim.call('line', '.');\n        let mode = await nvim.call('mode');\n        if (mode == 'v' || mode == 'V') {\n            let [start, end] = await this.getSelectedRange();\n            let exists = selected.has(start);\n            let reverse = start > end;\n            if (reverse)\n                [start, end] = [end, start];\n            for (let i = start; i <= end; i++) {\n                if (!exists) {\n                    selected.add(i);\n                    nvim.command(`sign place ${signOffset + i} line=${i} name=CocSelected buffer=${bufnr}`, true);\n                }\n                else {\n                    selected.delete(i);\n                    nvim.command(`sign unplace ${signOffset + i} buffer=${bufnr}`, true);\n                }\n            }\n            this.setCursor(end, 0);\n            nvim.command('redraw', true);\n            await nvim.resumeNotification();\n            return;\n        }\n        let exists = selected.has(lnum);\n        nvim.pauseNotification();\n        if (exists) {\n            selected.delete(lnum);\n            nvim.command(`sign unplace ${signOffset + lnum} buffer=${bufnr}`, true);\n        }\n        else {\n            selected.add(lnum);\n            nvim.command(`sign place ${signOffset + lnum} line=${lnum} name=CocSelected buffer=${bufnr}`, true);\n        }\n        this.setCursor(lnum + 1, 0);\n        nvim.command('redraw', true);\n        await nvim.resumeNotification();\n    }\n    async selectLines(start, end) {\n        let { nvim, signOffset, bufnr, length } = this;\n        this.clearSelection();\n        let { selected } = this;\n        nvim.pauseNotification();\n        let reverse = start > end;\n        if (reverse)\n            [start, end] = [end, start];\n        for (let i = start; i <= end; i++) {\n            if (i > length)\n                break;\n            selected.add(i);\n            nvim.command(`sign place ${signOffset + i} line=${i} name=CocSelected buffer=${bufnr}`, true);\n        }\n        this.setCursor(end, 0);\n        nvim.command('redraw', true);\n        await nvim.resumeNotification();\n    }\n    async selectAll() {\n        let { length } = this;\n        if (length == 0)\n            return;\n        await this.selectLines(1, length);\n    }\n    clearSelection() {\n        let { selected, nvim, signOffset, bufnr } = this;\n        if (!bufnr)\n            return;\n        if (selected.size > 0) {\n            let signIds = [];\n            for (let lnum of selected) {\n                signIds.push(signOffset + lnum);\n            }\n            nvim.call('coc#util#unplace_signs', [bufnr, signIds], true);\n            this.selected = new Set();\n        }\n    }\n    get shown() {\n        return this.window != null;\n    }\n    get bufnr() {\n        var _a;\n        return (_a = this.buffer) === null || _a === void 0 ? void 0 : _a.id;\n    }\n    get winid() {\n        var _a;\n        return (_a = this.window) === null || _a === void 0 ? void 0 : _a.id;\n    }\n    get ready() {\n        if (this.window)\n            return Promise.resolve();\n        return new Promise((resolve, reject) => {\n            let timeout = setTimeout(() => {\n                reject(new Error('window create timeout'));\n            }, 3000);\n            let disposable = this.onDidLineChange(() => {\n                disposable.dispose();\n                clearTimeout(timeout);\n                resolve();\n            });\n        });\n    }\n    async drawItems(items, height, reload = false, token) {\n        let count = this.drawCount = this.drawCount + 1;\n        const { nvim, name, listOptions } = this;\n        const release = await this.mutex.acquire();\n        this.items = items.length > this.limitLines ? items.slice(0, this.limitLines) : items;\n        const create = this.window == null;\n        if (create && !(token && token.isCancellationRequested)) {\n            try {\n                let { position, numberSelect } = listOptions;\n                let [bufnr, winid] = await nvim.call('coc#list#create', [position, height, name, numberSelect]);\n                if (token && token.isCancellationRequested) {\n                    nvim.call('coc#list#clean_up', [], true);\n                }\n                else {\n                    this.height = height;\n                    this.buffer = nvim.createBuffer(bufnr);\n                    this.window = nvim.createWindow(winid);\n                    this._onDidOpen.fire(this.bufnr);\n                }\n            }\n            catch (e) {\n                nvim.call('coc#prompt#stop_prompt', ['list'], true);\n                nvim.call('coc#list#clean_up', [], true);\n                release();\n                window_1.default.showMessage(`Error on list create: ${e.message}`, 'error');\n                return;\n            }\n        }\n        release();\n        if (token && token.isCancellationRequested)\n            return;\n        if (count !== this.drawCount)\n            return;\n        const lines = this.items.map(item => item.label);\n        this.clearSelection();\n        let newIndex = reload ? this.currIndex : 0;\n        await this.setLines(lines, false, newIndex);\n        this._onDidLineChange.fire(this.currIndex + 1);\n    }\n    async appendItems(items) {\n        if (!this.window)\n            return;\n        let curr = this.items.length;\n        if (curr >= this.limitLines)\n            return;\n        let max = this.limitLines - curr;\n        let append = items.slice(0, max);\n        this.items = this.items.concat(append);\n        await this.setLines(append.map(item => item.label), curr > 0, this.currIndex);\n    }\n    async setLines(lines, append = false, index) {\n        let { nvim, buffer, window } = this;\n        if (!buffer || !window)\n            return;\n        nvim.pauseNotification();\n        if (!append) {\n            let statusSegments = this.config.get('statusLineSegments');\n            if (statusSegments) {\n                window.notify('nvim_win_set_option', ['statusline', statusSegments.join(\" \")]);\n            }\n            nvim.call('coc#compat#clear_matches', [window.id], true);\n            if (!lines.length) {\n                lines = ['No results, press ? on normal mode to get help.'];\n                nvim.call('coc#compat#matchaddpos', ['Comment', [[1]], 99, this.window.id], true);\n            }\n        }\n        buffer.setOption('modifiable', true, true);\n        if (workspace_1.default.isVim) {\n            nvim.call('coc#list#setlines', [buffer.id, lines, append], true);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            buffer.setLines(lines, { start: append ? -1 : 0, end: -1, strictIndexing: false }, true);\n        }\n        buffer.setOption('modifiable', false, true);\n        if (!append && index == 0) {\n            this.doHighlight(0, 300);\n        }\n        else {\n            let height = this.newTab ? workspace_1.default.env.lines : this.height;\n            this.doHighlight(Math.max(0, index - height), Math.min(index + height + 1, this.length - 1));\n        }\n        if (!append) {\n            this.currIndex = index;\n            window.notify('nvim_win_set_cursor', [[index + 1, 0]]);\n        }\n        nvim.command('redraws', true);\n        let res = await nvim.resumeNotification();\n        if (Array.isArray(res[1]) && res[1][0] == 0) {\n            this.window = null;\n        }\n    }\n    restoreWindow() {\n        if (this.newTab)\n            return;\n        let { winid, height } = this;\n        if (winid && height) {\n            this.nvim.call('coc#list#restore', [winid, height], true);\n        }\n    }\n    reset() {\n        if (this.window) {\n            this.window = null;\n            this.buffer = null;\n        }\n    }\n    dispose() {\n        util_1.disposeAll(this.disposables);\n        this.window = null;\n        this._onDidChangeLine.dispose();\n        this._onDidOpen.dispose();\n        this._onDidClose.dispose();\n        this._onDidLineChange.dispose();\n        this._onDoubleClick.dispose();\n    }\n    get length() {\n        return this.items.length;\n    }\n    get selectedItems() {\n        let { selected, items } = this;\n        let res = [];\n        for (let i of selected) {\n            if (items[i - 1])\n                res.push(items[i - 1]);\n        }\n        return res;\n    }\n    doHighlight(start, end) {\n        let { nvim } = workspace_1.default;\n        let { items } = this;\n        let groups = [];\n        for (let i = start; i <= Math.min(end, items.length - 1); i++) {\n            let { ansiHighlights, highlights } = items[i];\n            if (ansiHighlights) {\n                for (let hi of ansiHighlights) {\n                    let { span, hlGroup } = hi;\n                    groups.push({ hlGroup, priority: 9, pos: [i + 1, span[0] + 1, span[1] - span[0]] });\n                }\n            }\n            if (highlights && Array.isArray(highlights.spans)) {\n                let { spans, hlGroup } = highlights;\n                for (let span of spans) {\n                    groups.push({ hlGroup: hlGroup || this.matchHighlightGroup, priority: 11, pos: [i + 1, span[0] + 1, span[1] - span[0]] });\n                }\n            }\n        }\n        nvim.call('coc#compat#matchaddgroups', [this.window.id, groups], true);\n    }\n    setCursor(lnum, col) {\n        let { window, items } = this;\n        let max = items.length == 0 ? 1 : items.length;\n        if (lnum > max)\n            return;\n        // change index since CursorMoved event not fired (seems bug of neovim)!\n        this.onLineChange(lnum - 1);\n        if (window)\n            window.notify('nvim_win_set_cursor', [[lnum, col]]);\n    }\n    async getSelectedRange() {\n        let { nvim } = this;\n        await nvim.call('coc#prompt#stop_prompt', ['list']);\n        await nvim.eval('feedkeys(\"\\\\<esc>\", \"in\")');\n        let [, start] = await nvim.call('getpos', \"'<\");\n        let [, end] = await nvim.call('getpos', \"'>\");\n        if (start > end) {\n            [start, end] = [end, start];\n        }\n        this.nvim.call('coc#prompt#start_prompt', ['list'], true);\n        return [start, end];\n    }\n}\nexports.default = ListUI;\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/ui.ts?");

/***/ }),

/***/ "./src/list/worker.ts":
/*!****************************!*\
  !*** ./src/list/worker.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseInput = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst ansiparse_1 = __webpack_require__(/*! ../util/ansiparse */ \"./src/util/ansiparse.ts\");\nconst diff_1 = __webpack_require__(/*! ../util/diff */ \"./src/util/diff.ts\");\nconst fzy_1 = __webpack_require__(/*! ../util/fzy */ \"./src/util/fzy.ts\");\nconst score_1 = __webpack_require__(/*! ../util/score */ \"./src/util/score.ts\");\nconst string_1 = __webpack_require__(/*! ../util/string */ \"./src/util/string.ts\");\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('list-worker');\nconst controlCode = '\\x1b';\n// perform loading task\nclass Worker {\n    constructor(nvim, list, prompt, listOptions, config) {\n        this.nvim = nvim;\n        this.list = list;\n        this.prompt = prompt;\n        this.listOptions = listOptions;\n        this.config = config;\n        this._loading = false;\n        this.totalItems = [];\n        this._onDidChangeItems = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidChangeLoading = new vscode_languageserver_protocol_1.Emitter();\n        this.onDidChangeItems = this._onDidChangeItems.event;\n        this.onDidChangeLoading = this._onDidChangeLoading.event;\n    }\n    set loading(loading) {\n        if (this._loading == loading)\n            return;\n        this._loading = loading;\n        this._onDidChangeLoading.fire(loading);\n    }\n    get isLoading() {\n        return this._loading;\n    }\n    async loadItems(context, reload = false) {\n        let { list, listOptions } = this;\n        this.loading = true;\n        let { interactive } = listOptions;\n        this.tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n        let token = this.tokenSource.token;\n        let items = await list.loadItems(context, token);\n        if (token.isCancellationRequested)\n            return;\n        if (!items || Array.isArray(items)) {\n            this.tokenSource = null;\n            items = (items || []);\n            this.totalItems = items.map(item => {\n                item.label = this.fixLabel(item.label);\n                this.parseListItemAnsi(item);\n                return item;\n            });\n            this.loading = false;\n            let filtered;\n            if (!interactive) {\n                filtered = this.filterItems(items);\n            }\n            else {\n                filtered = this.convertToHighlightItems(items);\n            }\n            this._onDidChangeItems.fire({\n                items: filtered,\n                reload,\n                finished: true\n            });\n        }\n        else {\n            let task = items;\n            let totalItems = this.totalItems = [];\n            let count = 0;\n            let currInput = context.input;\n            let timer;\n            let lastTs;\n            let _onData = (finished) => {\n                lastTs = Date.now();\n                if (count >= totalItems.length)\n                    return;\n                let inputChanged = this.input != currInput;\n                if (interactive && inputChanged)\n                    return;\n                if (count == 0 || inputChanged) {\n                    currInput = this.input;\n                    count = totalItems.length;\n                    let items;\n                    if (interactive) {\n                        items = this.convertToHighlightItems(totalItems);\n                    }\n                    else {\n                        items = this.filterItems(totalItems);\n                    }\n                    this._onDidChangeItems.fire({ items, reload, append: false, finished });\n                }\n                else {\n                    let remain = totalItems.slice(count);\n                    count = totalItems.length;\n                    let items;\n                    if (!interactive) {\n                        items = this.filterItems(remain);\n                    }\n                    else {\n                        items = this.convertToHighlightItems(remain);\n                    }\n                    this._onDidChangeItems.fire({ items, append: true, finished });\n                }\n            };\n            task.on('data', item => {\n                if (timer)\n                    clearTimeout(timer);\n                if (token.isCancellationRequested)\n                    return;\n                if (interactive && this.input != currInput)\n                    return;\n                item.label = this.fixLabel(item.label);\n                this.parseListItemAnsi(item);\n                totalItems.push(item);\n                if ((!lastTs && totalItems.length == 500)\n                    || Date.now() - lastTs > 200) {\n                    _onData();\n                }\n                else {\n                    timer = setTimeout(() => _onData(), 50);\n                }\n            });\n            let onEnd = () => {\n                if (task == null)\n                    return;\n                this.tokenSource = null;\n                task = null;\n                this.loading = false;\n                disposable.dispose();\n                if (timer)\n                    clearTimeout(timer);\n                if (totalItems.length == 0) {\n                    this._onDidChangeItems.fire({ items: [], finished: true });\n                }\n                else {\n                    _onData(true);\n                }\n            };\n            let disposable = token.onCancellationRequested(() => {\n                if (task) {\n                    task.dispose();\n                    onEnd();\n                }\n            });\n            task.on('error', async (error) => {\n                if (task == null)\n                    return;\n                task = null;\n                this.tokenSource = null;\n                this.loading = false;\n                disposable.dispose();\n                if (timer)\n                    clearTimeout(timer);\n                this.nvim.call('coc#prompt#stop_prompt', ['list'], true);\n                window_1.default.showMessage(`Task error: ${error.toString()}`, 'error');\n                logger.error(error);\n            });\n            task.on('end', onEnd);\n        }\n    }\n    /*\n     * Draw all items with filter if necessary\n     */\n    drawItems() {\n        let { totalItems, listOptions } = this;\n        let items;\n        if (listOptions.interactive) {\n            items = this.convertToHighlightItems(totalItems);\n        }\n        else {\n            items = this.filterItems(totalItems);\n        }\n        this._onDidChangeItems.fire({ items, finished: true });\n    }\n    stop() {\n        if (this.tokenSource) {\n            this.tokenSource.cancel();\n            this.tokenSource = null;\n        }\n        this.loading = false;\n    }\n    get length() {\n        return this.totalItems.length;\n    }\n    get input() {\n        return this.prompt.input;\n    }\n    /**\n     * Add highlights for interactive list\n     */\n    convertToHighlightItems(items) {\n        let { input } = this;\n        if (!input)\n            return [];\n        return items.map(item => {\n            let filterLabel = getFilterLabel(item);\n            if (filterLabel == '')\n                return item;\n            let res = score_1.getMatchResult(filterLabel, input);\n            if (!res || !res.score)\n                return item;\n            let highlights = this.getHighlights(filterLabel, res.matches);\n            return Object.assign({}, item, { highlights });\n        });\n    }\n    filterItems(items) {\n        let { input } = this;\n        let { sort, matcher, ignorecase } = this.listOptions;\n        let inputs = this.config.extendedSearchMode ? parseInput(input) : [input];\n        if (input.length == 0 || inputs.length == 0)\n            return items;\n        if (matcher == 'strict') {\n            let filtered = [];\n            for (let item of items) {\n                let spans = [];\n                let filterLabel = getFilterLabel(item);\n                let match = true;\n                for (let input of inputs) {\n                    let idx = ignorecase ? filterLabel.toLowerCase().indexOf(input.toLowerCase()) : filterLabel.indexOf(input);\n                    if (idx == -1) {\n                        match = false;\n                        break;\n                    }\n                    spans.push([string_1.byteIndex(filterLabel, idx), string_1.byteIndex(filterLabel, idx + string_1.byteLength(input))]);\n                }\n                if (match) {\n                    filtered.push(Object.assign({}, item, {\n                        highlights: { spans }\n                    }));\n                }\n            }\n            return filtered;\n        }\n        if (matcher == 'regex') {\n            let filtered = [];\n            let flags = ignorecase ? 'iu' : 'u';\n            let regexes = inputs.reduce((p, c) => {\n                try {\n                    let regex = new RegExp(c, flags);\n                    p.push(regex);\n                }\n                catch (e) { }\n                return p;\n            }, []);\n            for (let item of items) {\n                let spans = [];\n                let filterLabel = getFilterLabel(item);\n                let match = true;\n                for (let regex of regexes) {\n                    let ms = filterLabel.match(regex);\n                    if (ms == null) {\n                        match = false;\n                        break;\n                    }\n                    spans.push([string_1.byteIndex(filterLabel, ms.index), string_1.byteIndex(filterLabel, ms.index + string_1.byteLength(ms[0]))]);\n                }\n                if (match) {\n                    filtered.push(Object.assign({}, item, {\n                        highlights: { spans }\n                    }));\n                }\n            }\n            return filtered;\n        }\n        let filtered = [];\n        let idx = 0;\n        for (let item of items) {\n            let filterText = item.filterText || item.label;\n            let matchScore = 0;\n            let matches = [];\n            let filterLabel = getFilterLabel(item);\n            let match = true;\n            for (let input of inputs) {\n                if (!fzy_1.hasMatch(input, filterText)) {\n                    match = false;\n                    break;\n                }\n                matches.push(...fzy_1.positions(input, filterLabel));\n                if (sort)\n                    matchScore += fzy_1.score(input, filterText);\n            }\n            if (!match)\n                continue;\n            let obj = Object.assign({}, item, {\n                sortText: typeof item.sortText === 'string' ? item.sortText : String.fromCharCode(idx),\n                score: matchScore,\n                highlights: this.getHighlights(filterLabel, matches)\n            });\n            filtered.push(obj);\n            idx = idx + 1;\n        }\n        if (sort && filtered.length) {\n            filtered.sort((a, b) => {\n                if (a.score != b.score)\n                    return b.score - a.score;\n                if (a.sortText > b.sortText)\n                    return 1;\n                return -1;\n            });\n        }\n        return filtered;\n    }\n    getHighlights(text, matches) {\n        let spans = [];\n        if (matches && matches.length) {\n            let start = matches.shift();\n            let next = matches.shift();\n            let curr = start;\n            while (next) {\n                if (next == curr + 1) {\n                    curr = next;\n                    next = matches.shift();\n                    continue;\n                }\n                spans.push([string_1.byteIndex(text, start), string_1.byteIndex(text, curr) + 1]);\n                start = next;\n                curr = start;\n                next = matches.shift();\n            }\n            spans.push([string_1.byteIndex(text, start), string_1.byteIndex(text, curr) + 1]);\n        }\n        return { spans };\n    }\n    // set correct label, add ansi highlights\n    parseListItemAnsi(item) {\n        let { label } = item;\n        if (item.ansiHighlights || !label.includes(controlCode))\n            return;\n        let { line, highlights } = ansiparse_1.parseAnsiHighlights(label);\n        item.label = line;\n        item.ansiHighlights = highlights;\n    }\n    fixLabel(label) {\n        let { columns } = workspace_1.default.env;\n        label = label.split('\\n').join(' ');\n        return label.slice(0, columns * 2);\n    }\n    dispose() {\n        this.stop();\n    }\n}\nexports.default = Worker;\nfunction getFilterLabel(item) {\n    return item.filterText != null ? diff_1.patchLine(item.filterText, item.label) : item.label;\n}\n/**\n * `a\\ b` => [`a b`]\n * `a b` =>  ['a', 'b']\n */\nfunction parseInput(input) {\n    let res = [];\n    let startIdx = 0;\n    let currIdx = 0;\n    let prev = '';\n    for (; currIdx < input.length; currIdx++) {\n        let ch = input[currIdx];\n        if (ch.charCodeAt(0) === 32) {\n            // find space\n            if (prev && prev != '\\\\' && startIdx != currIdx) {\n                res.push(input.slice(startIdx, currIdx));\n                startIdx = currIdx + 1;\n            }\n        }\n        else {\n        }\n        prev = ch;\n    }\n    if (startIdx != input.length) {\n        res.push(input.slice(startIdx, input.length));\n    }\n    return res.map(s => s.replace(/\\\\\\s/g, ' ').trim()).filter(s => s.length > 0);\n}\nexports.parseInput = parseInput;\n\n\n//# sourceURL=webpack://coc.nvim/./src/list/worker.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst semver_1 = tslib_1.__importDefault(__webpack_require__(/*! semver */ \"./node_modules/semver/index.js\"));\nconst promiseFinally = __webpack_require__(/*! promise.prototype.finally */ \"./node_modules/promise.prototype.finally/index.js\");\nconst version = process.version.replace('v', '');\nif (!semver_1.default.gte(version, '8.10.0')) {\n    console.error('node version ' + version + ' < 8.10.0, please upgrade nodejs, or use `let g:coc_node_path = \"/path/to/node\"` in your vimrc');\n    process.exit();\n}\nif (!semver_1.default.gte(version, '10.12.0')) {\n    if (process.env.COC_NO_WARNINGS != '1') {\n        console.error('node version ' + version + ' < 10.12.0, upgrade nodejs or use `let g:coc_disable_startup_warning = 1` to disable this warning.');\n    }\n}\nObject.defineProperty(console, 'log', {\n    value() {\n        logger.info(...arguments);\n    }\n});\npromiseFinally.shim();\nconst logger = __webpack_require__(/*! ./util/logger */ \"./src/util/logger.ts\")('server');\nconst attach = __webpack_require__(/*! ./attach */ \"./src/attach.ts\").default;\nattach({ reader: process.stdin, writer: process.stdout });\nprocess.on('uncaughtException', function (err) {\n    let msg = 'Uncaught exception: ' + err.message;\n    console.error(msg);\n    logger.error('uncaughtException', err.stack);\n});\nprocess.on('unhandledRejection', function (reason, p) {\n    if (reason instanceof Error) {\n        console.error('UnhandledRejection: ' + reason.message + '\\n' + reason.stack);\n    }\n    else {\n        console.error('UnhandledRejection: ' + reason);\n    }\n    logger.error('unhandledRejection ', p, reason);\n});\n\n\n//# sourceURL=webpack://coc.nvim/./src/main.ts?");

/***/ }),

/***/ "./src/markdown/index.ts":
/*!*******************************!*\
  !*** ./src/markdown/index.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseMarkdown = exports.getHighlightItems = exports.parseDocuments = exports.diagnosticFiletypes = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst marked_1 = tslib_1.__importDefault(__webpack_require__(/*! marked */ \"./node_modules/marked/src/marked.js\"));\nconst renderer_1 = tslib_1.__importDefault(__webpack_require__(/*! ./renderer */ \"./src/markdown/renderer.ts\"));\nconst ansiparse_1 = __webpack_require__(/*! ../util/ansiparse */ \"./src/util/ansiparse.ts\");\nconst string_1 = __webpack_require__(/*! ../util/string */ \"./src/util/string.ts\");\nexports.diagnosticFiletypes = ['Error', 'Warning', 'Info', 'Hint'];\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('markdown-index');\nmarked_1.default.setOptions({\n    renderer: new renderer_1.default()\n});\nfunction parseDocuments(docs) {\n    let lines = [];\n    let highlights = [];\n    let codes = [];\n    let idx = 0;\n    for (let doc of docs) {\n        let currline = lines.length;\n        let { content, filetype } = doc;\n        if (filetype == 'markdown') {\n            let info = parseMarkdown(content);\n            codes.push(...info.codes.map(o => {\n                o.startLine = o.startLine + currline;\n                o.endLine = o.endLine + currline;\n                return o;\n            }));\n            highlights.push(...info.highlights.map(o => {\n                o.lnum = o.lnum + currline;\n                return o;\n            }));\n            lines.push(...info.lines);\n        }\n        else {\n            let parts = content.trim().split(/\\r?\\n/);\n            if (exports.diagnosticFiletypes.includes(doc.filetype)) {\n                codes.push({ hlGroup: `Coc${filetype}Float`, startLine: currline, endLine: currline + parts.length });\n            }\n            else {\n                codes.push({ filetype: doc.filetype, startLine: currline, endLine: currline + parts.length });\n            }\n            lines.push(...parts);\n        }\n        if (doc.active) {\n            let arr = getHighlightItems(content, currline, doc.active);\n            if (arr.length)\n                highlights.push(...arr);\n        }\n        if (idx != docs.length - 1) {\n            lines.push(''); // separate line\n        }\n        idx = idx + 1;\n    }\n    return { lines, highlights, codes };\n}\nexports.parseDocuments = parseDocuments;\n/**\n * Get highlight items from offset range\n */\nfunction getHighlightItems(content, currline, active) {\n    let res = [];\n    let [start, end] = active;\n    let lines = content.split(/\\r?\\n/);\n    let used = 0;\n    let inRange = false;\n    for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        if (!inRange) {\n            if (used + line.length > start) {\n                inRange = true;\n                let colStart = string_1.byteLength(line.slice(0, start - used));\n                if (used + line.length > end) {\n                    let colEnd = string_1.byteLength(line.slice(0, end - used));\n                    inRange = false;\n                    res.push({ colStart, colEnd, lnum: i + currline, hlGroup: 'CocUnderline' });\n                    break;\n                }\n                else {\n                    let colEnd = string_1.byteLength(line);\n                    res.push({ colStart, colEnd, lnum: i + currline, hlGroup: 'CocUnderline' });\n                }\n            }\n        }\n        else {\n            if (used + line.length > end) {\n                let colEnd = string_1.byteLength(line.slice(0, end - used));\n                res.push({ colStart: 0, colEnd, lnum: i + currline, hlGroup: 'CocUnderline' });\n                inRange = false;\n                break;\n            }\n            else {\n                let colEnd = string_1.byteLength(line);\n                res.push({ colStart: 0, colEnd, lnum: i + currline, hlGroup: 'CocUnderline' });\n            }\n        }\n        used = used + line.length + 1;\n    }\n    return res;\n}\nexports.getHighlightItems = getHighlightItems;\n/**\n * Parse markdown for lines, highlights & codes\n */\nfunction parseMarkdown(content) {\n    let lines = [];\n    let highlights = [];\n    let codes = [];\n    let currline = 0;\n    let inCodeBlock = false;\n    let filetype;\n    let startLnum = 0;\n    let parsed = marked_1.default(content);\n    let links = renderer_1.default.getLinks();\n    if (links.length) {\n        parsed = parsed + '\\n\\n' + links.join('\\n');\n    }\n    for (let line of parsed.replace(/\\s*$/, '').split(/\\n/)) {\n        if (!line.length) {\n            let pre = lines[lines.length - 1];\n            if (pre && pre.length) {\n                lines.push(line);\n                currline++;\n            }\n            continue;\n        }\n        if (line.startsWith('```')) {\n            let pre = lines[lines.length - 1];\n            if (!inCodeBlock) {\n                inCodeBlock = true;\n                filetype = line.replace(/^```\\s*/, '');\n                if (filetype == 'js')\n                    filetype = 'javascript';\n                if (filetype == 'ts')\n                    filetype = 'typescript';\n                startLnum = currline;\n            }\n            else {\n                inCodeBlock = false;\n                codes.push({\n                    filetype,\n                    startLine: startLnum,\n                    endLine: currline\n                });\n            }\n            if (pre && pre.length) {\n                lines.push('');\n                currline++;\n            }\n            continue;\n        }\n        if (inCodeBlock) {\n            // no parse\n            lines.push(line);\n            currline++;\n            continue;\n        }\n        let res = ansiparse_1.parseAnsiHighlights(line, true);\n        if (res.highlights) {\n            for (let hi of res.highlights) {\n                let { hlGroup, span } = hi;\n                highlights.push({\n                    hlGroup,\n                    lnum: currline,\n                    colStart: span[0],\n                    colEnd: span[1]\n                });\n            }\n        }\n        lines.push(res.line);\n        currline++;\n    }\n    return { lines, highlights, codes };\n}\nexports.parseMarkdown = parseMarkdown;\n\n\n//# sourceURL=webpack://coc.nvim/./src/markdown/index.ts?");

/***/ }),

/***/ "./src/markdown/renderer.ts":
/*!**********************************!*\
  !*** ./src/markdown/renderer.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/**\n * Renderer for convert markdown to terminal string\n */\nconst cli_table_1 = tslib_1.__importDefault(__webpack_require__(/*! cli-table */ \"./node_modules/cli-table/lib/index.js\"));\nconst styles = tslib_1.__importStar(__webpack_require__(/*! ./styles */ \"./src/markdown/styles.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('markdown-renderer');\nlet TABLE_CELL_SPLIT = '^*||*^';\nlet TABLE_ROW_WRAP = '*|*|*|*';\nlet TABLE_ROW_WRAP_REGEXP = new RegExp(escapeRegExp(TABLE_ROW_WRAP), 'g');\nlet COLON_REPLACER = '*#COLON|*';\nlet COLON_REPLACER_REGEXP = new RegExp(escapeRegExp(COLON_REPLACER), 'g');\nlet TAB_ALLOWED_CHARACTERS = ['\\t'];\n// HARD_RETURN holds a character sequence used to indicate text has a\n// hard (no-reflowing) line break.  Previously \\r and \\r\\n were turned\n// into \\n in marked's lexer- preprocessing step. So \\r is safe to use\n// to indicate a hard (non-reflowed) return.\nlet HARD_RETURN = '\\r';\nlet defaultOptions = {\n    code: identity,\n    blockquote: identity,\n    html: styles.gray,\n    heading: styles.magenta,\n    firstHeading: styles.magenta,\n    hr: identity,\n    listitem: identity,\n    list,\n    table: identity,\n    paragraph: identity,\n    strong: styles.bold,\n    em: styles.italic,\n    codespan: styles.yellow,\n    del: styles.underline,\n    link: styles.underline,\n    href: styles.underline,\n    text: identity,\n    unescape: true,\n    emoji: false,\n    width: 80,\n    showSectionPrefix: true,\n    tab: 2,\n    tableOptions: {}\n};\nfunction fixHardReturn(text, reflow) {\n    return reflow ? text.replace(HARD_RETURN, /\\n/g) : text;\n}\nfunction sanitizeTab(tab, fallbackTab) {\n    if (typeof tab === 'number') {\n        return new Array(tab + 1).join(' ');\n    }\n    else if (typeof tab === 'string' && isAllowedTabString(tab)) {\n        return tab;\n    }\n    else {\n        return new Array(fallbackTab + 1).join(' ');\n    }\n}\nfunction isAllowedTabString(str) {\n    return TAB_ALLOWED_CHARACTERS.some(function (char) {\n        return str.match('^(' + char + ')+$');\n    });\n}\nfunction indentLines(indent, text) {\n    return text.replace(/(^|\\n)(.+)/g, '$1' + indent + '$2');\n}\nfunction indentify(indent, text) {\n    if (!text)\n        return text;\n    return indent + text.split('\\n').join('\\n' + indent);\n}\nlet BULLET_POINT_REGEX = '\\\\*';\nlet NUMBERED_POINT_REGEX = '\\\\d+\\\\.';\nlet POINT_REGEX = '(?:' + [BULLET_POINT_REGEX, NUMBERED_POINT_REGEX].join('|') + ')';\n// Prevents nested lists from joining their parent list's last line\nfunction fixNestedLists(body, indent) {\n    let regex = new RegExp('' +\n        '(\\\\S(?: |  )?)' + // Last char of current point, plus one or two spaces\n        // to allow trailing spaces\n        '((?:' +\n        indent +\n        ')+)' + // Indentation of sub point\n        '(' +\n        POINT_REGEX +\n        '(?:.*)+)$', 'gm'); // Body of subpoint\n    return body.replace(regex, '$1\\n' + indent + '$2$3');\n}\nlet isPointedLine = function (line, indent) {\n    return line.match('^(?:' + indent + ')*' + POINT_REGEX);\n};\nfunction toSpaces(str) {\n    return ' '.repeat(str.length);\n}\nlet BULLET_POINT = '* ';\nfunction bulletPointLine(indent, line) {\n    return isPointedLine(line, indent) ? line : toSpaces(BULLET_POINT) + line;\n}\nfunction bulletPointLines(lines, indent) {\n    let transform = bulletPointLine.bind(null, indent);\n    return lines\n        .split('\\n')\n        .filter(identity)\n        .map(transform)\n        .join('\\n');\n}\nlet numberedPoint = function (n) {\n    return n + '. ';\n};\nfunction numberedLine(indent, line, num) {\n    return isPointedLine(line, indent)\n        ? {\n            num: num + 1,\n            line: line.replace(BULLET_POINT, numberedPoint(num + 1))\n        }\n        : {\n            num,\n            line: toSpaces(numberedPoint(num)) + line\n        };\n}\nfunction numberedLines(lines, indent) {\n    let transform = numberedLine.bind(null, indent);\n    let num = 0;\n    return lines\n        .split('\\n')\n        .filter(identity)\n        .map(line => {\n        const numbered = transform(line, num);\n        num = numbered.num;\n        return numbered.line;\n    })\n        .join('\\n');\n}\nfunction list(body, ordered, indent) {\n    body = body.trim();\n    body = ordered ? numberedLines(body, indent) : bulletPointLines(body, indent);\n    return body;\n}\nfunction section(text) {\n    return text + '\\n\\n';\n}\nfunction hr(inputHrStr, length) {\n    length = length || process.stdout.columns;\n    return new Array(length).join(inputHrStr);\n}\nfunction undoColon(str) {\n    return str.replace(COLON_REPLACER_REGEXP, ':');\n}\nfunction generateTableRow(text, escape = null) {\n    if (!text)\n        return [];\n    escape = escape || identity;\n    let lines = escape(text).split('\\n');\n    let data = [];\n    lines.forEach(function (line) {\n        if (!line)\n            return;\n        let parsed = line\n            .replace(TABLE_ROW_WRAP_REGEXP, '')\n            .split(TABLE_CELL_SPLIT);\n        data.push(parsed.splice(0, parsed.length - 1));\n    });\n    return data;\n}\nfunction escapeRegExp(str) {\n    // eslint-disable-next-line no-useless-escape\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n}\nfunction unescapeEntities(html) {\n    return html\n        .replace(/&amp;/g, '&')\n        .replace(/&lt;/g, '<')\n        .replace(/&gt;/g, '>')\n        .replace(/&quot;/g, '\"')\n        .replace(/&#39;/g, \"'\");\n}\nfunction identity(str) {\n    return str;\n}\nconst links = new Map();\nclass Renderer {\n    constructor(options = {}, highlightOptions = {}) {\n        this.options = options;\n        this.highlightOptions = highlightOptions;\n        this.o = Object.assign({}, defaultOptions, options);\n        this.tab = sanitizeTab(this.o.tab, defaultOptions.tab);\n        this.tableSettings = this.o.tableOptions;\n        // this.emoji = identity\n        this.unescape = this.o.unescape ? unescapeEntities : identity;\n        this.highlightOptions = highlightOptions || {};\n        this.transform = this.compose(undoColon, this.unescape);\n    }\n    // Compute length of str not including ANSI escape codes.\n    // See http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    textLength(str) {\n        // eslint-disable-next-line no-control-regex\n        return str.replace(/\\u001b\\[(?:\\d{1,3})(?:;\\d{1,3})*m/g, '').length;\n    }\n    text(t) {\n        return this.o.text(t);\n    }\n    code(code, lang, _escaped) {\n        return '``` ' + lang + '\\n' + code + '\\n```\\n';\n    }\n    blockquote(quote) {\n        return section(this.o.blockquote(indentify(this.tab, quote.trim())));\n    }\n    html(html) {\n        return this.o.html(html);\n    }\n    heading(text, level, _raw) {\n        text = this.transform(text);\n        let prefix = this.o.showSectionPrefix\n            ? new Array(level + 1).join('#') + ' '\n            : '';\n        text = prefix + text;\n        return section(level === 1 ? this.o.firstHeading(text) : this.o.heading(text));\n    }\n    hr() {\n        return `---\\n\\n`;\n    }\n    list(body, ordered) {\n        body = this.o.list(body, ordered, this.tab);\n        return section(fixNestedLists(indentLines(this.tab, body), this.tab));\n    }\n    listitem(text) {\n        let transform = this.compose(this.o.listitem, this.transform);\n        let isNested = text.indexOf('\\n') !== -1;\n        if (isNested)\n            text = text.trim();\n        // Use BULLET_POINT as a marker for ordered or unordered list item\n        return '\\n' + BULLET_POINT + transform(text);\n    }\n    checkbox(checked) {\n        return '[' + (checked ? 'X' : ' ') + '] ';\n    }\n    paragraph(text) {\n        let transform = this.compose(this.o.paragraph, this.transform);\n        text = transform(text);\n        return section(text);\n    }\n    table(header, body) {\n        let table = new cli_table_1.default(Object.assign({}, {\n            head: generateTableRow(header)[0]\n        }, this.tableSettings));\n        generateTableRow(body, this.transform).forEach(function (row) {\n            table.push(row);\n        });\n        return section(this.o.table(table.toString()));\n    }\n    tablerow(content) {\n        return TABLE_ROW_WRAP + content + TABLE_ROW_WRAP + '\\n';\n    }\n    tablecell(content, _flags) {\n        return content + TABLE_CELL_SPLIT;\n    }\n    strong(text) {\n        return this.o.strong(text);\n    }\n    em(text) {\n        text = fixHardReturn(text, this.o.reflowText);\n        return this.o.em(text);\n    }\n    codespan(text) {\n        text = fixHardReturn(text, this.o.reflowText);\n        return this.o.codespan(text.replace(/:/g, COLON_REPLACER));\n    }\n    br() {\n        return '\\n';\n    }\n    del(text) {\n        return this.o.del(text);\n    }\n    link(href, title, text) {\n        let prot;\n        if (this.options.sanitize) {\n            try {\n                prot = decodeURIComponent(unescape(href))\n                    .replace(/[^\\w:]/g, '')\n                    .toLowerCase();\n            }\n            catch (e) {\n                return '';\n            }\n            if (prot.startsWith('javascript:')) {\n                return '';\n            }\n        }\n        if (text && href && text != href) {\n            links.set(text, href);\n        }\n        if (text && text != href)\n            return styles.blue(text);\n        let out = this.o.href(href);\n        return this.o.link(out);\n    }\n    image(href, title, text) {\n        if (typeof this.o.image === 'function') {\n            return this.o.image(href, title, text);\n        }\n        let out = '![' + text;\n        if (title)\n            out += '  ' + title;\n        return out + '](' + href + ')\\n';\n    }\n    compose(...funcs) {\n        return (...args) => {\n            for (let i = funcs.length; i-- > 0;) {\n                args = [funcs[i].apply(this, args)];\n            }\n            return args[0];\n        };\n    }\n    static getLinks() {\n        let res = [];\n        for (let [text, href] of links.entries()) {\n            res.push(`${styles.blue(text)}: ${href}`);\n        }\n        links.clear();\n        return res;\n    }\n}\nexports.default = Renderer;\n\n\n//# sourceURL=webpack://coc.nvim/./src/markdown/renderer.ts?");

/***/ }),

/***/ "./src/markdown/styles.ts":
/*!********************************!*\
  !*** ./src/markdown/styles.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.blue = exports.green = exports.yellow = exports.italic = exports.underline = exports.bold = exports.magenta = exports.gray = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst ansi_styles_1 = tslib_1.__importDefault(__webpack_require__(/*! ansi-styles */ \"./node_modules/ansi-styles/index.js\"));\nfunction gray(str) {\n    return `${ansi_styles_1.default.gray.open}${str}${ansi_styles_1.default.gray.close}`;\n}\nexports.gray = gray;\nfunction magenta(str) {\n    return `${ansi_styles_1.default.magenta.open}${str}${ansi_styles_1.default.magenta.close}`;\n}\nexports.magenta = magenta;\nfunction bold(str) {\n    return `${ansi_styles_1.default.bold.open}${str}${ansi_styles_1.default.bold.close}`;\n}\nexports.bold = bold;\nfunction underline(str) {\n    return `${ansi_styles_1.default.underline.open}${str}${ansi_styles_1.default.underline.close}`;\n}\nexports.underline = underline;\nfunction italic(str) {\n    return `${ansi_styles_1.default.italic.open}${str}${ansi_styles_1.default.italic.close}`;\n}\nexports.italic = italic;\nfunction yellow(str) {\n    return `${ansi_styles_1.default.yellow.open}${str}${ansi_styles_1.default.yellow.close}`;\n}\nexports.yellow = yellow;\nfunction green(str) {\n    return `${ansi_styles_1.default.green.open}${str}${ansi_styles_1.default.green.close}`;\n}\nexports.green = green;\nfunction blue(str) {\n    return `${ansi_styles_1.default.blue.open}${str}${ansi_styles_1.default.blue.close}`;\n}\nexports.blue = blue;\n\n\n//# sourceURL=webpack://coc.nvim/./src/markdown/styles.ts?");

/***/ }),

/***/ "./src/model/bufferSync.ts":
/*!*********************************!*\
  !*** ./src/model/bufferSync.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\n/**\n * Buffer sync support, document is always attached and not command line buffer.\n */\nclass BufferSync {\n    constructor(_create, workspace) {\n        this._create = _create;\n        this.workspace = workspace;\n        this.disposables = [];\n        this.itemsMap = new Map();\n        let { disposables } = this;\n        for (let doc of workspace.documents) {\n            this.create(doc);\n        }\n        workspace.onDidOpenTextDocument(e => {\n            let doc = workspace.getDocument(e.bufnr);\n            if (doc)\n                this.create(doc);\n        }, null, disposables);\n        workspace.onDidChangeTextDocument(e => {\n            this.onChange(e);\n        }, null, disposables);\n        workspace.onDidCloseTextDocument(e => {\n            this.delete(e.bufnr);\n        }, null, disposables);\n    }\n    get items() {\n        return Array.from(this.itemsMap.values()).map(x => x.item);\n    }\n    getItem(bufnr) {\n        var _a;\n        if (typeof bufnr === 'number') {\n            return (_a = this.itemsMap.get(bufnr)) === null || _a === void 0 ? void 0 : _a.item;\n        }\n        let o = Array.from(this.itemsMap.values()).find(v => {\n            return v.uri == bufnr;\n        });\n        return o ? o.item : undefined;\n    }\n    create(doc) {\n        if (!doc || doc.isCommandLine || !doc.attached)\n            return;\n        let o = this.itemsMap.get(doc.bufnr);\n        if (o)\n            o.item.dispose();\n        let item = this._create(doc);\n        if (item)\n            this.itemsMap.set(doc.bufnr, { uri: doc.uri, item });\n    }\n    onChange(e) {\n        let o = this.itemsMap.get(e.bufnr);\n        if (o && typeof o.item.onChange == 'function') {\n            o.item.onChange(e);\n        }\n    }\n    delete(bufnr) {\n        let o = this.itemsMap.get(bufnr);\n        if (o) {\n            this.itemsMap.delete(bufnr);\n            o.item.dispose();\n        }\n    }\n    reset() {\n        for (let o of this.itemsMap.values()) {\n            o.item.dispose();\n        }\n        this.itemsMap.clear();\n    }\n    dispose() {\n        util_1.disposeAll(this.disposables);\n        for (let o of this.itemsMap.values()) {\n            o.item.dispose();\n        }\n        this.itemsMap.clear();\n    }\n}\nexports.default = BufferSync;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/bufferSync.ts?");

/***/ }),

/***/ "./src/model/chars.ts":
/*!****************************!*\
  !*** ./src/model/chars.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Chars = exports.Range = void 0;\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('model-chars');\nclass Range {\n    constructor(start, end) {\n        this.start = start;\n        this.end = end ? end : start;\n    }\n    static fromKeywordOption(keywordOption) {\n        let parts = keywordOption.split(',');\n        let ranges = [];\n        for (let part of parts) {\n            if (part == '@') {\n                // isalpha() of c\n                ranges.push(new Range(65, 90));\n                ranges.push(new Range(97, 122));\n            }\n            else if (part == '@-@') {\n                ranges.push(new Range(64));\n            }\n            else if (/^([A-Za-z])-([A-Za-z])$/.test(part)) {\n                let ms = part.match(/^([A-Za-z])-([A-Za-z])$/);\n                ranges.push(new Range(ms[1].charCodeAt(0), ms[2].charCodeAt(0)));\n            }\n            else if (/^\\d+-\\d+$/.test(part)) {\n                let ms = part.match(/^(\\d+)-(\\d+)$/);\n                ranges.push(new Range(Number(ms[1]), Number(ms[2])));\n            }\n            else if (/^\\d+$/.test(part)) {\n                ranges.push(new Range(Number(part)));\n            }\n            else {\n                let c = part.charCodeAt(0);\n                if (!ranges.some(o => o.contains(c))) {\n                    ranges.push(new Range(c));\n                }\n            }\n        }\n        return ranges;\n    }\n    contains(c) {\n        return c >= this.start && c <= this.end;\n    }\n}\nexports.Range = Range;\nclass Chars {\n    constructor(keywordOption) {\n        this.ranges = [];\n        if (keywordOption)\n            this.ranges = Range.fromKeywordOption(keywordOption);\n    }\n    addKeyword(ch) {\n        let c = ch.charCodeAt(0);\n        let { ranges } = this;\n        if (!ranges.some(o => o.contains(c))) {\n            ranges.push(new Range(c));\n        }\n    }\n    clone() {\n        let chars = new Chars();\n        chars.ranges = this.ranges.slice();\n        return chars;\n    }\n    setKeywordOption(keywordOption) {\n        this.ranges = Range.fromKeywordOption(keywordOption);\n    }\n    matchKeywords(content, min = 3) {\n        let length = content.length;\n        if (length == 0)\n            return [];\n        let res = new Set();\n        let str = '';\n        let len = 0;\n        for (let i = 0; i < length; i++) {\n            let ch = content[i];\n            let code = ch.codePointAt(0);\n            if (len == 0 && code == 45)\n                continue;\n            let isKeyword = this.isKeywordCode(code);\n            if (isKeyword) {\n                if (len == 48)\n                    continue;\n                str = str + ch;\n                len = len + 1;\n            }\n            else {\n                if (len >= min && len < 48)\n                    res.add(str);\n                str = '';\n                len = 0;\n            }\n        }\n        if (len != 0)\n            res.add(str);\n        return Array.from(res);\n    }\n    isKeywordCode(code) {\n        if (code > 255)\n            return true;\n        if (code < 33)\n            return false;\n        return this.ranges.some(r => r.contains(code));\n    }\n    isKeywordChar(ch) {\n        let { ranges } = this;\n        let c = ch.charCodeAt(0);\n        if (c > 255)\n            return true;\n        if (c < 33)\n            return false;\n        return ranges.some(r => r.contains(c));\n    }\n    isKeyword(word) {\n        let { ranges } = this;\n        for (let i = 0, l = word.length; i < l; i++) {\n            let ch = word.charCodeAt(i);\n            // for speed\n            if (ch > 255)\n                return false;\n            if (ranges.some(r => r.contains(ch)))\n                continue;\n            return false;\n        }\n        return true;\n    }\n}\nexports.Chars = Chars;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/chars.ts?");

/***/ }),

/***/ "./src/model/db.ts":
/*!*************************!*\
  !*** ./src/model/db.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst fs_extra_1 = tslib_1.__importDefault(__webpack_require__(/*! fs-extra */ \"./node_modules/fs-extra/lib/index.js\"));\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nclass DB {\n    constructor(filepath) {\n        this.filepath = filepath;\n    }\n    /**\n     * Get data by key.\n     *\n     * @param {string} key unique key allows dot notation.\n     * @returns {any}\n     */\n    fetch(key) {\n        let obj = this.load();\n        if (!key)\n            return obj;\n        let parts = key.split('.');\n        for (let part of parts) {\n            if (typeof obj[part] == 'undefined') {\n                return undefined;\n            }\n            obj = obj[part];\n        }\n        return obj;\n    }\n    /**\n     * Check if key exists\n     *\n     * @param {string} key unique key allows dot notation.\n     */\n    exists(key) {\n        let obj = this.load();\n        let parts = key.split('.');\n        for (let part of parts) {\n            if (typeof obj[part] == 'undefined') {\n                return false;\n            }\n            obj = obj[part];\n        }\n        return true;\n    }\n    /**\n     * Delete data by key\n     *\n     * @param {string} key unique key allows dot notation.\n     */\n    delete(key) {\n        let obj = this.load();\n        let origin = obj;\n        let parts = key.split('.');\n        let len = parts.length;\n        for (let i = 0; i < len; i++) {\n            if (typeof obj[parts[i]] == 'undefined') {\n                break;\n            }\n            if (i == len - 1) {\n                delete obj[parts[i]];\n                fs_extra_1.default.writeFileSync(this.filepath, JSON.stringify(origin, null, 2), 'utf8');\n                break;\n            }\n            obj = obj[parts[i]];\n        }\n    }\n    /**\n     * Save data with key\n     *\n     * @param {string} key unique string that allows dot notation.\n     * @param {number|null|boolean|string|{[index} data saved data.\n     */\n    push(key, data) {\n        let origin = this.load() || {};\n        let obj = origin;\n        let parts = key.split('.');\n        let len = parts.length;\n        if (obj == null) {\n            let dir = path_1.default.dirname(this.filepath);\n            fs_extra_1.default.mkdirpSync(dir);\n            obj = origin;\n        }\n        for (let i = 0; i < len; i++) {\n            let key = parts[i];\n            if (i == len - 1) {\n                obj[key] = data;\n                fs_extra_1.default.writeFileSync(this.filepath, JSON.stringify(origin, null, 2));\n                break;\n            }\n            if (typeof obj[key] == 'undefined') {\n                obj[key] = {};\n                obj = obj[key];\n            }\n            else {\n                obj = obj[key];\n            }\n        }\n    }\n    load() {\n        let dir = path_1.default.dirname(this.filepath);\n        let stat = fs_extra_1.default.statSync(dir);\n        if (!stat || !stat.isDirectory()) {\n            fs_extra_1.default.mkdirpSync(dir);\n            fs_extra_1.default.writeFileSync(this.filepath, '{}', 'utf8');\n            return {};\n        }\n        try {\n            let content = fs_extra_1.default.readFileSync(this.filepath, 'utf8');\n            return JSON.parse(content.trim());\n        }\n        catch (e) {\n            fs_extra_1.default.writeFileSync(this.filepath, '{}', 'utf8');\n            return {};\n        }\n    }\n    /**\n     * Empty db file.\n     */\n    clear() {\n        let stat = fs_extra_1.default.statSync(this.filepath);\n        if (!stat || !stat.isFile())\n            return;\n        fs_extra_1.default.writeFileSync(this.filepath, '{}', 'utf8');\n    }\n    /**\n     * Remove db file.\n     */\n    destroy() {\n        if (fs_extra_1.default.existsSync(this.filepath)) {\n            fs_extra_1.default.unlinkSync(this.filepath);\n        }\n    }\n}\nexports.default = DB;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/db.ts?");

/***/ }),

/***/ "./src/model/dialog.ts":
/*!*****************************!*\
  !*** ./src/model/dialog.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('model-dialog');\nclass Dialog {\n    constructor(nvim, config) {\n        this.nvim = nvim;\n        this.config = config;\n        this.disposables = [];\n        events_1.default.on('BufWinLeave', bufnr => {\n            if (bufnr == this.bufnr) {\n                this.dispose();\n                if (config.callback)\n                    config.callback(-1);\n            }\n        }, null, this.disposables);\n        events_1.default.on('FloatBtnClick', (bufnr, idx) => {\n            if (bufnr == this.bufnr) {\n                this.dispose();\n                let btns = config === null || config === void 0 ? void 0 : config.buttons.filter(o => o.disabled != true);\n                if (config.callback)\n                    config.callback(btns[idx].index);\n            }\n        }, null, this.disposables);\n    }\n    get lines() {\n        return [...this.config.content.split(/\\r?\\n/)];\n    }\n    async show(preferences) {\n        let { nvim } = this;\n        let { title, close, buttons } = this.config;\n        let borderhighlight = this.config.borderhighlight || preferences.floatBorderHighlight;\n        let highlight = this.config.highlight || preferences.floatHighlight;\n        let opts = { maxwidth: preferences.maxWidth || 80, };\n        if (title)\n            opts.title = title;\n        if (close || typeof close === 'undefined')\n            opts.close = 1;\n        if (preferences.maxHeight)\n            opts.maxHeight = preferences.maxHeight;\n        if (preferences.maxWidth)\n            opts.maxWidth = preferences.maxWidth;\n        if (highlight)\n            opts.highlight = highlight;\n        if (borderhighlight)\n            opts.borderhighlight = [borderhighlight];\n        if (buttons)\n            opts.buttons = buttons.filter(o => !o.disabled).map(o => o.text);\n        let res = await nvim.call('coc#float#create_dialog', [this.lines, opts]);\n        if (!res[1])\n            return;\n        this.bufnr = res[1];\n        nvim.command('redraw', true);\n    }\n    get winid() {\n        if (!this.bufnr)\n            return Promise.resolve(null);\n        return this.nvim.call('bufwinid', [this.bufnr]);\n    }\n    dispose() {\n        this.bufnr = undefined;\n        util_1.disposeAll(this.disposables);\n        this.disposables = [];\n    }\n}\nexports.default = Dialog;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/dialog.ts?");

/***/ }),

/***/ "./src/model/document.ts":
/*!*******************************!*\
  !*** ./src/model/document.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst debounce_1 = tslib_1.__importDefault(__webpack_require__(/*! debounce */ \"./node_modules/debounce/index.js\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst vscode_languageserver_textdocument_1 = __webpack_require__(/*! vscode-languageserver-textdocument */ \"./node_modules/vscode-languageserver-textdocument/lib/esm/main.js\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nconst diff_1 = __webpack_require__(/*! ../util/diff */ \"./src/util/diff.ts\");\nconst index_1 = __webpack_require__(/*! ../util/index */ \"./src/util/index.ts\");\nconst mutex_1 = __webpack_require__(/*! ../util/mutex */ \"./src/util/mutex.ts\");\nconst object_1 = __webpack_require__(/*! ../util/object */ \"./src/util/object.ts\");\nconst string_1 = __webpack_require__(/*! ../util/string */ \"./src/util/string.ts\");\nconst chars_1 = __webpack_require__(/*! ./chars */ \"./src/model/chars.ts\");\nconst textdocument_1 = __webpack_require__(/*! ./textdocument */ \"./src/model/textdocument.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('model-document');\n// getText, positionAt, offsetAt\nclass Document {\n    constructor(buffer, env, maxFileSize) {\n        this.buffer = buffer;\n        this.env = env;\n        this.maxFileSize = maxFileSize;\n        this.isIgnored = false;\n        this.mutex = new mutex_1.Mutex();\n        this._version = 1;\n        this.size = 0;\n        this.eol = true;\n        // real current lines\n        this.lines = [];\n        this.syncLines = [];\n        this._attached = false;\n        this._previewwindow = false;\n        this._winid = -1;\n        this._words = [];\n        this._onDocumentChange = new vscode_languageserver_protocol_1.Emitter();\n        this._onDocumentDetach = new vscode_languageserver_protocol_1.Emitter();\n        this.disposables = [];\n        this.onDocumentChange = this._onDocumentChange.event;\n        this.onDocumentDetach = this._onDocumentDetach.event;\n        this.fireContentChanges = debounce_1.default(() => {\n            this._fireContentChanges();\n        }, 100);\n        this.fetchContent = debounce_1.default(() => {\n            this._fetchContent().logError();\n        }, 100);\n    }\n    /**\n     * Synchronize content\n     */\n    get content() {\n        return this.syncLines.join('\\n') + (this.eol ? '\\n' : '');\n    }\n    get version() {\n        return this._version;\n    }\n    /**\n     * Buffer number\n     */\n    get bufnr() {\n        return this.buffer.id;\n    }\n    get filetype() {\n        return this._filetype;\n    }\n    get uri() {\n        return this._uri;\n    }\n    /**\n     * Check if current document should be attached for changes.\n     *\n     * Currently only attach for empty and `acwrite` buftype.\n     */\n    get shouldAttach() {\n        let { buftype, maxFileSize } = this;\n        if (!this.getVar('enabled', true))\n            return false;\n        if (this.uri.endsWith('%5BCommand%20Line%5D'))\n            return true;\n        // too big\n        if (this.size == -2)\n            return false;\n        if (maxFileSize && this.size > maxFileSize)\n            return false;\n        return buftype == '' || buftype == 'acwrite';\n    }\n    get isCommandLine() {\n        return this.uri && this.uri.endsWith('%5BCommand%20Line%5D');\n    }\n    get enabled() {\n        return this.getVar('enabled', true);\n    }\n    /**\n     * All words, extracted by `iskeyword` option.\n     */\n    get words() {\n        return this._words;\n    }\n    /**\n     * Map filetype for languageserver.\n     */\n    convertFiletype(filetype) {\n        let map = this.env.filetypeMap;\n        if (filetype == 'javascript.jsx')\n            return 'javascriptreact';\n        if (filetype == 'typescript.jsx' || filetype == 'typescript.tsx')\n            return 'typescriptreact';\n        return map[filetype] || filetype;\n    }\n    /**\n     * Get current buffer changedtick.\n     */\n    get changedtick() {\n        return this._changedtick;\n    }\n    /**\n     * Scheme of document.\n     */\n    get schema() {\n        return vscode_uri_1.URI.parse(this.uri).scheme;\n    }\n    /**\n     * Line count of current buffer.\n     */\n    get lineCount() {\n        return this.lines.length;\n    }\n    /**\n     * Window ID when buffer create, could be -1 when no window associated.\n     *\n     * @deprecated could be wrong.\n     */\n    get winid() {\n        return this._winid;\n    }\n    /**\n     * Returns if current document is opended with previewwindow\n     */\n    get previewwindow() {\n        return this._previewwindow;\n    }\n    /**\n     * Initialize document model.\n     *\n     * @internal\n     */\n    async init(nvim, token) {\n        this.nvim = nvim;\n        let opts = await nvim.call('coc#util#get_bufoptions', [this.bufnr, this.maxFileSize]);\n        if (opts == null)\n            return false;\n        let buftype = this.buftype = opts.buftype;\n        this._previewwindow = opts.previewwindow;\n        this._winid = opts.winid;\n        this.size = typeof opts.size == 'number' ? opts.size : 0;\n        this.variables = opts.variables || {};\n        this._changedtick = opts.changedtick;\n        this.eol = opts.eol == 1;\n        this._uri = index_1.getUri(opts.fullpath, this.bufnr, buftype, this.env.isCygwin);\n        if (token.isCancellationRequested)\n            return false;\n        if (this.shouldAttach) {\n            this.lines = opts.lines;\n            this.syncLines = this.lines;\n            let res = await this.attach();\n            if (!res)\n                return false;\n            this._attached = true;\n        }\n        this._filetype = this.convertFiletype(opts.filetype);\n        this.setIskeyword(opts.iskeyword);\n        if (token.isCancellationRequested) {\n            this.detach();\n            return false;\n        }\n        return true;\n    }\n    async attach() {\n        let attached = await this.buffer.attach(true);\n        if (!attached)\n            return false;\n        this.buffer.listen('lines', this.onChange.bind(this), this.disposables);\n        this.buffer.listen('detach', async (buf) => {\n            this._onDocumentDetach.fire(buf.id);\n        }, this.disposables);\n        return true;\n    }\n    async onChange(buf, tick, firstline, lastline, linedata) {\n        if (buf.id !== this.bufnr || !this._attached || tick == null)\n            return;\n        if (this.mutex.busy)\n            return;\n        if (tick > this._changedtick) {\n            this._changedtick = tick;\n            this.lines = [...this.lines.slice(0, firstline), ...linedata, ...this.lines.slice(lastline)];\n            this.fireContentChanges();\n        }\n    }\n    /**\n     * Make sure current document synced correctly\n     */\n    async checkDocument() {\n        let { buffer } = this;\n        let release = await this.mutex.acquire();\n        this.fireContentChanges.clear();\n        this._changedtick = await buffer.changedtick;\n        this.lines = await buffer.lines;\n        let changed = this._fireContentChanges();\n        if (changed)\n            await index_1.wait(30);\n        release();\n    }\n    /**\n     * Check if document changed after last synchronize\n     */\n    get dirty() {\n        if (this.lines === this.syncLines)\n            return false;\n        return !object_1.equals(this.lines, this.syncLines);\n    }\n    _fireContentChanges() {\n        let { cursor } = events_1.default;\n        let { textDocument } = this;\n        try {\n            let endOffset = null;\n            // consider cursor position.\n            if (cursor && cursor.bufnr == this.bufnr) {\n                endOffset = this.getEndOffset(cursor.lnum, cursor.col, cursor.insert);\n            }\n            let content = this.getDocumentContent();\n            let change = diff_1.getChange(textDocument.getText(), content, endOffset);\n            if (change == null)\n                return;\n            let start = textDocument.positionAt(change.start);\n            let end = textDocument.positionAt(change.end);\n            let original = textDocument.getText(vscode_languageserver_protocol_1.Range.create(start, end));\n            this._version = this._version + 1;\n            this.syncLines = this.lines;\n            let changes = [{\n                    range: { start, end },\n                    rangeLength: change.end - change.start,\n                    text: change.newText\n                }];\n            this._onDocumentChange.fire({\n                bufnr: this.bufnr,\n                original,\n                textDocument: { version: this.version, uri: this.uri },\n                contentChanges: changes\n            });\n            this._words = this.chars.matchKeywords(content);\n            return true;\n        }\n        catch (e) {\n            logger.error(e.message);\n        }\n        return false;\n    }\n    async applyEdits(edits) {\n        if (!Array.isArray(arguments[0]) && Array.isArray(arguments[1])) {\n            edits = arguments[1];\n        }\n        if (edits.length == 0)\n            return;\n        let current = this.getDocumentContent();\n        let textDocument = vscode_languageserver_textdocument_1.TextDocument.create(this.uri, this.filetype, 1, current);\n        // apply edits to current textDocument\n        let applied = vscode_languageserver_textdocument_1.TextDocument.applyEdits(textDocument, edits);\n        // could be equal sometimes\n        if (current !== applied) {\n            let newLines = (this.eol && applied.endsWith('\\n') ? applied.slice(0, -1) : applied).split('\\n');\n            let d = diff_1.diffLines(this.lines, newLines);\n            let release = await this.mutex.acquire();\n            try {\n                let res = await this.nvim.call('coc#util#set_lines', [this.bufnr, d.replacement, d.start, d.end]);\n                this._changedtick = res.changedtick;\n                // can't wait vim sync buffer\n                this.lines = newLines;\n                // res.lines\n                this.fireContentChanges.clear();\n                this._fireContentChanges();\n                // could be user type during applyEdits.\n                if (!object_1.equals(newLines, res.lines)) {\n                    process.nextTick(() => {\n                        this.lines = res.lines;\n                        this.fireContentChanges.clear();\n                        this._fireContentChanges();\n                    });\n                }\n                release();\n            }\n            catch (e) {\n                logger.error('Error on applyEdits: ', e);\n                release();\n            }\n        }\n    }\n    async changeLines(lines) {\n        let filtered = [];\n        let newLines = this.lines.slice();\n        for (let [lnum, text] of lines) {\n            if (newLines[lnum] != text) {\n                filtered.push([lnum, text]);\n                newLines[lnum] = text;\n            }\n        }\n        if (!filtered.length)\n            return;\n        let release = await this.mutex.acquire();\n        try {\n            let res = await this.nvim.call('coc#util#change_lines', [this.bufnr, filtered]);\n            if (res != null) {\n                this.lines = newLines;\n                this._changedtick = res.changedtick;\n                this.fireContentChanges.clear();\n                this._fireContentChanges();\n                if (!object_1.equals(newLines, res.lines)) {\n                    process.nextTick(() => {\n                        this.lines = res.lines;\n                        this.fireContentChanges.clear();\n                        this._fireContentChanges();\n                    });\n                }\n            }\n            release();\n        }\n        catch (e) {\n            release();\n        }\n    }\n    /**\n     * Force document synchronize and emit change event when necessary.\n     */\n    forceSync() {\n        if (this.mutex.busy)\n            return;\n        this.fireContentChanges.clear();\n        this._fireContentChanges();\n    }\n    /**\n     * Get offset from lnum & col\n     */\n    getOffset(lnum, col) {\n        return this.textDocument.offsetAt({\n            line: lnum - 1,\n            character: col\n        });\n    }\n    /**\n     * Check string is word.\n     */\n    isWord(word) {\n        return this.chars.isKeyword(word);\n    }\n    /**\n     * Generate more words by split word with `-`\n     */\n    getMoreWords() {\n        let res = [];\n        let { words, chars } = this;\n        if (!chars.isKeywordChar('-'))\n            return res;\n        for (let word of words) {\n            word = word.replace(/^-+/, '');\n            if (word.includes('-')) {\n                let parts = word.split('-');\n                for (let part of parts) {\n                    if (part.length > 2 &&\n                        !res.includes(part) &&\n                        !words.includes(part)) {\n                        res.push(part);\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    /**\n     * Current word for replacement\n     */\n    getWordRangeAtPosition(position, extraChars, current = true) {\n        let chars = this.chars.clone();\n        if (extraChars && extraChars.length) {\n            for (let ch of extraChars) {\n                chars.addKeyword(ch);\n            }\n        }\n        let line = this.getline(position.line, current);\n        if (line.length == 0 || position.character >= line.length)\n            return null;\n        if (!chars.isKeywordChar(line[position.character]))\n            return null;\n        let start = position.character;\n        let end = position.character + 1;\n        if (!chars.isKeywordChar(line[start])) {\n            return vscode_languageserver_protocol_1.Range.create(position, { line: position.line, character: position.character + 1 });\n        }\n        while (start >= 0) {\n            let ch = line[start - 1];\n            if (!ch || !chars.isKeyword(ch))\n                break;\n            start = start - 1;\n        }\n        while (end <= line.length) {\n            let ch = line[end];\n            if (!ch || !chars.isKeywordChar(ch))\n                break;\n            end = end + 1;\n        }\n        return vscode_languageserver_protocol_1.Range.create(position.line, start, position.line, end);\n    }\n    /**\n     * Synchronized textDocument.\n     */\n    get textDocument() {\n        let { version, filetype, uri } = this;\n        return new textdocument_1.LinesTextDoucment(uri, filetype, version, this.syncLines, this.eol);\n    }\n    /**\n     * Used by vim for fetch new lines.\n     */\n    async _fetchContent() {\n        if (!this.env.isVim || !this._attached)\n            return;\n        let { nvim, bufnr, changedtick } = this;\n        let release = await this.mutex.acquire();\n        let o = await nvim.call('coc#util#get_buf_lines', [bufnr, changedtick]);\n        if (o && o.changedtick >= this._changedtick) {\n            this._changedtick = o.changedtick;\n            this.lines = o.lines;\n            this.fireContentChanges.clear();\n            this._fireContentChanges();\n        }\n        release();\n    }\n    /**\n     * Get and synchronize change\n     */\n    async patchChange(currentLine) {\n        if (!this._attached)\n            return;\n        if (this.env.isVim) {\n            if (currentLine) {\n                let change = await this.nvim.call('coc#util#get_changeinfo', []);\n                if (change.changedtick < this._changedtick)\n                    return;\n                let { lnum, line, changedtick } = change;\n                let newLines = this.lines.slice();\n                this._changedtick = changedtick;\n                if (newLines[lnum - 1] == line)\n                    return;\n                newLines[lnum - 1] = line;\n                this.lines = newLines;\n                this.forceSync();\n            }\n            else {\n                this.fetchContent.clear();\n                await this._fetchContent();\n            }\n        }\n        else {\n            // we have latest lines aftet TextChange on neovim\n            this.forceSync();\n        }\n    }\n    /**\n     * Get ranges of word in textDocument.\n     */\n    getSymbolRanges(word) {\n        this.forceSync();\n        let res = [];\n        let { textDocument } = this;\n        let content = textDocument.getText();\n        let str = '';\n        for (let i = 0, l = content.length; i < l; i++) {\n            let ch = content[i];\n            if ('-' == ch && str.length == 0) {\n                continue;\n            }\n            let isKeyword = this.chars.isKeywordChar(ch);\n            if (isKeyword) {\n                str = str + ch;\n            }\n            if (str.length > 0 && !isKeyword && str == word) {\n                res.push(vscode_languageserver_protocol_1.Range.create(textDocument.positionAt(i - str.length), textDocument.positionAt(i)));\n            }\n            if (!isKeyword) {\n                str = '';\n            }\n        }\n        return res;\n    }\n    /**\n     * Adjust col with new valid character before position.\n     */\n    fixStartcol(position, valids) {\n        let line = this.getline(position.line);\n        if (!line)\n            return null;\n        let { character } = position;\n        let start = line.slice(0, character);\n        let col = string_1.byteLength(start);\n        let { chars } = this;\n        for (let i = start.length - 1; i >= 0; i--) {\n            let c = start[i];\n            if (c == ' ')\n                break;\n            if (!chars.isKeywordChar(c) && !valids.includes(c)) {\n                break;\n            }\n            col = col - string_1.byteLength(c);\n        }\n        return col;\n    }\n    /**\n     * Real current line\n     */\n    getline(line, current = true) {\n        if (current)\n            return this.lines[line] || '';\n        return this.syncLines[line] || '';\n    }\n    /**\n     * Get lines, zero indexed, end exclude.\n     */\n    getLines(start, end) {\n        return this.lines.slice(start, end);\n    }\n    /**\n     * Get current content text.\n     */\n    getDocumentContent() {\n        let content = this.lines.join('\\n');\n        return this.eol ? content + '\\n' : content;\n    }\n    /**\n     * Get variable value by key, defined by `b:coc_{key}`\n     */\n    getVar(key, defaultValue) {\n        let val = this.variables[`coc_${key}`];\n        return val === undefined ? defaultValue : val;\n    }\n    /**\n     * Get position from lnum & col\n     */\n    getPosition(lnum, col) {\n        let line = this.getline(lnum - 1);\n        if (!line || col == 0)\n            return { line: lnum - 1, character: 0 };\n        let pre = string_1.byteSlice(line, 0, col - 1);\n        return { line: lnum - 1, character: pre.length };\n    }\n    /**\n     * Get end offset from cursor position.\n     * For normal mode, use offset - 1 when possible\n     */\n    getEndOffset(lnum, col, insert) {\n        let total = 0;\n        let len = this.lines.length;\n        for (let i = lnum - 1; i < len; i++) {\n            let line = this.lines[i];\n            let l = line.length;\n            if (i == lnum - 1 && l != 0) {\n                // current\n                let buf = global.Buffer.from(line, 'utf8');\n                let isEnd = buf.byteLength <= col - 1;\n                if (!isEnd) {\n                    total = total + buf.slice(col - 1, buf.length).toString('utf8').length;\n                    if (!insert)\n                        total = total - 1;\n                }\n            }\n            else {\n                total = total + l;\n            }\n            if (!this.eol && i == len - 1)\n                break;\n            total = total + 1;\n        }\n        return total;\n    }\n    /**\n     * Recreate document with new filetype.\n     *\n     * @internal\n     */\n    setFiletype(filetype) {\n        this._filetype = this.convertFiletype(filetype);\n        this._version = this._version + 1;\n    }\n    /**\n     * Change iskeyword option of document\n     *\n     * @internal\n     */\n    setIskeyword(iskeyword) {\n        let chars = this.chars = new chars_1.Chars(iskeyword);\n        let additional = this.getVar('additional_keywords', []);\n        if (additional && Array.isArray(additional)) {\n            for (let ch of additional) {\n                chars.addKeyword(ch);\n            }\n        }\n        let lines = this.lines.length > 30000 ? this.lines.slice(0, 30000) : this.lines;\n        // TODO not parse words\n        this._words = this.chars.matchKeywords(lines.join('\\n'));\n    }\n    get attached() {\n        return this._attached;\n    }\n    /**\n     * Detach document.\n     *\n     * @internal\n     */\n    detach() {\n        this._attached = false;\n        index_1.disposeAll(this.disposables);\n        this.disposables = [];\n        this.fetchContent.clear();\n        this.fireContentChanges.clear();\n        this._onDocumentChange.dispose();\n        this._onDocumentDetach.dispose();\n    }\n    /**\n     * Get localify bonus map.\n     *\n     * @internal\n     */\n    getLocalifyBonus(sp, ep) {\n        let res = new Map();\n        let { chars } = this;\n        let startLine = Math.max(0, sp.line - 100);\n        let endLine = Math.min(this.lineCount, sp.line + 100);\n        let content = this.lines.slice(startLine, endLine).join('\\n');\n        sp = vscode_languageserver_protocol_1.Position.create(sp.line - startLine, sp.character);\n        ep = vscode_languageserver_protocol_1.Position.create(ep.line - startLine, ep.character);\n        let doc = vscode_languageserver_textdocument_1.TextDocument.create(this.uri, this.filetype, 1, content);\n        let headCount = doc.offsetAt(sp);\n        let len = content.length;\n        let tailCount = len - doc.offsetAt(ep);\n        let start = 0;\n        let preKeyword = false;\n        for (let i = 0; i < headCount; i++) {\n            let iskeyword = chars.isKeyword(content[i]);\n            if (!preKeyword && iskeyword) {\n                start = i;\n            }\n            else if (preKeyword && (!iskeyword || i == headCount - 1)) {\n                if (i - start > 1) {\n                    let str = content.slice(start, i);\n                    res.set(str, i / headCount);\n                }\n            }\n            preKeyword = iskeyword;\n        }\n        start = len - tailCount;\n        preKeyword = false;\n        for (let i = start; i < content.length; i++) {\n            let iskeyword = chars.isKeyword(content[i]);\n            if (!preKeyword && iskeyword) {\n                start = i;\n            }\n            else if (preKeyword && (!iskeyword || i == len - 1)) {\n                if (i - start > 1) {\n                    let end = i == len - 1 ? i + 1 : i;\n                    let str = content.slice(start, end);\n                    let score = res.get(str) || 0;\n                    res.set(str, Math.max(score, (len - i + (end - start)) / tailCount));\n                }\n            }\n            preKeyword = iskeyword;\n        }\n        return res;\n    }\n}\nexports.default = Document;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/document.ts?");

/***/ }),

/***/ "./src/model/download.ts":
/*!*******************************!*\
  !*** ./src/model/download.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst follow_redirects_1 = __webpack_require__(/*! follow-redirects */ \"./node_modules/follow-redirects/index.js\");\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nconst fs_extra_1 = tslib_1.__importDefault(__webpack_require__(/*! fs-extra */ \"./node_modules/fs-extra/lib/index.js\"));\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst tar_1 = tslib_1.__importDefault(__webpack_require__(/*! tar */ \"./node_modules/tar/index.js\"));\nconst unzipper_1 = tslib_1.__importDefault(__webpack_require__(/*! unzipper */ \"./node_modules/unzipper/unzip.js\"));\nconst fetch_1 = __webpack_require__(/*! ./fetch */ \"./src/model/fetch.ts\");\nconst content_disposition_1 = tslib_1.__importDefault(__webpack_require__(/*! content-disposition */ \"./node_modules/content-disposition/index.js\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('model-download');\n/**\n * Download file from url, with optional untar/unzip support.\n *\n * @param {string} url\n * @param {DownloadOptions} options contains dest folder and optional onProgress callback\n */\nfunction download(url, options, token) {\n    let { dest, onProgress, extract } = options;\n    if (!dest || !path_1.default.isAbsolute(dest)) {\n        throw new Error(`Expect absolute file path for dest option.`);\n    }\n    let stat;\n    try {\n        stat = fs_extra_1.default.statSync(dest);\n    }\n    catch (_e) {\n        fs_extra_1.default.mkdirpSync(dest);\n    }\n    if (stat && !stat.isDirectory()) {\n        throw new Error(`${dest} exists, but not directory!`);\n    }\n    let mod = url.startsWith('https') ? follow_redirects_1.https : follow_redirects_1.http;\n    let opts = fetch_1.resolveRequestOptions(url, options);\n    let extname = path_1.default.extname(url);\n    return new Promise((resolve, reject) => {\n        if (token) {\n            let disposable = token.onCancellationRequested(() => {\n                disposable.dispose();\n                req.destroy(new Error('request aborted'));\n            });\n        }\n        const req = mod.request(opts, (res) => {\n            var _a, _b;\n            if ((res.statusCode >= 200 && res.statusCode < 300) || res.statusCode === 1223) {\n                let headers = res.headers || {};\n                let dispositionHeader = headers['content-disposition'];\n                if (!extname && dispositionHeader) {\n                    let disposition = content_disposition_1.default.parse(dispositionHeader);\n                    if ((_a = disposition.parameters) === null || _a === void 0 ? void 0 : _a.filename) {\n                        extname = path_1.default.extname(disposition.parameters.filename);\n                    }\n                }\n                if (extract === true) {\n                    if (extname === '.zip' || headers['content-type'] == 'application/zip') {\n                        extract = 'unzip';\n                    }\n                    else if (extname == '.tgz') {\n                        extract = 'untar';\n                    }\n                    else {\n                        reject(new Error(`Unable to extract for ${url}`));\n                        return;\n                    }\n                }\n                let total = Number(headers['content-length']);\n                let cur = 0;\n                if (!isNaN(total)) {\n                    res.on('data', chunk => {\n                        cur += chunk.length;\n                        let percent = (cur / total * 100).toFixed(1);\n                        if (onProgress) {\n                            onProgress(percent);\n                        }\n                        else {\n                            logger.info(`Download ${url} progress ${percent}%`);\n                        }\n                    });\n                }\n                res.on('error', err => {\n                    reject(new Error(`Unable to connect ${url}: ${err.message}`));\n                });\n                res.on('end', () => {\n                    logger.info('Download completed:', url);\n                });\n                let stream;\n                if (extract === 'untar') {\n                    stream = res.pipe(tar_1.default.x({ strip: (_b = options.strip) !== null && _b !== void 0 ? _b : 1, C: dest }));\n                }\n                else if (extract === 'unzip') {\n                    stream = res.pipe(unzipper_1.default.Extract({ path: dest }));\n                }\n                else {\n                    dest = path_1.default.join(dest, `${uuid_1.v1()}${extname}`);\n                    stream = res.pipe(fs_extra_1.default.createWriteStream(dest));\n                }\n                stream.on('finish', () => {\n                    logger.info(`Downloaded ${url} => ${dest}`);\n                    setTimeout(() => {\n                        resolve(dest);\n                    }, 100);\n                });\n                stream.on('error', reject);\n            }\n            else {\n                reject(new Error(`Invalid response from ${url}: ${res.statusCode}`));\n            }\n        });\n        req.on('error', reject);\n        req.on('timeout', () => {\n            req.destroy(new Error(`request timeout after ${options.timeout}ms`));\n        });\n        if (options.timeout) {\n            req.setTimeout(options.timeout);\n        }\n        req.end();\n    });\n}\nexports.default = download;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/download.ts?");

/***/ }),

/***/ "./src/model/fetch.ts":
/*!****************************!*\
  !*** ./src/model/fetch.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.resolveRequestOptions = exports.getAgent = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst follow_redirects_1 = __webpack_require__(/*! follow-redirects */ \"./node_modules/follow-redirects/index.js\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst fs_1 = tslib_1.__importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst zlib_1 = tslib_1.__importDefault(__webpack_require__(/*! zlib */ \"zlib\"));\nconst is_1 = __webpack_require__(/*! ../util/is */ \"./src/util/is.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst querystring_1 = __webpack_require__(/*! querystring */ \"querystring\");\nconst http_proxy_agent_1 = tslib_1.__importDefault(__webpack_require__(/*! http-proxy-agent */ \"./node_modules/http-proxy-agent/dist/index.js\"));\nconst https_proxy_agent_1 = tslib_1.__importDefault(__webpack_require__(/*! https-proxy-agent */ \"./node_modules/https-proxy-agent/dist/index.js\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('model-fetch');\nfunction getSystemProxyURI(endpoint) {\n    let env;\n    if (endpoint.protocol === 'http:') {\n        env = process.env.HTTP_PROXY || process.env.http_proxy || null;\n    }\n    else if (endpoint.protocol === 'https:') {\n        env = process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;\n    }\n    let noProxy = process.env.NO_PROXY || process.env.no_proxy;\n    if (noProxy === '*') {\n        env = null;\n    }\n    else if (noProxy) {\n        // canonicalize the hostname, so that 'oogle.com' won't match 'google.com'\n        const hostname = endpoint.hostname.replace(/^\\.*/, '.').toLowerCase();\n        const port = endpoint.port || endpoint.protocol.startsWith('https') ? '443' : '80';\n        const noProxyList = noProxy.split(',');\n        for (let i = 0, len = noProxyList.length; i < len; i++) {\n            let noProxyItem = noProxyList[i].trim().toLowerCase();\n            // no_proxy can be granular at the port level, which complicates things a bit.\n            if (noProxyItem.includes(':')) {\n                let noProxyItemParts = noProxyItem.split(':', 2);\n                let noProxyHost = noProxyItemParts[0].replace(/^\\.*/, '.');\n                let noProxyPort = noProxyItemParts[1];\n                if (port === noProxyPort && hostname.endsWith(noProxyHost)) {\n                    env = null;\n                    break;\n                }\n            }\n            else {\n                noProxyItem = noProxyItem.replace(/^\\.*/, '.');\n                if (hostname.endsWith(noProxyItem)) {\n                    env = null;\n                    break;\n                }\n            }\n        }\n    }\n    return env;\n}\nfunction getAgent(endpoint, options) {\n    let proxy = options.proxyUrl || getSystemProxyURI(endpoint);\n    if (proxy) {\n        const proxyEndpoint = url_1.parse(proxy);\n        if (!/^https?:$/.test(proxyEndpoint.protocol)) {\n            return null;\n        }\n        let opts = {\n            host: proxyEndpoint.hostname,\n            port: proxyEndpoint.port ? Number(proxyEndpoint.port) : (proxyEndpoint.protocol === 'https' ? '443' : '80'),\n            auth: proxyEndpoint.auth,\n            rejectUnauthorized: typeof options.strictSSL === 'boolean' ? options.strictSSL : true\n        };\n        logger.info(`Using proxy ${proxy} from ${options.proxyUrl ? 'configuration' : 'system environment'} for ${endpoint.hostname}:`);\n        return endpoint.protocol === 'http:' ? http_proxy_agent_1.default(opts) : https_proxy_agent_1.default(opts);\n    }\n    return null;\n}\nexports.getAgent = getAgent;\nfunction resolveRequestOptions(url, options = {}) {\n    let config = workspace_1.default.getConfiguration('http');\n    let { data } = options;\n    let dataType = getDataType(data);\n    let proxyOptions = {\n        proxyUrl: config.get('proxy', ''),\n        strictSSL: config.get('proxyStrictSSL', true),\n        proxyAuthorization: config.get('proxyAuthorization', null),\n        proxyCA: config.get('proxyCA', null)\n    };\n    if (options.query && !url.includes('?')) {\n        url = `${url}?${querystring_1.stringify(options.query)}`;\n    }\n    let headers = Object.assign(options.headers || {}, { 'Proxy-Authorization': proxyOptions.proxyAuthorization });\n    let endpoint = url_1.parse(url);\n    let agent = getAgent(endpoint, proxyOptions);\n    let opts = {\n        method: options.method || 'GET',\n        hostname: endpoint.hostname,\n        port: endpoint.port ? parseInt(endpoint.port, 10) : (endpoint.protocol === 'https:' ? 443 : 80),\n        path: endpoint.path,\n        agent,\n        rejectUnauthorized: proxyOptions.strictSSL,\n        maxRedirects: 3,\n        headers: Object.assign({\n            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64)',\n            'Accept-Encoding': 'gzip, deflate'\n        }, headers)\n    };\n    if (proxyOptions.proxyCA) {\n        opts.ca = fs_1.default.readFileSync(proxyOptions.proxyCA);\n    }\n    if (dataType == 'object') {\n        opts.headers['Content-Type'] = 'application/json';\n    }\n    else if (dataType == 'string') {\n        opts.headers['Content-Type'] = 'text/plain';\n    }\n    if (options.user && options.password) {\n        opts.auth = options.user + ':' + options.password;\n    }\n    if (options.timeout) {\n        opts.timeout = options.timeout;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return opts;\n}\nexports.resolveRequestOptions = resolveRequestOptions;\nfunction request(url, data, opts, token) {\n    let mod = url.startsWith('https:') ? follow_redirects_1.https : follow_redirects_1.http;\n    return new Promise((resolve, reject) => {\n        if (token) {\n            let disposable = token.onCancellationRequested(() => {\n                disposable.dispose();\n                req.destroy(new Error('request aborted'));\n            });\n        }\n        const req = mod.request(opts, res => {\n            let readable = res;\n            if ((res.statusCode >= 200 && res.statusCode < 300) || res.statusCode === 1223) {\n                let headers = res.headers || {};\n                let chunks = [];\n                let contentType = headers['content-type'] || '';\n                let contentEncoding = headers['content-encoding'] || '';\n                if (contentEncoding === 'gzip') {\n                    const unzip = zlib_1.default.createGunzip();\n                    readable = res.pipe(unzip);\n                }\n                else if (contentEncoding === 'deflate') {\n                    let inflate = zlib_1.default.createInflate();\n                    res.pipe(inflate);\n                    readable = inflate;\n                }\n                readable.on('data', chunk => {\n                    chunks.push(chunk);\n                });\n                readable.on('end', () => {\n                    let buf = Buffer.concat(chunks);\n                    if (contentType.startsWith('application/json')\n                        || contentType.startsWith('text/')) {\n                        let ms = contentType.match(/charset=(\\S+)/);\n                        let encoding = ms ? ms[1] : 'utf8';\n                        let rawData = buf.toString(encoding);\n                        if (!contentType.includes('application/json')) {\n                            resolve(rawData);\n                        }\n                        else {\n                            try {\n                                const parsedData = JSON.parse(rawData);\n                                resolve(parsedData);\n                            }\n                            catch (e) {\n                                reject(new Error(`Parse response error: ${e}`));\n                            }\n                        }\n                    }\n                    else {\n                        resolve(buf);\n                    }\n                });\n                readable.on('error', err => {\n                    reject(new Error(`Unable to connect ${url}: ${err.message}`));\n                });\n            }\n            else {\n                reject(new Error(`Bad response from ${url}: ${res.statusCode}`));\n            }\n        });\n        req.on('error', reject);\n        req.on('timeout', () => {\n            req.destroy(new Error(`Request timeout after ${opts.timeout}ms`));\n        });\n        if (data) {\n            if (typeof data === 'string' || Buffer.isBuffer(data)) {\n                req.write(data);\n            }\n            else {\n                req.write(JSON.stringify(data));\n            }\n        }\n        if (opts.timeout) {\n            req.setTimeout(opts.timeout);\n        }\n        req.end();\n    });\n}\nfunction getDataType(data) {\n    if (data === null)\n        return 'null';\n    if (data === undefined)\n        return 'undefined';\n    if (typeof data == 'string')\n        return 'string';\n    if (Buffer.isBuffer(data))\n        return 'buffer';\n    if (Array.isArray(data) || is_1.objectLiteral(data))\n        return 'object';\n    return 'unknown';\n}\n/**\n * Send request to server for response, supports:\n *\n * - Send json data and parse json response.\n * - Throw error for failed response statusCode.\n * - Timeout support (no timeout by default).\n * - Send buffer (as data) and receive data (as response).\n * - Proxy support from user configuration & environment.\n * - Redirect support, limited to 3.\n * - Support of gzip & deflate response content.\n */\nfunction fetch(url, options = {}, token) {\n    let opts = resolveRequestOptions(url, options);\n    return request(url, options.data, opts, token).catch(err => {\n        logger.error(`Fetch error for ${url}:`, opts, err);\n        if (opts.agent && opts.agent.proxy) {\n            let { proxy } = opts.agent;\n            throw new Error(`Request failed using proxy ${proxy.host}: ${err.message}`);\n        }\n        else {\n            throw err;\n        }\n    });\n}\nexports.default = fetch;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/fetch.ts?");

/***/ }),

/***/ "./src/model/fileSystemWatcher.ts":
/*!****************************************!*\
  !*** ./src/model/fileSystemWatcher.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst minimatch_1 = tslib_1.__importDefault(__webpack_require__(/*! minimatch */ \"./node_modules/minimatch/minimatch.js\"));\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst array_1 = __webpack_require__(/*! ../util/array */ \"./src/util/array.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('filesystem-watcher');\nclass FileSystemWatcher {\n    constructor(clientPromise, globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {\n        this.globPattern = globPattern;\n        this.ignoreCreateEvents = ignoreCreateEvents;\n        this.ignoreChangeEvents = ignoreChangeEvents;\n        this.ignoreDeleteEvents = ignoreDeleteEvents;\n        this._onDidCreate = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidDelete = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidRename = new vscode_languageserver_protocol_1.Emitter();\n        this.onDidCreate = this._onDidCreate.event;\n        this.onDidChange = this._onDidChange.event;\n        this.onDidDelete = this._onDidDelete.event;\n        this.onDidRename = this._onDidRename.event;\n        this.disposables = [];\n        if (!clientPromise)\n            return;\n        clientPromise.then(client => {\n            if (client)\n                return this.listen(client);\n        }).catch(error => {\n            logger.error('watchman initialize failed');\n            logger.error(error.stack);\n        });\n    }\n    async listen(client) {\n        let { globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents } = this;\n        let disposable = await client.subscribe(globPattern, (change) => {\n            let { root, files } = change;\n            files = files.filter(f => f.type == 'f' && minimatch_1.default(f.name, globPattern, { dot: true }));\n            for (let file of files) {\n                let uri = vscode_uri_1.URI.file(path_1.default.join(root, file.name));\n                if (!file.exists) {\n                    if (!ignoreDeleteEvents)\n                        this._onDidDelete.fire(uri);\n                }\n                else {\n                    if (file.new === true) {\n                        if (!ignoreCreateEvents)\n                            this._onDidCreate.fire(uri);\n                    }\n                    else {\n                        if (!ignoreChangeEvents)\n                            this._onDidChange.fire(uri);\n                    }\n                }\n            }\n            // file rename\n            if (files.length == 2 && !files[0].exists && files[1].exists) {\n                let oldFile = files[0];\n                let newFile = files[1];\n                if (oldFile.size == newFile.size) {\n                    this._onDidRename.fire({\n                        oldUri: vscode_uri_1.URI.file(path_1.default.join(root, oldFile.name)),\n                        newUri: vscode_uri_1.URI.file(path_1.default.join(root, newFile.name))\n                    });\n                }\n            }\n            // detect folder rename\n            if (files.length >= 2) {\n                let [oldFiles, newFiles] = array_1.splitArray(files, o => o.exists === false);\n                if (oldFiles.length == newFiles.length) {\n                    for (let oldFile of oldFiles) {\n                        let newFile = newFiles.find(o => o.size == oldFile.size && o.mtime_ms == oldFile.mtime_ms);\n                        if (newFile) {\n                            this._onDidRename.fire({\n                                oldUri: vscode_uri_1.URI.file(path_1.default.join(root, oldFile.name)),\n                                newUri: vscode_uri_1.URI.file(path_1.default.join(root, newFile.name))\n                            });\n                        }\n                    }\n                }\n            }\n        });\n        this.disposables.push(disposable);\n        return disposable;\n    }\n    dispose() {\n        util_1.disposeAll(this.disposables);\n    }\n}\nexports.default = FileSystemWatcher;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/fileSystemWatcher.ts?");

/***/ }),

/***/ "./src/model/floatFactory.ts":
/*!***********************************!*\
  !*** ./src/model/floatFactory.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst debounce_1 = tslib_1.__importDefault(__webpack_require__(/*! debounce */ \"./node_modules/debounce/index.js\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nconst markdown_1 = __webpack_require__(/*! ../markdown */ \"./src/markdown/index.ts\");\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst mutex_1 = __webpack_require__(/*! ../util/mutex */ \"./src/util/mutex.ts\");\nconst object_1 = __webpack_require__(/*! ../util/object */ \"./src/util/object.ts\");\nconst isVim = process.env.VIM_NODE_RPC == '1';\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('model-float');\n/**\n * Float window/popup factory for create float/popup around current cursor.\n */\nclass FloatFactory {\n    constructor(nvim) {\n        this.nvim = nvim;\n        this.winid = 0;\n        this._bufnr = 0;\n        this.mutex = new mutex_1.Mutex();\n        this.disposables = [];\n        this.alignTop = false;\n        this.pumAlignTop = false;\n        this.autoHide = true;\n        this.mutex = new mutex_1.Mutex();\n        events_1.default.on('BufEnter', bufnr => {\n            if (bufnr == this._bufnr\n                || bufnr == this.targetBufnr)\n                return;\n            this.close();\n        }, null, this.disposables);\n        events_1.default.on('InsertEnter', bufnr => {\n            if (bufnr == this._bufnr || !this.autoHide)\n                return;\n            this.close();\n        }, null, this.disposables);\n        events_1.default.on('InsertLeave', () => {\n            this.close();\n        }, null, this.disposables);\n        events_1.default.on('MenuPopupChanged', (ev, cursorline) => {\n            let pumAlignTop = this.pumAlignTop = cursorline > ev.row;\n            if (pumAlignTop == this.alignTop) {\n                this.close();\n            }\n        }, null, this.disposables);\n        this.onCursorMoved = debounce_1.default(this._onCursorMoved.bind(this), 300);\n        events_1.default.on('CursorMoved', this.onCursorMoved.bind(this, false), null, this.disposables);\n        events_1.default.on('CursorMovedI', this.onCursorMoved.bind(this, true), null, this.disposables);\n        this.disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.onCursorMoved.clear();\n            this.cancel();\n        }));\n    }\n    _onCursorMoved(insertMode, bufnr, cursor) {\n        if (bufnr == this._bufnr)\n            return;\n        if (bufnr == this.targetBufnr && object_1.equals(cursor, this.cursor)) {\n            // cursor not moved\n            return;\n        }\n        if (this.autoHide) {\n            this.close();\n            return;\n        }\n        if (!insertMode || bufnr != this.targetBufnr) {\n            this.close();\n            return;\n        }\n    }\n    /**\n     * Create float window/popup at cursor position.\n     *\n     * @deprecated use show method instead\n     */\n    async create(docs, _allowSelection = false, offsetX = 0) {\n        this.onCursorMoved.clear();\n        if (docs.length == 0 || docs.every(doc => doc.content.length == 0)) {\n            this.close();\n            return;\n        }\n        let release = await this.mutex.acquire();\n        try {\n            await this.createPopup(docs, { offsetX });\n            release();\n        }\n        catch (e) {\n            release();\n            logger.error(`Error on create popup:`, e.message);\n            this.close();\n        }\n    }\n    /**\n     * Show documentations in float window/popup around cursor.\n     * Window and buffer are reused when possible.\n     * Window is closed automatically on change buffer, InsertEnter, CursorMoved and CursorMovedI.\n     *\n     * @param docs List of documentations.\n     * @param config Configuration for floating window/popup.\n     */\n    async show(docs, config = {}) {\n        this.onCursorMoved.clear();\n        if (docs.length == 0 || docs.every(doc => doc.content.length == 0)) {\n            this.close();\n            return;\n        }\n        let release = await this.mutex.acquire();\n        try {\n            await this.createPopup(docs, config);\n            release();\n        }\n        catch (e) {\n            release();\n            logger.error(`Error on create popup:`, e.message);\n            this.close();\n        }\n    }\n    async createPopup(docs, opts) {\n        let tokenSource = this.tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n        let token = tokenSource.token;\n        docs = docs.filter(o => o.content.trim().length > 0);\n        let { lines, codes, highlights } = markdown_1.parseDocuments(docs);\n        let config = {\n            pumAlignTop: this.pumAlignTop,\n            preferTop: typeof opts.preferTop === 'boolean' ? opts.preferTop : false,\n            offsetX: opts.offsetX || 0,\n            title: opts.title || '',\n            close: opts.close ? 1 : 0,\n            codes,\n            highlights,\n            modes: opts.modes || ['n', 'i', 'ic', 's']\n        };\n        if (opts.maxHeight)\n            config.maxHeight = opts.maxHeight;\n        if (opts.maxWidth)\n            config.maxWidth = opts.maxWidth;\n        if (opts.border && !opts.border.every(o => o == 0)) {\n            config.border = opts.border;\n        }\n        if (opts.title && !config.border)\n            config.border = [1, 1, 1, 1];\n        if (opts.highlight)\n            config.highlight = opts.highlight;\n        if (opts.borderhighlight)\n            config.borderhighlight = [opts.borderhighlight];\n        if (opts.cursorline)\n            config.cursorline = 1;\n        this.autoHide = opts.autoHide == false ? false : true;\n        if (this.autoHide)\n            config.autohide = 1;\n        let arr = await this.nvim.call('coc#float#create_cursor_float', [this.winid, this._bufnr, lines, config]);\n        if (isVim)\n            this.nvim.command('redraw', true);\n        if (!arr || arr.length == 0) {\n            this.winid = null;\n            return;\n        }\n        let [targetBufnr, cursor, winid, bufnr] = arr;\n        this.winid = winid;\n        if (token.isCancellationRequested) {\n            this.close();\n            return;\n        }\n        let pos = await this.nvim.call('coc#float#cursor_relative', [winid]);\n        if (pos)\n            this.alignTop = pos.row < 0;\n        this._bufnr = bufnr;\n        this.tokenSource.dispose();\n        this.tokenSource = null;\n        this.targetBufnr = targetBufnr;\n        this.cursor = cursor;\n        this.onCursorMoved.clear();\n    }\n    /**\n     * Close float window\n     */\n    close() {\n        let { winid, nvim } = this;\n        this.cancel();\n        if (winid) {\n            this.winid = 0;\n            nvim.pauseNotification();\n            nvim.call('coc#float#close', [winid], true);\n            if (isVim)\n                this.nvim.command('redraw', true);\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            nvim.resumeNotification(false, true);\n        }\n    }\n    cancel() {\n        let { tokenSource } = this;\n        if (tokenSource) {\n            tokenSource.cancel();\n            this.tokenSource = null;\n        }\n    }\n    dispose() {\n        util_1.disposeAll(this.disposables);\n    }\n    get bufnr() {\n        return this._bufnr;\n    }\n    get buffer() {\n        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : null;\n    }\n    get window() {\n        return this.winid ? this.nvim.createWindow(this.winid) : null;\n    }\n    async activated() {\n        if (!this.winid)\n            return false;\n        return await this.nvim.call('coc#float#valid', [this.winid]) != 0;\n    }\n}\nexports.default = FloatFactory;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/floatFactory.ts?");

/***/ }),

/***/ "./src/model/highligher.ts":
/*!*********************************!*\
  !*** ./src/model/highligher.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ansiparse_1 = __webpack_require__(/*! ../util/ansiparse */ \"./src/util/ansiparse.ts\");\nconst string_1 = __webpack_require__(/*! ../util/string */ \"./src/util/string.ts\");\n/**\n * Build highlights, with lines and highlights\n */\nclass Highlighter {\n    constructor(srcId = -1) {\n        this.srcId = srcId;\n        this.lines = [];\n        this.highlights = [];\n    }\n    addLine(line, hlGroup) {\n        if (line.includes('\\n')) {\n            for (let content of line.split(/\\r?\\n/)) {\n                this.addLine(content, hlGroup);\n            }\n            return;\n        }\n        if (hlGroup) {\n            this.highlights.push({\n                line: this.lines.length,\n                colStart: line.match(/^\\s*/)[0].length,\n                colEnd: string_1.byteLength(line),\n                hlGroup\n            });\n        } // '\\x1b'\n        if (line.includes('\\x1b')) {\n            let res = ansiparse_1.parseAnsiHighlights(line);\n            for (let hl of res.highlights) {\n                let { span, hlGroup } = hl;\n                if (span[0] != span[1]) {\n                    this.highlights.push({\n                        line: this.lines.length,\n                        colStart: span[0],\n                        colEnd: span[1],\n                        hlGroup\n                    });\n                }\n            }\n            this.lines.push(res.line);\n        }\n        else {\n            this.lines.push(line);\n        }\n    }\n    addLines(lines) {\n        this.lines.push(...lines);\n    }\n    addText(text, hlGroup) {\n        let { lines } = this;\n        let pre = lines[lines.length - 1] || '';\n        if (hlGroup) {\n            let colStart = string_1.byteLength(pre);\n            this.highlights.push({\n                line: lines.length ? lines.length - 1 : 0,\n                colStart,\n                colEnd: colStart + string_1.byteLength(text),\n                hlGroup\n            });\n        }\n        if (lines.length) {\n            lines[lines.length - 1] = `${pre}${text}`;\n        }\n        else {\n            lines.push(text);\n        }\n    }\n    get length() {\n        return this.lines.length;\n    }\n    getline(line) {\n        return this.lines[line] || '';\n    }\n    // default to replace\n    render(buffer, start = 0, end = -1) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        buffer.setLines(this.lines, { start, end, strictIndexing: false }, true);\n        for (let item of this.highlights) {\n            buffer.addHighlight({\n                hlGroup: item.hlGroup,\n                colStart: item.colStart,\n                colEnd: item.colEnd == null ? -1 : item.colEnd,\n                line: start + item.line,\n                srcId: this.srcId\n            }).logError();\n        }\n    }\n}\nexports.default = Highlighter;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/highligher.ts?");

/***/ }),

/***/ "./src/model/installBuffer.ts":
/*!************************************!*\
  !*** ./src/model/installBuffer.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.State = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst status_1 = __webpack_require__(/*! ./status */ \"./src/model/status.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('model-installBuffer');\nvar State;\n(function (State) {\n    State[State[\"Waiting\"] = 0] = \"Waiting\";\n    State[State[\"Faild\"] = 1] = \"Faild\";\n    State[State[\"Progressing\"] = 2] = \"Progressing\";\n    State[State[\"Success\"] = 3] = \"Success\";\n})(State = exports.State || (exports.State = {}));\nclass InstallBuffer extends events_1.EventEmitter {\n    constructor(isUpdate = false, isSync = false, channel = undefined) {\n        super();\n        this.isUpdate = isUpdate;\n        this.isSync = isSync;\n        this.channel = channel;\n        this.statMap = new Map();\n        this.messagesMap = new Map();\n        this.names = [];\n    }\n    setExtensions(names) {\n        this.statMap.clear();\n        this.names = names;\n        for (let name of names) {\n            this.statMap.set(name, State.Waiting);\n        }\n    }\n    addMessage(name, msg, isProgress = false) {\n        if (isProgress && this.channel)\n            return;\n        let lines = this.messagesMap.get(name) || [];\n        this.messagesMap.set(name, lines.concat(msg.trim().split(/\\r?\\n/)));\n        if (this.channel)\n            this.channel.appendLine(`[${name}] ${msg}`);\n    }\n    startProgress(names) {\n        for (let name of names) {\n            this.statMap.set(name, State.Progressing);\n        }\n    }\n    finishProgress(name, succeed = true) {\n        if (this.channel) {\n            if (succeed) {\n                this.channel.appendLine(`[${name}] install succeed!`);\n            }\n            else {\n                this.channel.appendLine(`[${name}] install failed!`);\n            }\n        }\n        this.statMap.set(name, succeed ? State.Success : State.Faild);\n    }\n    get remains() {\n        let count = 0;\n        for (let name of this.names) {\n            let stat = this.statMap.get(name);\n            if (![State.Success, State.Faild].includes(stat)) {\n                count = count + 1;\n            }\n        }\n        return count;\n    }\n    getLines() {\n        let lines = [];\n        for (let name of this.names) {\n            let state = this.statMap.get(name);\n            let processText = '*';\n            switch (state) {\n                case State.Progressing: {\n                    let d = new Date();\n                    let idx = Math.floor(d.getMilliseconds() / 100);\n                    processText = status_1.frames[idx];\n                    break;\n                }\n                case State.Faild:\n                    processText = '';\n                    break;\n                case State.Success:\n                    processText = '';\n                    break;\n            }\n            let msgs = this.messagesMap.get(name) || [];\n            lines.push(`- ${processText} ${name} ${msgs.length ? msgs[msgs.length - 1] : ''}`);\n        }\n        return lines;\n    }\n    getMessages(line) {\n        if (line <= 1)\n            return [];\n        let name = this.names[line - 2];\n        if (!name)\n            return [];\n        return this.messagesMap.get(name);\n    }\n    // draw frame\n    draw(nvim, buffer) {\n        let { remains } = this;\n        let first = remains == 0 ? `${this.isUpdate ? 'Update' : 'Install'} finished` : `Installing, ${remains} remains...`;\n        let lines = [first, '', ...this.getLines()];\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        buffer.setLines(lines, { start: 0, end: -1, strictIndexing: false }, true);\n        if (remains == 0 && this.interval) {\n            clearInterval(this.interval);\n            this.interval = null;\n        }\n        if (process.env.VIM_NODE_RPC) {\n            nvim.command('redraw', true);\n        }\n    }\n    highlight(nvim) {\n        nvim.call('matchadd', ['CocListFgCyan', '^\\\\-\\\\s\\\\zs\\\\*'], true);\n        nvim.call('matchadd', ['CocListFgGreen', '^\\\\-\\\\s\\\\zs'], true);\n        nvim.call('matchadd', ['CocListFgRed', '^\\\\-\\\\s\\\\zs'], true);\n        nvim.call('matchadd', ['CocListFgYellow', '^-.\\\\{3\\\\}\\\\zs\\\\S\\\\+'], true);\n    }\n    async show(nvim) {\n        let { isSync } = this;\n        if (this.channel)\n            return;\n        nvim.pauseNotification();\n        nvim.command(isSync ? 'enew' : 'vs +enew', true);\n        nvim.call('bufnr', ['%'], true);\n        nvim.command('setl buftype=nofile bufhidden=wipe noswapfile nobuflisted wrap undolevels=-1', true);\n        if (!isSync) {\n            nvim.command('nnoremap <silent><nowait><buffer> q :q<CR>', true);\n        }\n        this.highlight(nvim);\n        let res = await nvim.resumeNotification();\n        let bufnr = res && res[1] == null ? res[0][1] : null;\n        if (!bufnr)\n            return;\n        this.bufnr = bufnr;\n        let buffer = nvim.createBuffer(bufnr);\n        this.interval = setInterval(() => {\n            this.draw(nvim, buffer);\n        }, 100);\n    }\n    dispose() {\n        if (this.interval) {\n            clearInterval(this.interval);\n        }\n    }\n}\nexports.default = InstallBuffer;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/installBuffer.ts?");

/***/ }),

/***/ "./src/model/installer.ts":
/*!********************************!*\
  !*** ./src/model/installer.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createInstallerFactory = exports.Installer = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst child_process_1 = __webpack_require__(/*! child_process */ \"child_process\");\nconst readline_1 = tslib_1.__importDefault(__webpack_require__(/*! readline */ \"readline\"));\nconst fs_extra_1 = tslib_1.__importDefault(__webpack_require__(/*! fs-extra */ \"./node_modules/fs-extra/lib/index.js\"));\nconst os_1 = tslib_1.__importDefault(__webpack_require__(/*! os */ \"os\"));\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst rc_1 = tslib_1.__importDefault(__webpack_require__(/*! rc */ \"./node_modules/rc/index.js\"));\nconst semver_1 = tslib_1.__importDefault(__webpack_require__(/*! semver */ \"./node_modules/semver/index.js\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst download_1 = tslib_1.__importDefault(__webpack_require__(/*! ./download */ \"./src/model/download.ts\"));\nconst fetch_1 = tslib_1.__importDefault(__webpack_require__(/*! ./fetch */ \"./src/model/fetch.ts\"));\nconst fs_1 = __webpack_require__(/*! ../util/fs */ \"./src/util/fs.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('model-installer');\nfunction registryUrl(scope = 'coc.nvim') {\n    const result = rc_1.default('npm', { registry: 'https://registry.npmjs.org/' });\n    const registry = result[`${scope}:registry`] || result.config_registry || result.registry;\n    return registry.endsWith('/') ? registry : registry + '/';\n}\nclass Installer extends events_1.EventEmitter {\n    constructor(root, npm, \n    // could be url or name@version or name\n    def) {\n        super();\n        this.root = root;\n        this.npm = npm;\n        this.def = def;\n        if (!fs_extra_1.default.existsSync(root))\n            fs_extra_1.default.mkdirpSync(root);\n        if (/^https?:/.test(def)) {\n            this.url = def;\n        }\n        else {\n            if (def.includes('@')) {\n                let [name, version] = def.split('@', 2);\n                this.name = name;\n                this.version = version;\n            }\n            else {\n                this.name = def;\n            }\n        }\n    }\n    async install() {\n        this.log(`Using npm from: ${this.npm}`);\n        let info = await this.getInfo();\n        logger.info(`Fetched info of ${this.def}`, info);\n        let { name } = info;\n        let required = info['engines.coc'] ? info['engines.coc'].replace(/^\\^/, '>=') : '';\n        if (required && !semver_1.default.satisfies(workspace_1.default.version, required)) {\n            throw new Error(`${name} ${info.version} requires coc.nvim >= ${required}, please update coc.nvim.`);\n        }\n        await this.doInstall(info);\n        return name;\n    }\n    async update(url) {\n        this.url = url;\n        let folder = path_1.default.join(this.root, this.name);\n        let stat = await fs_extra_1.default.lstat(folder);\n        if (stat.isSymbolicLink()) {\n            this.log(`Skipped update for symbol link`);\n            return;\n        }\n        let version;\n        if (fs_extra_1.default.existsSync(path_1.default.join(folder, 'package.json'))) {\n            let content = await fs_extra_1.default.readFile(path_1.default.join(folder, 'package.json'), 'utf8');\n            version = JSON.parse(content).version;\n        }\n        this.log(`Using npm from: ${this.npm}`);\n        let info = await this.getInfo();\n        if (version && info.version && semver_1.default.gte(version, info.version)) {\n            this.log(`Current version ${version} is up to date.`);\n            return;\n        }\n        let required = info['engines.coc'] ? info['engines.coc'].replace(/^\\^/, '>=') : '';\n        if (required && !semver_1.default.satisfies(workspace_1.default.version, required)) {\n            throw new Error(`${info.version} requires coc.nvim ${required}, please update coc.nvim.`);\n        }\n        await this.doInstall(info);\n        let jsonFile = path_1.default.join(this.root, info.name, 'package.json');\n        if (fs_extra_1.default.existsSync(jsonFile)) {\n            this.log(`Updated to v${info.version}`);\n            return path_1.default.dirname(jsonFile);\n        }\n        else {\n            throw new Error(`Package.json not found: ${jsonFile}`);\n        }\n    }\n    async doInstall(info) {\n        let folder = path_1.default.join(this.root, info.name);\n        if (fs_extra_1.default.existsSync(folder)) {\n            let stat = fs_extra_1.default.statSync(folder);\n            if (!stat.isDirectory()) {\n                this.log(`${folder} is not directory skipped install`);\n                return;\n            }\n        }\n        let tmpFolder = await fs_extra_1.default.mkdtemp(path_1.default.join(os_1.default.tmpdir(), `${info.name}-`));\n        let url = info['dist.tarball'];\n        this.log(`Downloading from ${url}`);\n        await download_1.default(url, { dest: tmpFolder, onProgress: p => this.log(`Download progress ${p}%`, true), extract: 'untar' });\n        this.log(`Extension download at ${tmpFolder}`);\n        let content = await fs_extra_1.default.readFile(path_1.default.join(tmpFolder, 'package.json'), 'utf8');\n        let { dependencies } = JSON.parse(content);\n        if (dependencies && Object.keys(dependencies).length) {\n            let p = new Promise((resolve, reject) => {\n                let args = ['install', '--ignore-scripts', '--no-lockfile', '--production'];\n                if (url.startsWith('https://github.com')) {\n                    args = ['install'];\n                }\n                if (this.npm.endsWith('npm') && !this.npm.endsWith('pnpm')) {\n                    args.push('--legacy-peer-deps');\n                }\n                if (this.npm.endsWith('yarn')) {\n                    args.push('--ignore-engines');\n                }\n                this.log(`Installing dependencies by: ${this.npm} ${args.join(' ')}.`);\n                const child = child_process_1.spawn(this.npm, args, {\n                    cwd: tmpFolder,\n                });\n                const rl = readline_1.default.createInterface({\n                    input: child.stdout\n                });\n                rl.on('line', line => {\n                    this.log(`[npm] ${line}`, true);\n                });\n                child.stderr.setEncoding('utf8');\n                child.stdout.setEncoding('utf8');\n                child.on('error', reject);\n                let err = '';\n                child.stderr.on('data', data => {\n                    err += data;\n                });\n                child.on('exit', code => {\n                    if (code) {\n                        if (err)\n                            this.log(err);\n                        reject(new Error(`${this.npm} install exited with ${code}`));\n                        return;\n                    }\n                    resolve();\n                });\n            });\n            await p;\n        }\n        let jsonFile = path_1.default.resolve(this.root, global.hasOwnProperty('__TEST__') ? '' : '..', 'package.json');\n        let obj = JSON.parse(fs_extra_1.default.readFileSync(jsonFile, 'utf8'));\n        obj.dependencies = obj.dependencies || {};\n        if (this.url) {\n            obj.dependencies[info.name] = this.url;\n        }\n        else {\n            obj.dependencies[info.name] = '>=' + info.version;\n        }\n        const sortedObj = { dependencies: {} };\n        Object.keys(obj.dependencies).sort().forEach(k => {\n            sortedObj.dependencies[k] = obj.dependencies[k];\n        });\n        let stat = await fs_1.statAsync(folder);\n        if (stat) {\n            if (stat.isDirectory()) {\n                fs_extra_1.default.removeSync(folder);\n            }\n            else {\n                fs_extra_1.default.unlinkSync(folder);\n            }\n        }\n        await fs_extra_1.default.move(tmpFolder, folder, { overwrite: true });\n        await fs_extra_1.default.writeFile(jsonFile, JSON.stringify(sortedObj, null, 2), { encoding: 'utf8' });\n        this.log(`Update package.json at ${jsonFile}`);\n        this.log(`Installed extension ${this.name}@${info.version} at ${folder}`);\n    }\n    async getInfo() {\n        if (this.url)\n            return await this.getInfoFromUri();\n        let registry = registryUrl();\n        this.log(`Get info from ${registry}`);\n        let res = await fetch_1.default(registry + this.name, { timeout: 10000 });\n        if (!this.version)\n            this.version = res['dist-tags']['latest'];\n        let obj = res['versions'][this.version];\n        if (!obj)\n            throw new Error(`${this.def} doesn't exists in ${registry}.`);\n        let requiredVersion = obj['engines'] && obj['engines']['coc'];\n        if (!requiredVersion) {\n            throw new Error(`${this.def} is not valid coc extension, \"engines\" field with coc property required.`);\n        }\n        return {\n            'dist.tarball': obj['dist']['tarball'],\n            'engines.coc': requiredVersion,\n            version: obj['version'],\n            name: res.name\n        };\n    }\n    async getInfoFromUri() {\n        let { url } = this;\n        if (!url.includes('github.com')) {\n            throw new Error(`\"${url}\" is not supported, coc.nvim support github.com only`);\n        }\n        url = url.replace(/\\/$/, '');\n        let fileUrl = url.replace('github.com', 'raw.githubusercontent.com') + '/master/package.json';\n        this.log(`Get info from ${fileUrl}`);\n        let content = await fetch_1.default(fileUrl, { timeout: 10000 });\n        let obj = typeof content == 'string' ? JSON.parse(content) : content;\n        this.name = obj.name;\n        return {\n            'dist.tarball': `${url}/archive/master.tar.gz`,\n            'engines.coc': obj['engines'] ? obj['engines']['coc'] : null,\n            name: obj.name,\n            version: obj.version\n        };\n    }\n    log(msg, isProgress = false) {\n        logger.info(msg);\n        this.emit('message', msg, isProgress);\n    }\n}\nexports.Installer = Installer;\nfunction createInstallerFactory(npm, root) {\n    return (def) => new Installer(root, npm, def);\n}\nexports.createInstallerFactory = createInstallerFactory;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/installer.ts?");

/***/ }),

/***/ "./src/model/memos.ts":
/*!****************************!*\
  !*** ./src/model/memos.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst fs_1 = tslib_1.__importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst object_1 = __webpack_require__(/*! ../util/object */ \"./src/util/object.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('model-memos');\nclass Memos {\n    constructor(filepath) {\n        this.filepath = filepath;\n        if (!fs_1.default.existsSync(filepath)) {\n            fs_1.default.writeFileSync(filepath, '{}', 'utf8');\n        }\n    }\n    fetchContent(id, key) {\n        try {\n            let content = fs_1.default.readFileSync(this.filepath, 'utf8');\n            let res = JSON.parse(content);\n            let obj = res[id];\n            if (!obj)\n                return undefined;\n            return obj[key];\n        }\n        catch (e) {\n            return undefined;\n        }\n    }\n    async update(id, key, value) {\n        let { filepath } = this;\n        try {\n            let content = fs_1.default.readFileSync(filepath, 'utf8');\n            let current = content ? JSON.parse(content) : {};\n            current[id] = current[id] || {};\n            if (value !== undefined) {\n                current[id][key] = object_1.deepClone(value);\n            }\n            else {\n                delete current[id][key];\n            }\n            content = JSON.stringify(current, null, 2);\n            fs_1.default.writeFileSync(filepath, content, 'utf8');\n        }\n        catch (e) {\n            logger.error(`Error on update memos:`, e);\n        }\n    }\n    createMemento(id) {\n        return {\n            get: (key, defaultValue) => {\n                let res = this.fetchContent(id, key);\n                return res === undefined ? defaultValue : res;\n            },\n            update: async (key, value) => {\n                await this.update(id, key, value);\n            }\n        };\n    }\n}\nexports.default = Memos;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/memos.ts?");

/***/ }),

/***/ "./src/model/menu.ts":
/*!***************************!*\
  !*** ./src/model/menu.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst popup_1 = tslib_1.__importDefault(__webpack_require__(/*! ./popup */ \"./src/model/popup.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('model-menu');\n/**\n * Select single item from menu at cursor position.\n */\nclass Menu {\n    constructor(nvim, config, token) {\n        this.nvim = nvim;\n        this.config = config;\n        this.currIndex = 0;\n        this.disposables = [];\n        this.keyMappings = new Map();\n        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();\n        this.onDidClose = this._onDidClose.event;\n        this.total = config.items.length;\n        if (token) {\n            token.onCancellationRequested(() => {\n                var _a;\n                (_a = this.win) === null || _a === void 0 ? void 0 : _a.close();\n            });\n        }\n        this.disposables.push(this._onDidClose);\n        this.addKeymappings();\n    }\n    attachEvents() {\n        events_1.default.on('InputChar', this.onInputChar.bind(this), null, this.disposables);\n        events_1.default.on('BufWinLeave', bufnr => {\n            if (bufnr == this.bufnr) {\n                this._onDidClose.fire(-1);\n                this.bufnr = undefined;\n                this.win = undefined;\n                this.dispose();\n            }\n        }, null, this.disposables);\n    }\n    addKeymappings() {\n        let { nvim } = this;\n        this.addKeys(['<esc>', '<C-c>'], () => {\n            this._onDidClose.fire(-1);\n            this.dispose();\n        });\n        this.addKeys(['\\r', '<cr>'], () => {\n            this._onDidClose.fire(this.currIndex);\n            this.dispose();\n        });\n        let setCursorIndex = idx => {\n            var _a;\n            if (!this.win)\n                return;\n            nvim.pauseNotification();\n            this.setCursor(idx);\n            (_a = this.win) === null || _a === void 0 ? void 0 : _a.refreshScrollbar();\n            nvim.command('redraw', true);\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            nvim.resumeNotification(false, true);\n        };\n        this.addKeys('<C-f>', async () => {\n            var _a;\n            await ((_a = this.win) === null || _a === void 0 ? void 0 : _a.scrollForward());\n        });\n        this.addKeys('<C-b>', async () => {\n            var _a;\n            await ((_a = this.win) === null || _a === void 0 ? void 0 : _a.scrollBackward());\n        });\n        this.addKeys(['j', '<down>', '<tab>', '<C-n>'], () => {\n            // next\n            let idx = this.currIndex == this.total - 1 ? 0 : this.currIndex + 1;\n            setCursorIndex(idx);\n        });\n        this.addKeys(['k', '<up>', '<s-tab>', '<C-p>'], () => {\n            // previous\n            let idx = this.currIndex == 0 ? this.total - 1 : this.currIndex - 1;\n            setCursorIndex(idx);\n        });\n        this.addKeys(['g'], () => {\n            setCursorIndex(0);\n        });\n        this.addKeys(['G'], () => {\n            setCursorIndex(this.total - 1);\n        });\n        let timer;\n        let firstNumber;\n        this.addKeys(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'], character => {\n            if (timer)\n                clearTimeout(timer);\n            let n = parseInt(character, 10);\n            if (isNaN(n) || n > this.total)\n                return;\n            if (firstNumber == null && n == 0)\n                return;\n            if (firstNumber) {\n                let count = firstNumber * 10 + n;\n                firstNumber = undefined;\n                this._onDidClose.fire(count - 1);\n                this.dispose();\n                return;\n            }\n            if (this.total < 10 || n * 10 > this.total) {\n                this._onDidClose.fire(n - 1);\n                this.dispose();\n                return;\n            }\n            timer = setTimeout(async () => {\n                this._onDidClose.fire(n - 1);\n                this.dispose();\n            }, 200);\n            firstNumber = n;\n        });\n    }\n    async show(preferences = {}) {\n        let { nvim } = this;\n        let { title, items } = this.config;\n        let opts = {};\n        if (title)\n            opts.title = title;\n        if (preferences.maxHeight)\n            opts.maxHeight = preferences.maxHeight;\n        if (preferences.maxWidth)\n            opts.maxWidth = preferences.maxWidth;\n        if (preferences.floatHighlight)\n            opts.highlight = preferences.floatHighlight;\n        if (preferences.floatBorderHighlight)\n            opts.borderhighlight = [preferences.floatBorderHighlight];\n        let lines = items.map((v, i) => {\n            if (i < 99)\n                return `${i + 1}. ${v}`;\n            return v;\n        });\n        if (preferences.confirmKey && preferences.confirmKey != '<cr>') {\n            this.addKeys(preferences.confirmKey, () => {\n                this._onDidClose.fire(this.currIndex);\n                this.dispose();\n            });\n        }\n        let res = await nvim.call('coc#float#create_menu', [lines, opts]);\n        this.win = new popup_1.default(nvim, res[0], res[1]);\n        this.bufnr = res[1];\n        this.attachEvents();\n        nvim.call('coc#prompt#start_prompt', ['menu'], true);\n        return res[0];\n    }\n    get buffer() {\n        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : undefined;\n    }\n    dispose() {\n        var _a;\n        util_1.disposeAll(this.disposables);\n        this.disposables = [];\n        this.nvim.call('coc#prompt#stop_prompt', ['menu'], true);\n        (_a = this.win) === null || _a === void 0 ? void 0 : _a.close();\n        this.win = undefined;\n    }\n    async onInputChar(session, character) {\n        if (session != 'menu' || !this.win)\n            return;\n        let fn = this.keyMappings.get(character);\n        if (fn) {\n            await Promise.resolve(fn(character));\n        }\n        else {\n            logger.warn(`Ignored key press: ${character}`);\n        }\n    }\n    setCursor(index) {\n        if (!this.win)\n            return;\n        this.currIndex = index;\n        this.win.setCursor(index);\n    }\n    addKeys(keys, fn) {\n        if (Array.isArray(keys)) {\n            for (let key of keys) {\n                this.keyMappings.set(key, fn);\n            }\n        }\n        else {\n            this.keyMappings.set(keys, fn);\n        }\n    }\n}\nexports.default = Menu;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/menu.ts?");

/***/ }),

/***/ "./src/model/mru.ts":
/*!**************************!*\
  !*** ./src/model/mru.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst fs_extra_1 = tslib_1.__importDefault(__webpack_require__(/*! fs-extra */ \"./node_modules/fs-extra/lib/index.js\"));\n/**\n * Mru - manage string items as lines in mru file.\n */\nclass Mru {\n    /**\n     * @param {string} name unique name\n     * @param {string} base? optional directory name, default to config root of coc.nvim\n     */\n    constructor(name, base) {\n        this.name = name;\n        this.file = path_1.default.join(base || process.env.COC_DATA_HOME, name);\n    }\n    /**\n     * Load iems from mru file\n     */\n    async load() {\n        let dir = path_1.default.dirname(this.file);\n        try {\n            fs_extra_1.default.mkdirpSync(dir);\n            if (!fs_extra_1.default.existsSync(this.file)) {\n                fs_extra_1.default.writeFileSync(this.file, '', 'utf8');\n            }\n            let content = await fs_extra_1.default.readFile(this.file, 'utf8');\n            content = content.trim();\n            return content.length ? content.trim().split('\\n') : [];\n        }\n        catch (e) {\n            return [];\n        }\n    }\n    /**\n     * Add item to mru file.\n     */\n    async add(item) {\n        let items = await this.load();\n        let idx = items.indexOf(item);\n        if (idx !== -1)\n            items.splice(idx, 1);\n        items.unshift(item);\n        fs_extra_1.default.writeFileSync(this.file, items.join('\\n'), 'utf8');\n    }\n    /**\n     * Remove item from mru file.\n     */\n    async remove(item) {\n        let items = await this.load();\n        let idx = items.indexOf(item);\n        if (idx !== -1) {\n            items.splice(idx, 1);\n            fs_extra_1.default.writeFileSync(this.file, items.join('\\n'), 'utf8');\n        }\n    }\n    /**\n     * Remove the data file.\n     */\n    async clean() {\n        try {\n            await fs_extra_1.default.unlink(this.file);\n        }\n        catch (e) {\n            // noop\n        }\n    }\n}\nexports.default = Mru;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/mru.ts?");

/***/ }),

/***/ "./src/model/notification.ts":
/*!***********************************!*\
  !*** ./src/model/notification.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst isVim = process.env.VIM_NODE_RPC == '1';\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('model-notification');\nclass Notification {\n    constructor(nvim, config, attachEvents = true) {\n        this.nvim = nvim;\n        this.config = config;\n        this.disposables = [];\n        this._disposed = false;\n        if (attachEvents) {\n            events_1.default.on('BufWinLeave', bufnr => {\n                if (bufnr == this.bufnr) {\n                    this.dispose();\n                    if (config.callback)\n                        config.callback(-1);\n                }\n            }, null, this.disposables);\n            events_1.default.on('FloatBtnClick', (bufnr, idx) => {\n                if (bufnr == this.bufnr) {\n                    this.dispose();\n                    let btns = config === null || config === void 0 ? void 0 : config.buttons.filter(o => o.disabled != true);\n                    if (config.callback)\n                        config.callback(btns[idx].index);\n                }\n            }, null, this.disposables);\n        }\n    }\n    get lines() {\n        return this.config.content.split(/\\r?\\n/);\n    }\n    async show(preferences) {\n        let { nvim } = this;\n        let { title, close, timeout, buttons, borderhighlight } = this.config;\n        let opts = Object.assign({}, preferences);\n        opts.close = close ? 1 : 0;\n        if (title)\n            opts.title = title;\n        if (borderhighlight)\n            opts.borderhighlight = borderhighlight;\n        if (buttons)\n            opts.buttons = buttons.filter(o => !o.disabled).map(o => o.text);\n        if (timeout)\n            opts.timeout = timeout;\n        let res = await nvim.call('coc#float#create_notification', [this.lines, opts]);\n        if (!res)\n            return false;\n        if (this._disposed) {\n            this.nvim.call('coc#float#close', [res[0]], true);\n            if (isVim)\n                this.nvim.command('redraw', true);\n        }\n        else {\n            this._winid = res[0];\n            this.bufnr = res[1];\n        }\n        return this._winid != undefined;\n    }\n    get winid() {\n        return this._winid;\n    }\n    dispose() {\n        if (this._disposed)\n            return;\n        this._disposed = true;\n        let { winid } = this;\n        if (winid) {\n            this.nvim.call('coc#float#close', [winid], true);\n            if (isVim)\n                this.nvim.command('redraw', true);\n        }\n        this.bufnr = undefined;\n        this._winid = undefined;\n        util_1.disposeAll(this.disposables);\n        this.disposables = [];\n    }\n}\nexports.default = Notification;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/notification.ts?");

/***/ }),

/***/ "./src/model/outputChannel.ts":
/*!************************************!*\
  !*** ./src/model/outputChannel.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('outpubChannel');\nclass BufferChannel {\n    constructor(name, nvim) {\n        this.name = name;\n        this.nvim = nvim;\n        this._disposed = false;\n        this.lines = [''];\n        this.disposables = [];\n    }\n    get content() {\n        return this.lines.join('\\n');\n    }\n    _append(value) {\n        let { nvim } = this;\n        let idx = this.lines.length - 1;\n        let newlines = value.split('\\n');\n        let lastline = this.lines[idx] + newlines[0];\n        this.lines[idx] = lastline;\n        let append = newlines.slice(1);\n        this.lines = this.lines.concat(append);\n        nvim.pauseNotification();\n        nvim.call('setbufline', [this.bufname, '$', lastline], true);\n        if (append.length) {\n            nvim.call('appendbufline', [this.bufname, '$', append], true);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        nvim.resumeNotification(false, true);\n    }\n    append(value) {\n        if (!this.validate())\n            return;\n        this._append(value);\n    }\n    appendLine(value) {\n        if (!this.validate())\n            return;\n        this._append(value + '\\n');\n    }\n    clear(keep) {\n        if (!this.validate())\n            return;\n        let { nvim } = this;\n        this.lines = keep ? this.lines.slice(-keep) : [];\n        nvim.pauseNotification();\n        nvim.call('deletebufline', [this.bufname, 1, '$'], true);\n        if (this.lines.length) {\n            nvim.call('appendbufline', [this.bufname, '$', this.lines], true);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        nvim.resumeNotification(false, true);\n    }\n    hide() {\n        this.nvim.command(`exe 'silent! bd! '.fnameescape('${this.bufname}')`, true);\n    }\n    get bufname() {\n        return `output:///${this.name}`;\n    }\n    show(preserveFocus) {\n        let { nvim } = this;\n        nvim.pauseNotification();\n        nvim.command(`exe 'vsplit '.fnameescape('${this.bufname}')`, true);\n        if (preserveFocus) {\n            nvim.command('wincmd p', true);\n        }\n        nvim.command('redraw', true);\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        nvim.resumeNotification(false, true);\n    }\n    validate() {\n        if (this._disposed)\n            return false;\n        return true;\n    }\n    dispose() {\n        if (this._disposed)\n            return;\n        this._disposed = true;\n        this.hide();\n        this.lines = [];\n        util_1.disposeAll(this.disposables);\n    }\n}\nexports.default = BufferChannel;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/outputChannel.ts?");

/***/ }),

/***/ "./src/model/picker.ts":
/*!*****************************!*\
  !*** ./src/model/picker.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst string_1 = __webpack_require__(/*! ../util/string */ \"./src/util/string.ts\");\nconst popup_1 = tslib_1.__importDefault(__webpack_require__(/*! ./popup */ \"./src/model/popup.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('model-dialog');\nconst isVim = process.env.VIM_NODE_RPC == '1';\n/**\n * Pick multiple items from dialog\n */\nclass Picker {\n    constructor(nvim, config, token) {\n        this.nvim = nvim;\n        this.config = config;\n        this.picked = new Set();\n        this.currIndex = 0;\n        this.disposables = [];\n        this.keyMappings = new Map();\n        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();\n        this.onDidClose = this._onDidClose.event;\n        for (let i = 0; i < config.items.length; i++) {\n            let item = config.items[i];\n            if (item.picked)\n                this.picked.add(i);\n        }\n        this.total = config.items.length;\n        if (token) {\n            token.onCancellationRequested(() => {\n                var _a;\n                (_a = this.win) === null || _a === void 0 ? void 0 : _a.close();\n            });\n        }\n        this.disposables.push(this._onDidClose);\n        this.addKeymappings();\n    }\n    attachEvents() {\n        events_1.default.on('InputChar', this.onInputChar.bind(this), null, this.disposables);\n        events_1.default.on('BufWinLeave', bufnr => {\n            if (bufnr == this.bufnr) {\n                this._onDidClose.fire(undefined);\n                this.bufnr = undefined;\n                this.win = undefined;\n                this.dispose();\n            }\n        }, null, this.disposables);\n        events_1.default.on('FloatBtnClick', (bufnr, idx) => {\n            if (bufnr == this.bufnr) {\n                if (idx == 0) {\n                    let selected = Array.from(this.picked);\n                    this._onDidClose.fire(selected.length ? selected : undefined);\n                }\n                else {\n                    this._onDidClose.fire(undefined);\n                }\n                this.dispose();\n            }\n        }, null, this.disposables);\n    }\n    addKeymappings() {\n        let { nvim } = this;\n        const toggleSelect = idx => {\n            if (this.picked.has(idx)) {\n                this.picked.delete(idx);\n            }\n            else {\n                this.picked.add(idx);\n            }\n        };\n        this.addKeys('<LeftRelease>', async () => {\n            // not work on vim\n            if (isVim || !this.win)\n                return;\n            let [winid, lnum, col] = await nvim.eval('[v:mouse_winid,v:mouse_lnum,v:mouse_col]');\n            // can't simulate vvar.\n            if (global.hasOwnProperty('__TEST__')) {\n                let res = await nvim.getVar('mouse_position');\n                winid = res[0];\n                lnum = res[1];\n                col = res[2];\n            }\n            nvim.pauseNotification();\n            if (winid == this.win.winid) {\n                if (col <= 3) {\n                    toggleSelect(lnum - 1);\n                    this.changeLine(lnum - 1);\n                }\n                else {\n                    this.setCursor(lnum - 1);\n                }\n            }\n            nvim.call('win_gotoid', [winid], true);\n            nvim.call('cursor', [lnum, col], true);\n            nvim.call('coc#float#nvim_float_click', [], true);\n            nvim.command('redraw', true);\n            await nvim.resumeNotification();\n        });\n        this.addKeys(['<esc>', '<C-c>'], () => {\n            this._onDidClose.fire(undefined);\n            this.dispose();\n        });\n        this.addKeys('<cr>', () => {\n            if (this.picked.size == 0) {\n                this._onDidClose.fire(undefined);\n            }\n            else {\n                let selected = Array.from(this.picked);\n                this._onDidClose.fire(selected);\n            }\n            this.dispose();\n        });\n        let setCursorIndex = idx => {\n            nvim.pauseNotification();\n            this.setCursor(idx);\n            this.win.refreshScrollbar();\n            nvim.command('redraw', true);\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            nvim.resumeNotification(false, true);\n        };\n        this.addKeys(['j', '<down>', '<tab>', '<C-n>'], () => {\n            // next\n            let idx = this.currIndex == this.total - 1 ? 0 : this.currIndex + 1;\n            setCursorIndex(idx);\n        });\n        this.addKeys(['k', '<up>', '<s-tab>', '<C-p>'], () => {\n            // previous\n            let idx = this.currIndex == 0 ? this.total - 1 : this.currIndex - 1;\n            setCursorIndex(idx);\n        });\n        this.addKeys(['g'], () => {\n            setCursorIndex(0);\n        });\n        this.addKeys(['G'], () => {\n            setCursorIndex(this.total - 1);\n        });\n        this.addKeys(' ', async () => {\n            let idx = this.currIndex;\n            toggleSelect(idx);\n            nvim.pauseNotification();\n            this.changeLine(idx);\n            if (this.currIndex != this.total - 1) {\n                this.setCursor(this.currIndex + 1);\n            }\n            nvim.command('redraw', true);\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            await nvim.resumeNotification();\n        });\n        this.addKeys('<C-f>', async () => {\n            var _a;\n            await ((_a = this.win) === null || _a === void 0 ? void 0 : _a.scrollForward());\n        });\n        this.addKeys('<C-b>', async () => {\n            var _a;\n            await ((_a = this.win) === null || _a === void 0 ? void 0 : _a.scrollBackward());\n        });\n    }\n    async show(preferences = {}) {\n        let { nvim } = this;\n        let { title, items } = this.config;\n        let opts = { close: 1, cursorline: 1 };\n        if (preferences.maxHeight)\n            opts.maxHeight = preferences.maxHeight;\n        if (preferences.maxWidth)\n            opts.maxWidth = preferences.maxWidth;\n        if (title)\n            opts.title = title;\n        opts.close = 1;\n        opts.cursorline = 1;\n        if (preferences.floatHighlight) {\n            opts.highlight = preferences.floatHighlight;\n        }\n        if (preferences.floatBorderHighlight) {\n            opts.borderhighlight = [preferences.floatBorderHighlight];\n        }\n        if (preferences.pickerButtons) {\n            let shortcut = preferences.pickerButtonShortcut;\n            opts.buttons = ['Submit' + (shortcut ? ' <cr>' : ''), 'Cancel' + (shortcut ? ' <esc>' : '')];\n        }\n        if (preferences.confirmKey && preferences.confirmKey != '<cr>') {\n            this.addKeys(preferences.confirmKey, () => {\n                this._onDidClose.fire(undefined);\n                this.dispose();\n            });\n        }\n        let lines = [];\n        let positions = [];\n        for (let i = 0; i < items.length; i++) {\n            let item = items[i];\n            let line = `[${item.picked ? 'x' : ' '}] ${item.label}`;\n            positions.push([i, string_1.byteLength(line)]);\n            if (item.description)\n                line = line + ` ${item.description}`;\n            lines.push(line);\n        }\n        let res = await nvim.call('coc#float#create_dialog', [lines, opts]);\n        this.win = new popup_1.default(nvim, res[0], res[1]);\n        this.bufnr = res[1];\n        this.attachEvents();\n        let buf = nvim.createBuffer(this.bufnr);\n        nvim.pauseNotification();\n        for (let pos of positions) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            buf.addHighlight({ hlGroup: 'Comment', line: pos[0], srcId: 1, colStart: pos[1], colEnd: -1 });\n        }\n        nvim.command('redraw', true);\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        nvim.resumeNotification(false, true);\n        nvim.call('coc#prompt#start_prompt', ['picker'], true);\n        return res[0];\n    }\n    get buffer() {\n        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : undefined;\n    }\n    dispose() {\n        var _a;\n        util_1.disposeAll(this.disposables);\n        this.disposables = [];\n        this.nvim.call('coc#prompt#stop_prompt', ['picker'], true);\n        (_a = this.win) === null || _a === void 0 ? void 0 : _a.close();\n        this.win = undefined;\n    }\n    async onInputChar(session, character) {\n        if (session != 'picker' || !this.win)\n            return;\n        let fn = this.keyMappings.get(character);\n        if (fn) {\n            await Promise.resolve(fn(character));\n        }\n        else {\n            logger.warn(`Ignored key press: ${character}`);\n        }\n    }\n    changeLine(index) {\n        let { nvim } = this;\n        let item = this.config.items[index];\n        if (!item)\n            return;\n        let line = `[${this.picked.has(index) ? 'x' : ' '}] ${item.label}`;\n        let col = string_1.byteLength(line);\n        if (item.description)\n            line = line + ` ${item.description}`;\n        nvim.call('setbufline', [this.bufnr, index + 1, line], true);\n        if (!isVim) {\n            let buf = nvim.createBuffer(this.bufnr);\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            buf.addHighlight({ hlGroup: 'Comment', line: index, srcId: 1, colStart: col, colEnd: -1 });\n        }\n    }\n    setCursor(index) {\n        if (!this.win)\n            return;\n        this.currIndex = index;\n        this.win.setCursor(index);\n    }\n    addKeys(keys, fn) {\n        if (Array.isArray(keys)) {\n            for (let key of keys) {\n                this.keyMappings.set(key, fn);\n            }\n        }\n        else {\n            this.keyMappings.set(keys, fn);\n        }\n    }\n}\nexports.default = Picker;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/picker.ts?");

/***/ }),

/***/ "./src/model/popup.ts":
/*!****************************!*\
  !*** ./src/model/popup.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst isVim = process.env.VIM_NODE_RPC == '1';\n/**\n * More methods for float window/popup\n */\nclass Popup {\n    constructor(nvim, winid, bufnr) {\n        this.nvim = nvim;\n        this.winid = winid;\n        this.bufnr = bufnr;\n    }\n    get valid() {\n        return this.nvim.call('coc#float#valid', [this.winid]).then(res => {\n            return !!res;\n        });\n    }\n    close() {\n        this.nvim.call('coc#float#close', [this.winid], true);\n    }\n    refreshScrollbar() {\n        if (!isVim)\n            this.nvim.call('coc#float#nvim_scrollbar', [this.winid], true);\n    }\n    execute(cmd) {\n        this.nvim.call('coc#float#execute', [this.winid, cmd], true);\n    }\n    click(lnum, col) {\n        let { nvim } = this;\n        nvim.call('win_gotoid', [this.winid], true);\n        nvim.call('cursor', [lnum, col], true);\n        nvim.call('coc#float#nvim_float_click', [], true);\n    }\n    /**\n     * Simple scroll method, not consider wrapped lines.\n     */\n    async scrollForward() {\n        let { nvim, bufnr, winid } = this;\n        let buf = nvim.createBuffer(bufnr);\n        let total = await buf.length;\n        let botline;\n        if (!isVim) {\n            let infos = await nvim.call('getwininfo', [winid]);\n            if (!infos || !infos.length)\n                return;\n            botline = infos[0].botline;\n        }\n        else {\n            botline = await nvim.eval(`get(popup_getpos(${winid}), 'lastline', 0)`);\n        }\n        if (botline >= total || botline == 0)\n            return;\n        nvim.pauseNotification();\n        this.setCursor(botline - 1);\n        this.execute(`normal! ${botline}Gzt`);\n        this.refreshScrollbar();\n        nvim.command('redraw', true);\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        nvim.resumeNotification(false, true);\n    }\n    /**\n     * Simple scroll method, not consider wrapped lines.\n     */\n    async scrollBackward() {\n        let { nvim, winid } = this;\n        let topline;\n        if (!isVim) {\n            let infos = await nvim.call('getwininfo', [winid]);\n            if (!infos || !infos.length)\n                return;\n            topline = infos[0].topline;\n        }\n        else {\n            topline = await nvim.eval(`get(popup_getpos(${winid}), 'firstline', 0)`);\n        }\n        if (topline == 1)\n            return;\n        nvim.pauseNotification();\n        this.setCursor(topline - 1);\n        this.execute(`normal! ${topline}Gzb`);\n        this.refreshScrollbar();\n        nvim.command('redraw', true);\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        nvim.resumeNotification(false, true);\n    }\n    /**\n     * Move cursor and highlight.\n     */\n    setCursor(index) {\n        let { nvim, bufnr, winid } = this;\n        if (isVim) {\n            nvim.call('win_execute', [winid, `exe ${index + 1}`], true);\n        }\n        else {\n            let win = nvim.createWindow(winid);\n            win.notify('nvim_win_set_cursor', [[index + 1, 0]]);\n            nvim.command(`sign unplace 6 buffer=${bufnr}`, true);\n            nvim.command(`sign place 6 line=${index + 1} name=CocCurrentLine buffer=${bufnr}`, true);\n        }\n    }\n}\nexports.default = Popup;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/popup.ts?");

/***/ }),

/***/ "./src/model/progress.ts":
/*!*******************************!*\
  !*** ./src/model/progress.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst notification_1 = tslib_1.__importDefault(__webpack_require__(/*! ./notification */ \"./src/model/notification.ts\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nclass ProgressNotification extends notification_1.default {\n    constructor(nvim, option) {\n        super(nvim, {\n            content: '\\n',\n            close: option.cancellable == true,\n            title: option.title\n        }, false);\n        this.option = option;\n        events_1.default.on('BufWinLeave', bufnr => {\n            if (bufnr == this.bufnr) {\n                if (this.tokenSource) {\n                    this.tokenSource.cancel();\n                }\n                this.dispose();\n            }\n        }, null, this.disposables);\n    }\n    async show(preferences) {\n        let { task } = this.option;\n        let tokenSource = this.tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n        this.disposables.push(tokenSource);\n        let total = 0;\n        let res = await new Promise((resolve, reject) => {\n            tokenSource.token.onCancellationRequested(() => {\n                resolve(undefined);\n            });\n            super.show(Object.assign({ minWidth: preferences.minProgressWidth || 30, progress: 1 }, preferences)).then(shown => {\n                if (!shown)\n                    reject(new Error('Failed to create float window'));\n            }).catch(reject);\n            task({\n                report: p => {\n                    if (!this.bufnr)\n                        return;\n                    let text = '';\n                    if (p.message)\n                        text += p.message.replace(/\\r?\\n/g, ' ');\n                    if (p.increment) {\n                        total += p.increment;\n                        text = text + (text.length ? ` ${total}%` : `${total}%`);\n                    }\n                    this.nvim.call('setbufline', [this.bufnr, 2, text], true);\n                }\n            }, tokenSource.token).then(res => {\n                if (this._disposed)\n                    return;\n                setTimeout(() => {\n                    this.dispose();\n                }, 100);\n                resolve(res);\n            }, err => {\n                if (this._disposed)\n                    return;\n                this.dispose();\n                if (err instanceof Error) {\n                    reject(err);\n                }\n                else {\n                    resolve(undefined);\n                }\n            });\n        });\n        return res;\n    }\n    dispose() {\n        super.dispose();\n        this.tokenSource = undefined;\n    }\n}\nexports.default = ProgressNotification;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/progress.ts?");

/***/ }),

/***/ "./src/model/resolver.ts":
/*!*******************************!*\
  !*** ./src/model/resolver.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\nconst fs_1 = __webpack_require__(/*! ../util/fs */ \"./src/util/fs.ts\");\nconst decorator_1 = __webpack_require__(/*! ../util/decorator */ \"./src/util/decorator.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('model-resolver');\nclass Resolver {\n    get nodeFolder() {\n        if (!util_1.executable('npm'))\n            return Promise.resolve('');\n        return util_1.runCommand('npm --loglevel silent root -g', {}, 3000).then(root => root.trim());\n    }\n    get yarnFolder() {\n        if (!util_1.executable('yarnpkg'))\n            return Promise.resolve('');\n        return util_1.runCommand('yarnpkg global dir', {}, 3000).then(root => path_1.default.join(root.trim(), 'node_modules'));\n    }\n    async resolveModule(mod) {\n        let nodeFolder = await this.nodeFolder;\n        let yarnFolder = await this.yarnFolder;\n        if (yarnFolder) {\n            let s = await fs_1.statAsync(path_1.default.join(yarnFolder, mod, 'package.json'));\n            if (s && s.isFile())\n                return path_1.default.join(yarnFolder, mod);\n        }\n        if (nodeFolder) {\n            let s = await fs_1.statAsync(path_1.default.join(nodeFolder, mod, 'package.json'));\n            if (s && s.isFile())\n                return path_1.default.join(nodeFolder, mod);\n        }\n        return null;\n    }\n}\ntslib_1.__decorate([\n    decorator_1.memorize\n], Resolver.prototype, \"nodeFolder\", null);\ntslib_1.__decorate([\n    decorator_1.memorize\n], Resolver.prototype, \"yarnFolder\", null);\nexports.default = Resolver;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/resolver.ts?");

/***/ }),

/***/ "./src/model/source-vim.ts":
/*!*********************************!*\
  !*** ./src/model/source-vim.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst fuzzy_1 = __webpack_require__(/*! ../util/fuzzy */ \"./src/util/fuzzy.ts\");\nconst string_1 = __webpack_require__(/*! ../util/string */ \"./src/util/string.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst source_1 = tslib_1.__importDefault(__webpack_require__(/*! ./source */ \"./src/model/source.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('model-source-vim');\nclass VimSource extends source_1.default {\n    async callOptinalFunc(fname, args) {\n        let exists = this.optionalFns.includes(fname);\n        if (!exists)\n            return null;\n        let name = `coc#source#${this.name}#${fname}`;\n        let res;\n        try {\n            res = await this.nvim.call(name, args);\n        }\n        catch (e) {\n            window_1.default.showMessage(`Vim error from source ${this.name}: ${e.message}`, 'error');\n            return null;\n        }\n        return res;\n    }\n    async shouldComplete(opt) {\n        let shouldRun = await super.shouldComplete(opt);\n        if (!shouldRun)\n            return false;\n        if (!this.optionalFns.includes('should_complete'))\n            return true;\n        let res = await this.callOptinalFunc('should_complete', [opt]);\n        return !!res;\n    }\n    async refresh() {\n        await this.callOptinalFunc('refresh', []);\n    }\n    async onCompleteDone(item, opt) {\n        await super.onCompleteDone(item, opt);\n        if (!this.optionalFns.includes('on_complete'))\n            return;\n        await this.callOptinalFunc('on_complete', [item]);\n    }\n    onEnter(bufnr) {\n        if (!this.optionalFns.includes('on_enter'))\n            return;\n        let doc = workspace_1.default.getDocument(bufnr);\n        if (!doc)\n            return;\n        let { filetypes } = this;\n        if (filetypes && !filetypes.includes(doc.filetype))\n            return;\n        this.callOptinalFunc('on_enter', [{\n                bufnr,\n                uri: doc.uri,\n                languageId: doc.filetype\n            }]).logError();\n    }\n    async doComplete(opt, token) {\n        let { col, input, line, colnr } = opt;\n        let startcol = await this.callOptinalFunc('get_startcol', [opt]);\n        if (token.isCancellationRequested)\n            return;\n        if (startcol) {\n            if (startcol < 0)\n                return null;\n            startcol = Number(startcol);\n            // invalid startcol\n            if (isNaN(startcol) || startcol < 0)\n                startcol = col;\n            if (startcol !== col) {\n                input = string_1.byteSlice(line, startcol, colnr - 1);\n                opt = Object.assign({}, opt, {\n                    col: startcol,\n                    changed: col - startcol,\n                    input\n                });\n            }\n        }\n        let items = await this.nvim.callAsync('coc#util#do_complete', [this.name, opt]);\n        if (!items || items.length == 0 || token.isCancellationRequested)\n            return null;\n        if (this.firstMatch && input.length) {\n            let ch = input[0];\n            items = items.filter(item => {\n                let cfirst = item.filterText ? item.filterText[0] : item.word[0];\n                return fuzzy_1.fuzzyChar(ch, cfirst);\n            });\n        }\n        items = items.map(item => {\n            if (typeof item == 'string') {\n                return { word: item, menu: this.menu, isSnippet: this.isSnippet };\n            }\n            let menu = item.menu ? item.menu + ' ' : '';\n            item.menu = `${menu}${this.menu}`;\n            item.isSnippet = this.isSnippet;\n            delete item.user_data;\n            return item;\n        });\n        let res = { items };\n        if (startcol)\n            res.startcol = startcol;\n        return res;\n    }\n}\nexports.default = VimSource;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/source-vim.ts?");

/***/ }),

/***/ "./src/model/source.ts":
/*!*****************************!*\
  !*** ./src/model/source.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./src/types.ts\");\nconst string_1 = __webpack_require__(/*! ../util/string */ \"./src/util/string.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('model-source');\nclass Source {\n    constructor(option) {\n        this._disabled = false;\n        this.nvim = workspace_1.default.nvim;\n        // readonly properties\n        this.name = option.name;\n        this.filepath = option.filepath || '';\n        this.sourceType = option.sourceType || types_1.SourceType.Native;\n        this.isSnippet = !!option.isSnippet;\n        this.defaults = option;\n    }\n    /**\n     * Priority of source, higher priority makes items lower index.\n     */\n    get priority() {\n        return this.getConfig('priority', 1);\n    }\n    /**\n     * When triggerOnly is true, not trigger completion on keyword character insert.\n     */\n    get triggerOnly() {\n        let triggerOnly = this.defaults['triggerOnly'];\n        if (typeof triggerOnly == 'boolean')\n            return triggerOnly;\n        if (!this.triggerCharacters && !this.triggerPatterns)\n            return false;\n        return Array.isArray(this.triggerPatterns) && this.triggerPatterns.length != 0;\n    }\n    get triggerCharacters() {\n        return this.getConfig('triggerCharacters', null);\n    }\n    // exists opitonnal function names for remote source\n    get optionalFns() {\n        return this.defaults['optionalFns'] || [];\n    }\n    get triggerPatterns() {\n        let patterns = this.getConfig('triggerPatterns', null);\n        if (!patterns || patterns.length == 0)\n            return null;\n        return patterns.map(s => (typeof s === 'string') ? new RegExp(s + '$') : s);\n    }\n    get shortcut() {\n        let shortcut = this.getConfig('shortcut', '');\n        return shortcut ? shortcut : this.name.slice(0, 3);\n    }\n    get enable() {\n        if (this._disabled)\n            return false;\n        return this.getConfig('enable', true);\n    }\n    get filetypes() {\n        return this.getConfig('filetypes', null);\n    }\n    get disableSyntaxes() {\n        return this.getConfig('disableSyntaxes', []);\n    }\n    getConfig(key, defaultValue) {\n        let config = workspace_1.default.getConfiguration(`coc.source.${this.name}`);\n        defaultValue = this.defaults.hasOwnProperty(key) ? this.defaults[key] : defaultValue;\n        return config.get(key, defaultValue);\n    }\n    toggle() {\n        this._disabled = !this._disabled;\n    }\n    get firstMatch() {\n        return this.getConfig('firstMatch', true);\n    }\n    get menu() {\n        let { shortcut } = this;\n        return shortcut ? `[${shortcut}]` : '';\n    }\n    /**\n     * Filter words that too short or doesn't match input\n     */\n    filterWords(words, opt) {\n        let { firstMatch } = this;\n        let res = [];\n        let { input } = opt;\n        let cword = opt.word;\n        if (!input.length)\n            return [];\n        let cFirst = input[0];\n        for (let word of words) {\n            if (!word || word.length < 3)\n                continue;\n            if (firstMatch && cFirst != word[0])\n                continue;\n            if (!firstMatch && cFirst.toLowerCase() != word[0].toLowerCase())\n                continue;\n            if (word == cword || word == input)\n                continue;\n            res.push(word);\n        }\n        return res;\n    }\n    /**\n     * fix start column for new valid characters\n     *\n     * @protected\n     * @param {CompleteOption} opt\n     * @param {string[]} valids - valid charscters\n     * @returns {number}\n     */\n    fixStartcol(opt, valids) {\n        let { col, input, line, bufnr } = opt;\n        let start = string_1.byteSlice(line, 0, col);\n        let document = workspace_1.default.getDocument(bufnr);\n        if (!document)\n            return col;\n        let { chars } = document;\n        for (let i = start.length - 1; i >= 0; i--) {\n            let c = start[i];\n            if (!chars.isKeywordChar(c) && !valids.includes(c)) {\n                break;\n            }\n            input = `${c}${input}`;\n            col = col - 1;\n        }\n        opt.col = col;\n        opt.input = input;\n        return col;\n    }\n    async shouldComplete(opt) {\n        let { disableSyntaxes } = this;\n        if (opt.synname && disableSyntaxes && disableSyntaxes.length) {\n            let synname = (opt.synname || '').toLowerCase();\n            if (disableSyntaxes.findIndex(s => synname.includes(s.toLowerCase())) !== -1) {\n                return false;\n            }\n        }\n        let fn = this.defaults['shouldComplete'];\n        if (fn)\n            return await Promise.resolve(fn.call(this, opt));\n        return true;\n    }\n    async refresh() {\n        let fn = this.defaults['refresh'];\n        if (fn)\n            await Promise.resolve(fn.call(this));\n    }\n    async onCompleteDone(item, opt) {\n        let fn = this.defaults['onCompleteDone'];\n        if (fn)\n            await Promise.resolve(fn.call(this, item, opt));\n    }\n    async doComplete(opt, token) {\n        let fn = this.defaults['doComplete'];\n        if (fn)\n            return await Promise.resolve(fn.call(this, opt, token));\n        return null;\n    }\n}\nexports.default = Source;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/source.ts?");

/***/ }),

/***/ "./src/model/status.ts":
/*!*****************************!*\
  !*** ./src/model/status.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.frames = void 0;\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('model-status');\nexports.frames = ['', '', '', '', '', '', '', '', '', ''];\nclass StatusLine {\n    constructor(nvim) {\n        this.nvim = nvim;\n        this.items = new Map();\n        this.shownIds = new Set();\n        this._text = '';\n        this.interval = setInterval(() => {\n            this.setStatusText().logError();\n        }, 100);\n    }\n    dispose() {\n        clearInterval(this.interval);\n    }\n    createStatusBarItem(priority = 0, isProgress = false) {\n        let uid = uuid_1.v1();\n        let item = {\n            text: '',\n            priority,\n            isProgress,\n            show: () => {\n                this.shownIds.add(uid);\n            },\n            hide: () => {\n                this.shownIds.delete(uid);\n            },\n            dispose: () => {\n                this.shownIds.delete(uid);\n                this.items.delete(uid);\n            }\n        };\n        this.items.set(uid, item);\n        return item;\n    }\n    getText() {\n        if (this.shownIds.size == 0)\n            return '';\n        let d = new Date();\n        let idx = Math.floor(d.getMilliseconds() / 100);\n        let text = '';\n        let items = [];\n        for (let [id, item] of this.items) {\n            if (this.shownIds.has(id)) {\n                items.push(item);\n            }\n        }\n        items.sort((a, b) => a.priority - b.priority);\n        for (let item of items) {\n            if (!item.isProgress) {\n                text = `${text} ${item.text}`;\n            }\n            else {\n                text = `${text} ${exports.frames[idx]} ${item.text}`;\n            }\n        }\n        return text;\n    }\n    async setStatusText() {\n        let text = this.getText();\n        let { nvim } = this;\n        if (text != this._text) {\n            this._text = text;\n            nvim.pauseNotification();\n            this.nvim.setVar('coc_status', text, true);\n            this.nvim.call('coc#util#do_autocmd', ['CocStatusChange'], true);\n            await nvim.resumeNotification(false, true);\n        }\n    }\n}\nexports.default = StatusLine;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/status.ts?");

/***/ }),

/***/ "./src/model/task.ts":
/*!***************************!*\
  !*** ./src/model/task.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"./src/util/index.ts\");\n/**\n * Controls long running task started by vim.\n * Useful to keep the task running after CocRestart.\n *\n * @public\n */\nclass Task {\n    /**\n     * @param {Neovim} nvim\n     * @param {string} id unique id\n     */\n    constructor(nvim, id) {\n        this.nvim = nvim;\n        this.id = id;\n        this.disposables = [];\n        this._onExit = new vscode_languageserver_protocol_1.Emitter();\n        this._onStderr = new vscode_languageserver_protocol_1.Emitter();\n        this._onStdout = new vscode_languageserver_protocol_1.Emitter();\n        this.onExit = this._onExit.event;\n        this.onStdout = this._onStdout.event;\n        this.onStderr = this._onStderr.event;\n        events_1.default.on('TaskExit', (id, code) => {\n            if (id == this.id) {\n                this._onExit.fire(code);\n            }\n        }, null, this.disposables);\n        events_1.default.on('TaskStderr', (id, lines) => {\n            if (id == this.id) {\n                this._onStderr.fire(lines);\n            }\n        }, null, this.disposables);\n        let stdout = [];\n        let timer;\n        events_1.default.on('TaskStdout', (id, lines) => {\n            if (id == this.id) {\n                if (timer)\n                    clearTimeout(timer);\n                stdout.push(...lines);\n                timer = setTimeout(() => {\n                    this._onStdout.fire(stdout);\n                    stdout = [];\n                }, 100);\n            }\n        }, null, this.disposables);\n    }\n    /**\n     * Start task, task will be restarted when already running.\n     *\n     * @param {TaskOptions} opts\n     * @returns {Promise<boolean>}\n     */\n    async start(opts) {\n        let { nvim } = this;\n        return await nvim.call('coc#task#start', [this.id, opts]);\n    }\n    /**\n     * Stop task by SIGTERM or SIGKILL\n     */\n    async stop() {\n        let { nvim } = this;\n        await nvim.call('coc#task#stop', [this.id]);\n    }\n    /**\n     * Check if the task is running.\n     */\n    get running() {\n        let { nvim } = this;\n        return nvim.call('coc#task#running', [this.id]);\n    }\n    /**\n     * Stop task and dispose all events.\n     */\n    dispose() {\n        let { nvim } = this;\n        nvim.call('coc#task#stop', [this.id], true);\n        this._onStdout.dispose();\n        this._onStderr.dispose();\n        this._onExit.dispose();\n        util_1.disposeAll(this.disposables);\n    }\n}\nexports.default = Task;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/task.ts?");

/***/ }),

/***/ "./src/model/terminal.ts":
/*!*******************************!*\
  !*** ./src/model/terminal.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('model-terminal');\nclass TerminalModel {\n    constructor(cmd, args, nvim, _name) {\n        this.cmd = cmd;\n        this.args = args;\n        this.nvim = nvim;\n        this._name = _name;\n        this.pid = 0;\n    }\n    async start(cwd, env) {\n        let { nvim } = this;\n        let cmd = [this.cmd, ...this.args];\n        let [bufnr, pid] = await nvim.call('coc#terminal#start', [cmd, cwd, env || {}]);\n        this.bufnr = bufnr;\n        this.pid = pid;\n    }\n    get name() {\n        return this._name || this.cmd;\n    }\n    get processId() {\n        return Promise.resolve(this.pid);\n    }\n    sendText(text, addNewLine = true) {\n        if (!this.bufnr)\n            return;\n        this.nvim.call('coc#terminal#send', [this.bufnr, text, addNewLine], true);\n    }\n    async show(preserveFocus) {\n        let { bufnr, nvim } = this;\n        if (!bufnr)\n            return;\n        let [loaded, winid, curr] = await nvim.eval(`[bufloaded(${bufnr}),bufwinid(${bufnr}),win_getid()]`);\n        if (!loaded)\n            return false;\n        if (curr == winid)\n            return true;\n        nvim.pauseNotification();\n        if (winid == -1) {\n            nvim.command(`below ${bufnr}sb`, true);\n            nvim.command('resize 8', true);\n            nvim.call('coc#util#do_autocmd', ['CocTerminalOpen'], true);\n        }\n        else {\n            nvim.call('win_gotoid', [winid], true);\n        }\n        nvim.command('normal! G', true);\n        if (preserveFocus) {\n            nvim.command('wincmd p', true);\n        }\n        await nvim.resumeNotification();\n        return true;\n    }\n    async hide() {\n        let { bufnr, nvim } = this;\n        if (!bufnr)\n            return;\n        let winnr = await nvim.call('bufwinnr', bufnr);\n        if (winnr == -1)\n            return;\n        await nvim.command(`${winnr}close!`);\n    }\n    dispose() {\n        let { bufnr, nvim } = this;\n        if (!bufnr)\n            return;\n        nvim.call('coc#terminal#close', [bufnr], true);\n    }\n}\nexports.default = TerminalModel;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/terminal.ts?");

/***/ }),

/***/ "./src/model/textdocument.ts":
/*!***********************************!*\
  !*** ./src/model/textdocument.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LinesTextDoucment = void 0;\nfunction computeLineOffsets(text, isAtLineStart, textOffset = 0) {\n    const result = isAtLineStart ? [textOffset] : [];\n    for (let i = 0; i < text.length; i++) {\n        let ch = text.charCodeAt(i);\n        if (ch === 13 || ch === 10) {\n            if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {\n                i++;\n            }\n            result.push(textOffset + i + 1);\n        }\n    }\n    return result;\n}\n/**\n * Text document that created with readonly lines.\n *\n * Created for save memory since we could reuse readonly lines.\n */\nclass LinesTextDoucment {\n    constructor(uri, languageId, version, lines, eol) {\n        this.uri = uri;\n        this.languageId = languageId;\n        this.version = version;\n        this.lines = lines;\n        this.eol = eol;\n    }\n    get _content() {\n        return this.lines.join('\\n') + (this.eol ? '\\n' : '');\n    }\n    get lineCount() {\n        return this.lines.length + (this.eol ? 1 : 0);\n    }\n    getText(range) {\n        if (range) {\n            const start = this.offsetAt(range.start);\n            const end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    }\n    positionAt(offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        let lineOffsets = this.getLineOffsets();\n        let low = 0;\n        let high = lineOffsets.length;\n        if (high === 0) {\n            return { line: 0, character: offset };\n        }\n        while (low < high) {\n            let mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        let line = low - 1;\n        return { line, character: offset - lineOffsets[line] };\n    }\n    offsetAt(position) {\n        let lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        let lineOffset = lineOffsets[position.line];\n        let nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    }\n    getLineOffsets() {\n        if (this._lineOffsets === undefined) {\n            this._lineOffsets = computeLineOffsets(this._content, true);\n        }\n        return this._lineOffsets;\n    }\n}\nexports.LinesTextDoucment = LinesTextDoucment;\n\n\n//# sourceURL=webpack://coc.nvim/./src/model/textdocument.ts?");

/***/ }),

/***/ "./src/plugin.ts":
/*!***********************!*\
  !*** ./src/plugin.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst fs_1 = tslib_1.__importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst commands_1 = tslib_1.__importDefault(__webpack_require__(/*! ./commands */ \"./src/commands.ts\"));\nconst completion_1 = tslib_1.__importDefault(__webpack_require__(/*! ./completion */ \"./src/completion/index.ts\"));\nconst cursors_1 = tslib_1.__importDefault(__webpack_require__(/*! ./cursors */ \"./src/cursors/index.ts\"));\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./diagnostic/manager */ \"./src/diagnostic/manager.ts\"));\nconst extensions_1 = tslib_1.__importDefault(__webpack_require__(/*! ./extensions */ \"./src/extensions.ts\"));\nconst handler_1 = tslib_1.__importDefault(__webpack_require__(/*! ./handler */ \"./src/handler/index.ts\"));\nconst languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ./languages */ \"./src/languages.ts\"));\nconst manager_2 = tslib_1.__importDefault(__webpack_require__(/*! ./list/manager */ \"./src/list/manager.ts\"));\nconst services_1 = tslib_1.__importDefault(__webpack_require__(/*! ./services */ \"./src/services.ts\"));\nconst manager_3 = tslib_1.__importDefault(__webpack_require__(/*! ./snippets/manager */ \"./src/snippets/manager.ts\"));\nconst sources_1 = tslib_1.__importDefault(__webpack_require__(/*! ./sources */ \"./src/sources.ts\"));\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/types.ts\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/util/index.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ./workspace */ \"./src/workspace.ts\"));\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ./window */ \"./src/window.ts\"));\nconst events_2 = tslib_1.__importDefault(__webpack_require__(/*! ./events */ \"./src/events.ts\"));\nconst logger = __webpack_require__(/*! ./util/logger */ \"./src/util/logger.ts\")('plugin');\nclass Plugin extends events_1.EventEmitter {\n    constructor(nvim) {\n        super();\n        this.nvim = nvim;\n        this._ready = false;\n        this.actions = new Map();\n        Object.defineProperty(workspace_1.default, 'nvim', {\n            get: () => this.nvim\n        });\n        this.cursors = new cursors_1.default(nvim);\n        this.addAction('hasProvider', (id) => this.handler.hasProvider(id));\n        this.addAction('getTagList', async () => await this.handler.getTagList());\n        this.addAction('hasSelected', () => completion_1.default.hasSelected());\n        this.addAction('listNames', () => manager_2.default.names);\n        this.addAction('listDescriptions', () => manager_2.default.descriptions);\n        this.addAction('listLoadItems', async (name) => await manager_2.default.loadItems(name));\n        this.addAction('search', (...args) => this.handler.search(args));\n        this.addAction('cursorsSelect', (bufnr, kind, mode) => this.cursors.select(bufnr, kind, mode));\n        this.addAction('fillDiagnostics', (bufnr) => manager_1.default.setLocationlist(bufnr));\n        this.addAction('getConfig', async (key) => {\n            let document = await workspace_1.default.document;\n            // eslint-disable-next-line id-blacklist\n            return workspace_1.default.getConfiguration(key, document ? document.uri : undefined);\n        });\n        this.addAction('rootPatterns', bufnr => {\n            let doc = workspace_1.default.getDocument(bufnr);\n            if (!doc)\n                return null;\n            return {\n                buffer: workspace_1.default.getRootPatterns(doc, types_1.PatternType.Buffer),\n                server: workspace_1.default.getRootPatterns(doc, types_1.PatternType.LanguageServer),\n                global: workspace_1.default.getRootPatterns(doc, types_1.PatternType.Global)\n            };\n        });\n        this.addAction('installExtensions', async (...list) => {\n            await extensions_1.default.installExtensions(list);\n        });\n        this.addAction('saveRefactor', async (bufnr) => {\n            await this.handler.saveRefactor(bufnr);\n        });\n        this.addAction('updateExtensions', async (sync) => {\n            await extensions_1.default.updateExtensions(sync);\n        });\n        this.addAction('commandList', () => commands_1.default.commandList.map(o => o.id));\n        this.addAction('openList', async (...args) => {\n            await this.ready;\n            await manager_2.default.start(args);\n        });\n        this.addAction('selectSymbolRange', (inner, visualmode, supportedSymbols) => this.handler.selectSymbolRange(inner, visualmode, supportedSymbols));\n        this.addAction('listResume', (name) => manager_2.default.resume(name));\n        this.addAction('listCancel', () => manager_2.default.cancel(true));\n        this.addAction('listPrev', (name) => manager_2.default.previous(name));\n        this.addAction('listNext', (name) => manager_2.default.next(name));\n        this.addAction('listFirst', (name) => manager_2.default.first(name));\n        this.addAction('listLast', (name) => manager_2.default.last(name));\n        this.addAction('sendRequest', (id, method, params) => services_1.default.sendRequest(id, method, params));\n        this.addAction('sendNotification', (id, method, params) => {\n            return services_1.default.sendNotification(id, method, params);\n        });\n        this.addAction('registNotification', (id, method) => {\n            return services_1.default.registNotification(id, method);\n        });\n        this.addAction('doAutocmd', async (id, ...args) => {\n            let autocmd = workspace_1.default.autocmds.get(id);\n            if (autocmd) {\n                try {\n                    await Promise.resolve(autocmd.callback.apply(autocmd.thisArg, args));\n                }\n                catch (e) {\n                    logger.error(`Error on autocmd ${autocmd.event}`, e);\n                    window_1.default.showMessage(`Error on autocmd ${autocmd.event}: ${e.message}`);\n                }\n            }\n        });\n        this.addAction('updateConfig', (section, val) => {\n            workspace_1.default.configurations.updateUserConfig({ [section]: val });\n        });\n        this.addAction('snippetNext', async () => {\n            await manager_3.default.nextPlaceholder();\n            return '';\n        });\n        this.addAction('snippetPrev', async () => {\n            await manager_3.default.previousPlaceholder();\n            return '';\n        });\n        this.addAction('snippetCancel', () => {\n            manager_3.default.cancel();\n        });\n        this.addAction('openLocalConfig', async () => {\n            await window_1.default.openLocalConfig();\n        });\n        this.addAction('openLog', async () => {\n            let file = logger.getLogFile();\n            await workspace_1.default.jumpTo(vscode_uri_1.URI.file(file).toString());\n        });\n        this.addAction('attach', () => {\n            return workspace_1.default.attach();\n        });\n        this.addAction('detach', () => {\n            return workspace_1.default.detach();\n        });\n        this.addAction('doKeymap', async (key, defaultReturn = '', pressed) => {\n            let keymap = workspace_1.default.keymaps.get(key);\n            if (!keymap) {\n                logger.error(`keymap for ${key} not found`);\n                this.nvim.command(`silent! unmap <buffer> ${pressed.startsWith('{') && pressed.endsWith('}') ? `<${pressed.slice(1, -1)}>` : pressed}`, true);\n                return defaultReturn;\n            }\n            let [fn, repeat] = keymap;\n            let res = await Promise.resolve(fn());\n            if (repeat)\n                await nvim.command(`silent! call repeat#set(\"\\\\<Plug>(coc-${key})\", -1)`);\n            return res !== null && res !== void 0 ? res : defaultReturn;\n        });\n        this.addAction('registExtensions', async (...folders) => {\n            for (let folder of folders) {\n                await extensions_1.default.loadExtension(folder);\n            }\n        });\n        this.addAction('snippetCheck', async (checkExpand, checkJump) => {\n            if (checkExpand && !extensions_1.default.has('coc-snippets')) {\n                console.error('coc-snippets required for check expand status!');\n                return false;\n            }\n            if (checkJump) {\n                let jumpable = manager_3.default.jumpable();\n                if (jumpable)\n                    return true;\n            }\n            if (checkExpand) {\n                let api = extensions_1.default.getExtensionApi('coc-snippets');\n                if (api && api.hasOwnProperty('expandable')) {\n                    let expandable = await Promise.resolve(api.expandable());\n                    if (expandable)\n                        return true;\n                }\n            }\n            return false;\n        });\n        this.addAction('showInfo', async () => {\n            if (!this.infoChannel) {\n                this.infoChannel = window_1.default.createOutputChannel('info');\n            }\n            else {\n                this.infoChannel.clear();\n            }\n            let channel = this.infoChannel;\n            channel.appendLine('## versions');\n            channel.appendLine('');\n            let out = await this.nvim.call('execute', ['version']);\n            let first = out.trim().split('\\n', 2)[0].replace(/\\(.*\\)/, '').trim();\n            channel.appendLine('vim version: ' + first + `${workspace_1.default.isVim ? ' ' + workspace_1.default.env.version : ''}`);\n            channel.appendLine('node version: ' + process.version);\n            channel.appendLine('coc.nvim version: ' + this.version);\n            channel.appendLine('coc.nvim directory: ' + path_1.default.dirname(__dirname));\n            channel.appendLine('term: ' + (process.env.TERM_PROGRAM || process.env.TERM));\n            channel.appendLine('platform: ' + process.platform);\n            channel.appendLine('');\n            channel.appendLine('## Log of coc.nvim');\n            channel.appendLine('');\n            let file = logger.getLogFile();\n            if (fs_1.default.existsSync(file)) {\n                let content = fs_1.default.readFileSync(file, { encoding: 'utf8' });\n                channel.appendLine(content);\n            }\n            channel.show();\n        });\n        this.addAction('findLocations', (id, method, params, openCommand) => {\n            return this.handler.findLocations(id, method, params, openCommand);\n        });\n        this.addAction('links', () => {\n            return this.handler.links();\n        });\n        this.addAction('openLink', () => {\n            return this.handler.openLink();\n        });\n        this.addAction('pickColor', () => {\n            return this.handler.pickColor();\n        });\n        this.addAction('colorPresentation', () => {\n            return this.handler.pickPresentation();\n        });\n        this.addAction('highlight', async () => {\n            await this.handler.highlight();\n        });\n        this.addAction('fold', (kind) => {\n            return this.handler.fold(kind);\n        });\n        this.addAction('startCompletion', async (option) => {\n            await completion_1.default.startCompletion(option);\n        });\n        this.addAction('stopCompletion', () => {\n            completion_1.default.stop(false);\n        });\n        this.addAction('sourceStat', () => {\n            return sources_1.default.sourceStats();\n        });\n        this.addAction('refreshSource', async (name) => {\n            await sources_1.default.refresh(name);\n        });\n        this.addAction('toggleSource', name => {\n            sources_1.default.toggleSource(name);\n        });\n        this.addAction('diagnosticInfo', async () => {\n            await manager_1.default.echoMessage();\n        });\n        this.addAction('diagnosticToggle', () => {\n            manager_1.default.toggleDiagnostic();\n        });\n        this.addAction('diagnosticNext', async (severity) => {\n            await manager_1.default.jumpNext(severity);\n        });\n        this.addAction('diagnosticPrevious', async (severity) => {\n            await manager_1.default.jumpPrevious(severity);\n        });\n        this.addAction('diagnosticPreview', async () => {\n            await manager_1.default.preview();\n        });\n        this.addAction('diagnosticList', () => {\n            return manager_1.default.getDiagnosticList();\n        });\n        this.addAction('jumpDefinition', openCommand => {\n            return this.handler.gotoDefinition(openCommand);\n        });\n        this.addAction('jumpDeclaration', openCommand => {\n            return this.handler.gotoDeclaration(openCommand);\n        });\n        this.addAction('jumpImplementation', openCommand => {\n            return this.handler.gotoImplementation(openCommand);\n        });\n        this.addAction('jumpTypeDefinition', openCommand => {\n            return this.handler.gotoTypeDefinition(openCommand);\n        });\n        this.addAction('jumpReferences', openCommand => {\n            return this.handler.gotoReferences(openCommand);\n        });\n        this.addAction('jumpUsed', openCommand => {\n            return this.handler.gotoReferences(openCommand, false);\n        });\n        this.addAction('doHover', hoverTarget => {\n            return this.handler.onHover(hoverTarget);\n        });\n        this.addAction('getHover', () => {\n            return this.handler.getHover();\n        });\n        this.addAction('showSignatureHelp', () => {\n            return this.handler.showSignatureHelp();\n        });\n        this.addAction('documentSymbols', async (bufnr) => {\n            if (!bufnr)\n                bufnr = await nvim.call('bufnr', ['%']);\n            return await this.handler.getDocumentSymbols(bufnr);\n        });\n        this.addAction('symbolRanges', () => {\n            return this.handler.getSymbolsRanges();\n        });\n        this.addAction('selectionRanges', () => {\n            return this.handler.getSelectionRanges();\n        });\n        this.addAction('rangeSelect', (visualmode, forward) => {\n            return this.handler.selectRange(visualmode, forward);\n        });\n        this.addAction('rename', newName => {\n            return this.handler.rename(newName);\n        });\n        this.addAction('getWorkspaceSymbols', async (input) => {\n            let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n            return await languages_1.default.getWorkspaceSymbols(input, tokenSource.token);\n        });\n        this.addAction('formatSelected', mode => {\n            return this.handler.documentRangeFormatting(mode);\n        });\n        this.addAction('format', () => {\n            return this.handler.documentFormatting();\n        });\n        this.addAction('commands', () => {\n            return this.handler.getCommands();\n        });\n        this.addAction('services', () => {\n            return services_1.default.getServiceStats();\n        });\n        this.addAction('toggleService', name => {\n            return services_1.default.toggle(name);\n        });\n        this.addAction('codeAction', (mode, only) => {\n            return this.handler.doCodeAction(mode, only);\n        });\n        this.addAction('organizeImport', () => {\n            return this.handler.doCodeAction(null, [vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports]);\n        });\n        this.addAction('fixAll', () => {\n            return this.handler.doCodeAction(null, [vscode_languageserver_protocol_1.CodeActionKind.SourceFixAll]);\n        });\n        this.addAction('doCodeAction', codeAction => {\n            return this.handler.applyCodeAction(codeAction);\n        });\n        this.addAction('codeActions', (mode, only) => {\n            return this.handler.getCurrentCodeActions(mode, only);\n        });\n        this.addAction('quickfixes', mode => {\n            return this.handler.getCurrentCodeActions(mode, [vscode_languageserver_protocol_1.CodeActionKind.QuickFix]);\n        });\n        this.addAction('codeLensAction', () => {\n            return this.handler.doCodeLensAction();\n        });\n        this.addAction('runCommand', (...args) => {\n            return this.handler.runCommand(...args);\n        });\n        this.addAction('doQuickfix', () => {\n            return this.handler.doQuickfix();\n        });\n        this.addAction('refactor', () => {\n            return this.handler.doRefactor();\n        });\n        this.addAction('repeatCommand', () => {\n            return commands_1.default.repeatCommand();\n        });\n        this.addAction('extensionStats', () => {\n            return extensions_1.default.getExtensionStates();\n        });\n        this.addAction('loadedExtensions', () => {\n            return extensions_1.default.loadedExtensions();\n        });\n        this.addAction('watchExtension', (id) => {\n            return extensions_1.default.watchExtension(id);\n        });\n        this.addAction('activeExtension', name => {\n            return extensions_1.default.activate(name);\n        });\n        this.addAction('deactivateExtension', name => {\n            return extensions_1.default.deactivate(name);\n        });\n        this.addAction('reloadExtension', name => {\n            return extensions_1.default.reloadExtension(name);\n        });\n        this.addAction('toggleExtension', name => {\n            return extensions_1.default.toggleExtension(name);\n        });\n        this.addAction('uninstallExtension', (...args) => {\n            return extensions_1.default.uninstallExtension(args);\n        });\n        this.addAction('getCurrentFunctionSymbol', () => {\n            return this.handler.getCurrentFunctionSymbol();\n        });\n        this.addAction('getWordEdit', () => {\n            return this.handler.getWordEdit();\n        });\n        this.addAction('addRanges', async (ranges) => {\n            await this.cursors.addRanges(ranges);\n        });\n        this.addAction('currentWorkspacePath', () => {\n            return workspace_1.default.rootPath;\n        });\n        this.addAction('addCommand', cmd => {\n            this.addCommand(cmd);\n        });\n        this.addAction('selectCurrentPlaceholder', (triggerAutocmd) => {\n            return manager_3.default.selectCurrentPlaceholder(!!triggerAutocmd);\n        });\n        this.addAction('codeActionRange', (start, end, only) => this.handler.codeActionRange(start, end, only));\n        workspace_1.default.onDidChangeWorkspaceFolders(() => {\n            nvim.setVar('WorkspaceFolders', workspace_1.default.folderPaths, true);\n        });\n        commands_1.default.init(nvim, this);\n    }\n    addAction(key, fn) {\n        if (this.actions.has(key)) {\n            throw new Error(`Action ${key} already exists`);\n        }\n        this.actions.set(key, fn);\n    }\n    addCommand(cmd) {\n        let id = `vim.${cmd.id}`;\n        commands_1.default.registerCommand(id, async () => {\n            await this.nvim.command(cmd.cmd);\n        });\n        if (cmd.title)\n            commands_1.default.titles.set(id, cmd.title);\n    }\n    async init() {\n        let { nvim } = this;\n        let s = Date.now();\n        try {\n            await extensions_1.default.init();\n            await workspace_1.default.init();\n            languages_1.default.init();\n            for (let item of workspace_1.default.env.vimCommands) {\n                this.addCommand(item);\n            }\n            manager_3.default.init();\n            completion_1.default.init();\n            manager_1.default.init();\n            manager_2.default.init(nvim);\n            nvim.setVar('coc_workspace_initialized', 1, true);\n            nvim.setVar('WorkspaceFolders', workspace_1.default.folderPaths, true);\n            sources_1.default.init();\n            this.handler = new handler_1.default(nvim);\n            services_1.default.init();\n            await extensions_1.default.activateExtensions();\n            workspace_1.default.setupDynamicAutocmd(true);\n            nvim.setVar('coc_service_initialized', 1, true);\n            nvim.call('coc#util#do_autocmd', ['CocNvimInit'], true);\n            this._ready = true;\n            await events_2.default.fire('ready', []);\n            logger.info(`coc.nvim ${this.version} initialized with node: ${process.version} after ${Date.now() - s}ms`);\n            this.emit('ready');\n        }\n        catch (e) {\n            console.error(`Error on initialize: ${e.stack}`);\n            logger.error(e.stack);\n        }\n        workspace_1.default.onDidOpenTextDocument(async (doc) => {\n            if (!doc.uri.endsWith(util_1.CONFIG_FILE_NAME))\n                return;\n            if (extensions_1.default.has('coc-json'))\n                return;\n            window_1.default.showMessage(`Run :CocInstall coc-json for json intellisense`, 'more');\n        });\n    }\n    get isReady() {\n        return this._ready;\n    }\n    get ready() {\n        if (this._ready)\n            return Promise.resolve();\n        return new Promise(resolve => {\n            this.once('ready', () => {\n                resolve();\n            });\n        });\n    }\n    get version() {\n        return workspace_1.default.version + ( true ? '-' + \"c834db3134\" : 0);\n    }\n    hasAction(method) {\n        return this.actions.has(method);\n    }\n    async cocAction(method, ...args) {\n        let fn = this.actions.get(method);\n        if (!fn)\n            throw new Error(`Action \"${method}\" not exists`);\n        return await Promise.resolve(fn.apply(null, args));\n    }\n    getHandler() {\n        return this.handler;\n    }\n    dispose() {\n        this.removeAllListeners();\n        extensions_1.default.dispose();\n        manager_2.default.dispose();\n        workspace_1.default.dispose();\n        window_1.default.dispose();\n        sources_1.default.dispose();\n        services_1.default.stopAll();\n        services_1.default.dispose();\n        if (this.handler) {\n            this.handler.dispose();\n        }\n        manager_3.default.dispose();\n        commands_1.default.dispose();\n        completion_1.default.dispose();\n        manager_1.default.dispose();\n    }\n}\nexports.default = Plugin;\n\n\n//# sourceURL=webpack://coc.nvim/./src/plugin.ts?");

/***/ }),

/***/ "./src/provider/codeActionmanager.ts":
/*!*******************************************!*\
  !*** ./src/provider/codeActionmanager.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./manager */ \"./src/provider/manager.ts\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nconst array_1 = __webpack_require__(/*! ../util/array */ \"./src/util/array.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('codeActionManager');\nclass CodeActionManager extends manager_1.default {\n    register(selector, provider, clientId, codeActionKinds) {\n        let item = {\n            id: uuid_1.v4(),\n            selector,\n            provider,\n            kinds: codeActionKinds,\n            clientId\n        };\n        this.providers.add(item);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.providers.delete(item);\n        });\n    }\n    async provideCodeActions(document, range, context, token) {\n        let providers = this.getProviders(document);\n        if (!providers.length)\n            return null;\n        if (context.only) {\n            let { only } = context;\n            providers = providers.filter(p => {\n                if (p.kinds && !p.kinds.some(kind => only.includes(kind))) {\n                    return false;\n                }\n                return true;\n            });\n        }\n        let res = [];\n        await Promise.all(providers.map(item => {\n            let { provider, clientId } = item;\n            return Promise.resolve(provider.provideCodeActions(document, range, context, token)).then(actions => {\n                if (!actions || actions.length == 0)\n                    return;\n                for (let action of actions) {\n                    if (vscode_languageserver_protocol_1.Command.is(action)) {\n                        let codeAction = {\n                            title: action.title,\n                            command: action,\n                            clientId\n                        };\n                        res.push(codeAction);\n                    }\n                    else {\n                        if (context.only) {\n                            if (!action.kind)\n                                continue;\n                            let { only } = context;\n                            if (array_1.intersect(only, [vscode_languageserver_protocol_1.CodeActionKind.Source, vscode_languageserver_protocol_1.CodeActionKind.Refactor])) {\n                                if (!only.includes(action.kind.split('.', 2)[0])) {\n                                    continue;\n                                }\n                            }\n                            else if (!context.only.includes(action.kind)) {\n                                continue;\n                            }\n                        }\n                        let idx = res.findIndex(o => o.title == action.title);\n                        if (idx == -1)\n                            res.push(Object.assign({ clientId }, action));\n                    }\n                }\n            });\n        }));\n        return res;\n    }\n    dispose() {\n        this.providers = new Set();\n    }\n}\nexports.default = CodeActionManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/codeActionmanager.ts?");

/***/ }),

/***/ "./src/provider/codeLensManager.ts":
/*!*****************************************!*\
  !*** ./src/provider/codeLensManager.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./manager */ \"./src/provider/manager.ts\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nconst lodash_1 = __webpack_require__(/*! ../util/lodash */ \"./src/util/lodash.ts\");\n// const logger = require('../util/logger')('codeActionManager')\nclass CodeLensManager extends manager_1.default {\n    register(selector, provider) {\n        let item = {\n            id: uuid_1.v4(),\n            selector,\n            provider\n        };\n        this.providers.add(item);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.providers.delete(item);\n        });\n    }\n    async provideCodeLenses(document, token) {\n        let providers = this.getProviders(document);\n        if (!providers.length)\n            return null;\n        let arr = await Promise.all(providers.map(item => {\n            let { provider, id } = item;\n            return Promise.resolve(provider.provideCodeLenses(document, token)).then(res => {\n                if (Array.isArray(res)) {\n                    for (let item of res) {\n                        item.source = id;\n                    }\n                }\n                return res || [];\n            });\n        }));\n        return [].concat(...arr);\n    }\n    async resolveCodeLens(codeLens, token) {\n        // no need to resolve\n        if (codeLens.command)\n            return codeLens;\n        let { source } = codeLens;\n        let provider = this.poviderById(source);\n        if (!provider || typeof provider.resolveCodeLens != 'function') {\n            return codeLens;\n        }\n        let res = await Promise.resolve(provider.resolveCodeLens(lodash_1.omit(codeLens, ['source']), token));\n        Object.assign(codeLens, res);\n        return codeLens;\n    }\n    dispose() {\n        this.providers = new Set();\n    }\n}\nexports.default = CodeLensManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/codeLensManager.ts?");

/***/ }),

/***/ "./src/provider/declarationManager.ts":
/*!********************************************!*\
  !*** ./src/provider/declarationManager.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./manager */ \"./src/provider/manager.ts\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('definitionManager');\nclass DeclarationManager extends manager_1.default {\n    register(selector, provider) {\n        let item = {\n            id: uuid_1.v4(),\n            selector,\n            provider\n        };\n        this.providers.add(item);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.providers.delete(item);\n        });\n    }\n    async provideDeclaration(document, position, token) {\n        let item = this.getProvider(document);\n        if (!item)\n            return null;\n        let { provider } = item;\n        return await Promise.resolve(provider.provideDeclaration(document, position, token));\n    }\n    dispose() {\n        this.providers = new Set();\n    }\n}\nexports.default = DeclarationManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/declarationManager.ts?");

/***/ }),

/***/ "./src/provider/definitionManager.ts":
/*!*******************************************!*\
  !*** ./src/provider/definitionManager.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./manager */ \"./src/provider/manager.ts\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('definitionManager');\nclass DefinitionManager extends manager_1.default {\n    register(selector, provider) {\n        let item = {\n            id: uuid_1.v4(),\n            selector,\n            provider\n        };\n        this.providers.add(item);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.providers.delete(item);\n        });\n    }\n    async provideDefinition(document, position, token) {\n        let providers = this.getProviders(document);\n        if (!providers.length)\n            return null;\n        let arr = await Promise.all(providers.map(item => {\n            let { provider } = item;\n            return Promise.resolve(provider.provideDefinition(document, position, token));\n        }));\n        return this.mergeDefinitions(arr);\n    }\n    dispose() {\n        this.providers = new Set();\n    }\n}\nexports.default = DefinitionManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/definitionManager.ts?");

/***/ }),

/***/ "./src/provider/documentColorManager.ts":
/*!**********************************************!*\
  !*** ./src/provider/documentColorManager.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./manager */ \"./src/provider/manager.ts\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nclass DocumentColorManager extends manager_1.default {\n    register(selector, provider) {\n        let item = {\n            id: uuid_1.v4(),\n            selector,\n            provider\n        };\n        this.providers.add(item);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.providers.delete(item);\n        });\n    }\n    async provideDocumentColors(document, token) {\n        let item = this.getProvider(document);\n        if (!item)\n            return null;\n        let { provider } = item;\n        let res = await Promise.resolve(provider.provideDocumentColors(document, token));\n        return res;\n    }\n    async provideColorPresentations(colorInformation, document, token) {\n        let { range, color } = colorInformation;\n        let item = this.getProvider(document);\n        if (!item)\n            return null;\n        let { provider } = item;\n        let res = await Promise.resolve(provider.provideColorPresentations(color, { document, range }, token));\n        return res;\n    }\n    dispose() {\n        this.providers = new Set();\n    }\n}\nexports.default = DocumentColorManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/documentColorManager.ts?");

/***/ }),

/***/ "./src/provider/documentHighlightManager.ts":
/*!**************************************************!*\
  !*** ./src/provider/documentHighlightManager.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./manager */ \"./src/provider/manager.ts\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nclass DocumentHighlightManager extends manager_1.default {\n    register(selector, provider) {\n        let item = {\n            id: uuid_1.v4(),\n            selector,\n            provider\n        };\n        this.providers.add(item);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.providers.delete(item);\n        });\n    }\n    async provideDocumentHighlights(document, position, token) {\n        let item = this.getProvider(document);\n        if (!item)\n            return null;\n        let { provider } = item;\n        return await Promise.resolve(provider.provideDocumentHighlights(document, position, token));\n    }\n    dispose() {\n        this.providers = new Set();\n    }\n}\nexports.default = DocumentHighlightManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/documentHighlightManager.ts?");

/***/ }),

/***/ "./src/provider/documentLinkManager.ts":
/*!*********************************************!*\
  !*** ./src/provider/documentLinkManager.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./manager */ \"./src/provider/manager.ts\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nclass DocumentLinkManager extends manager_1.default {\n    register(selector, provider) {\n        let item = {\n            id: uuid_1.v4(),\n            selector,\n            provider\n        };\n        this.providers.add(item);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.providers.delete(item);\n        });\n    }\n    async _provideDocumentLinks(item, document, token) {\n        let { provider, id } = item;\n        let items = await Promise.resolve(provider.provideDocumentLinks(document, token));\n        if (!items || !items.length)\n            return [];\n        items.forEach(item => {\n            item.data = item.data || {};\n            item.data.source = id;\n        });\n        return items;\n    }\n    async provideDocumentLinks(document, token) {\n        let items = this.getProviders(document);\n        if (items.length == 0)\n            return [];\n        const arr = await Promise.all(items.map(item => this._provideDocumentLinks(item, document, token)));\n        return [].concat(...arr);\n    }\n    async resolveDocumentLink(link, token) {\n        let { data } = link;\n        if (!data || !data.source)\n            return null;\n        for (let item of this.providers) {\n            if (item.id == data.source) {\n                let { provider } = item;\n                link = await Promise.resolve(provider.resolveDocumentLink(link, token));\n                return link;\n            }\n        }\n        return null;\n    }\n    dispose() {\n        this.providers = new Set();\n    }\n}\nexports.default = DocumentLinkManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/documentLinkManager.ts?");

/***/ }),

/***/ "./src/provider/documentSymbolManager.ts":
/*!***********************************************!*\
  !*** ./src/provider/documentSymbolManager.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./manager */ \"./src/provider/manager.ts\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nclass DocumentSymbolManager extends manager_1.default {\n    register(selector, provider) {\n        let item = {\n            id: uuid_1.v4(),\n            selector,\n            provider\n        };\n        this.providers.add(item);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.providers.delete(item);\n        });\n    }\n    async provideDocumentSymbols(document, token) {\n        let item = this.getProvider(document);\n        if (!item)\n            return null;\n        let { provider } = item;\n        return (await Promise.resolve(provider.provideDocumentSymbols(document, token))) || [];\n    }\n    dispose() {\n        this.providers = new Set();\n    }\n}\nexports.default = DocumentSymbolManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/documentSymbolManager.ts?");

/***/ }),

/***/ "./src/provider/foldingRangeManager.ts":
/*!*********************************************!*\
  !*** ./src/provider/foldingRangeManager.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./manager */ \"./src/provider/manager.ts\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nclass FoldingRangeManager extends manager_1.default {\n    register(selector, provider) {\n        let item = {\n            id: uuid_1.v4(),\n            selector,\n            provider\n        };\n        this.providers.add(item);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.providers.delete(item);\n        });\n    }\n    async provideFoldingRanges(document, context, token) {\n        let item = this.getProvider(document);\n        if (!item)\n            return null;\n        let { provider } = item;\n        return (await Promise.resolve(provider.provideFoldingRanges(document, context, token)) || []);\n    }\n    dispose() {\n        this.providers = new Set();\n    }\n}\nexports.default = FoldingRangeManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/foldingRangeManager.ts?");

/***/ }),

/***/ "./src/provider/formatManager.ts":
/*!***************************************!*\
  !*** ./src/provider/formatManager.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./manager */ \"./src/provider/manager.ts\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nclass FormatManager extends manager_1.default {\n    register(selector, provider, priority = 0) {\n        let item = {\n            id: uuid_1.v4(),\n            selector,\n            priority,\n            provider\n        };\n        this.providers.add(item);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.providers.delete(item);\n        });\n    }\n    handles(doc) {\n        return this.getProvider(doc) != null;\n    }\n    async provideDocumentFormattingEdits(document, options, token) {\n        let item = this.getProvider(document);\n        if (!item)\n            return null;\n        let { provider } = item;\n        return await Promise.resolve(provider.provideDocumentFormattingEdits(document, options, token));\n    }\n    dispose() {\n        this.providers = new Set();\n    }\n}\nexports.default = FormatManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/formatManager.ts?");

/***/ }),

/***/ "./src/provider/formatRangeManager.ts":
/*!********************************************!*\
  !*** ./src/provider/formatRangeManager.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./manager */ \"./src/provider/manager.ts\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nclass FormatRangeManager extends manager_1.default {\n    register(selector, provider, priority = 0) {\n        let item = {\n            id: uuid_1.v4(),\n            selector,\n            provider,\n            priority\n        };\n        this.providers.add(item);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.providers.delete(item);\n        });\n    }\n    async provideDocumentRangeFormattingEdits(document, range, options, token) {\n        let item = this.getProvider(document);\n        if (!item)\n            return null;\n        let { provider } = item;\n        return await Promise.resolve(provider.provideDocumentRangeFormattingEdits(document, range, options, token));\n    }\n    dispose() {\n        this.providers = new Set();\n    }\n}\nexports.default = FormatRangeManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/formatRangeManager.ts?");

/***/ }),

/***/ "./src/provider/hoverManager.ts":
/*!**************************************!*\
  !*** ./src/provider/hoverManager.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./manager */ \"./src/provider/manager.ts\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nclass HoverManager extends manager_1.default {\n    register(selector, provider) {\n        let item = {\n            id: uuid_1.v4(),\n            selector,\n            provider\n        };\n        this.providers.add(item);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.providers.delete(item);\n        });\n    }\n    async provideHover(document, position, token) {\n        let items = this.getProviders(document);\n        if (items.length === 0)\n            return null;\n        let res = [];\n        for (let i = 0, len = items.length; i < len; i += 1) {\n            const item = items[i];\n            let hover = await Promise.resolve(item.provider.provideHover(document, position, token));\n            if (hover && hover.contents != '')\n                res.push(hover);\n        }\n        return res;\n    }\n    dispose() {\n        this.providers = new Set();\n    }\n}\nexports.default = HoverManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/hoverManager.ts?");

/***/ }),

/***/ "./src/provider/implementationManager.ts":
/*!***********************************************!*\
  !*** ./src/provider/implementationManager.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./manager */ \"./src/provider/manager.ts\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nclass ImplementationManager extends manager_1.default {\n    register(selector, provider) {\n        let item = {\n            id: uuid_1.v4(),\n            selector,\n            provider\n        };\n        this.providers.add(item);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.providers.delete(item);\n        });\n    }\n    async provideReferences(document, position, token) {\n        let providers = this.getProviders(document);\n        if (!providers.length)\n            return null;\n        let arr = await Promise.all(providers.map(item => {\n            let { provider } = item;\n            return Promise.resolve(provider.provideImplementation(document, position, token));\n        }));\n        return this.mergeDefinitions(arr);\n    }\n    dispose() {\n        this.providers = new Set();\n    }\n}\nexports.default = ImplementationManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/implementationManager.ts?");

/***/ }),

/***/ "./src/provider/index.ts":
/*!*******************************!*\
  !*** ./src/provider/index.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/index.ts?");

/***/ }),

/***/ "./src/provider/manager.ts":
/*!*********************************!*\
  !*** ./src/provider/manager.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('provider-manager');\nclass Manager {\n    constructor() {\n        this.providers = new Set();\n    }\n    hasProvider(document) {\n        return this.getProvider(document) != null;\n    }\n    getProvider(document) {\n        let currScore = 0;\n        let providerItem;\n        for (let item of this.providers) {\n            let { selector, priority } = item;\n            let score = workspace_1.default.match(selector, document);\n            if (score == 0)\n                continue;\n            if (typeof priority == 'number') {\n                score = priority;\n            }\n            if (score < currScore)\n                continue;\n            currScore = score;\n            providerItem = item;\n        }\n        return providerItem;\n    }\n    poviderById(id) {\n        let item = Array.from(this.providers).find(o => o.id == id);\n        return item ? item.provider : null;\n    }\n    getProviders(document) {\n        let items = Array.from(this.providers);\n        items = items.filter(item => workspace_1.default.match(item.selector, document) > 0);\n        return items.sort((a, b) => workspace_1.default.match(b.selector, document) - workspace_1.default.match(a.selector, document));\n    }\n    mergeDefinitions(arr) {\n        let res = [];\n        for (let def of arr) {\n            if (!def)\n                continue;\n            if (vscode_languageserver_protocol_1.Location.is(def)) {\n                let { uri, range } = def;\n                let idx = res.findIndex(l => l.uri == uri && l.range.start.line == range.start.line);\n                if (idx == -1) {\n                    res.push(def);\n                }\n            }\n            else if (Array.isArray(def)) {\n                for (let d of def) {\n                    if (vscode_languageserver_protocol_1.Location.is(d)) {\n                        let { uri, range } = d;\n                        let idx = res.findIndex(l => l.uri == uri && l.range.start.line == range.start.line);\n                        if (idx == -1) {\n                            res.push(d);\n                        }\n                    }\n                    else if (vscode_languageserver_protocol_1.LocationLink.is(d)) {\n                        let { targetUri, targetSelectionRange } = d;\n                        let idx = res.findIndex(l => l.uri === targetUri && l.range.start.line === targetSelectionRange.start.line);\n                        if (idx === -1) {\n                            res.push(vscode_languageserver_protocol_1.Location.create(targetUri, targetSelectionRange));\n                        }\n                    }\n                }\n            }\n            else {\n                window_1.default.showMessage(`Bad definition ${JSON.stringify(def)}`, 'error');\n            }\n        }\n        return res;\n    }\n}\nexports.default = Manager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/manager.ts?");

/***/ }),

/***/ "./src/provider/onTypeFormatManager.ts":
/*!*********************************************!*\
  !*** ./src/provider/onTypeFormatManager.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('onTypeFormatManager');\nclass OnTypeFormatManager {\n    constructor() {\n        this.providers = new Set();\n    }\n    register(selector, provider, triggerCharacters) {\n        let item = {\n            triggerCharacters,\n            selector,\n            provider\n        };\n        this.providers.add(item);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.providers.delete(item);\n        });\n    }\n    hasProvider(document) {\n        for (let o of this.providers) {\n            let { selector } = o;\n            if (workspace_1.default.match(selector, document) > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    getProvider(document, triggerCharacter) {\n        for (let o of this.providers) {\n            let { triggerCharacters, selector } = o;\n            if (workspace_1.default.match(selector, document) > 0 && triggerCharacters.includes(triggerCharacter)) {\n                return o.provider;\n            }\n        }\n        return null;\n    }\n    async onCharacterType(character, document, position, token) {\n        let provider = this.getProvider(document, character);\n        if (!provider)\n            return;\n        let formatOpts = await workspace_1.default.getFormatOptions(document.uri);\n        return await Promise.resolve(provider.provideOnTypeFormattingEdits(document, position, character, formatOpts, token));\n    }\n    dispose() {\n        this.providers = new Set();\n    }\n}\nexports.default = OnTypeFormatManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/onTypeFormatManager.ts?");

/***/ }),

/***/ "./src/provider/referenceManager.ts":
/*!******************************************!*\
  !*** ./src/provider/referenceManager.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./manager */ \"./src/provider/manager.ts\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nclass ReferenceManager extends manager_1.default {\n    register(selector, provider) {\n        let item = {\n            id: uuid_1.v4(),\n            selector,\n            provider\n        };\n        this.providers.add(item);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.providers.delete(item);\n        });\n    }\n    async provideReferences(document, position, context, token) {\n        let providers = this.getProviders(document);\n        if (!providers.length)\n            return null;\n        let arr = await Promise.all(providers.map(item => {\n            let { provider } = item;\n            return Promise.resolve(provider.provideReferences(document, position, context, token));\n        }));\n        return this.mergeDefinitions(arr);\n    }\n    dispose() {\n        this.providers = new Set();\n    }\n}\nexports.default = ReferenceManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/referenceManager.ts?");

/***/ }),

/***/ "./src/provider/renameManager.ts":
/*!***************************************!*\
  !*** ./src/provider/renameManager.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./manager */ \"./src/provider/manager.ts\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nclass RenameManager extends manager_1.default {\n    register(selector, provider) {\n        let item = {\n            id: uuid_1.v4(),\n            selector,\n            provider\n        };\n        this.providers.add(item);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.providers.delete(item);\n        });\n    }\n    async provideRenameEdits(document, position, newName, token) {\n        let item = this.getProvider(document);\n        if (!item)\n            return null;\n        let { provider } = item;\n        return await Promise.resolve(provider.provideRenameEdits(document, position, newName, token));\n    }\n    async prepareRename(document, position, token) {\n        let item = this.getProvider(document);\n        if (!item)\n            return null;\n        let { provider } = item;\n        if (provider.prepareRename == null)\n            return null;\n        let res = await Promise.resolve(provider.prepareRename(document, position, token));\n        // can not rename\n        if (res == null)\n            return false;\n        return res;\n    }\n    dispose() {\n        this.providers = new Set();\n    }\n}\nexports.default = RenameManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/renameManager.ts?");

/***/ }),

/***/ "./src/provider/selectionRangeManager.ts":
/*!***********************************************!*\
  !*** ./src/provider/selectionRangeManager.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./manager */ \"./src/provider/manager.ts\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nclass SelectionRangeManager extends manager_1.default {\n    register(selector, provider) {\n        let item = {\n            id: uuid_1.v4(),\n            selector,\n            provider\n        };\n        this.providers.add(item);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.providers.delete(item);\n        });\n    }\n    async provideSelectionRanges(document, positions, token) {\n        let item = this.getProvider(document);\n        if (!item)\n            return null;\n        let { provider } = item;\n        return (await Promise.resolve(provider.provideSelectionRanges(document, positions, token)) || []);\n    }\n    dispose() {\n        this.providers = new Set();\n    }\n}\nexports.default = SelectionRangeManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/selectionRangeManager.ts?");

/***/ }),

/***/ "./src/provider/signatureManager.ts":
/*!******************************************!*\
  !*** ./src/provider/signatureManager.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./manager */ \"./src/provider/manager.ts\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nclass SignatureManager extends manager_1.default {\n    register(selector, provider, triggerCharacters) {\n        let characters = triggerCharacters.reduce((p, c) => p.concat(c.split(/\\s*/g)), []);\n        let item = {\n            id: uuid_1.v4(),\n            selector,\n            provider,\n            triggerCharacters: characters\n        };\n        this.providers.add(item);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.providers.delete(item);\n        });\n    }\n    shouldTrigger(document, triggerCharacter) {\n        let item = this.getProvider(document);\n        if (!item)\n            return false;\n        let { triggerCharacters } = item;\n        return triggerCharacters && triggerCharacters.indexOf(triggerCharacter) != -1;\n    }\n    async provideSignatureHelp(document, position, token, context) {\n        let item = this.getProvider(document);\n        if (!item)\n            return null;\n        let res = await Promise.resolve(item.provider.provideSignatureHelp(document, position, token, context));\n        if (res && res.signatures && res.signatures.length)\n            return res;\n        return null;\n    }\n    dispose() {\n        this.providers = new Set();\n    }\n}\nexports.default = SignatureManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/signatureManager.ts?");

/***/ }),

/***/ "./src/provider/typeDefinitionManager.ts":
/*!***********************************************!*\
  !*** ./src/provider/typeDefinitionManager.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst manager_1 = tslib_1.__importDefault(__webpack_require__(/*! ./manager */ \"./src/provider/manager.ts\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nclass TypeDefinitionManager extends manager_1.default {\n    register(selector, provider) {\n        let item = {\n            id: uuid_1.v4(),\n            selector,\n            provider\n        };\n        this.providers.add(item);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.providers.delete(item);\n        });\n    }\n    async provideTypeDefinition(document, position, token) {\n        let providers = this.getProviders(document);\n        if (!providers.length)\n            return null;\n        let arr = await Promise.all(providers.map(item => {\n            let { provider } = item;\n            return Promise.resolve(provider.provideTypeDefinition(document, position, token));\n        }));\n        return this.mergeDefinitions(arr);\n    }\n    dispose() {\n        this.providers = new Set();\n    }\n}\nexports.default = TypeDefinitionManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/typeDefinitionManager.ts?");

/***/ }),

/***/ "./src/provider/workspaceSymbolsManager.ts":
/*!*************************************************!*\
  !*** ./src/provider/workspaceSymbolsManager.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nclass WorkspaceSymbolManager {\n    constructor() {\n        this.providers = new Map();\n    }\n    register(provider) {\n        let id = uuid_1.v4();\n        this.providers.set(id, provider);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.providers.delete(id);\n        });\n    }\n    async provideWorkspaceSymbols(query, token) {\n        let entries = Array.from(this.providers.entries());\n        if (!entries.length)\n            return [];\n        let res = [];\n        await Promise.all(entries.map(o => {\n            let [id, p] = o;\n            return Promise.resolve(p.provideWorkspaceSymbols(query, token)).then(item => {\n                if (item) {\n                    item.source = id;\n                    res.push(...item);\n                }\n            });\n        }));\n        return res;\n    }\n    async resolveWorkspaceSymbol(symbolInfo, token) {\n        let provider = this.providers.get(symbolInfo.source);\n        if (!provider)\n            return;\n        if (typeof provider.resolveWorkspaceSymbol != 'function') {\n            return Promise.resolve(symbolInfo);\n        }\n        return await Promise.resolve(provider.resolveWorkspaceSymbol(symbolInfo, token));\n    }\n    hasProvider() {\n        return this.providers.size > 0;\n    }\n    dispose() {\n        this.providers = new Map();\n    }\n}\nexports.default = WorkspaceSymbolManager;\n\n\n//# sourceURL=webpack://coc.nvim/./src/provider/workspaceSymbolsManager.ts?");

/***/ }),

/***/ "./src/services.ts":
/*!*************************!*\
  !*** ./src/services.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getTransportKind = exports.getDocumentSelector = exports.getRevealOutputChannelOn = exports.getLanguageServerOptions = exports.documentSelectorToLanguageIds = exports.ServiceManager = exports.getStateName = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst fs_1 = tslib_1.__importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst net_1 = tslib_1.__importDefault(__webpack_require__(/*! net */ \"net\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst language_client_1 = __webpack_require__(/*! ./language-client */ \"./src/language-client/index.ts\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/types.ts\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/util/index.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ./workspace */ \"./src/workspace.ts\"));\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ./window */ \"./src/window.ts\"));\nconst logger = __webpack_require__(/*! ./util/logger */ \"./src/util/logger.ts\")('services');\nfunction getStateName(state) {\n    switch (state) {\n        case types_1.ServiceStat.Initial:\n            return 'init';\n        case types_1.ServiceStat.Running:\n            return 'running';\n        case types_1.ServiceStat.Starting:\n            return 'starting';\n        case types_1.ServiceStat.StartFailed:\n            return 'startFailed';\n        case types_1.ServiceStat.Stopping:\n            return 'stopping';\n        case types_1.ServiceStat.Stopped:\n            return 'stopped';\n        default:\n            return 'unknown';\n    }\n}\nexports.getStateName = getStateName;\nclass ServiceManager extends events_1.EventEmitter {\n    constructor() {\n        super(...arguments);\n        this.registered = new Map();\n        this.disposables = [];\n    }\n    init() {\n        workspace_1.default.onDidOpenTextDocument(document => {\n            this.start(document);\n        }, null, this.disposables);\n        workspace_1.default.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('languageserver')) {\n                this.createCustomServices();\n            }\n        }, null, this.disposables);\n        this.createCustomServices();\n    }\n    dispose() {\n        this.removeAllListeners();\n        util_1.disposeAll(this.disposables);\n        for (let service of this.registered.values()) {\n            service.dispose();\n        }\n    }\n    regist(service) {\n        let { id } = service;\n        if (!id)\n            logger.error('invalid service configuration. ', service.name);\n        if (this.registered.get(id))\n            return;\n        this.registered.set(id, service);\n        logger.info(`registered service \"${id}\"`);\n        if (this.shouldStart(service)) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            service.start();\n        }\n        if (service.state == types_1.ServiceStat.Running) {\n            this.emit('ready', id);\n        }\n        service.onServiceReady(() => {\n            logger.info(`service ${id} started`);\n            this.emit('ready', id);\n        }, null, this.disposables);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            service.stop();\n            service.dispose();\n            this.registered.delete(id);\n        });\n    }\n    getService(id) {\n        let service = this.registered.get(id);\n        if (!service)\n            service = this.registered.get(`languageserver.${id}`);\n        return service;\n    }\n    shouldStart(service) {\n        if (service.state != types_1.ServiceStat.Initial) {\n            return false;\n        }\n        let selector = service.selector;\n        for (let doc of workspace_1.default.documents) {\n            if (workspace_1.default.match(selector, doc.textDocument)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    start(document) {\n        let services = this.getServices(document);\n        for (let service of services) {\n            if (service.state == types_1.ServiceStat.Initial) {\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                service.start();\n            }\n        }\n    }\n    getServices(document) {\n        let res = [];\n        for (let service of this.registered.values()) {\n            if (workspace_1.default.match(service.selector, document) > 0) {\n                res.push(service);\n            }\n        }\n        return res;\n    }\n    stop(id) {\n        let service = this.registered.get(id);\n        if (!service) {\n            window_1.default.showMessage(`Service ${id} not found`, 'error');\n            return;\n        }\n        return Promise.resolve(service.stop());\n    }\n    stopAll() {\n        for (let service of this.registered.values()) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            service.stop();\n        }\n    }\n    async toggle(id) {\n        let service = this.registered.get(id);\n        if (!service) {\n            window_1.default.showMessage(`Service ${id} not found`, 'error');\n            return;\n        }\n        let { state } = service;\n        try {\n            if (state == types_1.ServiceStat.Running) {\n                await Promise.resolve(service.stop());\n            }\n            else if (state == types_1.ServiceStat.Initial) {\n                await service.start();\n            }\n            else if (state == types_1.ServiceStat.Stopped) {\n                await service.restart();\n            }\n        }\n        catch (e) {\n            window_1.default.showMessage(`Service error: ${e.message}`, 'error');\n        }\n    }\n    getServiceStats() {\n        let res = [];\n        for (let [id, service] of this.registered) {\n            res.push({\n                id,\n                languageIds: documentSelectorToLanguageIds(service.selector),\n                state: getStateName(service.state)\n            });\n        }\n        return res;\n    }\n    createCustomServices() {\n        let lspConfig = workspace_1.default.getConfiguration().get('languageserver', {});\n        for (let key of Object.keys(lspConfig)) {\n            let config = lspConfig[key];\n            this.registLanguageClient(key, config);\n        }\n    }\n    waitClient(id) {\n        let service = this.getService(id);\n        if (service && service.state == types_1.ServiceStat.Running)\n            return Promise.resolve();\n        if (service)\n            return new Promise(resolve => {\n                service.onServiceReady(() => {\n                    resolve();\n                });\n            });\n        return new Promise(resolve => {\n            let listener = clientId => {\n                if (clientId == id || clientId == `languageserver.${id}`) {\n                    this.off('ready', listener);\n                    resolve();\n                }\n            };\n            this.on('ready', listener);\n        });\n    }\n    async registNotification(id, method) {\n        await this.waitClient(id);\n        let service = this.getService(id);\n        if (!service.client) {\n            window_1.default.showMessage(`Not a language client: ${id}`, 'error');\n            return;\n        }\n        let client = service.client;\n        client.onNotification(method, async (result) => {\n            await workspace_1.default.nvim.call('coc#do_notify', [id, method, result]);\n        });\n    }\n    async sendNotification(id, method, params) {\n        if (!method)\n            throw new Error(`method required for ontification`);\n        let service = this.getService(id);\n        // wait for extension activate\n        if (!service || !service.client)\n            throw new Error(`Language server ${id} not found`);\n        if (service.state == types_1.ServiceStat.Starting) {\n            await service.client.onReady();\n        }\n        if (service.state != types_1.ServiceStat.Running) {\n            throw new Error(`Language server ${id} not running`);\n        }\n        await Promise.resolve(service.client.sendNotification(method, params));\n    }\n    async sendRequest(id, method, params, token) {\n        if (!method)\n            throw new Error(`method required for sendRequest`);\n        let service = this.getService(id);\n        // wait for extension activate\n        if (!service)\n            await util_1.wait(100);\n        service = this.getService(id);\n        if (!service || !service.client) {\n            throw new Error(`Language server ${id} not found`);\n        }\n        if (service.state == types_1.ServiceStat.Starting) {\n            await service.client.onReady();\n        }\n        if (service.state != types_1.ServiceStat.Running) {\n            throw new Error(`Language server ${id} not running`);\n        }\n        if (!token) {\n            let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n            token = tokenSource.token;\n        }\n        return await Promise.resolve(service.client.sendRequest(method, params, token));\n    }\n    registLanguageClient(name, config) {\n        let id = typeof name === 'string' ? `languageserver.${name}` : name.id;\n        let disposables = [];\n        let onDidServiceReady = new vscode_languageserver_protocol_1.Emitter();\n        let client = typeof name === 'string' ? null : name;\n        if (this.registered.has(id))\n            return;\n        let created = false;\n        let service = {\n            id,\n            client,\n            name: typeof name === 'string' ? name : name.name,\n            selector: typeof name === 'string' ? getDocumentSelector(config.filetypes, config.additionalSchemes) : name.clientOptions.documentSelector,\n            state: types_1.ServiceStat.Initial,\n            onServiceReady: onDidServiceReady.event,\n            start: () => {\n                if (service.state == types_1.ServiceStat.Starting || service.state == types_1.ServiceStat.Running) {\n                    return;\n                }\n                if (client && !client.needsStart()) {\n                    return;\n                }\n                if (created && client) {\n                    client.restart();\n                    return Promise.resolve();\n                }\n                if (!created) {\n                    if (typeof name == 'string' && !client) {\n                        let config = workspace_1.default.getConfiguration().get('languageserver', {})[name];\n                        if (!config || config.enable === false)\n                            return;\n                        let opts = getLanguageServerOptions(id, name, config);\n                        if (!opts)\n                            return;\n                        client = new language_client_1.LanguageClient(id, name, opts[1], opts[0]);\n                        service.selector = opts[0].documentSelector;\n                        service.client = client;\n                    }\n                    client.onDidChangeState(changeEvent => {\n                        let { oldState, newState } = changeEvent;\n                        if (newState == language_client_1.State.Starting) {\n                            service.state = types_1.ServiceStat.Starting;\n                        }\n                        else if (newState == language_client_1.State.Running) {\n                            service.state = types_1.ServiceStat.Running;\n                        }\n                        else if (newState == language_client_1.State.Stopped) {\n                            service.state = types_1.ServiceStat.Stopped;\n                        }\n                        let oldStr = stateString(oldState);\n                        let newStr = stateString(newState);\n                        logger.info(`${client.name} state change: ${oldStr} => ${newStr}`);\n                    }, null, disposables);\n                    created = true;\n                }\n                service.state = types_1.ServiceStat.Starting;\n                logger.debug(`starting service: ${id}`);\n                let disposable = client.start();\n                disposables.push(disposable);\n                return new Promise(resolve => {\n                    client.onReady().then(() => {\n                        onDidServiceReady.fire(void 0);\n                        resolve();\n                    }, e => {\n                        window_1.default.showMessage(`Server ${id} failed to start: ${e}`, 'error');\n                        logger.error(`Server ${id} failed to start:`, e);\n                        service.state = types_1.ServiceStat.StartFailed;\n                        resolve();\n                    });\n                });\n            },\n            dispose: async () => {\n                onDidServiceReady.dispose();\n                util_1.disposeAll(disposables);\n            },\n            stop: async () => {\n                if (!client || !client.needsStop())\n                    return;\n                await Promise.resolve(client.stop());\n            },\n            restart: async () => {\n                if (client) {\n                    service.state = types_1.ServiceStat.Starting;\n                    client.restart();\n                }\n                else {\n                    await service.start();\n                }\n            },\n        };\n        return this.regist(service);\n    }\n}\nexports.ServiceManager = ServiceManager;\nfunction documentSelectorToLanguageIds(documentSelector) {\n    let res = documentSelector.map(filter => {\n        if (typeof filter == 'string') {\n            return filter;\n        }\n        return filter.language;\n    });\n    res = res.filter(s => typeof s == 'string');\n    return Array.from(new Set(res));\n}\nexports.documentSelectorToLanguageIds = documentSelectorToLanguageIds;\n// convert config to options\nfunction getLanguageServerOptions(id, name, config) {\n    let { command, module, port, args, filetypes } = config;\n    args = args || [];\n    if (!filetypes) {\n        window_1.default.showMessage(`Wrong configuration of LS \"${name}\", filetypes not found`, 'error');\n        return null;\n    }\n    if (!command && !module && !port) {\n        window_1.default.showMessage(`Wrong configuration of LS \"${name}\", no command or module specified.`, 'error');\n        return null;\n    }\n    let serverOptions;\n    if (module) {\n        module = workspace_1.default.expand(module);\n        if (!fs_1.default.existsSync(module)) {\n            window_1.default.showMessage(`Module file \"${module}\" not found for LS \"${name}\"`, 'error');\n            return null;\n        }\n        serverOptions = {\n            module,\n            runtime: config.runtime || process.execPath,\n            args,\n            transport: getTransportKind(config),\n            options: getForkOptions(config)\n        };\n    }\n    else if (command) {\n        serverOptions = {\n            command,\n            args,\n            options: getSpawnOptions(config)\n        };\n    }\n    else if (port) {\n        serverOptions = () => new Promise((resolve, reject) => {\n            let client = new net_1.default.Socket();\n            let host = config.host || '127.0.0.1';\n            logger.info(`languageserver \"${id}\" connecting to ${host}:${port}`);\n            client.connect(port, host, () => {\n                resolve({\n                    reader: client,\n                    writer: client\n                });\n            });\n            client.on('error', e => {\n                reject(new Error(`Connection error for ${id}: ${e.message}`));\n            });\n        });\n    }\n    let disableWorkspaceFolders = !!config.disableWorkspaceFolders;\n    let disableSnippetCompletion = !!config.disableSnippetCompletion;\n    let ignoredRootPaths = config.ignoredRootPaths || [];\n    let clientOptions = {\n        ignoredRootPaths: ignoredRootPaths.map(s => workspace_1.default.expand(s)),\n        disableWorkspaceFolders,\n        disableSnippetCompletion,\n        disableDynamicRegister: !!config.disableDynamicRegister,\n        disableCompletion: !!config.disableCompletion,\n        disableDiagnostics: !!config.disableDiagnostics,\n        formatterPriority: config.formatterPriority || 0,\n        documentSelector: getDocumentSelector(config.filetypes, config.additionalSchemes),\n        revealOutputChannelOn: getRevealOutputChannelOn(config.revealOutputChannelOn),\n        synchronize: {\n            configurationSection: `${id}.settings`\n        },\n        diagnosticCollectionName: name,\n        outputChannelName: id,\n        stdioEncoding: config.stdioEncoding || 'utf8',\n        progressOnInitialization: config.progressOnInitialization !== false,\n        initializationOptions: config.initializationOptions || {}\n    };\n    return [clientOptions, serverOptions];\n}\nexports.getLanguageServerOptions = getLanguageServerOptions;\nfunction getRevealOutputChannelOn(revealOn) {\n    switch (revealOn) {\n        case 'info':\n            return language_client_1.RevealOutputChannelOn.Info;\n        case 'warn':\n            return language_client_1.RevealOutputChannelOn.Warn;\n        case 'error':\n            return language_client_1.RevealOutputChannelOn.Error;\n        case 'never':\n            return language_client_1.RevealOutputChannelOn.Never;\n        default:\n            return language_client_1.RevealOutputChannelOn.Never;\n    }\n}\nexports.getRevealOutputChannelOn = getRevealOutputChannelOn;\nfunction getDocumentSelector(filetypes, additionalSchemes) {\n    let documentSelector = [];\n    let schemes = ['file', 'untitled'].concat(additionalSchemes || []);\n    if (!filetypes)\n        return schemes.map(s => ({ scheme: s }));\n    filetypes.forEach(filetype => {\n        documentSelector.push(...schemes.map(scheme => ({ language: filetype, scheme })));\n    });\n    return documentSelector;\n}\nexports.getDocumentSelector = getDocumentSelector;\nfunction getTransportKind(config) {\n    let { transport, transportPort } = config;\n    if (!transport || transport == 'ipc')\n        return language_client_1.TransportKind.ipc;\n    if (transport == 'stdio')\n        return language_client_1.TransportKind.stdio;\n    if (transport == 'pipe')\n        return language_client_1.TransportKind.pipe;\n    return { kind: language_client_1.TransportKind.socket, port: transportPort };\n}\nexports.getTransportKind = getTransportKind;\nfunction getForkOptions(config) {\n    return {\n        cwd: config.cwd,\n        execArgv: config.execArgv || [],\n        env: config.env || undefined\n    };\n}\nfunction getSpawnOptions(config) {\n    return {\n        cwd: config.cwd,\n        detached: !!config.detached,\n        shell: !!config.shell,\n        env: config.env || undefined\n    };\n}\nfunction stateString(state) {\n    switch (state) {\n        case language_client_1.State.Running:\n            return 'running';\n        case language_client_1.State.Starting:\n            return 'starting';\n        case language_client_1.State.Stopped:\n            return 'stopped';\n        default:\n            return 'unknown';\n    }\n}\nexports.default = new ServiceManager();\n\n\n//# sourceURL=webpack://coc.nvim/./src/services.ts?");

/***/ }),

/***/ "./src/snippets/manager.ts":
/*!*********************************!*\
  !*** ./src/snippets/manager.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SnippetManager = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst Snippets = tslib_1.__importStar(__webpack_require__(/*! ./parser */ \"./src/snippets/parser.ts\"));\nconst session_1 = __webpack_require__(/*! ./session */ \"./src/snippets/session.ts\");\nconst variableResolve_1 = __webpack_require__(/*! ./variableResolve */ \"./src/snippets/variableResolve.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('snippets-manager');\nclass SnippetManager {\n    constructor() {\n        this.sessionMap = new Map();\n        this.disposables = [];\n        workspace_1.default.onDidChangeTextDocument(async (e) => {\n            let session = this.getSession(e.bufnr);\n            if (session) {\n                await session.synchronizeUpdatedPlaceholders(e.contentChanges[0]);\n            }\n        }, null, this.disposables);\n        workspace_1.default.onDidCloseTextDocument(textDocument => {\n            let doc = workspace_1.default.getDocument(textDocument.uri);\n            if (!doc)\n                return;\n            let session = this.getSession(doc.bufnr);\n            if (session)\n                session.deactivate();\n        }, null, this.disposables);\n        events_1.default.on('BufEnter', async (bufnr) => {\n            let session = this.getSession(bufnr);\n            if (!this.statusItem)\n                return;\n            if (session && session.isActive) {\n                this.statusItem.show();\n            }\n            else {\n                this.statusItem.hide();\n            }\n        }, null, this.disposables);\n        events_1.default.on('InsertEnter', async () => {\n            let { session } = this;\n            if (!session)\n                return;\n            await session.checkPosition();\n        }, null, this.disposables);\n    }\n    init() {\n        let config = workspace_1.default.getConfiguration('coc.preferences');\n        this.statusItem = window_1.default.createStatusBarItem(0);\n        this.statusItem.text = config.get('snippetStatusText', 'SNIP');\n    }\n    /**\n     * Insert snippet at current cursor position\n     */\n    async insertSnippet(snippet, select = true, range) {\n        let { bufnr } = workspace_1.default;\n        let session = this.getSession(bufnr);\n        if (!session) {\n            session = new session_1.SnippetSession(workspace_1.default.nvim, bufnr);\n            this.sessionMap.set(bufnr, session);\n            session.onCancel(() => {\n                this.sessionMap.delete(bufnr);\n                if (workspace_1.default.bufnr == bufnr) {\n                    this.statusItem.hide();\n                }\n            });\n        }\n        let isActive = await session.start(snippet, select, range);\n        if (isActive)\n            this.statusItem.show();\n        return isActive;\n    }\n    async selectCurrentPlaceholder(triggerAutocmd = true) {\n        let { session } = this;\n        if (session)\n            return await session.selectCurrentPlaceholder(triggerAutocmd);\n    }\n    async nextPlaceholder() {\n        let { session } = this;\n        if (session)\n            return await session.nextPlaceholder();\n        workspace_1.default.nvim.call('coc#snippet#disable', [], true);\n        this.statusItem.hide();\n    }\n    async previousPlaceholder() {\n        let { session } = this;\n        if (session)\n            return await session.previousPlaceholder();\n        workspace_1.default.nvim.call('coc#snippet#disable', [], true);\n        this.statusItem.hide();\n    }\n    cancel() {\n        let session = this.getSession(workspace_1.default.bufnr);\n        if (session)\n            return session.deactivate();\n        workspace_1.default.nvim.call('coc#snippet#disable', [], true);\n        if (this.statusItem)\n            this.statusItem.hide();\n    }\n    get session() {\n        let session = this.getSession(workspace_1.default.bufnr);\n        return session && session.isActive ? session : null;\n    }\n    isActived(bufnr) {\n        let session = this.getSession(bufnr);\n        return session && session.isActive;\n    }\n    jumpable() {\n        let { session } = this;\n        if (!session)\n            return false;\n        let placeholder = session.placeholder;\n        if (placeholder && !placeholder.isFinalTabstop) {\n            return true;\n        }\n        return false;\n    }\n    getSession(bufnr) {\n        return this.sessionMap.get(bufnr);\n    }\n    async resolveSnippet(body) {\n        let parser = new Snippets.SnippetParser();\n        const snippet = parser.parse(body, true);\n        const resolver = new variableResolve_1.SnippetVariableResolver();\n        await snippet.resolveVariables(resolver);\n        return snippet;\n    }\n    dispose() {\n        this.cancel();\n        for (let d of this.disposables) {\n            d.dispose();\n        }\n    }\n}\nexports.SnippetManager = SnippetManager;\nexports.default = new SnippetManager();\n\n\n//# sourceURL=webpack://coc.nvim/./src/snippets/manager.ts?");

/***/ }),

/***/ "./src/snippets/parser.ts":
/*!********************************!*\
  !*** ./src/snippets/parser.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* ---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SnippetParser = exports.TextmateSnippet = exports.Variable = exports.FormatString = exports.Transform = exports.Choice = exports.Placeholder = exports.TransformableMarker = exports.Text = exports.Marker = exports.Scanner = exports.TokenType = void 0;\nconst charCode_1 = __webpack_require__(/*! ../util/charCode */ \"./src/util/charCode.ts\");\nconst vscode_languageserver_textdocument_1 = __webpack_require__(/*! vscode-languageserver-textdocument */ \"./node_modules/vscode-languageserver-textdocument/lib/esm/main.js\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('snippets-parser');\nvar TokenType;\n(function (TokenType) {\n    TokenType[TokenType[\"Dollar\"] = 0] = \"Dollar\";\n    TokenType[TokenType[\"Colon\"] = 1] = \"Colon\";\n    TokenType[TokenType[\"Comma\"] = 2] = \"Comma\";\n    TokenType[TokenType[\"CurlyOpen\"] = 3] = \"CurlyOpen\";\n    TokenType[TokenType[\"CurlyClose\"] = 4] = \"CurlyClose\";\n    TokenType[TokenType[\"Backslash\"] = 5] = \"Backslash\";\n    TokenType[TokenType[\"Forwardslash\"] = 6] = \"Forwardslash\";\n    TokenType[TokenType[\"Pipe\"] = 7] = \"Pipe\";\n    TokenType[TokenType[\"Int\"] = 8] = \"Int\";\n    TokenType[TokenType[\"VariableName\"] = 9] = \"VariableName\";\n    TokenType[TokenType[\"Format\"] = 10] = \"Format\";\n    TokenType[TokenType[\"Plus\"] = 11] = \"Plus\";\n    TokenType[TokenType[\"Dash\"] = 12] = \"Dash\";\n    TokenType[TokenType[\"QuestionMark\"] = 13] = \"QuestionMark\";\n    TokenType[TokenType[\"EOF\"] = 14] = \"EOF\";\n})(TokenType = exports.TokenType || (exports.TokenType = {}));\nclass Scanner {\n    constructor() {\n        this.text('');\n    }\n    static isDigitCharacter(ch) {\n        return ch >= charCode_1.CharCode.Digit0 && ch <= charCode_1.CharCode.Digit9;\n    }\n    static isVariableCharacter(ch) {\n        return ch === charCode_1.CharCode.Underline\n            || (ch >= charCode_1.CharCode.a && ch <= charCode_1.CharCode.z)\n            || (ch >= charCode_1.CharCode.A && ch <= charCode_1.CharCode.Z);\n    }\n    text(value) {\n        this.value = value;\n        this.pos = 0;\n    }\n    tokenText(token) {\n        return this.value.substr(token.pos, token.len);\n    }\n    next() {\n        if (this.pos >= this.value.length) {\n            return { type: TokenType.EOF, pos: this.pos, len: 0 };\n        }\n        let pos = this.pos;\n        let len = 0;\n        let ch = this.value.charCodeAt(pos);\n        let type;\n        // static types\n        type = Scanner._table[ch];\n        if (typeof type === 'number') {\n            this.pos += 1;\n            return { type, pos, len: 1 };\n        }\n        // number\n        if (Scanner.isDigitCharacter(ch)) {\n            type = TokenType.Int;\n            do {\n                len += 1;\n                ch = this.value.charCodeAt(pos + len);\n            } while (Scanner.isDigitCharacter(ch));\n            this.pos += len;\n            return { type, pos, len };\n        }\n        // variable name\n        if (Scanner.isVariableCharacter(ch)) {\n            type = TokenType.VariableName;\n            do {\n                ch = this.value.charCodeAt(pos + (++len));\n            } while (Scanner.isVariableCharacter(ch) || Scanner.isDigitCharacter(ch));\n            this.pos += len;\n            return { type, pos, len };\n        }\n        // format\n        type = TokenType.Format;\n        do {\n            len += 1;\n            ch = this.value.charCodeAt(pos + len);\n        } while (!isNaN(ch)\n            && typeof Scanner._table[ch] === 'undefined' // not static token\n            && !Scanner.isDigitCharacter(ch) // not number\n            && !Scanner.isVariableCharacter(ch) // not variable\n        );\n        this.pos += len;\n        return { type, pos, len };\n    }\n}\nexports.Scanner = Scanner;\nScanner._table = {\n    [charCode_1.CharCode.DollarSign]: TokenType.Dollar,\n    [charCode_1.CharCode.Colon]: TokenType.Colon,\n    [charCode_1.CharCode.Comma]: TokenType.Comma,\n    [charCode_1.CharCode.OpenCurlyBrace]: TokenType.CurlyOpen,\n    [charCode_1.CharCode.CloseCurlyBrace]: TokenType.CurlyClose,\n    [charCode_1.CharCode.Backslash]: TokenType.Backslash,\n    [charCode_1.CharCode.Slash]: TokenType.Forwardslash,\n    [charCode_1.CharCode.Pipe]: TokenType.Pipe,\n    [charCode_1.CharCode.Plus]: TokenType.Plus,\n    [charCode_1.CharCode.Dash]: TokenType.Dash,\n    [charCode_1.CharCode.QuestionMark]: TokenType.QuestionMark,\n};\nclass Marker {\n    constructor() {\n        this._children = [];\n    }\n    appendChild(child) {\n        if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {\n            // this and previous child are text -> merge them\n            this._children[this._children.length - 1].value += child.value;\n        }\n        else {\n            // normal adoption of child\n            child.parent = this;\n            this._children.push(child);\n        }\n        return this;\n    }\n    setOnlyChild(child) {\n        child.parent = this;\n        this._children = [child];\n    }\n    replace(child, others) {\n        const { parent } = child;\n        const idx = parent.children.indexOf(child);\n        const newChildren = parent.children.slice(0);\n        newChildren.splice(idx, 1, ...others);\n        parent._children = newChildren;\n        (function _fixParent(children, parent) {\n            for (const child of children) {\n                child.parent = parent;\n                _fixParent(child.children, child);\n            }\n        })(others, parent);\n    }\n    get children() {\n        return this._children;\n    }\n    get snippet() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let candidate = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            if (!candidate) {\n                return undefined;\n            }\n            if (candidate instanceof TextmateSnippet) {\n                return candidate;\n            }\n            candidate = candidate.parent;\n        }\n    }\n    toString() {\n        return this.children.reduce((prev, cur) => prev + cur.toString(), '');\n    }\n    len() {\n        return 0;\n    }\n    get next() {\n        let { parent } = this;\n        let { children } = parent;\n        let idx = children.indexOf(this);\n        return children[idx + 1];\n    }\n}\nexports.Marker = Marker;\nclass Text extends Marker {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    static escape(value) {\n        return value.replace(/\\$|}|\\\\/g, '\\\\$&');\n    }\n    toString() {\n        return this.value;\n    }\n    toTextmateString() {\n        return Text.escape(this.value);\n    }\n    len() {\n        return this.value.length;\n    }\n    clone() {\n        return new Text(this.value);\n    }\n}\nexports.Text = Text;\nclass TransformableMarker extends Marker {\n}\nexports.TransformableMarker = TransformableMarker;\nclass Placeholder extends TransformableMarker {\n    constructor(index) {\n        super();\n        this.index = index;\n    }\n    static compareByIndex(a, b) {\n        if (a.index === b.index) {\n            return 0;\n        }\n        else if (a.isFinalTabstop) {\n            return 1;\n        }\n        else if (b.isFinalTabstop) {\n            return -1;\n        }\n        else if (a.index < b.index) {\n            return -1;\n        }\n        else if (a.index > b.index) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    get isFinalTabstop() {\n        return this.index === 0;\n    }\n    get choice() {\n        return this._children.length === 1 && this._children[0] instanceof Choice\n            ? this._children[0]\n            : undefined;\n    }\n    toTextmateString() {\n        let transformString = '';\n        if (this.transform) {\n            transformString = this.transform.toTextmateString();\n        }\n        if (this.children.length === 0 && !this.transform) {\n            return `$${this.index}`;\n        }\n        else if (this.children.length === 0) {\n            return `\\${${this.index}${transformString}}`;\n        }\n        else if (this.choice) {\n            return `\\${${this.index}|${this.choice.toTextmateString()}|${transformString}}`;\n        }\n        else {\n            return `\\${${this.index}:${this.children.map(child => child.toTextmateString()).join('')}${transformString}}`;\n        }\n    }\n    clone() {\n        let ret = new Placeholder(this.index);\n        if (this.transform) {\n            ret.transform = this.transform.clone();\n        }\n        ret._children = this.children.map(child => child.clone());\n        return ret;\n    }\n}\nexports.Placeholder = Placeholder;\nclass Choice extends Marker {\n    constructor() {\n        super(...arguments);\n        this.options = [];\n    }\n    appendChild(marker) {\n        if (marker instanceof Text) {\n            marker.parent = this;\n            this.options.push(marker);\n        }\n        return this;\n    }\n    toString() {\n        return this.options[0].value;\n    }\n    toTextmateString() {\n        return this.options\n            .map(option => option.value.replace(/\\||,/g, '\\\\$&'))\n            .join(',');\n    }\n    len() {\n        return this.options[0].len();\n    }\n    clone() {\n        let ret = new Choice();\n        for (let opt of this.options) {\n            ret.appendChild(opt);\n        }\n        return ret;\n    }\n}\nexports.Choice = Choice;\nclass Transform extends Marker {\n    resolve(value) {\n        let didMatch = false;\n        let ret = value.replace(this.regexp, (...args) => {\n            didMatch = true;\n            return this._replace(args.slice(0, -2));\n        });\n        // when the regex didn't match and when the transform has\n        // else branches, then run those\n        if (!didMatch && this._children.some(child => child instanceof FormatString && Boolean(child.elseValue))) {\n            ret = this._replace([]);\n        }\n        return ret;\n    }\n    _replace(groups) {\n        let ret = '';\n        for (const marker of this._children) {\n            if (marker instanceof FormatString) {\n                let value = groups[marker.index] || '';\n                value = marker.resolve(value);\n                ret += value;\n            }\n            else {\n                ret += marker.toString();\n            }\n        }\n        return ret;\n    }\n    toString() {\n        return '';\n    }\n    toTextmateString() {\n        return `/${this.regexp.source}/${this.children.map(c => c.toTextmateString())}/${(this.regexp.ignoreCase ? 'i' : '') + (this.regexp.global ? 'g' : '')}`;\n    }\n    clone() {\n        let ret = new Transform();\n        ret.regexp = new RegExp(this.regexp.source, '' + (this.regexp.ignoreCase ? 'i' : '') + (this.regexp.global ? 'g' : ''));\n        ret._children = this.children.map(child => child.clone());\n        return ret;\n    }\n}\nexports.Transform = Transform;\nclass FormatString extends Marker {\n    constructor(index, shorthandName, ifValue, elseValue) {\n        super();\n        this.index = index;\n        this.shorthandName = shorthandName;\n        this.ifValue = ifValue;\n        this.elseValue = elseValue;\n    }\n    resolve(value) {\n        if (this.shorthandName === 'upcase') {\n            return !value ? '' : value.toLocaleUpperCase();\n        }\n        else if (this.shorthandName === 'downcase') {\n            return !value ? '' : value.toLocaleLowerCase();\n        }\n        else if (this.shorthandName === 'capitalize') {\n            return !value ? '' : (value[0].toLocaleUpperCase() + value.substr(1));\n        }\n        else if (this.shorthandName === 'pascalcase') {\n            return !value ? '' : this._toPascalCase(value);\n        }\n        else if (Boolean(value) && typeof this.ifValue === 'string') {\n            return this.ifValue;\n        }\n        else if (!value && typeof this.elseValue === 'string') {\n            return this.elseValue;\n        }\n        else {\n            return value || '';\n        }\n    }\n    _toPascalCase(value) {\n        const match = value.match(/[a-z]+/gi);\n        if (!match) {\n            return value;\n        }\n        return match.map(word => word.charAt(0).toUpperCase()\n            + word.substr(1).toLowerCase())\n            .join('');\n    }\n    toTextmateString() {\n        let value = '${';\n        value += this.index;\n        if (this.shorthandName) {\n            value += `:/${this.shorthandName}`;\n        }\n        else if (this.ifValue && this.elseValue) {\n            value += `:?${this.ifValue}:${this.elseValue}`;\n        }\n        else if (this.ifValue) {\n            value += `:+${this.ifValue}`;\n        }\n        else if (this.elseValue) {\n            value += `:-${this.elseValue}`;\n        }\n        value += '}';\n        return value;\n    }\n    clone() {\n        let ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);\n        return ret;\n    }\n}\nexports.FormatString = FormatString;\nclass Variable extends TransformableMarker {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n    async resolve(resolver) {\n        let value = await resolver.resolve(this);\n        if (value && value.includes('\\n')) {\n            // get indent from previous texts\n            let indent = '';\n            this.snippet.walk(m => {\n                if (m == this) {\n                    return false;\n                }\n                if (m instanceof Text) {\n                    let lines = m.toString().split(/\\r?\\n/);\n                    indent = lines[lines.length - 1].match(/^\\s*/)[0];\n                }\n                return true;\n            });\n            let lines = value.split('\\n');\n            let indents = lines.filter(s => s.length > 0).map(s => s.match(/^\\s*/)[0]);\n            let minIndent = indents.length == 0 ? '' :\n                indents.reduce((p, c) => p.length < c.length ? p : c);\n            let newLines = lines.map((s, i) => i == 0 || s.length == 0 || !s.startsWith(minIndent) ? s :\n                indent + s.slice(minIndent.length));\n            value = newLines.join('\\n');\n        }\n        if (this.transform) {\n            value = this.transform.resolve(value || '');\n        }\n        if (value !== undefined) {\n            this._children = [new Text(value)];\n            return true;\n        }\n        return false;\n    }\n    toTextmateString() {\n        let transformString = '';\n        if (this.transform) {\n            transformString = this.transform.toTextmateString();\n        }\n        if (this.children.length === 0) {\n            return `\\${${this.name}${transformString}}`;\n        }\n        else {\n            return `\\${${this.name}:${this.children.map(child => child.toTextmateString()).join('')}${transformString}}`;\n        }\n    }\n    clone() {\n        const ret = new Variable(this.name);\n        if (this.transform) {\n            ret.transform = this.transform.clone();\n        }\n        ret._children = this.children.map(child => child.clone());\n        return ret;\n    }\n}\nexports.Variable = Variable;\nfunction walk(marker, visitor) {\n    const stack = [...marker];\n    while (stack.length > 0) {\n        const marker = stack.shift();\n        const recurse = visitor(marker);\n        if (!recurse) {\n            break;\n        }\n        stack.unshift(...marker.children);\n    }\n}\nclass TextmateSnippet extends Marker {\n    get placeholderInfo() {\n        if (!this._placeholders) {\n            this._variables = [];\n            // fill in placeholders\n            let all = [];\n            let last;\n            this.walk(candidate => {\n                if (candidate instanceof Placeholder) {\n                    all.push(candidate);\n                    last = !last || last.index < candidate.index ? candidate : last;\n                }\n                else if (candidate instanceof Variable) {\n                    let first = candidate.name.charCodeAt(0);\n                    // not jumpover for uppercase variable.\n                    if (first < 65 || first > 90) {\n                        this._variables.push(candidate);\n                    }\n                }\n                return true;\n            });\n            this._placeholders = { all, last };\n        }\n        return this._placeholders;\n    }\n    get variables() {\n        return this._variables;\n    }\n    get placeholders() {\n        const { all } = this.placeholderInfo;\n        return all;\n    }\n    get maxIndexNumber() {\n        let { placeholders } = this;\n        return placeholders.reduce((curr, p) => Math.max(curr, p.index), 0);\n    }\n    get minIndexNumber() {\n        let { placeholders } = this;\n        let nums = placeholders.map(p => p.index);\n        nums.sort((a, b) => a - b);\n        if (nums.length > 1 && nums[0] == 0)\n            return nums[1];\n        return nums[0] || 0;\n    }\n    insertSnippet(snippet, id, range) {\n        let placeholder = this.placeholders[id];\n        if (!placeholder)\n            return;\n        let { index } = placeholder;\n        const document = vscode_languageserver_textdocument_1.TextDocument.create('untitled:/1', 'snippet', 0, placeholder.toString());\n        snippet = vscode_languageserver_textdocument_1.TextDocument.applyEdits(document, [{ range, newText: snippet }]);\n        let nested = new SnippetParser().parse(snippet, true);\n        let maxIndexAdded = nested.maxIndexNumber + 1;\n        let indexes = [];\n        for (let p of nested.placeholders) {\n            if (p.isFinalTabstop) {\n                p.index = maxIndexAdded + index;\n            }\n            else {\n                p.index = p.index + index;\n            }\n            indexes.push(p.index);\n        }\n        this.walk(m => {\n            if (m instanceof Placeholder && m.index > index) {\n                m.index = m.index + maxIndexAdded;\n            }\n            return true;\n        });\n        this.replace(placeholder, nested.children);\n        return Math.min.apply(null, indexes);\n    }\n    updatePlaceholder(id, val) {\n        const placeholder = this.placeholders[id];\n        for (let p of this.placeholders) {\n            if (p.index == placeholder.index) {\n                let child = p.children[0];\n                let newText = p.transform ? p.transform.resolve(val) : val;\n                if (child) {\n                    p.setOnlyChild(new Text(newText));\n                }\n                else {\n                    p.appendChild(new Text(newText));\n                }\n            }\n        }\n        this._placeholders = undefined;\n    }\n    updateVariable(id, val) {\n        const find = this.variables[id - this.maxIndexNumber - 1];\n        if (find) {\n            let variables = this.variables.filter(o => o.name == find.name);\n            for (let variable of variables) {\n                let newText = variable.transform ? variable.transform.resolve(val) : val;\n                variable.setOnlyChild(new Text(newText));\n            }\n        }\n    }\n    /**\n     * newText after update with value\n     */\n    getPlaceholderText(id, value) {\n        const placeholder = this.placeholders[id];\n        if (!placeholder)\n            return value;\n        return placeholder.transform ? placeholder.transform.resolve(value) : value;\n    }\n    offset(marker) {\n        let pos = 0;\n        let found = false;\n        this.walk(candidate => {\n            if (candidate === marker) {\n                found = true;\n                return false;\n            }\n            pos += candidate.len();\n            return true;\n        });\n        if (!found) {\n            return -1;\n        }\n        return pos;\n    }\n    fullLen(marker) {\n        let ret = 0;\n        walk([marker], marker => {\n            ret += marker.len();\n            return true;\n        });\n        return ret;\n    }\n    enclosingPlaceholders(placeholder) {\n        let ret = [];\n        let { parent } = placeholder;\n        while (parent) {\n            if (parent instanceof Placeholder) {\n                ret.push(parent);\n            }\n            parent = parent.parent;\n        }\n        return ret;\n    }\n    async resolveVariables(resolver) {\n        let items = [];\n        this.walk(candidate => {\n            if (candidate instanceof Variable) {\n                items.push(candidate);\n            }\n            return true;\n        });\n        await Promise.all(items.map(o => o.resolve(resolver)));\n    }\n    appendChild(child) {\n        this._placeholders = undefined;\n        return super.appendChild(child);\n    }\n    replace(child, others) {\n        this._placeholders = undefined;\n        return super.replace(child, others);\n    }\n    toTextmateString() {\n        return this.children.reduce((prev, cur) => prev + cur.toTextmateString(), '');\n    }\n    clone() {\n        let ret = new TextmateSnippet();\n        this._children = this.children.map(child => child.clone());\n        return ret;\n    }\n    walk(visitor) {\n        walk(this.children, visitor);\n    }\n}\nexports.TextmateSnippet = TextmateSnippet;\nclass SnippetParser {\n    constructor() {\n        this._scanner = new Scanner();\n    }\n    static escape(value) {\n        return value.replace(/\\$|}|\\\\/g, '\\\\$&');\n    }\n    text(value) {\n        return this.parse(value).toString();\n    }\n    parse(value, insertFinalTabstop) {\n        this._scanner.text(value);\n        this._token = this._scanner.next();\n        const snippet = new TextmateSnippet();\n        while (this._parse(snippet)) {\n            // nothing\n        }\n        // fill in values for placeholders. the first placeholder of an index\n        // that has a value defines the value for all placeholders with that index\n        const placeholderDefaultValues = new Map();\n        const incompletePlaceholders = [];\n        snippet.walk(marker => {\n            if (marker instanceof Placeholder) {\n                if (marker.isFinalTabstop) {\n                    placeholderDefaultValues.set(0, undefined);\n                }\n                else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {\n                    placeholderDefaultValues.set(marker.index, marker.children);\n                }\n                else {\n                    incompletePlaceholders.push(marker);\n                }\n            }\n            return true;\n        });\n        for (const placeholder of incompletePlaceholders) {\n            if (placeholderDefaultValues.has(placeholder.index)) {\n                const clone = new Placeholder(placeholder.index);\n                clone.transform = placeholder.transform;\n                for (const child of placeholderDefaultValues.get(placeholder.index)) {\n                    let marker = child.clone();\n                    if (clone.transform) {\n                        if (marker instanceof Text) {\n                            marker = new Text(clone.transform.resolve(marker.value));\n                        }\n                        else {\n                            for (let child of marker.children) {\n                                if (child instanceof Text) {\n                                    marker.replace(child, [new Text(clone.transform.resolve(child.value))]);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    clone.appendChild(marker);\n                }\n                snippet.replace(placeholder, [clone]);\n            }\n        }\n        if (!placeholderDefaultValues.has(0) && insertFinalTabstop) {\n            // the snippet uses placeholders but has no\n            // final tabstop defined -> insert at the end\n            snippet.appendChild(new Placeholder(0));\n        }\n        return snippet;\n    }\n    _accept(type, value) {\n        if (type === undefined || this._token.type === type) {\n            let ret = !value ? true : this._scanner.tokenText(this._token);\n            this._token = this._scanner.next();\n            return ret;\n        }\n        return false;\n    }\n    _backTo(token) {\n        this._scanner.pos = token.pos + token.len;\n        this._token = token;\n        return false;\n    }\n    _until(type) {\n        if (this._token.type === TokenType.EOF) {\n            return false;\n        }\n        let start = this._token;\n        while (this._token.type !== type) {\n            this._token = this._scanner.next();\n            if (this._token.type === TokenType.EOF) {\n                return false;\n            }\n        }\n        let value = this._scanner.value.substring(start.pos, this._token.pos);\n        this._token = this._scanner.next();\n        return value;\n    }\n    _parse(marker) {\n        return this._parseEscaped(marker)\n            || this._parseTabstopOrVariableName(marker)\n            || this._parseComplexPlaceholder(marker)\n            || this._parseComplexVariable(marker)\n            || this._parseAnything(marker);\n    }\n    // \\$, \\\\, \\} -> just text\n    _parseEscaped(marker) {\n        let value;\n        // eslint-disable-next-line no-cond-assign\n        if (value = this._accept(TokenType.Backslash, true)) {\n            // saw a backslash, append escaped token or that backslash\n            value = this._accept(TokenType.Dollar, true)\n                || this._accept(TokenType.CurlyClose, true)\n                || this._accept(TokenType.Backslash, true)\n                || value;\n            marker.appendChild(new Text(value));\n            return true;\n        }\n        return false;\n    }\n    // $foo -> variable, $1 -> tabstop\n    _parseTabstopOrVariableName(parent) {\n        let value;\n        const token = this._token;\n        const match = this._accept(TokenType.Dollar)\n            && (value = this._accept(TokenType.VariableName, true) || this._accept(TokenType.Int, true));\n        if (!match) {\n            return this._backTo(token);\n        }\n        parent.appendChild(/^\\d+$/.test(value)\n            ? new Placeholder(Number(value))\n            : new Variable(value));\n        return true;\n    }\n    // ${1:<children>}, ${1} -> placeholder\n    _parseComplexPlaceholder(parent) {\n        let index;\n        const token = this._token;\n        const match = this._accept(TokenType.Dollar)\n            && this._accept(TokenType.CurlyOpen)\n            && (index = this._accept(TokenType.Int, true));\n        if (!match) {\n            return this._backTo(token);\n        }\n        const placeholder = new Placeholder(Number(index));\n        if (this._accept(TokenType.Colon)) {\n            // ${1:<children>}\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                // ...} -> done\n                if (this._accept(TokenType.CurlyClose)) {\n                    parent.appendChild(placeholder);\n                    return true;\n                }\n                if (this._parse(placeholder)) {\n                    continue;\n                }\n                // fallback\n                parent.appendChild(new Text('${' + index + ':'));\n                placeholder.children.forEach(parent.appendChild, parent);\n                return true;\n            }\n        }\n        else if (placeholder.index > 0 && this._accept(TokenType.Pipe)) {\n            // ${1|one,two,three|}\n            const choice = new Choice();\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                if (this._parseChoiceElement(choice)) {\n                    if (this._accept(TokenType.Comma)) {\n                        // opt, -> more\n                        continue;\n                    }\n                    if (this._accept(TokenType.Pipe)) {\n                        placeholder.appendChild(choice);\n                        if (this._accept(TokenType.CurlyClose)) {\n                            // ..|} -> done\n                            parent.appendChild(placeholder);\n                            return true;\n                        }\n                    }\n                }\n                this._backTo(token);\n                return false;\n            }\n        }\n        else if (this._accept(TokenType.Forwardslash)) {\n            // ${1/<regex>/<format>/<options>}\n            if (this._parseTransform(placeholder)) {\n                parent.appendChild(placeholder);\n                return true;\n            }\n            this._backTo(token);\n            return false;\n        }\n        else if (this._accept(TokenType.CurlyClose)) {\n            // ${1}\n            parent.appendChild(placeholder);\n            return true;\n        }\n        else {\n            // ${1 <- missing curly or colon\n            return this._backTo(token);\n        }\n    }\n    _parseChoiceElement(parent) {\n        const token = this._token;\n        const values = [];\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            if (this._token.type === TokenType.Comma || this._token.type === TokenType.Pipe) {\n                break;\n            }\n            let value;\n            // eslint-disable-next-line no-cond-assign\n            if (value = this._accept(TokenType.Backslash, true)) {\n                // \\, \\|, or \\\\\n                value = this._accept(TokenType.Comma, true)\n                    || this._accept(TokenType.Pipe, true)\n                    || this._accept(TokenType.Backslash, true)\n                    || value;\n            }\n            else {\n                value = this._accept(undefined, true);\n            }\n            if (!value) {\n                // EOF\n                this._backTo(token);\n                return false;\n            }\n            values.push(value);\n        }\n        if (values.length === 0) {\n            this._backTo(token);\n            return false;\n        }\n        parent.appendChild(new Text(values.join('')));\n        return true;\n    }\n    // ${foo:<children>}, ${foo} -> variable\n    _parseComplexVariable(parent) {\n        let name;\n        const token = this._token;\n        const match = this._accept(TokenType.Dollar)\n            && this._accept(TokenType.CurlyOpen)\n            && (name = this._accept(TokenType.VariableName, true));\n        if (!match) {\n            return this._backTo(token);\n        }\n        const variable = new Variable(name);\n        if (this._accept(TokenType.Colon)) {\n            // ${foo:<children>}\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                // ...} -> done\n                if (this._accept(TokenType.CurlyClose)) {\n                    parent.appendChild(variable);\n                    return true;\n                }\n                if (this._parse(variable)) {\n                    continue;\n                }\n                // fallback\n                parent.appendChild(new Text('${' + name + ':'));\n                variable.children.forEach(parent.appendChild, parent);\n                return true;\n            }\n        }\n        else if (this._accept(TokenType.Forwardslash)) {\n            // ${foo/<regex>/<format>/<options>}\n            if (this._parseTransform(variable)) {\n                parent.appendChild(variable);\n                return true;\n            }\n            this._backTo(token);\n            return false;\n        }\n        else if (this._accept(TokenType.CurlyClose)) {\n            // ${foo}\n            parent.appendChild(variable);\n            return true;\n        }\n        else {\n            // ${foo <- missing curly or colon\n            return this._backTo(token);\n        }\n    }\n    _parseTransform(parent) {\n        // ...<regex>/<format>/<options>}\n        let transform = new Transform();\n        let regexValue = '';\n        let regexOptions = '';\n        // (1) /regex\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            if (this._accept(TokenType.Forwardslash)) {\n                break;\n            }\n            let escaped;\n            // eslint-disable-next-line no-cond-assign\n            if (escaped = this._accept(TokenType.Backslash, true)) {\n                escaped = this._accept(TokenType.Forwardslash, true) || escaped;\n                regexValue += escaped;\n                continue;\n            }\n            if (this._token.type !== TokenType.EOF) {\n                regexValue += this._accept(undefined, true);\n                continue;\n            }\n            return false;\n        }\n        // (2) /format\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            if (this._accept(TokenType.Forwardslash)) {\n                break;\n            }\n            let escaped;\n            // eslint-disable-next-line no-cond-assign\n            if (escaped = this._accept(TokenType.Backslash, true)) {\n                escaped = this._accept(TokenType.Forwardslash, true) || escaped;\n                transform.appendChild(new Text(escaped));\n                continue;\n            }\n            if (this._parseFormatString(transform) || this._parseAnything(transform)) {\n                let text = transform.children[0];\n                if (text && text.value && text.value.includes('\\\\n')) {\n                    text.value = text.value.replace(/\\\\n/g, '\\n');\n                }\n                continue;\n            }\n            return false;\n        }\n        // (3) /option\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            if (this._accept(TokenType.CurlyClose)) {\n                break;\n            }\n            if (this._token.type !== TokenType.EOF) {\n                regexOptions += this._accept(undefined, true);\n                continue;\n            }\n            return false;\n        }\n        try {\n            transform.regexp = new RegExp(regexValue, regexOptions);\n        }\n        catch (e) {\n            // invalid regexp\n            return false;\n        }\n        parent.transform = transform;\n        return true;\n    }\n    _parseFormatString(parent) {\n        const token = this._token;\n        if (!this._accept(TokenType.Dollar)) {\n            return false;\n        }\n        let complex = false;\n        if (this._accept(TokenType.CurlyOpen)) {\n            complex = true;\n        }\n        let index = this._accept(TokenType.Int, true);\n        if (!index) {\n            this._backTo(token);\n            return false;\n        }\n        else if (!complex) {\n            // $1\n            parent.appendChild(new FormatString(Number(index)));\n            return true;\n        }\n        else if (this._accept(TokenType.CurlyClose)) {\n            // ${1}\n            parent.appendChild(new FormatString(Number(index)));\n            return true;\n        }\n        else if (!this._accept(TokenType.Colon)) {\n            this._backTo(token);\n            return false;\n        }\n        if (this._accept(TokenType.Forwardslash)) {\n            // ${1:/upcase}\n            let shorthand = this._accept(TokenType.VariableName, true);\n            if (!shorthand || !this._accept(TokenType.CurlyClose)) {\n                this._backTo(token);\n                return false;\n            }\n            else {\n                parent.appendChild(new FormatString(Number(index), shorthand));\n                return true;\n            }\n        }\n        else if (this._accept(TokenType.Plus)) {\n            // ${1:+<if>}\n            let ifValue = this._until(TokenType.CurlyClose);\n            if (ifValue) {\n                parent.appendChild(new FormatString(Number(index), undefined, ifValue, undefined));\n                return true;\n            }\n        }\n        else if (this._accept(TokenType.Dash)) {\n            // ${2:-<else>}\n            let elseValue = this._until(TokenType.CurlyClose);\n            if (elseValue) {\n                parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));\n                return true;\n            }\n        }\n        else if (this._accept(TokenType.QuestionMark)) {\n            // ${2:?<if>:<else>}\n            let ifValue = this._until(TokenType.Colon);\n            if (ifValue) {\n                let elseValue = this._until(TokenType.CurlyClose);\n                if (elseValue) {\n                    parent.appendChild(new FormatString(Number(index), undefined, ifValue, elseValue));\n                    return true;\n                }\n            }\n        }\n        else {\n            // ${1:<else>}\n            let elseValue = this._until(TokenType.CurlyClose);\n            if (elseValue) {\n                parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));\n                return true;\n            }\n        }\n        this._backTo(token);\n        return false;\n    }\n    _parseAnything(marker) {\n        if (this._token.type !== TokenType.EOF) {\n            let text = this._scanner.tokenText(this._token);\n            marker.appendChild(new Text(text));\n            this._accept(undefined);\n            return true;\n        }\n        return false;\n    }\n}\nexports.SnippetParser = SnippetParser;\n\n\n//# sourceURL=webpack://coc.nvim/./src/snippets/parser.ts?");

/***/ }),

/***/ "./src/snippets/session.ts":
/*!*********************************!*\
  !*** ./src/snippets/session.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.normalizeSnippetString = exports.SnippetSession = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst completion_1 = tslib_1.__importDefault(__webpack_require__(/*! ../completion */ \"./src/completion/index.ts\"));\nconst position_1 = __webpack_require__(/*! ../util/position */ \"./src/util/position.ts\");\nconst string_1 = __webpack_require__(/*! ../util/string */ \"./src/util/string.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ../events */ \"./src/events.ts\"));\nconst snippet_1 = __webpack_require__(/*! ./snippet */ \"./src/snippets/snippet.ts\");\nconst variableResolve_1 = __webpack_require__(/*! ./variableResolve */ \"./src/snippets/variableResolve.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('snippets-session');\nclass SnippetSession {\n    constructor(nvim, bufnr) {\n        this.nvim = nvim;\n        this.bufnr = bufnr;\n        this._isActive = false;\n        this._currId = 0;\n        // Get state of line where we inserted\n        this.applying = false;\n        this.preferComplete = false;\n        this._snippet = null;\n        this._onCancelEvent = new vscode_languageserver_protocol_1.Emitter();\n        this.onCancel = this._onCancelEvent.event;\n        let config = workspace_1.default.getConfiguration('coc.preferences');\n        let suggest = workspace_1.default.getConfiguration('suggest');\n        this.preferComplete = config.get('preferCompleteThanJumpPlaceholder', suggest.get('preferCompleteThanJumpPlaceholder', false));\n    }\n    async start(snippetString, select = true, range) {\n        const { document } = this;\n        if (!document || !document.attached)\n            return false;\n        events_1.default.fire('InsertSnippet', []).logError();\n        if (!range) {\n            let position = await window_1.default.getCursorPosition();\n            range = vscode_languageserver_protocol_1.Range.create(position, position);\n        }\n        let position = range.start;\n        const formatOptions = await workspace_1.default.getFormatOptions(this.document.uri);\n        await document.patchChange(true);\n        const currentLine = document.getline(position.line);\n        const currentIndent = currentLine.match(/^\\s*/)[0];\n        let inserted = normalizeSnippetString(snippetString, currentIndent, formatOptions);\n        const resolver = new variableResolve_1.SnippetVariableResolver();\n        const snippet = new snippet_1.CocSnippet(inserted, position, resolver);\n        await snippet.init();\n        const edit = vscode_languageserver_protocol_1.TextEdit.replace(range, snippet.toString());\n        if (snippetString.endsWith('\\n')\n            && currentLine.slice(position.character).length) {\n            // make next line same indent\n            edit.newText = edit.newText + currentIndent;\n            inserted = inserted + currentIndent;\n        }\n        this.applying = true;\n        await document.applyEdits([edit]);\n        this.applying = false;\n        if (this._isActive) {\n            // find valid placeholder\n            let placeholder = this.findPlaceholder(range);\n            // insert to placeholder\n            if (placeholder && !placeholder.isFinalTabstop) {\n                // don't repeat snippet insert\n                let index = this.snippet.insertSnippet(placeholder, inserted, range);\n                let p = this.snippet.getPlaceholder(index);\n                this._currId = p.id;\n                if (select)\n                    await this.selectPlaceholder(p);\n                return true;\n            }\n        }\n        if (snippet.isPlainText) {\n            this.deactivate();\n            let placeholder = snippet.finalPlaceholder;\n            await window_1.default.moveTo(placeholder.range.start);\n            return false;\n        }\n        // new snippet\n        this._snippet = snippet;\n        this._currId = snippet.firstPlaceholder.id;\n        if (select)\n            await this.selectPlaceholder(snippet.firstPlaceholder);\n        this.activate();\n        return true;\n    }\n    activate() {\n        if (this._isActive)\n            return;\n        this._isActive = true;\n        this.nvim.call('coc#snippet#enable', [], true);\n    }\n    deactivate() {\n        if (this._isActive) {\n            this._isActive = false;\n            this._snippet = null;\n            this.nvim.call('coc#snippet#disable', [], true);\n            logger.debug(\"[SnippetManager::cancel]\");\n        }\n        this._onCancelEvent.fire(void 0);\n        this._onCancelEvent.dispose();\n    }\n    get isActive() {\n        return this._isActive;\n    }\n    async nextPlaceholder() {\n        if (!this.isActive)\n            return;\n        await this.document.patchChange();\n        let curr = this.placeholder;\n        let next = this.snippet.getNextPlaceholder(curr.index);\n        await this.selectPlaceholder(next);\n    }\n    async previousPlaceholder() {\n        if (!this.isActive)\n            return;\n        await this.document.patchChange();\n        let curr = this.placeholder;\n        let prev = this.snippet.getPrevPlaceholder(curr.index);\n        await this.selectPlaceholder(prev);\n    }\n    async synchronizeUpdatedPlaceholders(change) {\n        if (!this.isActive || !this.document || this.applying)\n            return;\n        let edit = { range: change.range, newText: change.text };\n        let { snippet } = this;\n        // change outside range\n        let adjusted = snippet.adjustTextEdit(edit);\n        if (adjusted)\n            return;\n        if (position_1.comparePosition(edit.range.start, snippet.range.end) > 0) {\n            if (!edit.newText)\n                return;\n            logger.info('Content change after snippet, cancelling snippet session');\n            this.deactivate();\n            return;\n        }\n        let placeholder = this.findPlaceholder(edit.range);\n        if (!placeholder) {\n            logger.info('Change outside placeholder, cancelling snippet session');\n            this.deactivate();\n            return;\n        }\n        if (placeholder.isFinalTabstop && snippet.finalCount <= 1) {\n            logger.info('Change final placeholder, cancelling snippet session');\n            this.deactivate();\n            return;\n        }\n        this._currId = placeholder.id;\n        let { edits, delta } = snippet.updatePlaceholder(placeholder, edit);\n        if (!edits.length)\n            return;\n        this.applying = true;\n        await this.document.applyEdits(edits);\n        this.applying = false;\n        if (delta) {\n            await this.nvim.call('coc#util#move_cursor', delta);\n        }\n    }\n    async selectCurrentPlaceholder(triggerAutocmd = true) {\n        let placeholder = this.snippet.getPlaceholderById(this._currId);\n        if (placeholder)\n            await this.selectPlaceholder(placeholder, triggerAutocmd);\n    }\n    async selectPlaceholder(placeholder, triggerAutocmd = true) {\n        let { nvim, document } = this;\n        if (!document || !placeholder)\n            return;\n        let { start, end } = placeholder.range;\n        const len = end.character - start.character;\n        const col = string_1.byteLength(document.getline(start.line).slice(0, start.character)) + 1;\n        this._currId = placeholder.id;\n        if (placeholder.choice) {\n            await nvim.call('coc#snippet#show_choices', [start.line + 1, col, len, placeholder.choice]);\n            if (triggerAutocmd)\n                nvim.call('coc#util#do_autocmd', ['CocJumpPlaceholder'], true);\n        }\n        else {\n            await this.select(placeholder, triggerAutocmd);\n        }\n    }\n    async select(placeholder, triggerAutocmd = true) {\n        let { range, value, isFinalTabstop } = placeholder;\n        let { document, nvim } = this;\n        let { start, end } = range;\n        let { textDocument } = document;\n        let len = textDocument.offsetAt(end) - textDocument.offsetAt(start);\n        let line = document.getline(start.line);\n        let col = line ? string_1.byteLength(line.slice(0, start.character)) : 0;\n        let endLine = document.getline(end.line);\n        let endCol = endLine ? string_1.byteLength(endLine.slice(0, end.character)) : 0;\n        nvim.setVar('coc_last_placeholder', {\n            current_text: value,\n            start: { line: start.line, col },\n            end: { line: end.line, col: endCol }\n        }, true);\n        let [ve, selection, pumvisible, mode] = await nvim.eval('[&virtualedit, &selection, pumvisible(), mode()]');\n        let move_cmd = '';\n        if (pumvisible && this.preferComplete) {\n            let pre = completion_1.default.hasSelected() ? '' : '\\\\<C-n>';\n            await nvim.eval(`feedkeys(\"${pre}\\\\<C-y>\", 'in')`);\n            return;\n        }\n        // create move cmd\n        if (mode != 'n')\n            move_cmd += \"\\\\<Esc>\";\n        if (len == 0) {\n            if (col == 0 || (!mode.startsWith('i') && col < string_1.byteLength(line))) {\n                move_cmd += 'i';\n            }\n            else {\n                move_cmd += 'a';\n            }\n        }\n        else {\n            move_cmd += 'v';\n            endCol = await this.getVirtualCol(end.line + 1, endCol);\n            if (selection == 'inclusive') {\n                if (end.character == 0) {\n                    move_cmd += `${end.line}G`;\n                }\n                else {\n                    move_cmd += `${end.line + 1}G${endCol}|`;\n                }\n            }\n            else if (selection == 'old') {\n                move_cmd += `${end.line + 1}G${endCol}|`;\n            }\n            else {\n                move_cmd += `${end.line + 1}G${endCol + 1}|`;\n            }\n            col = await this.getVirtualCol(start.line + 1, col);\n            move_cmd += `o${start.line + 1}G${col + 1}|o\\\\<c-g>`;\n        }\n        if (mode == 'i' && move_cmd == \"\\\\<Esc>a\") {\n            move_cmd = '';\n        }\n        nvim.pauseNotification();\n        nvim.setOption('virtualedit', 'onemore', true);\n        nvim.call('cursor', [start.line + 1, col + (move_cmd == 'a' ? 0 : 1)], true);\n        if (move_cmd) {\n            nvim.call('eval', [`feedkeys(\"${move_cmd}\", 'in')`], true);\n        }\n        if (mode == 'i') {\n            nvim.call('coc#_cancel', [], true);\n        }\n        nvim.setOption('virtualedit', ve, true);\n        if (isFinalTabstop) {\n            if (this.snippet.finalCount == 1) {\n                logger.info('Jump to final placeholder, cancelling snippet session');\n                this.deactivate();\n            }\n            else {\n                nvim.call('coc#snippet#disable', [], true);\n            }\n        }\n        if (workspace_1.default.env.isVim)\n            nvim.command('redraw', true);\n        await nvim.resumeNotification();\n        if (triggerAutocmd)\n            nvim.call('coc#util#do_autocmd', ['CocJumpPlaceholder'], true);\n    }\n    async getVirtualCol(line, col) {\n        let { nvim } = this;\n        return await nvim.eval(`virtcol([${line}, ${col}])`);\n    }\n    async checkPosition() {\n        if (!this.isActive)\n            return;\n        let position = await window_1.default.getCursorPosition();\n        if (this.snippet && position_1.positionInRange(position, this.snippet.range) != 0) {\n            logger.info('Cursor insert out of range, cancelling snippet session');\n            this.deactivate();\n        }\n    }\n    findPlaceholder(range) {\n        if (!this.snippet)\n            return null;\n        let { placeholder } = this;\n        if (placeholder && position_1.rangeInRange(range, placeholder.range))\n            return placeholder;\n        return this.snippet.getPlaceholderByRange(range) || null;\n    }\n    get placeholder() {\n        if (!this.snippet)\n            return null;\n        return this.snippet.getPlaceholderById(this._currId);\n    }\n    get snippet() {\n        return this._snippet;\n    }\n    get document() {\n        return workspace_1.default.getDocument(this.bufnr);\n    }\n}\nexports.SnippetSession = SnippetSession;\nfunction normalizeSnippetString(snippet, indent, opts) {\n    let lines = snippet.split(/\\r?\\n/);\n    let ind = opts.insertSpaces ? ' '.repeat(opts.tabSize) : '\\t';\n    let tabSize = opts.tabSize || 2;\n    lines = lines.map((line, idx) => {\n        let space = line.match(/^\\s*/)[0];\n        let pre = space;\n        let isTab = space.startsWith('\\t');\n        if (isTab && opts.insertSpaces) {\n            pre = ind.repeat(space.length);\n        }\n        else if (!isTab && !opts.insertSpaces) {\n            pre = ind.repeat(space.length / tabSize);\n        }\n        return (idx == 0 || line.length == 0 ? '' : indent) + pre + line.slice(space.length);\n    });\n    return lines.join('\\n');\n}\nexports.normalizeSnippetString = normalizeSnippetString;\n\n\n//# sourceURL=webpack://coc.nvim/./src/snippets/session.ts?");

/***/ }),

/***/ "./src/snippets/snippet.ts":
/*!*********************************!*\
  !*** ./src/snippets/snippet.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CocSnippet = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst vscode_languageserver_textdocument_1 = __webpack_require__(/*! vscode-languageserver-textdocument */ \"./node_modules/vscode-languageserver-textdocument/lib/esm/main.js\");\nconst position_1 = __webpack_require__(/*! ../util/position */ \"./src/util/position.ts\");\nconst Snippets = tslib_1.__importStar(__webpack_require__(/*! ./parser */ \"./src/snippets/parser.ts\"));\nconst string_1 = __webpack_require__(/*! ../util/string */ \"./src/util/string.ts\");\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('snippets-snipet');\nclass CocSnippet {\n    constructor(_snippetString, position, _variableResolver) {\n        this._snippetString = _snippetString;\n        this.position = position;\n        this._variableResolver = _variableResolver;\n        this._parser = new Snippets.SnippetParser();\n    }\n    async init() {\n        const snippet = this._parser.parse(this._snippetString, true);\n        let { _variableResolver } = this;\n        if (_variableResolver) {\n            await snippet.resolveVariables(_variableResolver);\n        }\n        this.tmSnippet = snippet;\n        this.update();\n    }\n    adjustPosition(characterCount, lineCount) {\n        let { line, character } = this.position;\n        this.position = {\n            line: line + lineCount,\n            character: character + characterCount\n        };\n        this.update();\n    }\n    // adjust for edit before snippet\n    adjustTextEdit(edit) {\n        let { range, newText } = edit;\n        if (position_1.comparePosition(this.range.start, range.end) < 0)\n            return false;\n        // check change of placeholder at beginning\n        if (!newText.includes('\\n')\n            && position_1.comparePosition(range.start, range.end) == 0\n            && position_1.comparePosition(this.range.start, range.start) == 0) {\n            let idx = this._placeholders.findIndex(o => position_1.comparePosition(o.range.start, range.start) == 0);\n            if (idx !== -1)\n                return false;\n        }\n        let changed = position_1.getChangedPosition(this.range.start, edit);\n        if (changed.line == 0 && changed.character == 0)\n            return true;\n        this.adjustPosition(changed.character, changed.line);\n        return true;\n    }\n    get isPlainText() {\n        if (this._placeholders.length > 1)\n            return false;\n        return this._placeholders.every(o => o.value == '');\n    }\n    get finalCount() {\n        return this._placeholders.filter(o => o.isFinalTabstop).length;\n    }\n    toString() {\n        return this.tmSnippet.toString();\n    }\n    get range() {\n        let { position } = this;\n        const content = this.tmSnippet.toString();\n        const doc = vscode_languageserver_textdocument_1.TextDocument.create('untitled:/1', 'snippet', 0, content);\n        const pos = doc.positionAt(content.length);\n        const end = pos.line == 0 ? position.character + pos.character : pos.character;\n        return vscode_languageserver_protocol_1.Range.create(position, vscode_languageserver_protocol_1.Position.create(position.line + pos.line, end));\n    }\n    get firstPlaceholder() {\n        let index = 0;\n        for (let p of this._placeholders) {\n            if (p.index == 0)\n                continue;\n            if (index == 0 || p.index < index) {\n                index = p.index;\n            }\n        }\n        return this.getPlaceholder(index);\n    }\n    get lastPlaceholder() {\n        let index = 0;\n        for (let p of this._placeholders) {\n            if (index == 0 || p.index > index) {\n                index = p.index;\n            }\n        }\n        return this.getPlaceholder(index);\n    }\n    getPlaceholderById(id) {\n        return this._placeholders.find(o => o.id == id);\n    }\n    getPlaceholder(index) {\n        let placeholders = this._placeholders.filter(o => o.index == index);\n        let filtered = placeholders.filter(o => !o.transform);\n        return filtered.length ? filtered[0] : placeholders[0];\n    }\n    getPrevPlaceholder(index) {\n        if (index == 0)\n            return this.lastPlaceholder;\n        let prev = this.getPlaceholder(index - 1);\n        if (!prev)\n            return this.getPrevPlaceholder(index - 1);\n        return prev;\n    }\n    getNextPlaceholder(index) {\n        let indexes = this._placeholders.map(o => o.index);\n        let max = Math.max.apply(null, indexes);\n        if (index >= max)\n            return this.finalPlaceholder;\n        let next = this.getPlaceholder(index + 1);\n        if (!next)\n            return this.getNextPlaceholder(index + 1);\n        return next;\n    }\n    get finalPlaceholder() {\n        return this._placeholders.find(o => o.isFinalTabstop);\n    }\n    getPlaceholderByRange(range) {\n        return this._placeholders.find(o => position_1.rangeInRange(range, o.range));\n    }\n    insertSnippet(placeholder, snippet, range) {\n        let { start } = placeholder.range;\n        // let offset = position.character - start.character\n        let editStart = vscode_languageserver_protocol_1.Position.create(range.start.line - start.line, range.start.line == start.line ? range.start.character - start.character : range.start.character);\n        let editEnd = vscode_languageserver_protocol_1.Position.create(range.end.line - start.line, range.end.line == start.line ? range.end.character - start.character : range.end.character);\n        let editRange = vscode_languageserver_protocol_1.Range.create(editStart, editEnd);\n        let first = this.tmSnippet.insertSnippet(snippet, placeholder.id, editRange);\n        this.update();\n        return first;\n    }\n    // update internal positions, no change of buffer\n    // return TextEdit list when needed\n    updatePlaceholder(placeholder, edit) {\n        let { start, end } = edit.range;\n        let { range } = this;\n        let { value, id, index } = placeholder;\n        let newText = position_1.editRange(placeholder.range, value, edit);\n        let delta = 0;\n        if (!newText.includes('\\n')) {\n            for (let p of this._placeholders) {\n                if (p.index == index &&\n                    p.id < id &&\n                    p.line == placeholder.range.start.line) {\n                    let text = this.tmSnippet.getPlaceholderText(p.id, newText);\n                    delta = delta + string_1.byteLength(text) - string_1.byteLength(p.value);\n                }\n            }\n        }\n        if (placeholder.isVariable) {\n            this.tmSnippet.updateVariable(id, newText);\n        }\n        else {\n            this.tmSnippet.updatePlaceholder(id, newText);\n        }\n        let endPosition = position_1.adjustPosition(range.end, edit);\n        let snippetEdit = {\n            range: vscode_languageserver_protocol_1.Range.create(range.start, endPosition),\n            newText: this.tmSnippet.toString()\n        };\n        this.update();\n        return { edits: [snippetEdit], delta };\n    }\n    update() {\n        const snippet = this.tmSnippet;\n        const { line, character } = this.position;\n        const document = vscode_languageserver_textdocument_1.TextDocument.create('untitled:/1', 'snippet', 0, snippet.toString());\n        const { placeholders, variables, maxIndexNumber } = snippet;\n        const variableIndexMap = new Map();\n        let variableIndex = maxIndexNumber + 1;\n        this._placeholders = [...placeholders, ...variables].map((p, idx) => {\n            const offset = snippet.offset(p);\n            const position = document.positionAt(offset);\n            const start = {\n                line: line + position.line,\n                character: position.line == 0 ? character + position.character : position.character\n            };\n            let index;\n            if (p instanceof Snippets.Variable) {\n                let key = p.name;\n                if (variableIndexMap.has(key)) {\n                    index = variableIndexMap.get(key);\n                }\n                else {\n                    variableIndexMap.set(key, variableIndex);\n                    index = variableIndex;\n                    variableIndex = variableIndex + 1;\n                }\n                // variableIndex = variableIndex + 1\n            }\n            else {\n                index = p.index;\n            }\n            const value = p.toString();\n            const lines = value.split('\\n');\n            let res = {\n                range: vscode_languageserver_protocol_1.Range.create(start, {\n                    line: start.line + lines.length - 1,\n                    character: lines.length == 1 ? start.character + value.length : lines[lines.length - 1].length\n                }),\n                transform: p.transform != null,\n                line: start.line,\n                id: idx,\n                index,\n                value,\n                isVariable: p instanceof Snippets.Variable,\n                isFinalTabstop: p.index === 0\n            };\n            Object.defineProperty(res, 'snippet', {\n                enumerable: false\n            });\n            if (p instanceof Snippets.Placeholder && p.choice) {\n                let { options } = p.choice;\n                if (options && options.length) {\n                    res.choice = options.map(o => o.value);\n                }\n            }\n            return res;\n        });\n    }\n}\nexports.CocSnippet = CocSnippet;\n\n\n//# sourceURL=webpack://coc.nvim/./src/snippets/snippet.ts?");

/***/ }),

/***/ "./src/snippets/variableResolve.ts":
/*!*****************************************!*\
  !*** ./src/snippets/variableResolve.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SnippetVariableResolver = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst clipboardy_1 = tslib_1.__importDefault(__webpack_require__(/*! clipboardy */ \"./node_modules/clipboardy/index.js\"));\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ../window */ \"./src/window.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('snippets-variable');\nclass SnippetVariableResolver {\n    constructor() {\n        this._variableToValue = {};\n        const currentDate = new Date();\n        Object.assign(this._variableToValue, {\n            CURRENT_YEAR: currentDate.getFullYear().toString(),\n            CURRENT_YEAR_SHORT: currentDate\n                .getFullYear()\n                .toString()\n                .slice(-2),\n            CURRENT_MONTH: (currentDate.getMonth() + 1).toString(),\n            CURRENT_DATE: currentDate.getDate().toString(),\n            CURRENT_HOUR: currentDate.getHours().toString(),\n            CURRENT_MINUTE: currentDate.getMinutes().toString(),\n            CURRENT_SECOND: currentDate.getSeconds().toString(),\n            CURRENT_DAY_NAME: currentDate.toLocaleString(\"en-US\", { weekday: \"long\" }),\n            CURRENT_DAY_NAME_SHORT: currentDate.toLocaleString(\"en-US\", { weekday: \"short\" }),\n            CURRENT_MONTH_NAME: currentDate.toLocaleString(\"en-US\", { month: \"long\" }),\n            CURRENT_MONTH_NAME_SHORT: currentDate.toLocaleString(\"en-US\", { month: \"short\" }),\n            TM_FILENAME: null,\n            TM_FILENAME_BASE: null,\n            TM_DIRECTORY: null,\n            TM_FILEPATH: null,\n            YANK: null,\n            TM_LINE_INDEX: null,\n            TM_LINE_NUMBER: null,\n            TM_CURRENT_LINE: null,\n            TM_CURRENT_WORD: null,\n            TM_SELECTED_TEXT: null,\n            CLIPBOARD: null\n        });\n    }\n    async resovleValue(name) {\n        let { nvim } = window_1.default;\n        if (['TM_FILENAME', 'TM_FILENAME_BASE', 'TM_DIRECTORY', 'TM_FILEPATH'].includes(name)) {\n            let filepath = await nvim.eval('expand(\"%:p\")');\n            if (name == 'TM_FILENAME')\n                return path_1.default.basename(filepath);\n            if (name == 'TM_FILENAME_BASE')\n                return path_1.default.basename(filepath, path_1.default.extname(filepath));\n            if (name == 'TM_DIRECTORY')\n                return path_1.default.dirname(filepath);\n            if (name == 'TM_FILEPATH')\n                return filepath;\n        }\n        if (name == 'YANK') {\n            let yank = await nvim.call('getreg', ['\"\"']);\n            return yank;\n        }\n        if (name == 'TM_LINE_INDEX') {\n            let lnum = await nvim.call('line', ['.']);\n            return (lnum - 1).toString();\n        }\n        if (name == 'TM_LINE_NUMBER') {\n            let lnum = await nvim.call('line', ['.']);\n            return lnum.toString();\n        }\n        if (name == 'TM_CURRENT_LINE') {\n            let line = await nvim.call('getline', ['.']);\n            return line;\n        }\n        if (name == 'TM_CURRENT_WORD') {\n            let word = await nvim.eval(`expand('<cword>')`);\n            return word;\n        }\n        if (name == 'TM_SELECTED_TEXT') {\n            let text = await nvim.eval(`get(g:,'coc_selected_text', '')`);\n            return text;\n        }\n        if (name == 'CLIPBOARD') {\n            let clipboard = '';\n            try {\n                clipboard = await clipboardy_1.default.read();\n            }\n            catch (e) {\n                logger.error(`Error with clipboardy:`, e.message);\n            }\n            return clipboard;\n        }\n    }\n    async resolve(variable) {\n        const name = variable.name;\n        let resolved = this._variableToValue[name];\n        if (resolved != null)\n            return resolved.toString();\n        // resolve value from vim\n        let value = await this.resovleValue(name);\n        if (value)\n            return value;\n        // use default value when resolved is undefined\n        if (variable.children && variable.children.length) {\n            return variable.toString();\n        }\n        if (!this._variableToValue.hasOwnProperty(name)) {\n            return name;\n        }\n        return '';\n    }\n}\nexports.SnippetVariableResolver = SnippetVariableResolver;\n\n\n//# sourceURL=webpack://coc.nvim/./src/snippets/variableResolve.ts?");

/***/ }),

/***/ "./src/source/around.ts":
/*!******************************!*\
  !*** ./src/source/around.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.regist = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst source_1 = tslib_1.__importDefault(__webpack_require__(/*! ../model/source */ \"./src/model/source.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('source-around');\nclass Around extends source_1.default {\n    constructor() {\n        super({\n            name: 'around',\n            filepath: __filename\n        });\n    }\n    doComplete(opt) {\n        let { bufnr, input } = opt;\n        if (input.length === 0)\n            return null;\n        let document = workspace_1.default.getDocument(bufnr);\n        if (!document)\n            return null;\n        let words = document.words;\n        let moreWords = document.getMoreWords();\n        words.push(...moreWords);\n        words = this.filterWords(words, opt);\n        return Promise.resolve({\n            items: words.map(word => ({\n                word,\n                menu: this.menu\n            }))\n        });\n    }\n}\nexports.default = Around;\nfunction regist(sourceMap) {\n    sourceMap.set('around', new Around());\n    return vscode_languageserver_protocol_1.Disposable.create(() => {\n        sourceMap.delete('around');\n    });\n}\nexports.regist = regist;\n\n\n//# sourceURL=webpack://coc.nvim/./src/source/around.ts?");

/***/ }),

/***/ "./src/source/buffer.ts":
/*!******************************!*\
  !*** ./src/source/buffer.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.regist = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst source_1 = tslib_1.__importDefault(__webpack_require__(/*! ../model/source */ \"./src/model/source.ts\"));\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('source-buffer');\nclass Buffer extends source_1.default {\n    constructor() {\n        super({\n            name: 'buffer',\n            filepath: __filename\n        });\n    }\n    get ignoreGitignore() {\n        return this.getConfig('ignoreGitignore', true);\n    }\n    getWords(bufnr) {\n        let { ignoreGitignore } = this;\n        let words = [];\n        workspace_1.default.documents.forEach(document => {\n            if (document.bufnr == bufnr)\n                return;\n            if (ignoreGitignore && document.isIgnored)\n                return;\n            for (let word of document.words) {\n                if (!words.includes(word)) {\n                    words.push(word);\n                }\n            }\n        });\n        return words;\n    }\n    doComplete(opt) {\n        let { bufnr, input } = opt;\n        if (input.length == 0)\n            return null;\n        let words = this.getWords(bufnr);\n        words = this.filterWords(words, opt);\n        return Promise.resolve({\n            items: words.map(word => ({\n                word,\n                menu: this.menu\n            }))\n        });\n    }\n}\nexports.default = Buffer;\nfunction regist(sourceMap) {\n    sourceMap.set('buffer', new Buffer());\n    return vscode_languageserver_protocol_1.Disposable.create(() => {\n        sourceMap.delete('buffer');\n    });\n}\nexports.regist = regist;\n\n\n//# sourceURL=webpack://coc.nvim/./src/source/buffer.ts?");

/***/ }),

/***/ "./src/source/file.ts":
/*!****************************!*\
  !*** ./src/source/file.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.regist = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst fs_1 = tslib_1.__importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst minimatch_1 = tslib_1.__importDefault(__webpack_require__(/*! minimatch */ \"./node_modules/minimatch/minimatch.js\"));\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst util_1 = tslib_1.__importDefault(__webpack_require__(/*! util */ \"util\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst source_1 = tslib_1.__importDefault(__webpack_require__(/*! ../model/source */ \"./src/model/source.ts\"));\nconst fs_2 = __webpack_require__(/*! ../util/fs */ \"./src/util/fs.ts\");\nconst string_1 = __webpack_require__(/*! ../util/string */ \"./src/util/string.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ../workspace */ \"./src/workspace.ts\"));\nconst logger = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\")('source-file');\nconst pathRe = /(?:\\.{0,2}|~|\\$HOME|([\\w]+)|)\\/(?:[\\w.@()-]+\\/)*(?:[\\w.@()-])*$/;\nclass File extends source_1.default {\n    constructor() {\n        super({\n            name: 'file',\n            filepath: __filename\n        });\n    }\n    resolveEnvVariables(str) {\n        let replaced = str;\n        // windows\n        replaced = replaced.replace(/%([^%]+)%/g, (_, n) => process.env[n]);\n        // linux and mac\n        replaced = replaced.replace(/\\$([A-Z_]+[A-Z0-9_]*)|\\${([A-Z0-9_]*)}/gi, (_, a, b) => process.env[a || b]);\n        return replaced;\n    }\n    getPathOption(opt) {\n        let { line, colnr } = opt;\n        let part = string_1.byteSlice(line, 0, colnr - 1);\n        part = this.resolveEnvVariables(part);\n        if (!part || part.endsWith('//'))\n            return null;\n        let ms = part.match(pathRe);\n        if (ms && ms.length) {\n            const pathstr = workspace_1.default.expand(ms[0]);\n            let input = ms[0].match(/[^/]*$/)[0];\n            return { pathstr, part: ms[1], startcol: colnr - input.length - 1, input };\n        }\n        return null;\n    }\n    async getFileItem(root, filename) {\n        let f = path_1.default.join(root, filename);\n        let stat = await fs_2.statAsync(f);\n        if (stat) {\n            let abbr = stat.isDirectory() ? filename + '/' : filename;\n            let word = filename;\n            return { word, abbr };\n        }\n        return null;\n    }\n    filterFiles(files) {\n        let ignoreHidden = this.getConfig('ignoreHidden', true);\n        let ignorePatterns = this.getConfig('ignorePatterns', []);\n        return files.filter(f => {\n            if (f == null)\n                return false;\n            if (ignoreHidden && f.startsWith(\".\"))\n                return false;\n            for (let p of ignorePatterns) {\n                if (minimatch_1.default(f, p, { dot: true }))\n                    return false;\n            }\n            return true;\n        });\n    }\n    async getItemsFromRoot(pathstr, root) {\n        let res = [];\n        let part = pathstr.endsWith(\"/\") ? pathstr : path_1.default.dirname(pathstr);\n        let dir = path_1.default.isAbsolute(pathstr) ? part : path_1.default.join(root, part);\n        try {\n            let stat = await fs_2.statAsync(dir);\n            if (stat && stat.isDirectory()) {\n                let files = await util_1.default.promisify(fs_1.default.readdir)(dir);\n                files = this.filterFiles(files);\n                let items = await Promise.all(files.map(filename => this.getFileItem(dir, filename)));\n                res = res.concat(items);\n            }\n            res = res.filter(item => item != null);\n            return res;\n        }\n        catch (e) {\n            logger.error(`Error on list files:`, e);\n            return res;\n        }\n    }\n    get trimSameExts() {\n        return this.getConfig('trimSameExts', []);\n    }\n    async doComplete(opt) {\n        let { col, filepath } = opt;\n        let option = this.getPathOption(opt);\n        if (!option)\n            return null;\n        let { pathstr, part, startcol, input } = option;\n        if (startcol < opt.col)\n            return null;\n        let startPart = opt.col == startcol ? '' : string_1.byteSlice(opt.line, opt.col, startcol);\n        let dirname = path_1.default.dirname(filepath);\n        let ext = path_1.default.extname(path_1.default.basename(filepath));\n        let cwd = await this.nvim.call('getcwd', []);\n        let root;\n        if (pathstr.startsWith(\".\")) {\n            root = filepath ? path_1.default.dirname(filepath) : cwd;\n        }\n        else if (pathstr.startsWith(\"/\")) {\n            root = pathstr.endsWith(\"/\") ? pathstr : path_1.default.dirname(pathstr);\n        }\n        else if (part) {\n            if (fs_1.default.existsSync(path_1.default.join(dirname, part))) {\n                root = dirname;\n            }\n            else if (fs_1.default.existsSync(path_1.default.join(cwd, part))) {\n                root = cwd;\n            }\n        }\n        else {\n            root = cwd;\n        }\n        if (!root)\n            return null;\n        let items = await this.getItemsFromRoot(pathstr, root);\n        let trimExt = this.trimSameExts.includes(ext);\n        let first = input[0];\n        if (first && col == startcol)\n            items = items.filter(o => o.word[0] === first);\n        return {\n            items: items.map(item => {\n                let ex = path_1.default.extname(item.word);\n                item.word = trimExt && ex === ext ? item.word.replace(ext, '') : item.word;\n                return {\n                    word: `${startPart}${item.word}`,\n                    abbr: `${startPart}${item.abbr}`,\n                    menu: this.menu\n                };\n            })\n        };\n    }\n}\nexports.default = File;\nfunction regist(sourceMap) {\n    sourceMap.set('file', new File());\n    return vscode_languageserver_protocol_1.Disposable.create(() => {\n        sourceMap.delete('file');\n    });\n}\nexports.regist = regist;\n\n\n//# sourceURL=webpack://coc.nvim/./src/source/file.ts?");

/***/ }),

/***/ "./src/sources.ts":
/*!************************!*\
  !*** ./src/sources.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Sources = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst fast_diff_1 = tslib_1.__importDefault(__webpack_require__(/*! fast-diff */ \"./node_modules/fast-diff/diff.js\"));\nconst fs_1 = tslib_1.__importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst util_1 = tslib_1.__importDefault(__webpack_require__(/*! util */ \"util\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ./events */ \"./src/events.ts\"));\nconst extensions_1 = tslib_1.__importDefault(__webpack_require__(/*! ./extensions */ \"./src/extensions.ts\"));\nconst source_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/source */ \"./src/model/source.ts\"));\nconst source_vim_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/source-vim */ \"./src/model/source-vim.ts\"));\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/types.ts\");\nconst util_2 = __webpack_require__(/*! ./util */ \"./src/util/index.ts\");\nconst fs_2 = __webpack_require__(/*! ./util/fs */ \"./src/util/fs.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ./workspace */ \"./src/workspace.ts\"));\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ./window */ \"./src/window.ts\"));\nconst string_1 = __webpack_require__(/*! ./util/string */ \"./src/util/string.ts\");\nconst logger = __webpack_require__(/*! ./util/logger */ \"./src/util/logger.ts\")('sources');\nclass Sources {\n    constructor() {\n        this.sourceMap = new Map();\n        this.disposables = [];\n        this.remoteSourcePaths = [];\n    }\n    get nvim() {\n        return workspace_1.default.nvim;\n    }\n    createNativeSources() {\n        try {\n            this.disposables.push(__webpack_require__(/*! ./source/around */ \"./src/source/around.ts\").regist(this.sourceMap));\n            this.disposables.push(__webpack_require__(/*! ./source/buffer */ \"./src/source/buffer.ts\").regist(this.sourceMap));\n            this.disposables.push(__webpack_require__(/*! ./source/file */ \"./src/source/file.ts\").regist(this.sourceMap));\n        }\n        catch (e) {\n            console.error('Create source error:' + e.message);\n        }\n    }\n    async createVimSourceExtension(nvim, filepath) {\n        let name = path_1.default.basename(filepath, '.vim');\n        try {\n            await nvim.command(`source ${filepath}`);\n            let fns = await nvim.call('coc#util#remote_fns', name);\n            for (let fn of ['init', 'complete']) {\n                if (!fns.includes(fn)) {\n                    window_1.default.showMessage(`${fn} not found for source ${name}`, 'error');\n                    return null;\n                }\n            }\n            let props = await nvim.call(`coc#source#${name}#init`, []);\n            let packageJSON = {\n                name: `coc-source-${name}`,\n                engines: {\n                    coc: \">= 0.0.1\"\n                },\n                activationEvents: props.filetypes ? props.filetypes.map(f => `onLanguage:${f}`) : ['*'],\n                contributes: {\n                    configuration: {\n                        properties: {\n                            [`coc.source.${name}.enable`]: {\n                                type: 'boolean',\n                                default: true\n                            },\n                            [`coc.source.${name}.firstMatch`]: {\n                                type: 'boolean',\n                                default: !!props.firstMatch\n                            },\n                            [`coc.source.${name}.triggerCharacters`]: {\n                                type: 'number',\n                                default: props.triggerCharacters || []\n                            },\n                            [`coc.source.${name}.priority`]: {\n                                type: 'number',\n                                default: props.priority || 9\n                            },\n                            [`coc.source.${name}.shortcut`]: {\n                                type: 'string',\n                                default: props.shortcut || name.slice(0, 3).toUpperCase(),\n                                description: 'Shortcut text shown in complete menu.'\n                            },\n                            [`coc.source.${name}.disableSyntaxes`]: {\n                                type: 'array',\n                                default: [],\n                                items: {\n                                    type: 'string'\n                                }\n                            },\n                            [`coc.source.${name}.filetypes`]: {\n                                type: 'array',\n                                default: props.filetypes || null,\n                                description: 'Enabled filetypes.',\n                                items: {\n                                    type: 'string'\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n            let source = new source_vim_1.default({\n                name,\n                filepath,\n                sourceType: types_1.SourceType.Remote,\n                optionalFns: fns.filter(n => !['init', 'complete'].includes(n))\n            });\n            let isActive = false;\n            let extension = {\n                id: packageJSON.name,\n                packageJSON,\n                exports: void 0,\n                extensionPath: filepath,\n                activate: () => {\n                    isActive = true;\n                    this.addSource(source);\n                    return Promise.resolve();\n                }\n            };\n            Object.defineProperty(extension, 'isActive', {\n                get: () => isActive\n            });\n            extensions_1.default.registerExtension(extension, () => {\n                isActive = false;\n                this.removeSource(source);\n            });\n        }\n        catch (e) {\n            window_1.default.showMessage(`Error on create vim source ${name}: ${e.message}`, 'error');\n        }\n    }\n    createRemoteSources() {\n        let { runtimepath } = workspace_1.default.env;\n        let paths = runtimepath.split(',');\n        for (let path of paths) {\n            this.createVimSources(path).logError();\n        }\n    }\n    async createVimSources(pluginPath) {\n        if (this.remoteSourcePaths.includes(pluginPath))\n            return;\n        this.remoteSourcePaths.push(pluginPath);\n        let folder = path_1.default.join(pluginPath, 'autoload/coc/source');\n        let stat = await fs_2.statAsync(folder);\n        if (stat && stat.isDirectory()) {\n            let arr = await util_1.default.promisify(fs_1.default.readdir)(folder);\n            arr = arr.filter(s => s.endsWith('.vim'));\n            let files = arr.map(s => path_1.default.join(folder, s));\n            if (files.length == 0)\n                return;\n            await Promise.all(files.map(p => this.createVimSourceExtension(this.nvim, p)));\n        }\n    }\n    init() {\n        this.createNativeSources();\n        this.createRemoteSources();\n        events_1.default.on('BufEnter', this.onDocumentEnter, this, this.disposables);\n        workspace_1.default.watchOption('runtimepath', async (oldValue, newValue) => {\n            let result = fast_diff_1.default(oldValue, newValue);\n            for (let [changeType, value] of result) {\n                if (changeType == 1) {\n                    let paths = value.replace(/,$/, '').split(',');\n                    for (let p of paths) {\n                        if (p)\n                            await this.createVimSources(p);\n                    }\n                }\n            }\n        }, this.disposables);\n    }\n    get names() {\n        return Array.from(this.sourceMap.keys());\n    }\n    get sources() {\n        return Array.from(this.sourceMap.values());\n    }\n    has(name) {\n        return this.names.findIndex(o => o == name) != -1;\n    }\n    getSource(name) {\n        if (!name)\n            return null;\n        return this.sourceMap.get(name) || null;\n    }\n    async doCompleteResolve(item, token) {\n        let source = this.getSource(item.source);\n        if (source && typeof source.onCompleteResolve == 'function') {\n            try {\n                await Promise.resolve(source.onCompleteResolve(item, token));\n            }\n            catch (e) {\n                logger.error('Error on complete resolve:', e.stack);\n            }\n        }\n    }\n    async doCompleteDone(item, opt) {\n        let data = JSON.parse(item.user_data);\n        let source = this.getSource(data.source);\n        if (source && typeof source.onCompleteDone === 'function') {\n            await Promise.resolve(source.onCompleteDone(item, opt));\n        }\n    }\n    shouldCommit(item, commitCharacter) {\n        if (!item || !item.source)\n            return false;\n        let source = this.getSource(item.source);\n        if (source && source.sourceType == types_1.SourceType.Service && typeof source.shouldCommit === 'function') {\n            return source.shouldCommit(item, commitCharacter);\n        }\n        return false;\n    }\n    getCompleteSources(opt) {\n        let { filetype } = opt;\n        let pre = string_1.byteSlice(opt.line, 0, opt.colnr - 1);\n        let isTriggered = opt.input == '' && !!opt.triggerCharacter;\n        if (isTriggered)\n            return this.getTriggerSources(pre, filetype);\n        return this.getNormalSources(opt.filetype);\n    }\n    /**\n     * Get sources should be used without trigger.\n     *\n     * @param {string} filetype\n     * @returns {ISource[]}\n     */\n    getNormalSources(filetype) {\n        return this.sources.filter(source => {\n            let { filetypes, triggerOnly, enable } = source;\n            if (!enable || triggerOnly || (filetypes && !filetypes.includes(filetype))) {\n                return false;\n            }\n            if (this.disabledByLanguageId(source, filetype)) {\n                return false;\n            }\n            return true;\n        });\n    }\n    checkTrigger(source, pre, character) {\n        let { triggerCharacters, triggerPatterns } = source;\n        if (!triggerCharacters && !triggerPatterns)\n            return false;\n        if (character && triggerCharacters && triggerCharacters.includes(character)) {\n            return true;\n        }\n        if (triggerPatterns && triggerPatterns.findIndex(p => p.test(pre)) !== -1) {\n            return true;\n        }\n        return false;\n    }\n    shouldTrigger(pre, languageId) {\n        let sources = this.getTriggerSources(pre, languageId);\n        return sources.length > 0;\n    }\n    getTriggerSources(pre, languageId) {\n        let character = pre.length ? pre[pre.length - 1] : '';\n        if (!character)\n            return [];\n        return this.sources.filter(source => {\n            let { filetypes, enable } = source;\n            if (!enable || (filetypes && !filetypes.includes(languageId))) {\n                return false;\n            }\n            if (this.disabledByLanguageId(source, languageId))\n                return false;\n            return this.checkTrigger(source, pre, character);\n        });\n    }\n    addSource(source) {\n        let { name } = source;\n        if (this.names.includes(name)) {\n            window_1.default.showMessage(`Source \"${name}\" recreated`, 'warning');\n        }\n        this.sourceMap.set(name, source);\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.sourceMap.delete(name);\n        });\n    }\n    removeSource(source) {\n        let name = typeof source == 'string' ? source : source.name;\n        if (source == this.sourceMap.get(name)) {\n            this.sourceMap.delete(name);\n        }\n    }\n    async refresh(name) {\n        for (let source of this.sources) {\n            if (!name || source.name == name) {\n                if (typeof source.refresh === 'function') {\n                    await Promise.resolve(source.refresh());\n                }\n            }\n        }\n    }\n    toggleSource(name) {\n        if (!name)\n            return;\n        let source = this.getSource(name);\n        if (!source)\n            return;\n        if (typeof source.toggle === 'function') {\n            source.toggle();\n        }\n    }\n    sourceStats() {\n        let res = [];\n        let items = this.sources;\n        for (let item of items) {\n            res.push({\n                name: item.name,\n                priority: item.priority,\n                triggerCharacters: item.triggerCharacters || [],\n                shortcut: item.shortcut || '',\n                filetypes: item.filetypes || [],\n                filepath: item.filepath || '',\n                type: item.sourceType == types_1.SourceType.Native\n                    ? 'native' : item.sourceType == types_1.SourceType.Remote\n                    ? 'remote' : 'service',\n                disabled: !item.enable\n            });\n        }\n        return res;\n    }\n    onDocumentEnter(bufnr) {\n        let { sources } = this;\n        for (let s of sources) {\n            if (!s.enable)\n                continue;\n            if (typeof s.onEnter == 'function') {\n                s.onEnter(bufnr);\n            }\n        }\n    }\n    createSource(config) {\n        if (!config.name || !config.doComplete) {\n            console.error(`name and doComplete required for createSource`);\n            return;\n        }\n        let source = new source_1.default(Object.assign({ sourceType: types_1.SourceType.Service }, config));\n        return this.addSource(source);\n    }\n    disabledByLanguageId(source, languageId) {\n        let map = workspace_1.default.env.disabledSources;\n        let list = map ? map[languageId] : [];\n        return Array.isArray(list) && list.includes(source.name);\n    }\n    dispose() {\n        util_2.disposeAll(this.disposables);\n    }\n}\nexports.Sources = Sources;\nexports.default = new Sources();\n\n\n//# sourceURL=webpack://coc.nvim/./src/sources.ts?");

/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServiceStat = exports.ConfigurationTarget = exports.MessageLevel = exports.SourceType = exports.ExtensionType = exports.PatternType = void 0;\nvar PatternType;\n(function (PatternType) {\n    PatternType[PatternType[\"Buffer\"] = 0] = \"Buffer\";\n    PatternType[PatternType[\"LanguageServer\"] = 1] = \"LanguageServer\";\n    PatternType[PatternType[\"Global\"] = 2] = \"Global\";\n})(PatternType = exports.PatternType || (exports.PatternType = {}));\nvar ExtensionType;\n(function (ExtensionType) {\n    ExtensionType[ExtensionType[\"Global\"] = 0] = \"Global\";\n    ExtensionType[ExtensionType[\"Local\"] = 1] = \"Local\";\n    ExtensionType[ExtensionType[\"SingleFile\"] = 2] = \"SingleFile\";\n    ExtensionType[ExtensionType[\"Internal\"] = 3] = \"Internal\";\n})(ExtensionType = exports.ExtensionType || (exports.ExtensionType = {}));\nvar SourceType;\n(function (SourceType) {\n    SourceType[SourceType[\"Native\"] = 0] = \"Native\";\n    SourceType[SourceType[\"Remote\"] = 1] = \"Remote\";\n    SourceType[SourceType[\"Service\"] = 2] = \"Service\";\n})(SourceType = exports.SourceType || (exports.SourceType = {}));\nvar MessageLevel;\n(function (MessageLevel) {\n    MessageLevel[MessageLevel[\"More\"] = 0] = \"More\";\n    MessageLevel[MessageLevel[\"Warning\"] = 1] = \"Warning\";\n    MessageLevel[MessageLevel[\"Error\"] = 2] = \"Error\";\n})(MessageLevel = exports.MessageLevel || (exports.MessageLevel = {}));\nvar ConfigurationTarget;\n(function (ConfigurationTarget) {\n    ConfigurationTarget[ConfigurationTarget[\"Global\"] = 0] = \"Global\";\n    ConfigurationTarget[ConfigurationTarget[\"User\"] = 1] = \"User\";\n    ConfigurationTarget[ConfigurationTarget[\"Workspace\"] = 2] = \"Workspace\";\n})(ConfigurationTarget = exports.ConfigurationTarget || (exports.ConfigurationTarget = {}));\nvar ServiceStat;\n(function (ServiceStat) {\n    ServiceStat[ServiceStat[\"Initial\"] = 0] = \"Initial\";\n    ServiceStat[ServiceStat[\"Starting\"] = 1] = \"Starting\";\n    ServiceStat[ServiceStat[\"StartFailed\"] = 2] = \"StartFailed\";\n    ServiceStat[ServiceStat[\"Running\"] = 3] = \"Running\";\n    ServiceStat[ServiceStat[\"Stopping\"] = 4] = \"Stopping\";\n    ServiceStat[ServiceStat[\"Stopped\"] = 5] = \"Stopped\";\n})(ServiceStat = exports.ServiceStat || (exports.ServiceStat = {}));\n\n\n//# sourceURL=webpack://coc.nvim/./src/types.ts?");

/***/ }),

/***/ "./src/util/ansiparse.ts":
/*!*******************************!*\
  !*** ./src/util/ansiparse.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ansiparse = exports.parseAnsiHighlights = void 0;\nconst string_1 = __webpack_require__(/*! ./string */ \"./src/util/string.ts\");\nconst foregroundColors = {\n    30: 'black',\n    31: 'red',\n    32: 'green',\n    33: 'yellow',\n    34: 'blue',\n    35: 'magenta',\n    36: 'cyan',\n    37: 'white',\n    90: 'grey'\n};\nconst backgroundColors = {\n    40: 'black',\n    41: 'red',\n    42: 'green',\n    43: 'yellow',\n    44: 'blue',\n    45: 'magenta',\n    46: 'cyan',\n    47: 'white'\n};\nconst styles = {\n    1: 'bold',\n    3: 'italic',\n    4: 'underline'\n};\nfunction parseAnsiHighlights(line, markdown = false) {\n    let items = ansiparse(line);\n    let highlights = [];\n    let newLabel = '';\n    for (let item of items) {\n        if (!item.text)\n            continue;\n        let { foreground, background, bold, italic, underline } = item;\n        let len = string_1.byteLength(newLabel);\n        if (foreground || background || bold || italic || underline) {\n            let span = [len, len + string_1.byteLength(item.text)];\n            let hlGroup = '';\n            if (foreground && background) {\n                hlGroup = `CocList${string_1.upperFirst(foreground)}${string_1.upperFirst(background)}`;\n            }\n            else if (foreground) {\n                if (markdown) {\n                    if (foreground == 'yellow') {\n                        hlGroup = 'CocMarkdownCode';\n                    }\n                    else if (foreground == 'blue') {\n                        hlGroup = 'CocMarkdownLink';\n                    }\n                    else if (foreground == 'magenta') {\n                        hlGroup = 'CocMarkdownHeader';\n                    }\n                    else {\n                        hlGroup = `CocListFg${string_1.upperFirst(foreground)}`;\n                    }\n                }\n                else {\n                    hlGroup = `CocListFg${string_1.upperFirst(foreground)}`;\n                }\n            }\n            else if (background) {\n                hlGroup = `CocListBg${string_1.upperFirst(background)}`;\n            }\n            else if (bold) {\n                hlGroup = 'CocBold';\n            }\n            else if (italic) {\n                hlGroup = 'CocItalic';\n            }\n            else if (underline) {\n                hlGroup = 'CocUnderline';\n            }\n            highlights.push({ span, hlGroup });\n        }\n        newLabel = newLabel + item.text;\n    }\n    return { line: newLabel, highlights };\n}\nexports.parseAnsiHighlights = parseAnsiHighlights;\nfunction ansiparse(str) {\n    //\n    // I'm terrible at writing parsers.\n    //\n    let matchingControl = null;\n    let matchingData = null;\n    let matchingText = '';\n    let ansiState = [];\n    let result = [];\n    let state = {};\n    let eraseChar;\n    //\n    // General workflow for this thing is:\n    // \\033\\[33mText\n    // |     |  |\n    // |     |  matchingText\n    // |     matchingData\n    // matchingControl\n    //\n    // \\033\\[K or \\033\\[m\n    //\n    // In further steps we hope it's all going to be fine. It usually is.\n    //\n    //\n    // Erases a char from the output\n    //\n    eraseChar = () => {\n        let index;\n        let text;\n        if (matchingText.length) {\n            matchingText = matchingText.substr(0, matchingText.length - 1);\n        }\n        else if (result.length) {\n            index = result.length - 1;\n            text = result[index].text;\n            if (text.length === 1) {\n                //\n                // A result bit was fully deleted, pop it out to simplify the final output\n                //\n                result.pop();\n            }\n            else {\n                result[index].text = text.substr(0, text.length - 1);\n            }\n        }\n    };\n    for (let i = 0; i < str.length; i++) {\n        if (matchingControl != null) {\n            if (matchingControl == '\\x1b' && str[i] == '[') {\n                //\n                // We've matched full control code. Lets start matching formating data.\n                //\n                //\n                // \"emit\" matched text with correct state\n                //\n                if (matchingText) {\n                    state.text = matchingText;\n                    result.push(state);\n                    state = {};\n                    matchingText = '';\n                }\n                if (matchingText == '' && (str[i + 1] == 'm' || str[i + 1] == 'K')) {\n                    if (state.foreground || state.background) {\n                        state.text = '';\n                        result.push(state);\n                    }\n                    state = {};\n                }\n                matchingControl = null;\n                matchingData = '';\n            }\n            else {\n                //\n                // We failed to match anything - most likely a bad control code. We\n                // go back to matching regular strings.\n                //\n                matchingText += matchingControl + str[i];\n                matchingControl = null;\n            }\n            continue;\n        }\n        else if (matchingData != null) {\n            if (str[i] == ';') {\n                //\n                // `;` separates many formatting codes, for example: `\\033[33;43m`\n                // means that both `33` and `43` should be applied.\n                //\n                // TODO: this can be simplified by modifying state here.\n                //\n                ansiState.push(matchingData);\n                matchingData = '';\n            }\n            else if (str[i] == 'm' || str[i] == 'K') {\n                //\n                // `m` finished whole formatting code. We can proceed to matching\n                // formatted text.\n                //\n                ansiState.push(matchingData);\n                matchingData = null;\n                matchingText = '';\n                //\n                // Convert matched formatting data into user-friendly state object.\n                //\n                // TODO: DRY.\n                //\n                ansiState.forEach(ansiCode => {\n                    if (foregroundColors[ansiCode]) {\n                        state.foreground = foregroundColors[ansiCode];\n                    }\n                    else if (backgroundColors[ansiCode]) {\n                        state.background = backgroundColors[ansiCode];\n                    }\n                    else if (ansiCode == 39) {\n                        delete state.foreground;\n                    }\n                    else if (ansiCode == 49) {\n                        delete state.background;\n                    }\n                    else if (styles[ansiCode]) {\n                        state[styles[ansiCode]] = true;\n                    }\n                    else if (ansiCode == 22) {\n                        state.bold = false;\n                    }\n                    else if (ansiCode == 23) {\n                        state.italic = false;\n                    }\n                    else if (ansiCode == 24) {\n                        state.underline = false;\n                    }\n                });\n                ansiState = [];\n            }\n            else {\n                matchingData += str[i];\n            }\n            continue;\n        }\n        if (str[i] == '\\x1b') {\n            matchingControl = str[i];\n        }\n        else if (str[i] == '\\u0008') {\n            eraseChar();\n        }\n        else {\n            matchingText += str[i];\n        }\n    }\n    if (matchingText) {\n        state.text = matchingText + (matchingControl ? matchingControl : '');\n        result.push(state);\n    }\n    return result;\n}\nexports.ansiparse = ansiparse;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/ansiparse.ts?");

/***/ }),

/***/ "./src/util/array.ts":
/*!***************************!*\
  !*** ./src/util/array.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.flatMap = exports.lastIndex = exports.distinct = exports.group = exports.tail = exports.splitArray = exports.intersect = void 0;\nfunction intersect(array, other) {\n    for (let item of other) {\n        if (array.includes(item)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.intersect = intersect;\nfunction splitArray(array, fn) {\n    let res = [[], []];\n    for (let item of array) {\n        if (fn(item)) {\n            res[0].push(item);\n        }\n        else {\n            res[1].push(item);\n        }\n    }\n    return res;\n}\nexports.splitArray = splitArray;\nfunction tail(array, n = 0) {\n    return array[array.length - (1 + n)];\n}\nexports.tail = tail;\nfunction group(array, size) {\n    let len = array.length;\n    let res = [];\n    for (let i = 0; i < Math.ceil(len / size); i++) {\n        res.push(array.slice(i * size, (i + 1) * size));\n    }\n    return res;\n}\nexports.group = group;\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equalness by returning a unique string for each.\n */\nfunction distinct(array, keyFn) {\n    if (!keyFn) {\n        return array.filter((element, position) => array.indexOf(element) === position);\n    }\n    const seen = Object.create(null);\n    return array.filter(elem => {\n        const key = keyFn(elem);\n        if (seen[key]) {\n            return false;\n        }\n        seen[key] = true;\n        return true;\n    });\n}\nexports.distinct = distinct;\nfunction lastIndex(array, fn) {\n    let i = array.length - 1;\n    while (i >= 0) {\n        if (fn(array[i])) {\n            break;\n        }\n        i--;\n    }\n    return i;\n}\nexports.lastIndex = lastIndex;\nconst flatMap = (xs, f) => xs.reduce((x, y) => [...x, ...f(y)], []);\nexports.flatMap = flatMap;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/array.ts?");

/***/ }),

/***/ "./src/util/charCode.ts":
/*!******************************!*\
  !*** ./src/util/charCode.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/* ---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CharCode = void 0;\n// Names from https://blog.codinghorror.com/ascii-pronunciation-rules-for-programmers/\n/**\n * An inlined enum containing useful character codes (to be used with String.charCodeAt).\n * Please leave the const keyword such that it gets inlined when compiled to JavaScript!\n */\nvar CharCode;\n(function (CharCode) {\n    CharCode[CharCode[\"Null\"] = 0] = \"Null\";\n    /**\n     * The `\\b` character.\n     */\n    CharCode[CharCode[\"Backspace\"] = 8] = \"Backspace\";\n    /**\n     * The `\\t` character.\n     */\n    CharCode[CharCode[\"Tab\"] = 9] = \"Tab\";\n    /**\n     * The `\\n` character.\n     */\n    CharCode[CharCode[\"LineFeed\"] = 10] = \"LineFeed\";\n    /**\n     * The `\\r` character.\n     */\n    CharCode[CharCode[\"CarriageReturn\"] = 13] = \"CarriageReturn\";\n    CharCode[CharCode[\"Space\"] = 32] = \"Space\";\n    /**\n     * The `!` character.\n     */\n    CharCode[CharCode[\"ExclamationMark\"] = 33] = \"ExclamationMark\";\n    /**\n     * The `\"` character.\n     */\n    CharCode[CharCode[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n    /**\n     * The `#` character.\n     */\n    CharCode[CharCode[\"Hash\"] = 35] = \"Hash\";\n    /**\n     * The `$` character.\n     */\n    CharCode[CharCode[\"DollarSign\"] = 36] = \"DollarSign\";\n    /**\n     * The `%` character.\n     */\n    CharCode[CharCode[\"PercentSign\"] = 37] = \"PercentSign\";\n    /**\n     * The `&` character.\n     */\n    CharCode[CharCode[\"Ampersand\"] = 38] = \"Ampersand\";\n    /**\n     * The `'` character.\n     */\n    CharCode[CharCode[\"SingleQuote\"] = 39] = \"SingleQuote\";\n    /**\n     * The `(` character.\n     */\n    CharCode[CharCode[\"OpenParen\"] = 40] = \"OpenParen\";\n    /**\n     * The `)` character.\n     */\n    CharCode[CharCode[\"CloseParen\"] = 41] = \"CloseParen\";\n    /**\n     * The `*` character.\n     */\n    CharCode[CharCode[\"Asterisk\"] = 42] = \"Asterisk\";\n    /**\n     * The `+` character.\n     */\n    CharCode[CharCode[\"Plus\"] = 43] = \"Plus\";\n    /**\n     * The `,` character.\n     */\n    CharCode[CharCode[\"Comma\"] = 44] = \"Comma\";\n    /**\n     * The `-` character.\n     */\n    CharCode[CharCode[\"Dash\"] = 45] = \"Dash\";\n    /**\n     * The `.` character.\n     */\n    CharCode[CharCode[\"Period\"] = 46] = \"Period\";\n    /**\n     * The `/` character.\n     */\n    CharCode[CharCode[\"Slash\"] = 47] = \"Slash\";\n    CharCode[CharCode[\"Digit0\"] = 48] = \"Digit0\";\n    CharCode[CharCode[\"Digit1\"] = 49] = \"Digit1\";\n    CharCode[CharCode[\"Digit2\"] = 50] = \"Digit2\";\n    CharCode[CharCode[\"Digit3\"] = 51] = \"Digit3\";\n    CharCode[CharCode[\"Digit4\"] = 52] = \"Digit4\";\n    CharCode[CharCode[\"Digit5\"] = 53] = \"Digit5\";\n    CharCode[CharCode[\"Digit6\"] = 54] = \"Digit6\";\n    CharCode[CharCode[\"Digit7\"] = 55] = \"Digit7\";\n    CharCode[CharCode[\"Digit8\"] = 56] = \"Digit8\";\n    CharCode[CharCode[\"Digit9\"] = 57] = \"Digit9\";\n    /**\n     * The `:` character.\n     */\n    CharCode[CharCode[\"Colon\"] = 58] = \"Colon\";\n    /**\n     * The `;` character.\n     */\n    CharCode[CharCode[\"Semicolon\"] = 59] = \"Semicolon\";\n    /**\n     * The `<` character.\n     */\n    CharCode[CharCode[\"LessThan\"] = 60] = \"LessThan\";\n    /**\n     * The `=` character.\n     */\n    CharCode[CharCode[\"Equals\"] = 61] = \"Equals\";\n    /**\n     * The `>` character.\n     */\n    CharCode[CharCode[\"GreaterThan\"] = 62] = \"GreaterThan\";\n    /**\n     * The `?` character.\n     */\n    CharCode[CharCode[\"QuestionMark\"] = 63] = \"QuestionMark\";\n    /**\n     * The `@` character.\n     */\n    CharCode[CharCode[\"AtSign\"] = 64] = \"AtSign\";\n    CharCode[CharCode[\"A\"] = 65] = \"A\";\n    CharCode[CharCode[\"B\"] = 66] = \"B\";\n    CharCode[CharCode[\"C\"] = 67] = \"C\";\n    CharCode[CharCode[\"D\"] = 68] = \"D\";\n    CharCode[CharCode[\"E\"] = 69] = \"E\";\n    CharCode[CharCode[\"F\"] = 70] = \"F\";\n    CharCode[CharCode[\"G\"] = 71] = \"G\";\n    CharCode[CharCode[\"H\"] = 72] = \"H\";\n    CharCode[CharCode[\"I\"] = 73] = \"I\";\n    CharCode[CharCode[\"J\"] = 74] = \"J\";\n    CharCode[CharCode[\"K\"] = 75] = \"K\";\n    CharCode[CharCode[\"L\"] = 76] = \"L\";\n    CharCode[CharCode[\"M\"] = 77] = \"M\";\n    CharCode[CharCode[\"N\"] = 78] = \"N\";\n    CharCode[CharCode[\"O\"] = 79] = \"O\";\n    CharCode[CharCode[\"P\"] = 80] = \"P\";\n    CharCode[CharCode[\"Q\"] = 81] = \"Q\";\n    CharCode[CharCode[\"R\"] = 82] = \"R\";\n    CharCode[CharCode[\"S\"] = 83] = \"S\";\n    CharCode[CharCode[\"T\"] = 84] = \"T\";\n    CharCode[CharCode[\"U\"] = 85] = \"U\";\n    CharCode[CharCode[\"V\"] = 86] = \"V\";\n    CharCode[CharCode[\"W\"] = 87] = \"W\";\n    CharCode[CharCode[\"X\"] = 88] = \"X\";\n    CharCode[CharCode[\"Y\"] = 89] = \"Y\";\n    CharCode[CharCode[\"Z\"] = 90] = \"Z\";\n    /**\n     * The `[` character.\n     */\n    CharCode[CharCode[\"OpenSquareBracket\"] = 91] = \"OpenSquareBracket\";\n    /**\n     * The `\\` character.\n     */\n    CharCode[CharCode[\"Backslash\"] = 92] = \"Backslash\";\n    /**\n     * The `]` character.\n     */\n    CharCode[CharCode[\"CloseSquareBracket\"] = 93] = \"CloseSquareBracket\";\n    /**\n     * The `^` character.\n     */\n    CharCode[CharCode[\"Caret\"] = 94] = \"Caret\";\n    /**\n     * The `_` character.\n     */\n    CharCode[CharCode[\"Underline\"] = 95] = \"Underline\";\n    /**\n     * The ``(`)`` character.\n     */\n    CharCode[CharCode[\"BackTick\"] = 96] = \"BackTick\";\n    CharCode[CharCode[\"a\"] = 97] = \"a\";\n    CharCode[CharCode[\"b\"] = 98] = \"b\";\n    CharCode[CharCode[\"c\"] = 99] = \"c\";\n    CharCode[CharCode[\"d\"] = 100] = \"d\";\n    CharCode[CharCode[\"e\"] = 101] = \"e\";\n    CharCode[CharCode[\"f\"] = 102] = \"f\";\n    CharCode[CharCode[\"g\"] = 103] = \"g\";\n    CharCode[CharCode[\"h\"] = 104] = \"h\";\n    CharCode[CharCode[\"i\"] = 105] = \"i\";\n    CharCode[CharCode[\"j\"] = 106] = \"j\";\n    CharCode[CharCode[\"k\"] = 107] = \"k\";\n    CharCode[CharCode[\"l\"] = 108] = \"l\";\n    CharCode[CharCode[\"m\"] = 109] = \"m\";\n    CharCode[CharCode[\"n\"] = 110] = \"n\";\n    CharCode[CharCode[\"o\"] = 111] = \"o\";\n    CharCode[CharCode[\"p\"] = 112] = \"p\";\n    CharCode[CharCode[\"q\"] = 113] = \"q\";\n    CharCode[CharCode[\"r\"] = 114] = \"r\";\n    CharCode[CharCode[\"s\"] = 115] = \"s\";\n    CharCode[CharCode[\"t\"] = 116] = \"t\";\n    CharCode[CharCode[\"u\"] = 117] = \"u\";\n    CharCode[CharCode[\"v\"] = 118] = \"v\";\n    CharCode[CharCode[\"w\"] = 119] = \"w\";\n    CharCode[CharCode[\"x\"] = 120] = \"x\";\n    CharCode[CharCode[\"y\"] = 121] = \"y\";\n    CharCode[CharCode[\"z\"] = 122] = \"z\";\n    /**\n     * The `{` character.\n     */\n    CharCode[CharCode[\"OpenCurlyBrace\"] = 123] = \"OpenCurlyBrace\";\n    /**\n     * The `|` character.\n     */\n    CharCode[CharCode[\"Pipe\"] = 124] = \"Pipe\";\n    /**\n     * The `}` character.\n     */\n    CharCode[CharCode[\"CloseCurlyBrace\"] = 125] = \"CloseCurlyBrace\";\n    /**\n     * The `~` character.\n     */\n    CharCode[CharCode[\"Tilde\"] = 126] = \"Tilde\";\n    CharCode[CharCode[\"U_Combining_Grave_Accent\"] = 768] = \"U_Combining_Grave_Accent\";\n    CharCode[CharCode[\"U_Combining_Acute_Accent\"] = 769] = \"U_Combining_Acute_Accent\";\n    CharCode[CharCode[\"U_Combining_Circumflex_Accent\"] = 770] = \"U_Combining_Circumflex_Accent\";\n    CharCode[CharCode[\"U_Combining_Tilde\"] = 771] = \"U_Combining_Tilde\";\n    CharCode[CharCode[\"U_Combining_Macron\"] = 772] = \"U_Combining_Macron\";\n    CharCode[CharCode[\"U_Combining_Overline\"] = 773] = \"U_Combining_Overline\";\n    CharCode[CharCode[\"U_Combining_Breve\"] = 774] = \"U_Combining_Breve\";\n    CharCode[CharCode[\"U_Combining_Dot_Above\"] = 775] = \"U_Combining_Dot_Above\";\n    CharCode[CharCode[\"U_Combining_Diaeresis\"] = 776] = \"U_Combining_Diaeresis\";\n    CharCode[CharCode[\"U_Combining_Hook_Above\"] = 777] = \"U_Combining_Hook_Above\";\n    CharCode[CharCode[\"U_Combining_Ring_Above\"] = 778] = \"U_Combining_Ring_Above\";\n    CharCode[CharCode[\"U_Combining_Double_Acute_Accent\"] = 779] = \"U_Combining_Double_Acute_Accent\";\n    CharCode[CharCode[\"U_Combining_Caron\"] = 780] = \"U_Combining_Caron\";\n    CharCode[CharCode[\"U_Combining_Vertical_Line_Above\"] = 781] = \"U_Combining_Vertical_Line_Above\";\n    CharCode[CharCode[\"U_Combining_Double_Vertical_Line_Above\"] = 782] = \"U_Combining_Double_Vertical_Line_Above\";\n    CharCode[CharCode[\"U_Combining_Double_Grave_Accent\"] = 783] = \"U_Combining_Double_Grave_Accent\";\n    CharCode[CharCode[\"U_Combining_Candrabindu\"] = 784] = \"U_Combining_Candrabindu\";\n    CharCode[CharCode[\"U_Combining_Inverted_Breve\"] = 785] = \"U_Combining_Inverted_Breve\";\n    CharCode[CharCode[\"U_Combining_Turned_Comma_Above\"] = 786] = \"U_Combining_Turned_Comma_Above\";\n    CharCode[CharCode[\"U_Combining_Comma_Above\"] = 787] = \"U_Combining_Comma_Above\";\n    CharCode[CharCode[\"U_Combining_Reversed_Comma_Above\"] = 788] = \"U_Combining_Reversed_Comma_Above\";\n    CharCode[CharCode[\"U_Combining_Comma_Above_Right\"] = 789] = \"U_Combining_Comma_Above_Right\";\n    CharCode[CharCode[\"U_Combining_Grave_Accent_Below\"] = 790] = \"U_Combining_Grave_Accent_Below\";\n    CharCode[CharCode[\"U_Combining_Acute_Accent_Below\"] = 791] = \"U_Combining_Acute_Accent_Below\";\n    CharCode[CharCode[\"U_Combining_Left_Tack_Below\"] = 792] = \"U_Combining_Left_Tack_Below\";\n    CharCode[CharCode[\"U_Combining_Right_Tack_Below\"] = 793] = \"U_Combining_Right_Tack_Below\";\n    CharCode[CharCode[\"U_Combining_Left_Angle_Above\"] = 794] = \"U_Combining_Left_Angle_Above\";\n    CharCode[CharCode[\"U_Combining_Horn\"] = 795] = \"U_Combining_Horn\";\n    CharCode[CharCode[\"U_Combining_Left_Half_Ring_Below\"] = 796] = \"U_Combining_Left_Half_Ring_Below\";\n    CharCode[CharCode[\"U_Combining_Up_Tack_Below\"] = 797] = \"U_Combining_Up_Tack_Below\";\n    CharCode[CharCode[\"U_Combining_Down_Tack_Below\"] = 798] = \"U_Combining_Down_Tack_Below\";\n    CharCode[CharCode[\"U_Combining_Plus_Sign_Below\"] = 799] = \"U_Combining_Plus_Sign_Below\";\n    CharCode[CharCode[\"U_Combining_Minus_Sign_Below\"] = 800] = \"U_Combining_Minus_Sign_Below\";\n    CharCode[CharCode[\"U_Combining_Palatalized_Hook_Below\"] = 801] = \"U_Combining_Palatalized_Hook_Below\";\n    CharCode[CharCode[\"U_Combining_Retroflex_Hook_Below\"] = 802] = \"U_Combining_Retroflex_Hook_Below\";\n    CharCode[CharCode[\"U_Combining_Dot_Below\"] = 803] = \"U_Combining_Dot_Below\";\n    CharCode[CharCode[\"U_Combining_Diaeresis_Below\"] = 804] = \"U_Combining_Diaeresis_Below\";\n    CharCode[CharCode[\"U_Combining_Ring_Below\"] = 805] = \"U_Combining_Ring_Below\";\n    CharCode[CharCode[\"U_Combining_Comma_Below\"] = 806] = \"U_Combining_Comma_Below\";\n    CharCode[CharCode[\"U_Combining_Cedilla\"] = 807] = \"U_Combining_Cedilla\";\n    CharCode[CharCode[\"U_Combining_Ogonek\"] = 808] = \"U_Combining_Ogonek\";\n    CharCode[CharCode[\"U_Combining_Vertical_Line_Below\"] = 809] = \"U_Combining_Vertical_Line_Below\";\n    CharCode[CharCode[\"U_Combining_Bridge_Below\"] = 810] = \"U_Combining_Bridge_Below\";\n    CharCode[CharCode[\"U_Combining_Inverted_Double_Arch_Below\"] = 811] = \"U_Combining_Inverted_Double_Arch_Below\";\n    CharCode[CharCode[\"U_Combining_Caron_Below\"] = 812] = \"U_Combining_Caron_Below\";\n    CharCode[CharCode[\"U_Combining_Circumflex_Accent_Below\"] = 813] = \"U_Combining_Circumflex_Accent_Below\";\n    CharCode[CharCode[\"U_Combining_Breve_Below\"] = 814] = \"U_Combining_Breve_Below\";\n    CharCode[CharCode[\"U_Combining_Inverted_Breve_Below\"] = 815] = \"U_Combining_Inverted_Breve_Below\";\n    CharCode[CharCode[\"U_Combining_Tilde_Below\"] = 816] = \"U_Combining_Tilde_Below\";\n    CharCode[CharCode[\"U_Combining_Macron_Below\"] = 817] = \"U_Combining_Macron_Below\";\n    CharCode[CharCode[\"U_Combining_Low_Line\"] = 818] = \"U_Combining_Low_Line\";\n    CharCode[CharCode[\"U_Combining_Double_Low_Line\"] = 819] = \"U_Combining_Double_Low_Line\";\n    CharCode[CharCode[\"U_Combining_Tilde_Overlay\"] = 820] = \"U_Combining_Tilde_Overlay\";\n    CharCode[CharCode[\"U_Combining_Short_Stroke_Overlay\"] = 821] = \"U_Combining_Short_Stroke_Overlay\";\n    CharCode[CharCode[\"U_Combining_Long_Stroke_Overlay\"] = 822] = \"U_Combining_Long_Stroke_Overlay\";\n    CharCode[CharCode[\"U_Combining_Short_Solidus_Overlay\"] = 823] = \"U_Combining_Short_Solidus_Overlay\";\n    CharCode[CharCode[\"U_Combining_Long_Solidus_Overlay\"] = 824] = \"U_Combining_Long_Solidus_Overlay\";\n    CharCode[CharCode[\"U_Combining_Right_Half_Ring_Below\"] = 825] = \"U_Combining_Right_Half_Ring_Below\";\n    CharCode[CharCode[\"U_Combining_Inverted_Bridge_Below\"] = 826] = \"U_Combining_Inverted_Bridge_Below\";\n    CharCode[CharCode[\"U_Combining_Square_Below\"] = 827] = \"U_Combining_Square_Below\";\n    CharCode[CharCode[\"U_Combining_Seagull_Below\"] = 828] = \"U_Combining_Seagull_Below\";\n    CharCode[CharCode[\"U_Combining_X_Above\"] = 829] = \"U_Combining_X_Above\";\n    CharCode[CharCode[\"U_Combining_Vertical_Tilde\"] = 830] = \"U_Combining_Vertical_Tilde\";\n    CharCode[CharCode[\"U_Combining_Double_Overline\"] = 831] = \"U_Combining_Double_Overline\";\n    CharCode[CharCode[\"U_Combining_Grave_Tone_Mark\"] = 832] = \"U_Combining_Grave_Tone_Mark\";\n    CharCode[CharCode[\"U_Combining_Acute_Tone_Mark\"] = 833] = \"U_Combining_Acute_Tone_Mark\";\n    CharCode[CharCode[\"U_Combining_Greek_Perispomeni\"] = 834] = \"U_Combining_Greek_Perispomeni\";\n    CharCode[CharCode[\"U_Combining_Greek_Koronis\"] = 835] = \"U_Combining_Greek_Koronis\";\n    CharCode[CharCode[\"U_Combining_Greek_Dialytika_Tonos\"] = 836] = \"U_Combining_Greek_Dialytika_Tonos\";\n    CharCode[CharCode[\"U_Combining_Greek_Ypogegrammeni\"] = 837] = \"U_Combining_Greek_Ypogegrammeni\";\n    CharCode[CharCode[\"U_Combining_Bridge_Above\"] = 838] = \"U_Combining_Bridge_Above\";\n    CharCode[CharCode[\"U_Combining_Equals_Sign_Below\"] = 839] = \"U_Combining_Equals_Sign_Below\";\n    CharCode[CharCode[\"U_Combining_Double_Vertical_Line_Below\"] = 840] = \"U_Combining_Double_Vertical_Line_Below\";\n    CharCode[CharCode[\"U_Combining_Left_Angle_Below\"] = 841] = \"U_Combining_Left_Angle_Below\";\n    CharCode[CharCode[\"U_Combining_Not_Tilde_Above\"] = 842] = \"U_Combining_Not_Tilde_Above\";\n    CharCode[CharCode[\"U_Combining_Homothetic_Above\"] = 843] = \"U_Combining_Homothetic_Above\";\n    CharCode[CharCode[\"U_Combining_Almost_Equal_To_Above\"] = 844] = \"U_Combining_Almost_Equal_To_Above\";\n    CharCode[CharCode[\"U_Combining_Left_Right_Arrow_Below\"] = 845] = \"U_Combining_Left_Right_Arrow_Below\";\n    CharCode[CharCode[\"U_Combining_Upwards_Arrow_Below\"] = 846] = \"U_Combining_Upwards_Arrow_Below\";\n    CharCode[CharCode[\"U_Combining_Grapheme_Joiner\"] = 847] = \"U_Combining_Grapheme_Joiner\";\n    CharCode[CharCode[\"U_Combining_Right_Arrowhead_Above\"] = 848] = \"U_Combining_Right_Arrowhead_Above\";\n    CharCode[CharCode[\"U_Combining_Left_Half_Ring_Above\"] = 849] = \"U_Combining_Left_Half_Ring_Above\";\n    CharCode[CharCode[\"U_Combining_Fermata\"] = 850] = \"U_Combining_Fermata\";\n    CharCode[CharCode[\"U_Combining_X_Below\"] = 851] = \"U_Combining_X_Below\";\n    CharCode[CharCode[\"U_Combining_Left_Arrowhead_Below\"] = 852] = \"U_Combining_Left_Arrowhead_Below\";\n    CharCode[CharCode[\"U_Combining_Right_Arrowhead_Below\"] = 853] = \"U_Combining_Right_Arrowhead_Below\";\n    CharCode[CharCode[\"U_Combining_Right_Arrowhead_And_Up_Arrowhead_Below\"] = 854] = \"U_Combining_Right_Arrowhead_And_Up_Arrowhead_Below\";\n    CharCode[CharCode[\"U_Combining_Right_Half_Ring_Above\"] = 855] = \"U_Combining_Right_Half_Ring_Above\";\n    CharCode[CharCode[\"U_Combining_Dot_Above_Right\"] = 856] = \"U_Combining_Dot_Above_Right\";\n    CharCode[CharCode[\"U_Combining_Asterisk_Below\"] = 857] = \"U_Combining_Asterisk_Below\";\n    CharCode[CharCode[\"U_Combining_Double_Ring_Below\"] = 858] = \"U_Combining_Double_Ring_Below\";\n    CharCode[CharCode[\"U_Combining_Zigzag_Above\"] = 859] = \"U_Combining_Zigzag_Above\";\n    CharCode[CharCode[\"U_Combining_Double_Breve_Below\"] = 860] = \"U_Combining_Double_Breve_Below\";\n    CharCode[CharCode[\"U_Combining_Double_Breve\"] = 861] = \"U_Combining_Double_Breve\";\n    CharCode[CharCode[\"U_Combining_Double_Macron\"] = 862] = \"U_Combining_Double_Macron\";\n    CharCode[CharCode[\"U_Combining_Double_Macron_Below\"] = 863] = \"U_Combining_Double_Macron_Below\";\n    CharCode[CharCode[\"U_Combining_Double_Tilde\"] = 864] = \"U_Combining_Double_Tilde\";\n    CharCode[CharCode[\"U_Combining_Double_Inverted_Breve\"] = 865] = \"U_Combining_Double_Inverted_Breve\";\n    CharCode[CharCode[\"U_Combining_Double_Rightwards_Arrow_Below\"] = 866] = \"U_Combining_Double_Rightwards_Arrow_Below\";\n    CharCode[CharCode[\"U_Combining_Latin_Small_Letter_A\"] = 867] = \"U_Combining_Latin_Small_Letter_A\";\n    CharCode[CharCode[\"U_Combining_Latin_Small_Letter_E\"] = 868] = \"U_Combining_Latin_Small_Letter_E\";\n    CharCode[CharCode[\"U_Combining_Latin_Small_Letter_I\"] = 869] = \"U_Combining_Latin_Small_Letter_I\";\n    CharCode[CharCode[\"U_Combining_Latin_Small_Letter_O\"] = 870] = \"U_Combining_Latin_Small_Letter_O\";\n    CharCode[CharCode[\"U_Combining_Latin_Small_Letter_U\"] = 871] = \"U_Combining_Latin_Small_Letter_U\";\n    CharCode[CharCode[\"U_Combining_Latin_Small_Letter_C\"] = 872] = \"U_Combining_Latin_Small_Letter_C\";\n    CharCode[CharCode[\"U_Combining_Latin_Small_Letter_D\"] = 873] = \"U_Combining_Latin_Small_Letter_D\";\n    CharCode[CharCode[\"U_Combining_Latin_Small_Letter_H\"] = 874] = \"U_Combining_Latin_Small_Letter_H\";\n    CharCode[CharCode[\"U_Combining_Latin_Small_Letter_M\"] = 875] = \"U_Combining_Latin_Small_Letter_M\";\n    CharCode[CharCode[\"U_Combining_Latin_Small_Letter_R\"] = 876] = \"U_Combining_Latin_Small_Letter_R\";\n    CharCode[CharCode[\"U_Combining_Latin_Small_Letter_T\"] = 877] = \"U_Combining_Latin_Small_Letter_T\";\n    CharCode[CharCode[\"U_Combining_Latin_Small_Letter_V\"] = 878] = \"U_Combining_Latin_Small_Letter_V\";\n    CharCode[CharCode[\"U_Combining_Latin_Small_Letter_X\"] = 879] = \"U_Combining_Latin_Small_Letter_X\";\n    /**\n     * Unicode Character 'LINE SEPARATOR' (U+2028)\n     * http://www.fileformat.info/info/unicode/char/2028/index.htm\n     */\n    CharCode[CharCode[\"LINE_SEPARATOR_2028\"] = 8232] = \"LINE_SEPARATOR_2028\";\n    // http://www.fileformat.info/info/unicode/category/Sk/list.htm\n    CharCode[CharCode[\"U_CIRCUMFLEX\"] = 94] = \"U_CIRCUMFLEX\";\n    CharCode[CharCode[\"U_GRAVE_ACCENT\"] = 96] = \"U_GRAVE_ACCENT\";\n    CharCode[CharCode[\"U_DIAERESIS\"] = 168] = \"U_DIAERESIS\";\n    CharCode[CharCode[\"U_MACRON\"] = 175] = \"U_MACRON\";\n    CharCode[CharCode[\"U_ACUTE_ACCENT\"] = 180] = \"U_ACUTE_ACCENT\";\n    CharCode[CharCode[\"U_CEDILLA\"] = 184] = \"U_CEDILLA\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_LEFT_ARROWHEAD\"] = 706] = \"U_MODIFIER_LETTER_LEFT_ARROWHEAD\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_RIGHT_ARROWHEAD\"] = 707] = \"U_MODIFIER_LETTER_RIGHT_ARROWHEAD\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_UP_ARROWHEAD\"] = 708] = \"U_MODIFIER_LETTER_UP_ARROWHEAD\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_DOWN_ARROWHEAD\"] = 709] = \"U_MODIFIER_LETTER_DOWN_ARROWHEAD\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_CENTRED_RIGHT_HALF_RING\"] = 722] = \"U_MODIFIER_LETTER_CENTRED_RIGHT_HALF_RING\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_CENTRED_LEFT_HALF_RING\"] = 723] = \"U_MODIFIER_LETTER_CENTRED_LEFT_HALF_RING\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_UP_TACK\"] = 724] = \"U_MODIFIER_LETTER_UP_TACK\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_DOWN_TACK\"] = 725] = \"U_MODIFIER_LETTER_DOWN_TACK\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_PLUS_SIGN\"] = 726] = \"U_MODIFIER_LETTER_PLUS_SIGN\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_MINUS_SIGN\"] = 727] = \"U_MODIFIER_LETTER_MINUS_SIGN\";\n    CharCode[CharCode[\"U_BREVE\"] = 728] = \"U_BREVE\";\n    CharCode[CharCode[\"U_DOT_ABOVE\"] = 729] = \"U_DOT_ABOVE\";\n    CharCode[CharCode[\"U_RING_ABOVE\"] = 730] = \"U_RING_ABOVE\";\n    CharCode[CharCode[\"U_OGONEK\"] = 731] = \"U_OGONEK\";\n    CharCode[CharCode[\"U_SMALL_TILDE\"] = 732] = \"U_SMALL_TILDE\";\n    CharCode[CharCode[\"U_DOUBLE_ACUTE_ACCENT\"] = 733] = \"U_DOUBLE_ACUTE_ACCENT\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_RHOTIC_HOOK\"] = 734] = \"U_MODIFIER_LETTER_RHOTIC_HOOK\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_CROSS_ACCENT\"] = 735] = \"U_MODIFIER_LETTER_CROSS_ACCENT\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_EXTRA_HIGH_TONE_BAR\"] = 741] = \"U_MODIFIER_LETTER_EXTRA_HIGH_TONE_BAR\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_HIGH_TONE_BAR\"] = 742] = \"U_MODIFIER_LETTER_HIGH_TONE_BAR\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_MID_TONE_BAR\"] = 743] = \"U_MODIFIER_LETTER_MID_TONE_BAR\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_LOW_TONE_BAR\"] = 744] = \"U_MODIFIER_LETTER_LOW_TONE_BAR\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_EXTRA_LOW_TONE_BAR\"] = 745] = \"U_MODIFIER_LETTER_EXTRA_LOW_TONE_BAR\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_YIN_DEPARTING_TONE_MARK\"] = 746] = \"U_MODIFIER_LETTER_YIN_DEPARTING_TONE_MARK\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_YANG_DEPARTING_TONE_MARK\"] = 747] = \"U_MODIFIER_LETTER_YANG_DEPARTING_TONE_MARK\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_UNASPIRATED\"] = 749] = \"U_MODIFIER_LETTER_UNASPIRATED\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_LOW_DOWN_ARROWHEAD\"] = 751] = \"U_MODIFIER_LETTER_LOW_DOWN_ARROWHEAD\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_LOW_UP_ARROWHEAD\"] = 752] = \"U_MODIFIER_LETTER_LOW_UP_ARROWHEAD\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_LOW_LEFT_ARROWHEAD\"] = 753] = \"U_MODIFIER_LETTER_LOW_LEFT_ARROWHEAD\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_LOW_RIGHT_ARROWHEAD\"] = 754] = \"U_MODIFIER_LETTER_LOW_RIGHT_ARROWHEAD\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_LOW_RING\"] = 755] = \"U_MODIFIER_LETTER_LOW_RING\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_MIDDLE_GRAVE_ACCENT\"] = 756] = \"U_MODIFIER_LETTER_MIDDLE_GRAVE_ACCENT\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_MIDDLE_DOUBLE_GRAVE_ACCENT\"] = 757] = \"U_MODIFIER_LETTER_MIDDLE_DOUBLE_GRAVE_ACCENT\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_MIDDLE_DOUBLE_ACUTE_ACCENT\"] = 758] = \"U_MODIFIER_LETTER_MIDDLE_DOUBLE_ACUTE_ACCENT\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_LOW_TILDE\"] = 759] = \"U_MODIFIER_LETTER_LOW_TILDE\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_RAISED_COLON\"] = 760] = \"U_MODIFIER_LETTER_RAISED_COLON\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_BEGIN_HIGH_TONE\"] = 761] = \"U_MODIFIER_LETTER_BEGIN_HIGH_TONE\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_END_HIGH_TONE\"] = 762] = \"U_MODIFIER_LETTER_END_HIGH_TONE\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_BEGIN_LOW_TONE\"] = 763] = \"U_MODIFIER_LETTER_BEGIN_LOW_TONE\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_END_LOW_TONE\"] = 764] = \"U_MODIFIER_LETTER_END_LOW_TONE\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_SHELF\"] = 765] = \"U_MODIFIER_LETTER_SHELF\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_OPEN_SHELF\"] = 766] = \"U_MODIFIER_LETTER_OPEN_SHELF\";\n    CharCode[CharCode[\"U_MODIFIER_LETTER_LOW_LEFT_ARROW\"] = 767] = \"U_MODIFIER_LETTER_LOW_LEFT_ARROW\";\n    CharCode[CharCode[\"U_GREEK_LOWER_NUMERAL_SIGN\"] = 885] = \"U_GREEK_LOWER_NUMERAL_SIGN\";\n    CharCode[CharCode[\"U_GREEK_TONOS\"] = 900] = \"U_GREEK_TONOS\";\n    CharCode[CharCode[\"U_GREEK_DIALYTIKA_TONOS\"] = 901] = \"U_GREEK_DIALYTIKA_TONOS\";\n    CharCode[CharCode[\"U_GREEK_KORONIS\"] = 8125] = \"U_GREEK_KORONIS\";\n    CharCode[CharCode[\"U_GREEK_PSILI\"] = 8127] = \"U_GREEK_PSILI\";\n    CharCode[CharCode[\"U_GREEK_PERISPOMENI\"] = 8128] = \"U_GREEK_PERISPOMENI\";\n    CharCode[CharCode[\"U_GREEK_DIALYTIKA_AND_PERISPOMENI\"] = 8129] = \"U_GREEK_DIALYTIKA_AND_PERISPOMENI\";\n    CharCode[CharCode[\"U_GREEK_PSILI_AND_VARIA\"] = 8141] = \"U_GREEK_PSILI_AND_VARIA\";\n    CharCode[CharCode[\"U_GREEK_PSILI_AND_OXIA\"] = 8142] = \"U_GREEK_PSILI_AND_OXIA\";\n    CharCode[CharCode[\"U_GREEK_PSILI_AND_PERISPOMENI\"] = 8143] = \"U_GREEK_PSILI_AND_PERISPOMENI\";\n    CharCode[CharCode[\"U_GREEK_DASIA_AND_VARIA\"] = 8157] = \"U_GREEK_DASIA_AND_VARIA\";\n    CharCode[CharCode[\"U_GREEK_DASIA_AND_OXIA\"] = 8158] = \"U_GREEK_DASIA_AND_OXIA\";\n    CharCode[CharCode[\"U_GREEK_DASIA_AND_PERISPOMENI\"] = 8159] = \"U_GREEK_DASIA_AND_PERISPOMENI\";\n    CharCode[CharCode[\"U_GREEK_DIALYTIKA_AND_VARIA\"] = 8173] = \"U_GREEK_DIALYTIKA_AND_VARIA\";\n    CharCode[CharCode[\"U_GREEK_DIALYTIKA_AND_OXIA\"] = 8174] = \"U_GREEK_DIALYTIKA_AND_OXIA\";\n    CharCode[CharCode[\"U_GREEK_VARIA\"] = 8175] = \"U_GREEK_VARIA\";\n    CharCode[CharCode[\"U_GREEK_OXIA\"] = 8189] = \"U_GREEK_OXIA\";\n    CharCode[CharCode[\"U_GREEK_DASIA\"] = 8190] = \"U_GREEK_DASIA\";\n    CharCode[CharCode[\"U_OVERLINE\"] = 8254] = \"U_OVERLINE\";\n    /**\n     * UTF-8 BOM\n     * Unicode Character 'ZERO WIDTH NO-BREAK SPACE' (U+FEFF)\n     * http://www.fileformat.info/info/unicode/char/feff/index.htm\n     */\n    CharCode[CharCode[\"UTF8_BOM\"] = 65279] = \"UTF8_BOM\";\n})(CharCode = exports.CharCode || (exports.CharCode = {}));\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/charCode.ts?");

/***/ }),

/***/ "./src/util/complete.ts":
/*!******************************!*\
  !*** ./src/util/complete.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getValidWord = exports.getSnippetDocumentation = exports.completionKindString = exports.getDocumentation = exports.getWord = exports.getPosition = void 0;\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst parser_1 = __webpack_require__(/*! ../snippets/parser */ \"./src/snippets/parser.ts\");\nconst string_1 = __webpack_require__(/*! ./string */ \"./src/util/string.ts\");\nconst logger = __webpack_require__(/*! ./logger */ \"./src/util/logger.ts\")('util-complete');\nfunction getPosition(opt) {\n    let { line, linenr, colnr } = opt;\n    let part = string_1.byteSlice(line, 0, colnr - 1);\n    return {\n        line: linenr - 1,\n        character: part.length\n    };\n}\nexports.getPosition = getPosition;\nfunction getWord(item, opt, invalidInsertCharacters) {\n    let { label, data, insertTextFormat, insertText, textEdit } = item;\n    let word;\n    let newText;\n    if (data && typeof data.word === 'string')\n        return data.word;\n    if (textEdit) {\n        let { range } = textEdit;\n        newText = textEdit.newText;\n        if (range && range.start.line == range.end.line) {\n            let { line, col, colnr } = opt;\n            let character = string_1.characterIndex(line, col);\n            if (range.start.character > character) {\n                let before = line.slice(character - range.start.character);\n                newText = before + newText;\n            }\n            else {\n                let start = line.slice(range.start.character, character);\n                if (start.length && newText.startsWith(start)) {\n                    newText = newText.slice(start.length);\n                }\n            }\n            character = string_1.characterIndex(line, colnr - 1);\n            if (range.end.character > character) {\n                let end = line.slice(character, range.end.character);\n                if (newText.endsWith(end)) {\n                    newText = newText.slice(0, -end.length);\n                }\n            }\n        }\n    }\n    else {\n        newText = insertText;\n    }\n    if (insertTextFormat == vscode_languageserver_protocol_1.InsertTextFormat.Snippet\n        && newText\n        && newText.includes('$')) {\n        let parser = new parser_1.SnippetParser();\n        let text = parser.text(newText);\n        word = text ? getValidWord(text, invalidInsertCharacters) : label;\n    }\n    else {\n        word = getValidWord(newText, invalidInsertCharacters) || label;\n    }\n    return word || '';\n}\nexports.getWord = getWord;\nfunction getDocumentation(item) {\n    let { documentation } = item;\n    if (!documentation)\n        return '';\n    if (typeof documentation === 'string')\n        return documentation;\n    return documentation.value;\n}\nexports.getDocumentation = getDocumentation;\nfunction completionKindString(kind, map, defaultValue = '') {\n    return map.get(kind) || defaultValue;\n}\nexports.completionKindString = completionKindString;\nfunction getSnippetDocumentation(languageId, body) {\n    languageId = languageId.replace(/react$/, '');\n    let str = body.replace(/\\$\\d+/g, '').replace(/\\$\\{\\d+(?::([^{]+))?\\}/, '$1');\n    str = '``` ' + languageId + '\\n' + str + '\\n' + '```';\n    return str;\n}\nexports.getSnippetDocumentation = getSnippetDocumentation;\nfunction getValidWord(text, invalidChars) {\n    if (!text)\n        return '';\n    for (let i = 0; i < text.length; i++) {\n        let c = text[i];\n        if (invalidChars.includes(c)) {\n            return text.slice(0, i);\n        }\n    }\n    return text;\n}\nexports.getValidWord = getValidWord;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/complete.ts?");

/***/ }),

/***/ "./src/util/convert.ts":
/*!*****************************!*\
  !*** ./src/util/convert.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getSymbolKind = void 0;\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nfunction getSymbolKind(kind) {\n    switch (kind) {\n        case vscode_languageserver_protocol_1.SymbolKind.File:\n            return 'File';\n        case vscode_languageserver_protocol_1.SymbolKind.Module:\n            return 'Module';\n        case vscode_languageserver_protocol_1.SymbolKind.Namespace:\n            return 'Namespace';\n        case vscode_languageserver_protocol_1.SymbolKind.Package:\n            return 'Package';\n        case vscode_languageserver_protocol_1.SymbolKind.Class:\n            return 'Class';\n        case vscode_languageserver_protocol_1.SymbolKind.Method:\n            return 'Method';\n        case vscode_languageserver_protocol_1.SymbolKind.Property:\n            return 'Property';\n        case vscode_languageserver_protocol_1.SymbolKind.Field:\n            return 'Field';\n        case vscode_languageserver_protocol_1.SymbolKind.Constructor:\n            return 'Constructor';\n        case vscode_languageserver_protocol_1.SymbolKind.Enum:\n            return 'Enum';\n        case vscode_languageserver_protocol_1.SymbolKind.Interface:\n            return 'Interface';\n        case vscode_languageserver_protocol_1.SymbolKind.Function:\n            return 'Function';\n        case vscode_languageserver_protocol_1.SymbolKind.Variable:\n            return 'Variable';\n        case vscode_languageserver_protocol_1.SymbolKind.Constant:\n            return 'Constant';\n        case vscode_languageserver_protocol_1.SymbolKind.String:\n            return 'String';\n        case vscode_languageserver_protocol_1.SymbolKind.Number:\n            return 'Number';\n        case vscode_languageserver_protocol_1.SymbolKind.Boolean:\n            return 'Boolean';\n        case vscode_languageserver_protocol_1.SymbolKind.Array:\n            return 'Array';\n        case vscode_languageserver_protocol_1.SymbolKind.Object:\n            return 'Object';\n        case vscode_languageserver_protocol_1.SymbolKind.Key:\n            return 'Key';\n        case vscode_languageserver_protocol_1.SymbolKind.Null:\n            return 'Null';\n        case vscode_languageserver_protocol_1.SymbolKind.EnumMember:\n            return 'EnumMember';\n        case vscode_languageserver_protocol_1.SymbolKind.Struct:\n            return 'Struct';\n        case vscode_languageserver_protocol_1.SymbolKind.Event:\n            return 'Event';\n        case vscode_languageserver_protocol_1.SymbolKind.Operator:\n            return 'Operator';\n        case vscode_languageserver_protocol_1.SymbolKind.TypeParameter:\n            return 'TypeParameter';\n        default:\n            return 'Unknown';\n    }\n}\nexports.getSymbolKind = getSymbolKind;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/convert.ts?");

/***/ }),

/***/ "./src/util/decorator.ts":
/*!*******************************!*\
  !*** ./src/util/decorator.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.memorize = void 0;\nconst logger = __webpack_require__(/*! ./logger */ \"./src/util/logger.ts\")('util-decorator');\nfunction memorize(_target, key, descriptor) {\n    let fn = descriptor.value;\n    if (typeof fn !== 'function')\n        return;\n    let memoKey = '$' + key;\n    descriptor.value = function (...args) {\n        if (this.hasOwnProperty(memoKey))\n            return Promise.resolve(this[memoKey]);\n        return new Promise((resolve, reject) => {\n            Promise.resolve(fn.apply(this, args)).then(res => {\n                this[memoKey] = res;\n                resolve(res);\n            }, e => {\n                reject(e);\n            });\n        });\n    };\n}\nexports.memorize = memorize;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/decorator.ts?");

/***/ }),

/***/ "./src/util/diff.ts":
/*!**************************!*\
  !*** ./src/util/diff.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.patchLine = exports.getChange = exports.diffLines = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst fast_diff_1 = tslib_1.__importDefault(__webpack_require__(/*! fast-diff */ \"./node_modules/fast-diff/diff.js\"));\nconst string_1 = __webpack_require__(/*! ./string */ \"./src/util/string.ts\");\nconst logger = __webpack_require__(/*! ./logger */ \"./src/util/logger.ts\")('util-diff');\nfunction diffLines(oldLines, newLines) {\n    let start = 0;\n    let end = oldLines.length;\n    let oldLen = end;\n    let len = newLines.length;\n    for (let i = 0; i <= end; i++) {\n        if (newLines[i] !== oldLines[i]) {\n            start = i;\n            break;\n        }\n        if (i == end) {\n            start = end;\n        }\n    }\n    if (start != newLines.length) {\n        let maxRemain = Math.min(end - start, len - start);\n        for (let j = 0; j < maxRemain; j++) {\n            if (oldLines[oldLen - j - 1] != newLines[len - j - 1]) {\n                break;\n            }\n            end = end - 1;\n        }\n    }\n    return {\n        start,\n        end,\n        replacement: newLines.slice(start, len - (oldLen - end))\n    };\n}\nexports.diffLines = diffLines;\nfunction getChange(oldStr, newStr, cursorEnd) {\n    let ol = oldStr.length;\n    let nl = newStr.length;\n    let max = Math.min(ol, nl);\n    let newText = '';\n    let startOffset = 0;\n    let endOffset = -1;\n    let shouldLimit = false;\n    // find first endOffset, could <= this. one\n    for (let i = 0; i <= max; i++) {\n        if (cursorEnd != null && i == cursorEnd) {\n            endOffset = i;\n            shouldLimit = true;\n            break;\n        }\n        if (oldStr[ol - i - 1] != newStr[nl - i - 1]) {\n            endOffset = i;\n            break;\n        }\n    }\n    if (endOffset == -1)\n        return null;\n    // find start offset\n    let remain = max - endOffset;\n    if (remain == 0) {\n        startOffset = 0;\n    }\n    else {\n        for (let i = 0; i <= remain; i++) {\n            if (oldStr[i] != newStr[i] || i == remain) {\n                startOffset = i;\n                break;\n            }\n        }\n    }\n    // limit to minimal change\n    remain = remain - startOffset;\n    if (shouldLimit && remain > 0) {\n        let end = endOffset;\n        for (let i = 0; i < remain; i++) {\n            let oc = oldStr[ol - end - 1 - i];\n            let nc = newStr[nl - end - 1 - i];\n            if (oc == nc) {\n                endOffset = endOffset + 1;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    let end = ol - endOffset;\n    if (ol == nl && startOffset == end)\n        return null;\n    newText = newStr.slice(startOffset, nl - endOffset);\n    // optimize for add new line(s)\n    if (startOffset == end) {\n        let pre = startOffset == 0 ? '' : newStr[startOffset - 1];\n        if (pre && pre != '\\n'\n            && oldStr[startOffset] == '\\n'\n            && newText.startsWith('\\n')) {\n            return { start: startOffset + 1, end: end + 1, newText: newText.slice(1) + '\\n' };\n        }\n    }\n    return { start: startOffset, end, newText };\n}\nexports.getChange = getChange;\nfunction patchLine(from, to, fill = ' ') {\n    if (from == to)\n        return to;\n    let idx = to.indexOf(from);\n    if (idx !== -1)\n        return fill.repeat(idx) + from;\n    let result = fast_diff_1.default(from, to);\n    let str = '';\n    for (let item of result) {\n        if (item[0] == fast_diff_1.default.DELETE) {\n            // not allowed\n            return to;\n        }\n        else if (item[0] == fast_diff_1.default.INSERT) {\n            str = str + fill.repeat(string_1.byteLength(item[1]));\n        }\n        else {\n            str = str + item[1];\n        }\n    }\n    return str;\n}\nexports.patchLine = patchLine;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/diff.ts?");

/***/ }),

/***/ "./src/util/extensions.ts":
/*!********************************!*\
  !*** ./src/util/extensions.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const logger = __webpack_require__(/*! ./logger */ \"./src/util/logger.ts\")('extensions');\n/**\n * Explicitly tells that promise should be run asynchonously.\n */\nPromise.prototype.logError = function () {\n    this.catch(e => {\n        logger.error(e);\n    });\n};\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/extensions.ts?");

/***/ }),

/***/ "./src/util/factory.ts":
/*!*****************************!*\
  !*** ./src/util/factory.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createExtension = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* eslint-disable @typescript-eslint/no-unsafe-return */\nconst fs_1 = tslib_1.__importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst path = tslib_1.__importStar(__webpack_require__(/*! path */ \"path\"));\nconst vm = tslib_1.__importStar(__webpack_require__(/*! vm */ \"vm\"));\nconst lodash_1 = __webpack_require__(/*! ./lodash */ \"./src/util/lodash.ts\");\nconst createLogger = __webpack_require__(/*! ./logger */ \"./src/util/logger.ts\");\nconst logger = createLogger('util-factoroy');\nconst requireFunc =  true ? require : 0;\nconst Module = __webpack_require__(/*! module */ \"module\");\nconst REMOVED_GLOBALS = [\n    'reallyExit',\n    'abort',\n    'umask',\n    'setuid',\n    'setgid',\n    'setgroups',\n    '_fatalException',\n    'exit',\n    'kill',\n];\nfunction removedGlobalStub(name) {\n    return () => {\n        throw new Error(`process.${name}() is not allowed in extension sandbox`);\n    };\n}\n// @see node/lib/internal/module.js\nfunction makeRequireFunction() {\n    const req = (p) => {\n        if (p === 'coc.nvim') {\n            return __webpack_require__(/*! ../index */ \"./src/index.ts\");\n        }\n        return this.require(p);\n    };\n    req.resolve = (request) => Module._resolveFilename(request, this);\n    req.main = process.mainModule;\n    // Enable support to add extra extension types\n    req.extensions = Module._extensions;\n    req.cache = Module._cache;\n    return req;\n}\n// @see node/lib/module.js\nfunction compileInSandbox(sandbox) {\n    // eslint-disable-next-line\n    return function (content, filename) {\n        const require = makeRequireFunction.call(this);\n        const dirname = path.dirname(filename);\n        // remove shebang\n        // eslint-disable-next-line\n        const newContent = content.replace(/^\\#\\!.*/, '');\n        const wrapper = Module.wrap(newContent);\n        const compiledWrapper = vm.runInContext(wrapper, sandbox, { filename });\n        const args = [this.exports, require, this, filename, dirname];\n        return compiledWrapper.apply(this.exports, args);\n    };\n}\nfunction createSandbox(filename, logger) {\n    const module = new Module(filename);\n    module.paths = Module._nodeModulePaths(filename);\n    const sandbox = vm.createContext({\n        module,\n        Buffer,\n        console: {\n            debug: (...args) => {\n                logger.debug.apply(logger, args);\n            },\n            log: (...args) => {\n                logger.debug.apply(logger, args);\n            },\n            error: (...args) => {\n                logger.error.apply(logger, args);\n            },\n            info: (...args) => {\n                logger.info.apply(logger, args);\n            },\n            warn: (...args) => {\n                logger.warn.apply(logger, args);\n            }\n        }\n    });\n    lodash_1.defaults(sandbox, global);\n    sandbox.Reflect = Reflect;\n    sandbox.require = function sandboxRequire(p) {\n        const oldCompile = Module.prototype._compile;\n        Module.prototype._compile = compileInSandbox(sandbox);\n        const moduleExports = sandbox.module.require(p);\n        Module.prototype._compile = oldCompile;\n        return moduleExports;\n    };\n    // patch `require` in sandbox to run loaded module in sandbox context\n    // if you need any of these, it might be worth discussing spawning separate processes\n    sandbox.process = new process.constructor();\n    for (let key of Object.keys(process)) {\n        sandbox.process[key] = process[key];\n    }\n    REMOVED_GLOBALS.forEach(name => {\n        sandbox.process[name] = removedGlobalStub(name);\n    });\n    sandbox.process['chdir'] = () => { };\n    // read-only umask\n    sandbox.process.umask = (mask) => {\n        if (typeof mask !== 'undefined') {\n            throw new Error('Cannot use process.umask() to change mask (read-only)');\n        }\n        return process.umask();\n    };\n    return sandbox;\n}\n// inspiration drawn from Module\nfunction createExtension(id, filename, isEmpty = false) {\n    if (isEmpty || !fs_1.default.existsSync(filename))\n        return {\n            activate: () => { },\n            deactivate: null\n        };\n    const sandbox = createSandbox(filename, createLogger(`extension:${id}`));\n    delete Module._cache[requireFunc.resolve(filename)];\n    // attempt to import plugin\n    // Require plugin to export activate & deactivate\n    const defaultImport = sandbox.require(filename);\n    const activate = (defaultImport && defaultImport.activate) || defaultImport;\n    if (typeof activate !== 'function') {\n        return { activate: () => { }, deactivate: null };\n    }\n    return {\n        activate,\n        deactivate: typeof defaultImport.deactivate === 'function' ? defaultImport.deactivate : null\n    };\n}\nexports.createExtension = createExtension;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/factory.ts?");

/***/ }),

/***/ "./src/util/fs.ts":
/*!************************!*\
  !*** ./src/util/fs.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fixDriver = exports.isParentFolder = exports.parentDirs = exports.isFile = exports.validSocket = exports.writeFile = exports.readFileLine = exports.readFileLines = exports.getFileLineCount = exports.readFile = exports.findUp = exports.inDirectory = exports.resolveRoot = exports.isGitIgnored = exports.renameAsync = exports.unlinkAsync = exports.isDirectory = exports.statAsync = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst child_process_1 = __webpack_require__(/*! child_process */ \"child_process\");\nconst fs_extra_1 = tslib_1.__importDefault(__webpack_require__(/*! fs-extra */ \"./node_modules/fs-extra/lib/index.js\"));\nconst net_1 = tslib_1.__importDefault(__webpack_require__(/*! net */ \"net\"));\nconst os_1 = tslib_1.__importDefault(__webpack_require__(/*! os */ \"os\"));\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst readline_1 = tslib_1.__importDefault(__webpack_require__(/*! readline */ \"readline\"));\nconst util_1 = tslib_1.__importDefault(__webpack_require__(/*! util */ \"util\"));\nconst minimatch_1 = tslib_1.__importDefault(__webpack_require__(/*! minimatch */ \"./node_modules/minimatch/minimatch.js\"));\nconst logger = __webpack_require__(/*! ./logger */ \"./src/util/logger.ts\")('util-fs');\nasync function statAsync(filepath) {\n    let stat = null;\n    try {\n        stat = await fs_extra_1.default.stat(filepath);\n    }\n    catch (e) { }\n    return stat;\n}\nexports.statAsync = statAsync;\nasync function isDirectory(filepath) {\n    let stat = await statAsync(filepath);\n    return stat && stat.isDirectory();\n}\nexports.isDirectory = isDirectory;\nasync function unlinkAsync(filepath) {\n    try {\n        await fs_extra_1.default.unlink(filepath);\n    }\n    catch (e) { }\n}\nexports.unlinkAsync = unlinkAsync;\nfunction renameAsync(oldPath, newPath) {\n    return new Promise((resolve, reject) => {\n        fs_extra_1.default.rename(oldPath, newPath, err => {\n            if (err)\n                return reject(err);\n            resolve();\n        });\n    });\n}\nexports.renameAsync = renameAsync;\nasync function isGitIgnored(fullpath) {\n    if (!fullpath)\n        return false;\n    let stat = await statAsync(fullpath);\n    if (!stat || !stat.isFile())\n        return false;\n    let root = null;\n    try {\n        let { stdout } = await util_1.default.promisify(child_process_1.exec)('git rev-parse --show-toplevel', { cwd: path_1.default.dirname(fullpath) });\n        root = stdout.trim();\n    }\n    catch (e) { }\n    if (!root)\n        return false;\n    let file = path_1.default.relative(root, fullpath);\n    try {\n        let { stdout } = await util_1.default.promisify(child_process_1.exec)(`git check-ignore ${file}`, { cwd: root });\n        return stdout.trim() == file;\n    }\n    catch (e) { }\n    return false;\n}\nexports.isGitIgnored = isGitIgnored;\nfunction resolveRoot(folder, subs, cwd) {\n    let home = os_1.default.homedir();\n    let dir = fixDriver(folder);\n    if (isParentFolder(dir, home, true))\n        return null;\n    if (cwd && isParentFolder(cwd, dir, true) && inDirectory(cwd, subs))\n        return cwd;\n    let parts = dir.split(path_1.default.sep);\n    let curr = [parts.shift()];\n    for (let part of parts) {\n        curr.push(part);\n        let dir = curr.join(path_1.default.sep);\n        if (dir != home && inDirectory(dir, subs)) {\n            return dir;\n        }\n    }\n    return null;\n}\nexports.resolveRoot = resolveRoot;\nfunction inDirectory(dir, subs) {\n    try {\n        let files = fs_extra_1.default.readdirSync(dir);\n        for (let pattern of subs) {\n            // note, only '*' expanded\n            let is_wildcard = (pattern.includes('*'));\n            let res = is_wildcard ?\n                (minimatch_1.default.match(files, pattern, { nobrace: true, noext: true, nocomment: true, nonegate: true, dot: true }).length !== 0) :\n                (files.includes(pattern));\n            if (res)\n                return true;\n        }\n    }\n    catch (e) {\n        // could be failed without permission\n    }\n    return false;\n}\nexports.inDirectory = inDirectory;\nfunction findUp(name, cwd) {\n    let root = path_1.default.parse(cwd).root;\n    let subs = Array.isArray(name) ? name : [name];\n    while (cwd && cwd !== root) {\n        let find = inDirectory(cwd, subs);\n        if (find) {\n            for (let sub of subs) {\n                let filepath = path_1.default.join(cwd, sub);\n                if (fs_extra_1.default.existsSync(filepath)) {\n                    return filepath;\n                }\n            }\n        }\n        cwd = path_1.default.dirname(cwd);\n    }\n    return null;\n}\nexports.findUp = findUp;\nfunction readFile(fullpath, encoding) {\n    return new Promise((resolve, reject) => {\n        fs_extra_1.default.readFile(fullpath, encoding, (err, content) => {\n            if (err)\n                reject(err);\n            resolve(content);\n        });\n    });\n}\nexports.readFile = readFile;\nfunction getFileLineCount(filepath) {\n    let i;\n    let count = 0;\n    return new Promise((resolve, reject) => {\n        fs_extra_1.default.createReadStream(filepath)\n            .on('error', e => reject(e))\n            .on('data', chunk => {\n            for (i = 0; i < chunk.length; ++i)\n                if (chunk[i] == 10)\n                    count++;\n        })\n            .on('end', () => resolve(count));\n    });\n}\nexports.getFileLineCount = getFileLineCount;\nfunction readFileLines(fullpath, start, end) {\n    if (!fs_extra_1.default.existsSync(fullpath)) {\n        return Promise.reject(new Error(`file does not exist: ${fullpath}`));\n    }\n    let res = [];\n    const rl = readline_1.default.createInterface({\n        input: fs_extra_1.default.createReadStream(fullpath, { encoding: 'utf8' }),\n        crlfDelay: Infinity,\n        terminal: false\n    });\n    let n = 0;\n    return new Promise((resolve, reject) => {\n        rl.on('line', line => {\n            if (n == 0 && line.startsWith('\\uFEFF')) {\n                // handle BOM\n                line = line.slice(1);\n            }\n            if (n >= start && n <= end) {\n                res.push(line);\n            }\n            if (n == end) {\n                rl.close();\n            }\n            n = n + 1;\n        });\n        rl.on('close', () => {\n            resolve(res);\n        });\n        rl.on('error', reject);\n    });\n}\nexports.readFileLines = readFileLines;\nfunction readFileLine(fullpath, count) {\n    if (!fs_extra_1.default.existsSync(fullpath)) {\n        return Promise.reject(new Error(`file does not exist: ${fullpath}`));\n    }\n    const rl = readline_1.default.createInterface({\n        input: fs_extra_1.default.createReadStream(fullpath, { encoding: 'utf8' }),\n        crlfDelay: Infinity,\n        terminal: false\n    });\n    let n = 0;\n    return new Promise((resolve, reject) => {\n        rl.on('line', line => {\n            if (n == count) {\n                if (n == 0 && line.startsWith('\\uFEFF')) {\n                    // handle BOM\n                    line = line.slice(1);\n                }\n                rl.close();\n                resolve(line);\n                return;\n            }\n            n = n + 1;\n        });\n        rl.on('error', reject);\n    });\n}\nexports.readFileLine = readFileLine;\nasync function writeFile(fullpath, content) {\n    await fs_extra_1.default.writeFile(fullpath, content, { encoding: 'utf8' });\n}\nexports.writeFile = writeFile;\nfunction validSocket(path) {\n    let clientSocket = new net_1.default.Socket();\n    return new Promise(resolve => {\n        clientSocket.on('error', () => {\n            resolve(false);\n        });\n        clientSocket.connect({ path }, () => {\n            clientSocket.unref();\n            resolve(true);\n        });\n    });\n}\nexports.validSocket = validSocket;\nfunction isFile(uri) {\n    return uri.startsWith('file:');\n}\nexports.isFile = isFile;\nfunction parentDirs(pth) {\n    let { root, dir } = path_1.default.parse(pth);\n    if (dir === root)\n        return [root];\n    const dirs = [root];\n    const parts = dir.slice(root.length).split(path_1.default.sep);\n    for (let i = 1; i <= parts.length; i++) {\n        dirs.push(path_1.default.join(root, parts.slice(0, i).join(path_1.default.sep)));\n    }\n    return dirs;\n}\nexports.parentDirs = parentDirs;\nfunction isParentFolder(folder, filepath, checkEqual = false) {\n    let pdir = fixDriver(path_1.default.resolve(path_1.default.normalize(folder)));\n    let dir = fixDriver(path_1.default.resolve(path_1.default.normalize(filepath)));\n    if (pdir == '//')\n        pdir = '/';\n    if (pdir == dir)\n        return checkEqual ? true : false;\n    if (pdir.endsWith(path_1.default.sep))\n        return dir.startsWith(pdir);\n    return dir.startsWith(pdir) && dir[pdir.length] == path_1.default.sep;\n}\nexports.isParentFolder = isParentFolder;\n// use uppercase for windows driver\nfunction fixDriver(filepath) {\n    if (os_1.default.platform() != 'win32' || filepath[1] != ':')\n        return filepath;\n    return filepath[0].toUpperCase() + filepath.slice(1);\n}\nexports.fixDriver = fixDriver;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/fs.ts?");

/***/ }),

/***/ "./src/util/fuzzy.ts":
/*!***************************!*\
  !*** ./src/util/fuzzy.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fuzzyMatch = exports.fuzzyChar = exports.caseMatch = exports.wordChar = exports.getCharCodes = void 0;\nfunction getCharCodes(str) {\n    let res = [];\n    for (let i = 0, l = str.length; i < l; i++) {\n        res.push(str.charCodeAt(i));\n    }\n    return res;\n}\nexports.getCharCodes = getCharCodes;\nfunction wordChar(ch) {\n    return (ch >= 97 && ch <= 122) || (ch >= 65 && ch <= 90);\n}\nexports.wordChar = wordChar;\nfunction caseMatch(input, code) {\n    if (input == code)\n        return true;\n    if (input >= 97 && input <= 122 && code + 32 === input)\n        return true;\n    return false;\n}\nexports.caseMatch = caseMatch;\nfunction fuzzyChar(a, b) {\n    let ca = a.charCodeAt(0);\n    let cb = b.charCodeAt(0);\n    if (ca === cb)\n        return true;\n    if (ca >= 97 && ca <= 122 && cb + 32 === ca)\n        return true;\n    return false;\n}\nexports.fuzzyChar = fuzzyChar;\n// upper case must match, lower case ignore case\nfunction fuzzyMatch(needle, text) {\n    let totalCount = needle.length;\n    if (needle.length > text.length)\n        return false;\n    let i = 0;\n    for (let j = 0; j < text.length; j++) {\n        if (i === totalCount)\n            break;\n        let code = text.charCodeAt(j);\n        let m = needle[i];\n        if (code === m) {\n            i = i + 1;\n            continue;\n        }\n        // upper case match lower case\n        if ((m >= 97 && m <= 122) && code + 32 === m) {\n            i = i + 1;\n            continue;\n        }\n    }\n    return i === totalCount;\n}\nexports.fuzzyMatch = fuzzyMatch;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/fuzzy.ts?");

/***/ }),

/***/ "./src/util/fzy.ts":
/*!*************************!*\
  !*** ./src/util/fzy.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hasMatch = exports.positions = exports.score = void 0;\nlet SCORE_MIN = -Infinity;\nlet SCORE_MAX = Infinity;\nlet SCORE_GAP_LEADING = -0.005;\nlet SCORE_GAP_TRAILING = -0.005;\nlet SCORE_GAP_INNER = -0.01;\nlet SCORE_MATCH_CONSECUTIVE = 1;\nlet SCORE_MATCH_SLASH = 0.9;\nlet SCORE_MATCH_WORD = 0.8;\nlet SCORE_MATCH_CAPITAL = 0.7;\nlet SCORE_MATCH_DOT = 0.6;\nfunction islower(s) {\n    return s.toLowerCase() === s;\n}\nfunction isupper(s) {\n    return s.toUpperCase() === s;\n}\nfunction precompute_bonus(haystack) {\n    /* Which positions are beginning of words */\n    let m = haystack.length;\n    let match_bonus = new Array(m);\n    let last_ch = '/';\n    for (let i = 0; i < m; i++) {\n        let ch = haystack[i];\n        if (last_ch === '/') {\n            match_bonus[i] = SCORE_MATCH_SLASH;\n        }\n        else if (last_ch === '-' || last_ch === '_' || last_ch === ' ') {\n            match_bonus[i] = SCORE_MATCH_WORD;\n        }\n        else if (last_ch === '.') {\n            match_bonus[i] = SCORE_MATCH_DOT;\n        }\n        else if (islower(last_ch) && isupper(ch)) {\n            match_bonus[i] = SCORE_MATCH_CAPITAL;\n        }\n        else {\n            match_bonus[i] = 0;\n        }\n        last_ch = ch;\n    }\n    return match_bonus;\n}\nfunction compute(needle, haystack, D, M) {\n    let n = needle.length;\n    let m = haystack.length;\n    let lower_needle = needle.toLowerCase();\n    let lower_haystack = haystack.toLowerCase();\n    let match_bonus = precompute_bonus(haystack);\n    /*\n     * D[][] Stores the best score for this position ending with a match.\n     * M[][] Stores the best possible score at this position.\n     */\n    for (let i = 0; i < n; i++) {\n        D[i] = new Array(m);\n        M[i] = new Array(m);\n        let prev_score = SCORE_MIN;\n        let gap_score = i === n - 1 ? SCORE_GAP_TRAILING : SCORE_GAP_INNER;\n        for (let j = 0; j < m; j++) {\n            if (lower_needle[i] === lower_haystack[j]) {\n                let score = SCORE_MIN;\n                if (!i) {\n                    score = (j * SCORE_GAP_LEADING) + match_bonus[j];\n                }\n                else if (j) { /* i > 0 && j > 0*/\n                    score = Math.max(M[i - 1][j - 1] + match_bonus[j], \n                    /* consecutive match, doesn't stack with match_bonus */\n                    D[i - 1][j - 1] + SCORE_MATCH_CONSECUTIVE);\n                }\n                D[i][j] = score;\n                M[i][j] = prev_score = Math.max(score, prev_score + gap_score);\n            }\n            else {\n                D[i][j] = SCORE_MIN;\n                M[i][j] = prev_score = prev_score + gap_score;\n            }\n        }\n    }\n}\nfunction score(needle, haystack) {\n    let n = needle.length;\n    let m = haystack.length;\n    if (!n || !m)\n        return SCORE_MIN;\n    if (n === m) {\n        /* Since this method can only be called with a haystack which\n         * matches needle. If the lengths of the strings are equal the\n         * strings themselves must also be equal (ignoring case).\n         */\n        return SCORE_MAX;\n    }\n    if (m > 1024) {\n        /*\n         * Unreasonably large candidate: return no score\n         * If it is a valid match it will still be returned, it will\n         * just be ranked below any reasonably sized candidates\n         */\n        return SCORE_MIN;\n    }\n    let D = new Array(n);\n    let M = new Array(n);\n    compute(needle, haystack, D, M);\n    return M[n - 1][m - 1];\n}\nexports.score = score;\nfunction positions(needle, haystack) {\n    let n = needle.length;\n    let m = haystack.length;\n    let positions = new Array(n);\n    if (!n || !m)\n        return positions;\n    if (n === m) {\n        for (let i = 0; i < n; i++)\n            positions[i] = i;\n        return positions;\n    }\n    if (m > 1024) {\n        return positions;\n    }\n    let D = new Array(n);\n    let M = new Array(n);\n    compute(needle, haystack, D, M);\n    /* backtrack to find the positions of optimal matching */\n    let match_required = false;\n    for (let i = n - 1, j = m - 1; i >= 0; i--) {\n        for (; j >= 0; j--) {\n            /*\n             * There may be multiple paths which result in\n             * the optimal weight.\n             *\n             * For simplicity, we will pick the first one\n             * we encounter, the latest in the candidate\n             * string.\n             */\n            if (D[i][j] !== SCORE_MIN &&\n                (match_required || D[i][j] === M[i][j])) {\n                /* If this score was determined using\n                 * SCORE_MATCH_CONSECUTIVE, the\n                 * previous character MUST be a match\n                 */\n                match_required =\n                    i && j &&\n                        M[i][j] === D[i - 1][j - 1] + SCORE_MATCH_CONSECUTIVE;\n                positions[i] = j--;\n                break;\n            }\n        }\n    }\n    return positions;\n}\nexports.positions = positions;\nfunction hasMatch(needle, haystack) {\n    needle = needle.toLowerCase();\n    haystack = haystack.toLowerCase();\n    let l = needle.length;\n    for (let i = 0, j = 0; i < l; i += 1) {\n        j = haystack.indexOf(needle[i], j) + 1;\n        if (j === 0)\n            return false;\n    }\n    return true;\n}\nexports.hasMatch = hasMatch;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/fzy.ts?");

/***/ }),

/***/ "./src/util/index.ts":
/*!***************************!*\
  !*** ./src/util/index.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.concurrent = exports.getKeymapModifier = exports.isRunning = exports.watchFile = exports.runCommand = exports.executable = exports.disposeAll = exports.getUri = exports.wait = exports.escapeSingleQuote = exports.CONFIG_FILE_NAME = exports.platform = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst child_process_1 = __webpack_require__(/*! child_process */ \"child_process\");\nconst debounce_1 = tslib_1.__importDefault(__webpack_require__(/*! debounce */ \"./node_modules/debounce/index.js\"));\nconst fs_1 = tslib_1.__importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst isuri_1 = tslib_1.__importDefault(__webpack_require__(/*! isuri */ \"./node_modules/isuri/index.js\"));\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst which_1 = tslib_1.__importDefault(__webpack_require__(/*! which */ \"./node_modules/which/which.js\"));\nconst platform = tslib_1.__importStar(__webpack_require__(/*! ./platform */ \"./src/util/platform.ts\"));\nexports.platform = platform;\nconst logger = __webpack_require__(/*! ./logger */ \"./src/util/logger.ts\")('util-index');\nexports.CONFIG_FILE_NAME = 'coc-settings.json';\nfunction escapeSingleQuote(str) {\n    return str.replace(/'/g, \"''\");\n}\nexports.escapeSingleQuote = escapeSingleQuote;\nfunction wait(ms) {\n    return new Promise(resolve => {\n        setTimeout(() => {\n            resolve(undefined);\n        }, ms);\n    });\n}\nexports.wait = wait;\nfunction getUri(fullpath, id, buftype, isCygwin) {\n    if (!fullpath)\n        return `untitled:${id}`;\n    // https://github.com/neoclide/coc-java/issues/82\n    if (platform.isWindows && !isCygwin && !fullpath.startsWith('jdt://'))\n        fullpath = path_1.default.win32.normalize(fullpath);\n    if (path_1.default.isAbsolute(fullpath))\n        return vscode_uri_1.URI.file(fullpath).toString();\n    if (isuri_1.default.isValid(fullpath))\n        return vscode_uri_1.URI.parse(fullpath).toString();\n    if (buftype != '')\n        return `${buftype}:${id}`;\n    return `unknown:${id}`;\n}\nexports.getUri = getUri;\nfunction disposeAll(disposables) {\n    while (disposables.length) {\n        const item = disposables.pop();\n        if (item) {\n            item.dispose();\n        }\n    }\n}\nexports.disposeAll = disposeAll;\nfunction executable(command) {\n    try {\n        which_1.default.sync(command);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nexports.executable = executable;\nfunction runCommand(cmd, opts = {}, timeout) {\n    if (!platform.isWindows) {\n        opts.shell = opts.shell || process.env.SHELL;\n    }\n    opts.maxBuffer = 500 * 1024;\n    return new Promise((resolve, reject) => {\n        let timer;\n        if (timeout) {\n            timer = setTimeout(() => {\n                reject(new Error(`timeout after ${timeout}s`));\n            }, timeout * 1000);\n        }\n        child_process_1.exec(cmd, opts, (err, stdout, stderr) => {\n            if (timer)\n                clearTimeout(timer);\n            if (err) {\n                reject(new Error(`exited with ${err.code}\\n${err}\\n${stderr}`));\n                return;\n            }\n            resolve(stdout);\n        });\n    });\n}\nexports.runCommand = runCommand;\nfunction watchFile(filepath, onChange) {\n    let callback = debounce_1.default(onChange, 100);\n    try {\n        let watcher = fs_1.default.watch(filepath, {\n            persistent: true,\n            recursive: false,\n            encoding: 'utf8'\n        }, () => {\n            callback();\n        });\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            callback.clear();\n            watcher.close();\n        });\n    }\n    catch (e) {\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            callback.clear();\n        });\n    }\n}\nexports.watchFile = watchFile;\nfunction isRunning(pid) {\n    try {\n        let res = process.kill(pid, 0);\n        return res == true;\n    }\n    catch (e) {\n        return e.code === 'EPERM';\n    }\n}\nexports.isRunning = isRunning;\nfunction getKeymapModifier(mode) {\n    if (mode == 'n' || mode == 'o' || mode == 'x' || mode == 'v')\n        return '<C-U>';\n    if (mode == 'i')\n        return '<C-o>';\n    if (mode == 's')\n        return '<Esc>';\n    return '';\n}\nexports.getKeymapModifier = getKeymapModifier;\nfunction concurrent(arr, fn, limit = 3) {\n    if (arr.length == 0)\n        return Promise.resolve();\n    let finished = 0;\n    let total = arr.length;\n    let remain = arr.slice();\n    return new Promise(resolve => {\n        let run = (val) => {\n            let cb = () => {\n                finished = finished + 1;\n                if (finished == total) {\n                    resolve();\n                }\n                else if (remain.length) {\n                    let next = remain.shift();\n                    run(next);\n                }\n            };\n            fn(val).then(cb, cb);\n        };\n        for (let i = 0; i < Math.min(limit, remain.length); i++) {\n            let val = remain.shift();\n            run(val);\n        }\n    });\n}\nexports.concurrent = concurrent;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/index.ts?");

/***/ }),

/***/ "./src/util/is.ts":
/*!************************!*\
  !*** ./src/util/is.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.typedArray = exports.emptyObject = exports.objectLiteral = exports.func = exports.array = exports.number = exports.string = exports.boolean = void 0;\n/* eslint-disable id-blacklist */\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction boolean(value) {\n    return typeof value === 'boolean';\n}\nexports.boolean = boolean;\nfunction string(value) {\n    return typeof value === 'string';\n}\nexports.string = string;\nfunction number(value) {\n    return typeof value === 'number';\n}\nexports.number = number;\nfunction array(array) {\n    return Array.isArray(array);\n}\nexports.array = array;\nfunction func(value) {\n    return typeof value == 'function';\n}\nexports.func = func;\nfunction objectLiteral(obj) {\n    return (obj != null &&\n        typeof obj === 'object' &&\n        !Array.isArray(obj) &&\n        !(obj instanceof RegExp) &&\n        !(obj instanceof Date));\n}\nexports.objectLiteral = objectLiteral;\nfunction emptyObject(obj) {\n    if (!objectLiteral(obj)) {\n        return false;\n    }\n    for (let key in obj) {\n        if (hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.emptyObject = emptyObject;\nfunction typedArray(value, check) {\n    return Array.isArray(value) && value.every(check);\n}\nexports.typedArray = typedArray;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/is.ts?");

/***/ }),

/***/ "./src/util/lodash.ts":
/*!****************************!*\
  !*** ./src/util/lodash.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.omit = exports.defaults = void 0;\n/** Used for built-in method references. */\nconst objectProto = Object.prototype;\n/** Used to check objects for own properties. */\nconst hasOwnProperty = objectProto.hasOwnProperty;\n/**\n * Assigns own and inherited enumerable string keyed properties of source\n * objects to the destination object for all destination properties that\n * resolve to `undefined`. Source objects are applied from left to right.\n * Once a property is set, additional values of the same property are ignored.\n *\n * **Note:** This method mutates `object`.\n *\n * @since 0.1.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see defaultsDeep\n * @example\n *\n * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 })\n * // => { 'a': 1, 'b': 2 }\n */\nfunction defaults(obj, ...sources) {\n    obj = Object(obj);\n    sources.forEach(source => {\n        if (source != null) {\n            source = Object(source);\n            for (const key in source) {\n                const value = obj[key];\n                if (value === undefined ||\n                    (value === objectProto[key] && !hasOwnProperty.call(obj, key))) {\n                    obj[key] = source[key];\n                }\n            }\n        }\n    });\n    return obj;\n}\nexports.defaults = defaults;\nfunction omit(obj, properties) {\n    let o = {};\n    for (let key of Object.keys(obj)) {\n        if (!properties.includes(key)) {\n            o[key] = obj[key];\n        }\n    }\n    return o;\n}\nexports.omit = omit;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/lodash.ts?");

/***/ }),

/***/ "./src/util/logger.ts":
/*!****************************!*\
  !*** ./src/util/logger.ts ***!
  \****************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst fs_1 = tslib_1.__importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst log4js_1 = tslib_1.__importDefault(__webpack_require__(/*! log4js */ \"./node_modules/log4js/lib/log4js.js\"));\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst os_1 = tslib_1.__importDefault(__webpack_require__(/*! os */ \"os\"));\nfunction getLogFile() {\n    let file = process.env.NVIM_COC_LOG_FILE;\n    if (file)\n        return file;\n    let dir = process.env.XDG_RUNTIME_DIR;\n    if (dir) {\n        try {\n            fs_1.default.accessSync(dir, fs_1.default.constants.R_OK | fs_1.default.constants.W_OK);\n            return path_1.default.join(dir, `coc-nvim-${process.pid}.log`);\n        }\n        catch (err) {\n            // noop\n        }\n    }\n    dir = path_1.default.join(process.env.TMPDIR, `coc.nvim-${process.pid}`);\n    if (os_1.default.platform() == 'win32') {\n        dir = path_1.default.win32.normalize(dir);\n    }\n    if (!fs_1.default.existsSync(dir))\n        fs_1.default.mkdirSync(dir, { recursive: true });\n    return path_1.default.join(dir, `coc-nvim.log`);\n}\nconst MAX_LOG_SIZE = 1024 * 1024;\nconst MAX_LOG_BACKUPS = 10;\nlet logfile = getLogFile();\nconst level = process.env.NVIM_COC_LOG_LEVEL || 'info';\nif (fs_1.default.existsSync(logfile)) {\n    // cleanup if exists\n    try {\n        fs_1.default.writeFileSync(logfile, '', { encoding: 'utf8', mode: 0o666 });\n    }\n    catch (e) {\n        // noop\n    }\n}\nlog4js_1.default.configure({\n    disableClustering: true,\n    appenders: {\n        out: {\n            type: 'file',\n            mode: 0o666,\n            filename: logfile,\n            maxLogSize: MAX_LOG_SIZE,\n            backups: MAX_LOG_BACKUPS,\n            layout: {\n                type: 'pattern',\n                // Format log in following pattern:\n                // yyyy-MM-dd HH:mm:ss.mil $Level (pid:$pid) $categroy - $message.\n                pattern: `%d{ISO8601} %p (pid:${process.pid}) [%c] - %m`,\n            },\n        }\n    },\n    categories: {\n        default: { appenders: ['out'], level }\n    }\n});\nmodule.exports = (name = 'coc-nvim') => {\n    let logger = log4js_1.default.getLogger(name);\n    logger.getLogFile = () => logfile;\n    return logger;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/logger.ts?");

/***/ }),

/***/ "./src/util/match.ts":
/*!***************************!*\
  !*** ./src/util/match.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.score = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst minimatch_1 = tslib_1.__importDefault(__webpack_require__(/*! minimatch */ \"./node_modules/minimatch/minimatch.js\"));\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst platform = tslib_1.__importStar(__webpack_require__(/*! ./platform */ \"./src/util/platform.ts\"));\nfunction score(selector, uri, languageId) {\n    if (Array.isArray(selector)) {\n        // array -> take max individual value\n        let ret = 0;\n        for (const filter of selector) {\n            const value = score(filter, uri, languageId);\n            if (value === 10) {\n                return value; // already at the highest\n            }\n            if (value > ret) {\n                ret = value;\n            }\n        }\n        return ret;\n    }\n    else if (typeof selector === 'string') {\n        // short-hand notion, desugars to\n        // 'fooLang' -> { language: 'fooLang'}\n        // '*' -> { language: '*' }\n        if (selector === '*') {\n            return 5;\n        }\n        else if (selector === languageId) {\n            return 10;\n        }\n        else {\n            return 0;\n        }\n    }\n    else if (selector) {\n        let u = vscode_uri_1.URI.parse(uri);\n        // filter -> select accordingly, use defaults for scheme\n        const { language, pattern, scheme } = selector;\n        let ret = 0;\n        if (scheme) {\n            if (scheme === u.scheme) {\n                ret = 5;\n            }\n            else if (scheme === '*') {\n                ret = 3;\n            }\n            else {\n                return 0;\n            }\n        }\n        if (language) {\n            if (language === languageId) {\n                ret = 10;\n            }\n            else if (language === '*') {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (pattern) {\n            let caseInsensitive = platform.isWindows || platform.isMacintosh;\n            let p = caseInsensitive ? pattern.toLowerCase() : pattern;\n            let f = caseInsensitive ? u.fsPath.toLowerCase() : u.fsPath;\n            if (p === f || minimatch_1.default(f, p, { dot: true })) {\n                ret = 5;\n            }\n            else {\n                return 0;\n            }\n        }\n        return ret;\n    }\n    else {\n        return 0;\n    }\n}\nexports.score = score;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/match.ts?");

/***/ }),

/***/ "./src/util/mutex.ts":
/*!***************************!*\
  !*** ./src/util/mutex.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Mutex = void 0;\nclass Mutex {\n    constructor() {\n        this.tasks = [];\n        this.count = 1;\n    }\n    sched() {\n        if (this.count > 0 && this.tasks.length > 0) {\n            this.count--;\n            let next = this.tasks.shift();\n            next();\n        }\n    }\n    get busy() {\n        return this.count == 0;\n    }\n    acquire() {\n        return new Promise(res => {\n            let task = () => {\n                let released = false;\n                res(() => {\n                    if (!released) {\n                        released = true;\n                        this.count++;\n                        this.sched();\n                    }\n                });\n            };\n            this.tasks.push(task);\n            process.nextTick(this.sched.bind(this));\n        });\n    }\n    use(f) {\n        return this.acquire()\n            .then(release => f()\n            .then(res => {\n            release();\n            return res;\n        })\n            .catch(err => {\n            release();\n            throw err;\n        }));\n    }\n}\nexports.Mutex = Mutex;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/mutex.ts?");

/***/ }),

/***/ "./src/util/object.ts":
/*!****************************!*\
  !*** ./src/util/object.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.equals = exports.mixin = exports.deepFreeze = exports.deepClone = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst Is = tslib_1.__importStar(__webpack_require__(/*! ./is */ \"./src/util/is.ts\"));\nfunction deepClone(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return obj;\n    }\n    if (obj instanceof RegExp) {\n        // See https://github.com/Microsoft/TypeScript/issues/10990\n        return obj;\n    }\n    const result = Array.isArray(obj) ? [] : {};\n    Object.keys(obj).forEach(key => {\n        if (obj[key] && typeof obj[key] === 'object') {\n            result[key] = deepClone(obj[key]);\n        }\n        else {\n            result[key] = obj[key];\n        }\n    });\n    return result;\n}\nexports.deepClone = deepClone;\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction deepFreeze(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return obj;\n    }\n    const stack = [obj];\n    while (stack.length > 0) {\n        let obj = stack.shift();\n        Object.freeze(obj);\n        for (const key in obj) {\n            if (_hasOwnProperty.call(obj, key)) {\n                let prop = obj[key];\n                if (typeof prop === 'object' && !Object.isFrozen(prop)) {\n                    stack.push(prop);\n                }\n            }\n        }\n    }\n    return obj;\n}\nexports.deepFreeze = deepFreeze;\n/**\n * Copies all properties of source into destination. The optional parameter \"overwrite\" allows to control\n * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).\n */\nfunction mixin(destination, source, overwrite = true) {\n    if (!Is.objectLiteral(destination)) {\n        return source;\n    }\n    if (Is.objectLiteral(source)) {\n        Object.keys(source).forEach(key => {\n            if (key in destination) {\n                if (overwrite) {\n                    if (Is.objectLiteral(destination[key]) && Is.objectLiteral(source[key])) {\n                        mixin(destination[key], source[key], overwrite);\n                    }\n                    else {\n                        destination[key] = source[key];\n                    }\n                }\n            }\n            else {\n                destination[key] = source[key];\n            }\n        });\n    }\n    return destination;\n}\nexports.mixin = mixin;\nfunction equals(one, other) {\n    if (one === other) {\n        return true;\n    }\n    if (one === null ||\n        one === undefined ||\n        other === null ||\n        other === undefined) {\n        return false;\n    }\n    if (typeof one !== typeof other) {\n        return false;\n    }\n    if (typeof one !== 'object') {\n        return false;\n    }\n    if (Array.isArray(one) !== Array.isArray(other)) {\n        return false;\n    }\n    let i;\n    let key;\n    if (Array.isArray(one)) {\n        if (one.length !== other.length) {\n            return false;\n        }\n        for (i = 0; i < one.length; i++) {\n            if (!equals(one[i], other[i])) {\n                return false;\n            }\n        }\n    }\n    else {\n        const oneKeys = [];\n        for (key in one) {\n            oneKeys.push(key);\n        }\n        oneKeys.sort();\n        const otherKeys = [];\n        for (key in other) {\n            otherKeys.push(key);\n        }\n        otherKeys.sort();\n        if (!equals(oneKeys, otherKeys)) {\n            return false;\n        }\n        for (i = 0; i < oneKeys.length; i++) {\n            if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nexports.equals = equals;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/object.ts?");

/***/ }),

/***/ "./src/util/platform.ts":
/*!******************************!*\
  !*** ./src/util/platform.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OS = exports.OperatingSystem = exports.globals = exports.platform = exports.isWeb = exports.isNative = exports.isLinux = exports.isMacintosh = exports.isWindows = exports.Platform = exports.language = void 0;\nlet _isWindows = false;\nlet _isMacintosh = false;\nlet _isLinux = false;\nlet _isNative = false;\nlet _isWeb = false;\nexports.language = 'en';\n// OS detection\nif (typeof process === 'object' &&\n    typeof process.nextTick === 'function' &&\n    typeof process.platform === 'string') {\n    _isWindows = process.platform === 'win32';\n    _isMacintosh = process.platform === 'darwin';\n    _isLinux = process.platform === 'linux';\n    _isNative = true;\n}\nvar Platform;\n(function (Platform) {\n    Platform[Platform[\"Web\"] = 0] = \"Web\";\n    Platform[Platform[\"Mac\"] = 1] = \"Mac\";\n    Platform[Platform[\"Linux\"] = 2] = \"Linux\";\n    Platform[Platform[\"Windows\"] = 3] = \"Windows\";\n})(Platform = exports.Platform || (exports.Platform = {}));\nlet _platform = Platform.Web;\nif (_isNative) {\n    if (_isMacintosh) {\n        _platform = Platform.Mac;\n    }\n    else if (_isWindows) {\n        _platform = Platform.Windows;\n    }\n    else if (_isLinux) {\n        _platform = Platform.Linux;\n    }\n}\nexports.isWindows = _isWindows;\nexports.isMacintosh = _isMacintosh;\nexports.isLinux = _isLinux;\nexports.isNative = _isNative;\nexports.isWeb = _isWeb;\nexports.platform = _platform;\nconst _globals = typeof self === 'object'\n    ? self\n    : typeof global === 'object'\n        ? global\n        : {};\nexports.globals = _globals;\nvar OperatingSystem;\n(function (OperatingSystem) {\n    OperatingSystem[OperatingSystem[\"Windows\"] = 1] = \"Windows\";\n    OperatingSystem[OperatingSystem[\"Macintosh\"] = 2] = \"Macintosh\";\n    OperatingSystem[OperatingSystem[\"Linux\"] = 3] = \"Linux\";\n})(OperatingSystem = exports.OperatingSystem || (exports.OperatingSystem = {}));\nexports.OS = _isMacintosh\n    ? OperatingSystem.Macintosh\n    : _isWindows\n        ? OperatingSystem.Windows\n        : OperatingSystem.Linux;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/platform.ts?");

/***/ }),

/***/ "./src/util/position.ts":
/*!******************************!*\
  !*** ./src/util/position.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getChangedFromEdits = exports.editRange = exports.positionToOffset = exports.adjustPosition = exports.getChangedPosition = exports.isSingleLine = exports.comparePosition = exports.positionInRange = exports.emptyRange = exports.lineInRange = exports.rangeIntersect = exports.rangeOverlap = exports.rangeInRange = void 0;\nfunction rangeInRange(r, range) {\n    return positionInRange(r.start, range) === 0 && positionInRange(r.end, range) === 0;\n}\nexports.rangeInRange = rangeInRange;\n/**\n * Check if two ranges have overlap character.\n */\nfunction rangeOverlap(r, range) {\n    let { start, end } = r;\n    if (comparePosition(end, range.start) <= 0) {\n        return false;\n    }\n    if (comparePosition(start, range.end) >= 0) {\n        return false;\n    }\n    return true;\n}\nexports.rangeOverlap = rangeOverlap;\n/**\n * Check if two ranges have overlap or nested\n */\nfunction rangeIntersect(r, range) {\n    if (positionInRange(r.start, range) == 0) {\n        return true;\n    }\n    if (positionInRange(r.end, range) == 0) {\n        return true;\n    }\n    if (rangeInRange(range, r)) {\n        return true;\n    }\n    return false;\n}\nexports.rangeIntersect = rangeIntersect;\nfunction lineInRange(line, range) {\n    let { start, end } = range;\n    return line >= start.line && line <= end.line;\n}\nexports.lineInRange = lineInRange;\nfunction emptyRange(range) {\n    let { start, end } = range;\n    return start.line == end.line && start.character == end.character;\n}\nexports.emptyRange = emptyRange;\nfunction positionInRange(position, range) {\n    let { start, end } = range;\n    if (comparePosition(position, start) < 0)\n        return -1;\n    if (comparePosition(position, end) > 0)\n        return 1;\n    return 0;\n}\nexports.positionInRange = positionInRange;\nfunction comparePosition(position, other) {\n    if (position.line > other.line)\n        return 1;\n    if (other.line == position.line && position.character > other.character)\n        return 1;\n    if (other.line == position.line && position.character == other.character)\n        return 0;\n    return -1;\n}\nexports.comparePosition = comparePosition;\nfunction isSingleLine(range) {\n    return range.start.line == range.end.line;\n}\nexports.isSingleLine = isSingleLine;\nfunction getChangedPosition(start, edit) {\n    let { range, newText } = edit;\n    if (comparePosition(range.end, start) <= 0) {\n        let lines = newText.split('\\n');\n        let lineCount = lines.length - (range.end.line - range.start.line) - 1;\n        let characterCount = 0;\n        if (range.end.line == start.line) {\n            let single = isSingleLine(range) && lineCount == 0;\n            let removed = single ? range.end.character - range.start.character : range.end.character;\n            let added = single ? newText.length : lines[lines.length - 1].length;\n            characterCount = added - removed;\n        }\n        return { line: lineCount, character: characterCount };\n    }\n    return { line: 0, character: 0 };\n}\nexports.getChangedPosition = getChangedPosition;\nfunction adjustPosition(pos, edit) {\n    let { range, newText } = edit;\n    if (comparePosition(range.start, pos) > 1)\n        return pos;\n    let { start, end } = range;\n    let newLines = newText.split('\\n');\n    let delta = (end.line - start.line) - newLines.length + 1;\n    let lastLine = newLines[newLines.length - 1];\n    let line = pos.line - delta;\n    if (pos.line != end.line)\n        return { line, character: pos.character };\n    let pre = newLines.length == 1 && start.line != end.line ? start.character : 0;\n    let removed = start.line == end.line && newLines.length == 1 ? end.character - start.character : end.character;\n    let character = pre + pos.character + lastLine.length - removed;\n    return {\n        line,\n        character\n    };\n}\nexports.adjustPosition = adjustPosition;\nfunction positionToOffset(lines, line, character) {\n    let offset = 0;\n    for (let i = 0; i <= line; i++) {\n        if (i == line) {\n            offset += character;\n        }\n        else {\n            offset += lines[i].length + 1;\n        }\n    }\n    return offset;\n}\nexports.positionToOffset = positionToOffset;\n// edit a range to newText\nfunction editRange(range, text, edit) {\n    // outof range\n    if (!rangeInRange(edit.range, range))\n        return text;\n    let { start, end } = edit.range;\n    let lines = text.split('\\n');\n    let character = start.line == range.start.line ? start.character - range.start.character : start.character;\n    let startOffset = positionToOffset(lines, start.line - range.start.line, character);\n    character = end.line == range.start.line ? end.character - range.start.character : end.character;\n    let endOffset = positionToOffset(lines, end.line - range.start.line, character);\n    return `${text.slice(0, startOffset)}${edit.newText}${text.slice(endOffset, text.length)}`;\n}\nexports.editRange = editRange;\nfunction getChangedFromEdits(start, edits) {\n    let changed = { line: 0, character: 0 };\n    for (let edit of edits) {\n        let d = getChangedPosition(start, edit);\n        changed = { line: changed.line + d.line, character: changed.character + d.character };\n    }\n    return changed.line == 0 && changed.character == 0 ? null : changed;\n}\nexports.getChangedFromEdits = getChangedFromEdits;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/position.ts?");

/***/ }),

/***/ "./src/util/processes.ts":
/*!*******************************!*\
  !*** ./src/util/processes.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.terminate = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* ---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst cp = tslib_1.__importStar(__webpack_require__(/*! child_process */ \"child_process\"));\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst fs_1 = tslib_1.__importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst isWebpack = typeof __webpack_require__ === \"function\";\nconst isWindows = process.platform === 'win32';\nconst isMacintosh = process.platform === 'darwin';\nconst isLinux = process.platform === 'linux';\nconst pluginRoot = isWebpack ? path_1.dirname(__dirname) : path_1.resolve(__dirname, '../..');\nfunction terminate(process, cwd) {\n    if (process.killed)\n        return;\n    if (isWindows) {\n        try {\n            // This we run in Atom execFileSync is available.\n            // Ignore stderr since this is otherwise piped to parent.stderr\n            // which might be already closed.\n            let options = {\n                stdio: ['pipe', 'pipe', 'ignore']\n            };\n            if (cwd) {\n                options.cwd = cwd;\n            }\n            cp.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);\n            return true;\n        }\n        catch (err) {\n            return false;\n        }\n    }\n    else if (isLinux || isMacintosh) {\n        try {\n            let filepath = path_1.join(pluginRoot, 'bin/terminateProcess.sh');\n            if (!fs_1.default.existsSync(filepath)) {\n                console.error(`\"${filepath}\" not found`);\n                return false;\n            }\n            let result = cp.spawnSync(filepath, [process.pid.toString()]);\n            return result.error ? false : true;\n        }\n        catch (err) {\n            return false;\n        }\n    }\n    else {\n        process.kill('SIGKILL');\n        return true;\n    }\n}\nexports.terminate = terminate;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/processes.ts?");

/***/ }),

/***/ "./src/util/score.ts":
/*!***************************!*\
  !*** ./src/util/score.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getMatchResult = void 0;\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst fuzzy_1 = __webpack_require__(/*! ./fuzzy */ \"./src/util/fuzzy.ts\");\n// first is start or path start +1, fuzzy +0.5\n// next is followed of path start +1, fuzzy +0.5\n// filename startsWith +1, fuzzy +0.5\nfunction getMatchResult(text, query, filename = '') {\n    if (!query)\n        return { score: 1 };\n    let matches = [];\n    let codes = fuzzy_1.getCharCodes(query);\n    let filenameIdx = filename ? text.indexOf(filename) : -1;\n    let matchBase = filenameIdx != -1 && fuzzy_1.fuzzyMatch(codes, filename);\n    let score = 0;\n    let c = query[0];\n    let idx = 0;\n    // base => start => pathSeparator => fuzzy\n    if (matchBase) {\n        if (filename.startsWith(c)) {\n            score = score + 2;\n            idx = filenameIdx + 1;\n            matches.push(filenameIdx);\n        }\n        else if (filename[0].toLowerCase() == c) {\n            score = score + 1.5;\n            idx = filenameIdx + 1;\n            matches.push(filenameIdx);\n        }\n        else {\n            for (let i = 1; i < filename.length; i++) {\n                if (fuzzy_1.fuzzyChar(c, filename[i])) {\n                    score = score + 1;\n                    idx = filenameIdx + i + 1;\n                    matches.push(filenameIdx + i);\n                    break;\n                }\n            }\n        }\n    }\n    else if (text.startsWith(c)) {\n        score = score + 1;\n        matches.push(0);\n        idx = 1;\n    }\n    else {\n        for (let i = 1; i < text.length; i++) {\n            let pre = text[i - 1];\n            if (pre == path_1.sep && text[i] == c) {\n                score = score + 1;\n                matches.push(i);\n                idx = i + 1;\n                break;\n            }\n        }\n        if (idx == 0) {\n            for (let i = 0; i < text.length; i++) {\n                if (fuzzy_1.fuzzyChar(c, text[i])) {\n                    score = score + 0.5;\n                    matches.push(i);\n                    idx = i + 1;\n                    break;\n                }\n            }\n        }\n    }\n    if (idx == 0)\n        return { score: 0 };\n    if (codes.length == 1)\n        return { score, matches };\n    return nextResult(codes.slice(1), text, idx, { score, matches });\n}\nexports.getMatchResult = getMatchResult;\n/**\n *\n * @public\n * @param {number[]} codes - remain codes\n * @param {string} text - total text\n * @param {number} idx - start index of text\n * @param {MatchResult} curr - current result\n * @returns {MatchResult | null}\n */\nfunction nextResult(codes, text, idx, curr) {\n    let { score, matches } = curr;\n    let results = [];\n    let c = codes[0];\n    let remain = codes.slice(1);\n    let result;\n    function getRemianResult(index) {\n        if (!result)\n            return;\n        if (remain.length == 0) {\n            results.push(result);\n        }\n        else if (result) {\n            let res = nextResult(remain, text, index, result);\n            if (res)\n                results.push(res);\n        }\n    }\n    let followed = idx < text.length ? text[idx].charCodeAt(0) : null;\n    if (!followed)\n        return null;\n    if (followed == c) {\n        result = { score: score + 1, matches: matches.concat([idx]) };\n        getRemianResult(idx + 1);\n    }\n    else if (fuzzy_1.caseMatch(c, followed)) {\n        result = { score: score + 0.5, matches: matches.concat([idx]) };\n        getRemianResult(idx + 1);\n    }\n    if (idx + 1 < text.length) {\n        // follow path\n        for (let i = idx + 1; i < text.length; i++) {\n            let ch = text[i].charCodeAt(0);\n            if (text[i - 1] == path_1.sep && fuzzy_1.caseMatch(c, ch)) {\n                let add = c == ch ? 1 : 0.5;\n                result = { score: score + add, matches: matches.concat([i]) };\n                getRemianResult(i + 1);\n                break;\n            }\n        }\n        // next fuzzy\n        for (let i = idx + 1; i < text.length; i++) {\n            let ch = text[i].charCodeAt(0);\n            if (fuzzy_1.caseMatch(c, ch)) {\n                let add = c == ch ? 0.5 : 0.2;\n                result = { score: score + add, matches: matches.concat([i]) };\n                getRemianResult(i + 1);\n                break;\n            }\n        }\n    }\n    return results.length ? bestResult(results) : null;\n}\nfunction bestResult(results) {\n    let res = results[0];\n    for (let i = 1; i < results.length; i++) {\n        if (results[i].score > res.score) {\n            res = results[i];\n        }\n    }\n    return res;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/score.ts?");

/***/ }),

/***/ "./src/util/string.ts":
/*!****************************!*\
  !*** ./src/util/string.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.equalsIgnoreCase = exports.isAsciiLetter = exports.isTriggerCharacter = exports.isWord = exports.byteSlice = exports.characterIndex = exports.indexOf = exports.byteIndex = exports.upperFirst = exports.byteLength = void 0;\n// nvim use utf8\nfunction byteLength(str) {\n    return Buffer.byteLength(str);\n}\nexports.byteLength = byteLength;\nfunction upperFirst(str) {\n    return str ? str[0].toUpperCase() + str.slice(1) : '';\n}\nexports.upperFirst = upperFirst;\nfunction byteIndex(content, index) {\n    let s = content.slice(0, index);\n    return Buffer.byteLength(s);\n}\nexports.byteIndex = byteIndex;\nfunction indexOf(str, ch, count = 1) {\n    let curr = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] == ch) {\n            curr = curr + 1;\n            if (curr == count) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\nexports.indexOf = indexOf;\nfunction characterIndex(content, byteIndex) {\n    let buf = Buffer.from(content, 'utf8');\n    return buf.slice(0, byteIndex).toString('utf8').length;\n}\nexports.characterIndex = characterIndex;\nfunction byteSlice(content, start, end) {\n    let buf = Buffer.from(content, 'utf8');\n    return buf.slice(start, end).toString('utf8');\n}\nexports.byteSlice = byteSlice;\nfunction isWord(character) {\n    let code = character.charCodeAt(0);\n    if (code > 128)\n        return false;\n    if (code == 95)\n        return true;\n    if (code >= 48 && code <= 57)\n        return true;\n    if (code >= 65 && code <= 90)\n        return true;\n    if (code >= 97 && code <= 122)\n        return true;\n    return false;\n}\nexports.isWord = isWord;\nfunction isTriggerCharacter(character) {\n    if (!character)\n        return false;\n    let code = character.charCodeAt(0);\n    if (code > 128)\n        return false;\n    if (code >= 65 && code <= 90)\n        return false;\n    if (code >= 97 && code <= 122)\n        return false;\n    return true;\n}\nexports.isTriggerCharacter = isTriggerCharacter;\nfunction isAsciiLetter(code) {\n    if (code >= 65 && code <= 90)\n        return true;\n    if (code >= 97 && code <= 122)\n        return true;\n    return false;\n}\nexports.isAsciiLetter = isAsciiLetter;\nfunction doEqualsIgnoreCase(a, b, stopAt = a.length) {\n    if (typeof a !== 'string' || typeof b !== 'string') {\n        return false;\n    }\n    for (let i = 0; i < stopAt; i++) {\n        const codeA = a.charCodeAt(i);\n        const codeB = b.charCodeAt(i);\n        if (codeA === codeB) {\n            continue;\n        }\n        // a-z A-Z\n        if (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {\n            const diff = Math.abs(codeA - codeB);\n            if (diff !== 0 && diff !== 32) {\n                return false;\n            }\n        }\n        // Any other charcode\n        else {\n            if (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction equalsIgnoreCase(a, b) {\n    const len1 = a ? a.length : 0;\n    const len2 = b ? b.length : 0;\n    if (len1 !== len2) {\n        return false;\n    }\n    return doEqualsIgnoreCase(a, b);\n}\nexports.equalsIgnoreCase = equalsIgnoreCase;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/string.ts?");

/***/ }),

/***/ "./src/util/throttle.ts":
/*!******************************!*\
  !*** ./src/util/throttle.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/**\n * Returns a new function that, when invoked, invokes `func` at most once per `wait` milliseconds.\n *\n * @param {Function} func Function to wrap.\n * @param {Number} wait Number of milliseconds that must elapse between `func` invocations.\n * @return {Function} A new function that wraps the `func` function passed in.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction throttle(func, wait) {\n    let args;\n    let rtn;\n    let timeoutID;\n    let last = 0;\n    function fn() {\n        args = arguments;\n        let delta = Date.now() - last;\n        if (!timeoutID) {\n            if (last != 0 && delta >= wait) {\n                call();\n            }\n            else {\n                timeoutID = setTimeout(call, wait - delta);\n            }\n        }\n        return rtn;\n    }\n    function call() {\n        timeoutID = 0;\n        last = Date.now();\n        rtn = func.apply(null, args);\n        args = null;\n    }\n    fn.clear = () => {\n        if (timeoutID) {\n            clearTimeout(timeoutID);\n        }\n    };\n    return fn;\n}\nexports.default = throttle;\n\n\n//# sourceURL=webpack://coc.nvim/./src/util/throttle.ts?");

/***/ }),

/***/ "./src/watchman.ts":
/*!*************************!*\
  !*** ./src/watchman.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isValidWatchRoot = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst fb_watchman_1 = tslib_1.__importDefault(__webpack_require__(/*! fb-watchman */ \"./node_modules/fb-watchman/index.js\"));\nconst os_1 = tslib_1.__importDefault(__webpack_require__(/*! os */ \"os\"));\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst minimatch_1 = tslib_1.__importDefault(__webpack_require__(/*! minimatch */ \"./node_modules/minimatch/minimatch.js\"));\nconst fs_1 = __webpack_require__(/*! ./util/fs */ \"./src/util/fs.ts\");\nconst logger = __webpack_require__(/*! ./util/logger */ \"./src/util/logger.ts\")('watchman');\nconst requiredCapabilities = ['relative_root', 'cmd-watch-project', 'wildmatch', 'field-new'];\nconst clientsMap = new Map();\n/**\n * Watchman wrapper for fb-watchman client\n *\n * @public\n */\nclass Watchman {\n    constructor(binaryPath, channel) {\n        this.channel = channel;\n        this._disposed = false;\n        this.client = new fb_watchman_1.default.Client({\n            watchmanBinaryPath: binaryPath\n        });\n        this.client.setMaxListeners(300);\n    }\n    checkCapability() {\n        let { client } = this;\n        return new Promise((resolve, reject) => {\n            client.capabilityCheck({\n                optional: [],\n                required: requiredCapabilities\n            }, (error, resp) => {\n                if (error)\n                    return reject(error);\n                let { capabilities } = resp;\n                for (let key of Object.keys(capabilities)) {\n                    if (!capabilities[key])\n                        return resolve(false);\n                }\n                resolve(true);\n            });\n        });\n    }\n    async watchProject(root) {\n        try {\n            let resp = await this.command(['watch-project', root]);\n            let { watch, warning, relative_path } = resp;\n            if (warning)\n                logger.warn(warning);\n            this.watch = watch;\n            this.relative_path = relative_path;\n            logger.info(`watchman watching project: ${root}`);\n            this.appendOutput(`watchman watching project: ${root}`);\n        }\n        catch (e) {\n            logger.error(e);\n            return false;\n        }\n        return true;\n    }\n    command(args) {\n        return new Promise((resolve, reject) => {\n            this.client.command(args, (error, resp) => {\n                if (error)\n                    return reject(error);\n                resolve(resp);\n            });\n        });\n    }\n    async subscribe(globPattern, cb) {\n        let { watch, relative_path } = this;\n        if (!watch) {\n            this.appendOutput(`watchman not watching: ${watch}`, 'Error');\n            return null;\n        }\n        let { clock } = await this.command(['clock', watch]);\n        let uid = uuid_1.v1();\n        let sub = {\n            expression: ['allof', ['match', '**/*', 'wholename']],\n            fields: ['name', 'size', 'new', 'exists', 'type', 'mtime_ms', 'ctime_ms'],\n            since: clock,\n        };\n        let root = watch;\n        if (relative_path) {\n            sub.relative_root = relative_path;\n            root = path_1.default.join(watch, relative_path);\n        }\n        let { subscribe } = await this.command(['subscribe', watch, uid, sub]);\n        if (global.hasOwnProperty('__TEST__'))\n            global.subscribe = subscribe;\n        this.appendOutput(`subscribing \"${globPattern}\" in ${root}`);\n        this.client.on('subscription', resp => {\n            if (!resp || resp.subscription != uid)\n                return;\n            let { files } = resp;\n            if (!files)\n                return;\n            files = files.filter(f => f.type == 'f' && minimatch_1.default(f.name, globPattern, { dot: true }));\n            if (!files.length)\n                return;\n            let ev = Object.assign({}, resp);\n            if (this.relative_path)\n                ev.root = path_1.default.resolve(resp.root, this.relative_path);\n            this.appendOutput(`file change detected: ${JSON.stringify(ev, null, 2)}`);\n            cb(ev);\n        });\n        return vscode_languageserver_protocol_1.Disposable.create(() => this.unsubscribe(subscribe));\n    }\n    unsubscribe(subscription) {\n        if (this._disposed)\n            return Promise.resolve();\n        let { watch } = this;\n        if (!watch)\n            return;\n        this.appendOutput(`unsubscribe \"${subscription}\" in: ${watch}`);\n        return this.command(['unsubscribe', watch, subscription]).catch(e => {\n            logger.error(e);\n        });\n    }\n    dispose() {\n        if (this._disposed)\n            return;\n        this._disposed = true;\n        this.client.removeAllListeners();\n        this.client.end();\n    }\n    appendOutput(message, type = \"Info\") {\n        if (this.channel) {\n            this.channel.appendLine(`[${type}  - ${(new Date().toLocaleTimeString())}] ${message}`);\n        }\n    }\n    static dispose() {\n        for (let promise of clientsMap.values()) {\n            promise.then(client => {\n                client.dispose();\n            }, _e => {\n                // noop\n            });\n        }\n    }\n    static createClient(binaryPath, root, channel) {\n        if (!isValidWatchRoot(root))\n            return null;\n        let client = clientsMap.get(root);\n        if (client)\n            return client;\n        let promise = new Promise(async (resolve, reject) => {\n            try {\n                let watchman = new Watchman(binaryPath, channel);\n                let valid = await watchman.checkCapability();\n                if (!valid)\n                    return resolve(null);\n                let watching = await watchman.watchProject(root);\n                if (!watching)\n                    return resolve(null);\n                resolve(watchman);\n            }\n            catch (e) {\n                reject(e);\n            }\n        });\n        clientsMap.set(root, promise);\n        return promise;\n    }\n}\nexports.default = Watchman;\n/**\n * Exclude user's home, driver, tmpdir\n */\nfunction isValidWatchRoot(root) {\n    if (root == '/' || root == '/tmp' || root == '/private/tmp')\n        return false;\n    if (root.toLowerCase() === os_1.default.homedir().toLowerCase())\n        return false;\n    if (path_1.default.parse(root).base == root)\n        return false;\n    if (root.startsWith('/tmp/') || root.startsWith('/private/tmp/'))\n        return false;\n    if (fs_1.isParentFolder(os_1.default.tmpdir(), root, true))\n        return false;\n    return true;\n}\nexports.isValidWatchRoot = isValidWatchRoot;\n\n\n//# sourceURL=webpack://coc.nvim/./src/watchman.ts?");

/***/ }),

/***/ "./src/window.ts":
/*!***********************!*\
  !*** ./src/window.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst fs_1 = tslib_1.__importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst os_1 = tslib_1.__importDefault(__webpack_require__(/*! os */ \"os\"));\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst channels_1 = tslib_1.__importDefault(__webpack_require__(/*! ./channels */ \"./src/channels.ts\"));\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ./events */ \"./src/events.ts\"));\nconst dialog_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/dialog */ \"./src/model/dialog.ts\"));\nconst menu_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/menu */ \"./src/model/menu.ts\"));\nconst notification_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/notification */ \"./src/model/notification.ts\"));\nconst picker_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/picker */ \"./src/model/picker.ts\"));\nconst progress_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/progress */ \"./src/model/progress.ts\"));\nconst status_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/status */ \"./src/model/status.ts\"));\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/types.ts\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/util/index.ts\");\nconst mutex_1 = __webpack_require__(/*! ./util/mutex */ \"./src/util/mutex.ts\");\nconst workspace_1 = tslib_1.__importDefault(__webpack_require__(/*! ./workspace */ \"./src/workspace.ts\"));\nconst logger = __webpack_require__(/*! ./util/logger */ \"./src/util/logger.ts\")('window');\nclass Window {\n    constructor() {\n        this.mutex = new mutex_1.Mutex();\n    }\n    get nvim() {\n        return workspace_1.default.nvim;\n    }\n    dispose() {\n        var _a;\n        (_a = this.statusLine) === null || _a === void 0 ? void 0 : _a.dispose();\n    }\n    /**\n     * Reveal message with message type.\n     *\n     * @param msg Message text to show.\n     * @param messageType Type of message, could be `error` `warning` and `more`, default to `more`\n     */\n    showMessage(msg, messageType = 'more') {\n        if (this.mutex.busy || !this.nvim)\n            return;\n        let { messageLevel } = this;\n        let method = process.env.VIM_NODE_RPC == '1' ? 'callTimer' : 'call';\n        if (global.hasOwnProperty('__TEST__'))\n            logger.info(msg);\n        let hl = 'Error';\n        let level = types_1.MessageLevel.Error;\n        switch (messageType) {\n            case 'more':\n                level = types_1.MessageLevel.More;\n                hl = 'MoreMsg';\n                break;\n            case 'warning':\n                level = types_1.MessageLevel.Warning;\n                hl = 'WarningMsg';\n                break;\n        }\n        if (level >= messageLevel) {\n            this.nvim[method]('coc#util#echo_messages', [hl, ('[coc.nvim] ' + msg).split('\\n')], true);\n        }\n    }\n    /**\n     * Run command in vim terminal for result\n     *\n     * @param cmd Command to run.\n     * @param cwd Cwd of terminal, default to result of |getcwd()|.\n     */\n    async runTerminalCommand(cmd, cwd, keepfocus = false) {\n        cwd = cwd || workspace_1.default.cwd;\n        return await this.nvim.callAsync('coc#util#run_terminal', { cmd, cwd, keepfocus: keepfocus ? 1 : 0 });\n    }\n    /**\n     * Open terminal window.\n     *\n     * @param cmd Command to run.\n     * @param opts Terminal option.\n     * @returns buffer number of terminal.\n     */\n    async openTerminal(cmd, opts = {}) {\n        let bufnr = await this.nvim.call('coc#util#open_terminal', Object.assign({ cmd }, opts));\n        return bufnr;\n    }\n    /**\n     * Show quickpick for single item, use `window.menuPick` for menu at current current position.\n     *\n     * @param items Label list.\n     * @param placeholder Prompt text, default to 'choose by number'.\n     * @returns Index of selected item, or -1 when canceled.\n     */\n    async showQuickpick(items, placeholder = 'Choose by number') {\n        let release = await this.mutex.acquire();\n        try {\n            let title = placeholder + ':';\n            items = items.map((s, idx) => `${idx + 1}. ${s}`);\n            let res = await this.nvim.callAsync('coc#util#quickpick', [title, items.map(s => s.trim())]);\n            release();\n            let n = parseInt(res, 10);\n            if (isNaN(n) || n <= 0 || n > items.length)\n                return -1;\n            return n - 1;\n        }\n        catch (e) {\n            release();\n            return -1;\n        }\n    }\n    /**\n     * Show menu picker at current cursor position, |inputlist()| is used as fallback.\n     * Use `workspace.env.dialog` to check if the picker window/popup could work.\n     *\n     * @param items Array of texts.\n     * @param title Optional title of float/popup window.\n     * @param token A token that can be used to signal cancellation.\n     * @returns Selected index (0 based), -1 when canceled.\n     */\n    async showMenuPicker(items, title, token) {\n        if (workspace_1.default.env.dialog) {\n            let release = await this.mutex.acquire();\n            if (token && token.isCancellationRequested) {\n                release();\n                return undefined;\n            }\n            try {\n                let menu = new menu_1.default(this.nvim, { items: items.map(s => s.trim()), title }, token);\n                let promise = new Promise(resolve => {\n                    menu.onDidClose(selected => {\n                        resolve(selected);\n                    });\n                });\n                await menu.show(this.dialogPreference);\n                let res = await promise;\n                release();\n                return res;\n            }\n            catch (e) {\n                logger.error(`Error on showMenuPicker:`, e);\n                release();\n            }\n        }\n        return await this.showQuickpick(items);\n    }\n    /**\n     * Open local config file\n     */\n    async openLocalConfig() {\n        let { root } = workspace_1.default;\n        if (root == os_1.default.homedir()) {\n            this.showMessage(`Can't create local config in home directory`, 'warning');\n            return;\n        }\n        let dir = path_1.default.join(root, '.vim');\n        if (!fs_1.default.existsSync(dir)) {\n            let res = await this.showPrompt(`Would you like to create folder'${root}/.vim'?`);\n            if (!res)\n                return;\n            fs_1.default.mkdirSync(dir);\n        }\n        await workspace_1.default.jumpTo(vscode_uri_1.URI.file(path_1.default.join(dir, util_1.CONFIG_FILE_NAME)).toString());\n    }\n    /**\n     * Prompt user for confirm, a float/popup window would be used when possible,\n     * use vim's |confirm()| function as callback.\n     *\n     * @param title The prompt text.\n     * @returns Result of confirm.\n     */\n    async showPrompt(title) {\n        let release = await this.mutex.acquire();\n        try {\n            let res = await this.nvim.callAsync('coc#float#prompt_confirm', [title]);\n            release();\n            return res == 1;\n        }\n        catch (e) {\n            release();\n            return false;\n        }\n    }\n    /**\n     * Show dialog window at the center of screen.\n     * Note that the dialog would always be closed after button click.\n     * Use `workspace.env.dialog` to check if dialog could work.\n     *\n     * @param config Dialog configuration.\n     * @returns Dialog or null when dialog can't work.\n     */\n    async showDialog(config) {\n        if (!this.checkDialog())\n            return null;\n        let dialog = new dialog_1.default(this.nvim, config);\n        await dialog.show(this.dialogPreference);\n        return dialog;\n    }\n    /**\n     * Request input from user\n     *\n     * @param title Title text of prompt window.\n     * @param defaultValue Default value of input, empty text by default.\n     */\n    async requestInput(title, defaultValue) {\n        let { nvim } = this;\n        const preferences = workspace_1.default.getConfiguration('coc.preferences');\n        if (workspace_1.default.env.dialog && preferences.get('promptInput', true)) {\n            let release = await this.mutex.acquire();\n            let preferences = this.dialogPreference;\n            try {\n                let opts = {};\n                if (preferences.floatHighlight)\n                    opts.highlight = preferences.floatHighlight;\n                if (preferences.floatBorderHighlight)\n                    opts.borderhighlight = preferences.floatBorderHighlight;\n                let arr = await nvim.call('coc#float#create_prompt_win', [title, defaultValue || '', opts]);\n                let [bufnr, winid] = arr;\n                let res = await new Promise(resolve => {\n                    let disposables = [];\n                    events_1.default.on('BufWinLeave', nr => {\n                        if (nr == bufnr) {\n                            util_1.disposeAll(disposables);\n                            resolve(null);\n                        }\n                    }, null, disposables);\n                    events_1.default.on('PromptInsert', async (value) => {\n                        util_1.disposeAll(disposables);\n                        await nvim.call('coc#float#close', [winid]);\n                        if (!value) {\n                            this.showMessage('Empty word, canceled', 'warning');\n                            resolve(null);\n                        }\n                        else {\n                            resolve(value);\n                        }\n                    }, null, disposables);\n                });\n                release();\n                return res;\n            }\n            catch (e) {\n                logger.error('Error on requestInput:', e);\n                release();\n            }\n        }\n        else {\n            let res = await workspace_1.default.callAsync('input', [title + ': ', defaultValue || '']);\n            nvim.command('normal! :<C-u>', true);\n            if (!res) {\n                this.showMessage('Empty word, canceled', 'warning');\n                return null;\n            }\n            return res;\n        }\n    }\n    /**\n     * Create statusbar item that would be included in `g:coc_status`.\n     *\n     * @param priority Higher priority item would be shown right.\n     * @param option\n     * @return A new status bar item.\n     */\n    createStatusBarItem(priority = 0, option = {}) {\n        if (!workspace_1.default.env) {\n            let fn = () => { };\n            return { text: '', show: fn, dispose: fn, hide: fn, priority: 0, isProgress: false };\n        }\n        if (!this.statusLine) {\n            this.statusLine = new status_1.default(this.nvim);\n        }\n        return this.statusLine.createStatusBarItem(priority, option.progress || false);\n    }\n    /**\n     * Create a new output channel\n     *\n     * @param name Unique name of output channel.\n     * @returns A new output channel.\n     */\n    createOutputChannel(name) {\n        return channels_1.default.create(name, this.nvim);\n    }\n    /**\n     * Reveal buffer of output channel.\n     *\n     * @param name Name of output channel.\n     * @param preserveFocus Preserve window focus when true.\n     */\n    showOutputChannel(name, preserveFocus) {\n        channels_1.default.show(name, preserveFocus);\n    }\n    /**\n     * Echo lines at the bottom of vim.\n     *\n     * @param lines Line list.\n     * @param truncate Truncate the lines to avoid 'press enter to continue' when true\n     */\n    async echoLines(lines, truncate = false) {\n        let { nvim } = this;\n        let cmdHeight = workspace_1.default.env.cmdheight;\n        if (lines.length > cmdHeight && truncate) {\n            lines = lines.slice(0, cmdHeight);\n        }\n        let maxLen = workspace_1.default.env.columns - 12;\n        lines = lines.map(line => {\n            line = line.replace(/\\n/g, ' ');\n            if (truncate)\n                line = line.slice(0, maxLen);\n            return line;\n        });\n        if (truncate && lines.length == cmdHeight) {\n            let last = lines[lines.length - 1];\n            lines[cmdHeight - 1] = `${last.length == maxLen ? last.slice(0, -4) : last} ...`;\n        }\n        await nvim.call('coc#util#echo_lines', [lines]);\n    }\n    /**\n     * Get current cursor position (line, character both 0 based).\n     *\n     * @returns Cursor position.\n     */\n    async getCursorPosition() {\n        // vim can't count utf16\n        let [line, content] = await this.nvim.eval(`[line('.')-1, strpart(getline('.'), 0, col('.') - 1)]`);\n        return vscode_languageserver_protocol_1.Position.create(line, content.length);\n    }\n    /**\n     * Move cursor to position.\n     *\n     * @param position LSP position.\n     */\n    async moveTo(position) {\n        await this.nvim.call('coc#util#jumpTo', [position.line, position.character]);\n        if (workspace_1.default.env.isVim)\n            this.nvim.command('redraw', true);\n    }\n    /**\n     * Get current cursor character offset in document,\n     * length of line break would always be 1.\n     *\n     * @returns Charactor offset.\n     */\n    async getOffset() {\n        return await this.nvim.call('coc#util#get_offset');\n    }\n    /**\n     * Get screen position of current cursor(relative to editor),\n     * both `row` and `col` are 0 based.\n     *\n     * @returns Cursor screen position.\n     */\n    async getCursorScreenPosition() {\n        let [row, col] = await this.nvim.call('coc#util#cursor_pos');\n        return { row, col };\n    }\n    async showPickerDialog(items, title, token) {\n        if (!this.checkDialog())\n            return undefined;\n        let release = await this.mutex.acquire();\n        if (token && token.isCancellationRequested) {\n            release();\n            return undefined;\n        }\n        try {\n            let useString = typeof items[0] === 'string';\n            let picker = new picker_1.default(this.nvim, {\n                title,\n                items: useString ? items.map(s => {\n                    return { label: s };\n                }) : items,\n            }, token);\n            let promise = new Promise(resolve => {\n                picker.onDidClose(selected => {\n                    resolve(selected);\n                });\n            });\n            await picker.show(this.dialogPreference);\n            let picked = await promise;\n            let res = picked == undefined ? undefined : items.filter((_, i) => picked.includes(i));\n            release();\n            return res;\n        }\n        catch (e) {\n            logger.error(`Error on showPickerDialog:`, e);\n            release();\n        }\n    }\n    async showInformationMessage(message, ...items) {\n        if (!this.enableMessageDialog)\n            return await this.showConfirm(message, items, 'Info');\n        let texts = typeof items[0] === 'string' ? items : items.map(s => s.title);\n        let idx = await this.createNotification('CocInfoFloat', message, texts);\n        return idx == -1 ? undefined : items[idx];\n    }\n    async showWarningMessage(message, ...items) {\n        if (!this.enableMessageDialog)\n            return await this.showConfirm(message, items, 'Warning');\n        let texts = typeof items[0] === 'string' ? items : items.map(s => s.title);\n        let idx = await this.createNotification('CocWarningFloat', message, texts);\n        return idx == -1 ? undefined : items[idx];\n    }\n    async showErrorMessage(message, ...items) {\n        if (!this.enableMessageDialog)\n            return await this.showConfirm(message, items, 'Error');\n        let texts = typeof items[0] === 'string' ? items : items.map(s => s.title);\n        let idx = await this.createNotification('CocErrorFloat', message, texts);\n        return idx == -1 ? undefined : items[idx];\n    }\n    async showNotification(config) {\n        if (!this.checkDialog())\n            return false;\n        let notification = new notification_1.default(this.nvim, config);\n        return await notification.show(this.notificationPreference);\n    }\n    // fallback for vim without dialog\n    async showConfirm(message, items, kind) {\n        if (!items || items.length == 0) {\n            let msgType = kind == 'Info' ? 'more' : kind == 'Error' ? 'error' : 'warning';\n            this.showMessage(message, msgType);\n            return undefined;\n        }\n        let choices = typeof items[0] === 'string' ? items.slice() : items.map(o => o.title);\n        let res = await this.nvim.callAsync('coc#util#with_callback', ['confirm', [message, choices.join('\\n'), 0, kind]]);\n        return items[res - 1];\n    }\n    /**\n     * Show progress in the editor. Progress is shown while running the given callback\n     * and while the promise it returned isn't resolved nor rejected.\n     *\n     * @param task A callback returning a promise. Progress state can be reported with\n     * the provided [progress](#Progress)-object.\n     *\n     * To report discrete progress, use `increment` to indicate how much work has been completed. Each call with\n     * a `increment` value will be summed up and reflected as overall progress until 100% is reached (a value of\n     * e.g. `10` accounts for `10%` of work done).\n     *\n     * To monitor if the operation has been cancelled by the user, use the provided [`CancellationToken`](#CancellationToken).\n     *\n     * @return The thenable the task-callback returned.\n     */\n    async withProgress(options, task) {\n        if (!this.checkDialog())\n            return undefined;\n        let progress = new progress_1.default(this.nvim, {\n            task,\n            title: options.title,\n            cancellable: options.cancellable\n        });\n        return await progress.show(this.notificationPreference);\n    }\n    createNotification(borderhighlight, message, items) {\n        return new Promise(resolve => {\n            let config = {\n                content: message,\n                borderhighlight,\n                close: true,\n                buttons: items.map((s, index) => {\n                    return { text: s, index };\n                }),\n                callback: idx => {\n                    resolve(idx);\n                }\n            };\n            let notification = new notification_1.default(this.nvim, config);\n            notification.show(this.notificationPreference).then(shown => {\n                if (!shown) {\n                    logger.error('Unable to open notification window');\n                    resolve(-1);\n                }\n                if (!items.length)\n                    resolve(-1);\n            }, e => {\n                logger.error('Unable to open notification window', e);\n                resolve(-1);\n            });\n        });\n    }\n    get dialogPreference() {\n        let config = workspace_1.default.getConfiguration('dialog');\n        return {\n            maxWidth: config.get('maxWidth'),\n            maxHeight: config.get('maxHeight'),\n            floatHighlight: config.get('floatHighlight'),\n            floatBorderHighlight: config.get('floatBorderHighlight'),\n            pickerButtons: config.get('pickerButtons'),\n            pickerButtonShortcut: config.get('pickerButtonShortcut'),\n            confirmKey: config.get('confirmKey'),\n        };\n    }\n    get notificationPreference() {\n        let config = workspace_1.default.getConfiguration('notification');\n        return {\n            top: config.get('marginTop'),\n            right: config.get('marginRight'),\n            maxWidth: config.get('maxWidth'),\n            maxHeight: config.get('maxHeight'),\n            highlight: config.get('highlightGroup'),\n            minProgressWidth: config.get('minProgressWidth'),\n        };\n    }\n    checkDialog() {\n        if (workspace_1.default.env.dialog)\n            return true;\n        this.showMessage('Dialog requires vim >= 8.2.0750 or neovim >= 0.4.0, please upgrade your vim', 'warning');\n        return false;\n    }\n    get enableMessageDialog() {\n        if (!workspace_1.default.env.dialog)\n            return false;\n        let config = workspace_1.default.getConfiguration('coc.preferences');\n        return config.get('enableMessageDialog', false);\n    }\n    get messageLevel() {\n        let config = workspace_1.default.getConfiguration('coc.preferences');\n        let level = config.get('messageLevel', 'more');\n        switch (level) {\n            case 'error':\n                return types_1.MessageLevel.Error;\n            case 'warning':\n                return types_1.MessageLevel.Warning;\n            default:\n                return types_1.MessageLevel.More;\n        }\n    }\n}\nexports.default = new Window();\n\n\n//# sourceURL=webpack://coc.nvim/./src/window.ts?");

/***/ }),

/***/ "./src/workspace.ts":
/*!**************************!*\
  !*** ./src/workspace.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Workspace = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nconst bytes_1 = tslib_1.__importDefault(__webpack_require__(/*! bytes */ \"./node_modules/bytes/index.js\"));\nconst fast_diff_1 = tslib_1.__importDefault(__webpack_require__(/*! fast-diff */ \"./node_modules/fast-diff/diff.js\"));\nconst fs_extra_1 = tslib_1.__importDefault(__webpack_require__(/*! fs-extra */ \"./node_modules/fs-extra/lib/index.js\"));\nconst os_1 = tslib_1.__importDefault(__webpack_require__(/*! os */ \"os\"));\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-node/index.js\");\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst which_1 = tslib_1.__importDefault(__webpack_require__(/*! which */ \"./node_modules/which/which.js\"));\nconst channels_1 = tslib_1.__importDefault(__webpack_require__(/*! ./channels */ \"./src/channels.ts\"));\nconst configuration_1 = tslib_1.__importDefault(__webpack_require__(/*! ./configuration */ \"./src/configuration/index.ts\"));\nconst shape_1 = tslib_1.__importDefault(__webpack_require__(/*! ./configuration/shape */ \"./src/configuration/shape.ts\"));\nconst events_1 = tslib_1.__importDefault(__webpack_require__(/*! ./events */ \"./src/events.ts\"));\nconst db_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/db */ \"./src/model/db.ts\"));\nconst document_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/document */ \"./src/model/document.ts\"));\nconst fileSystemWatcher_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/fileSystemWatcher */ \"./src/model/fileSystemWatcher.ts\"));\nconst mru_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/mru */ \"./src/model/mru.ts\"));\nconst resolver_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/resolver */ \"./src/model/resolver.ts\"));\nconst task_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/task */ \"./src/model/task.ts\"));\nconst terminal_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/terminal */ \"./src/model/terminal.ts\"));\nconst bufferSync_1 = tslib_1.__importDefault(__webpack_require__(/*! ./model/bufferSync */ \"./src/model/bufferSync.ts\"));\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/types.ts\");\nconst array_1 = __webpack_require__(/*! ./util/array */ \"./src/util/array.ts\");\nconst fs_1 = __webpack_require__(/*! ./util/fs */ \"./src/util/fs.ts\");\nconst index_1 = __webpack_require__(/*! ./util/index */ \"./src/util/index.ts\");\nconst match_1 = __webpack_require__(/*! ./util/match */ \"./src/util/match.ts\");\nconst object_1 = __webpack_require__(/*! ./util/object */ \"./src/util/object.ts\");\nconst position_1 = __webpack_require__(/*! ./util/position */ \"./src/util/position.ts\");\nconst string_1 = __webpack_require__(/*! ./util/string */ \"./src/util/string.ts\");\nconst watchman_1 = tslib_1.__importDefault(__webpack_require__(/*! ./watchman */ \"./src/watchman.ts\"));\nconst window_1 = tslib_1.__importDefault(__webpack_require__(/*! ./window */ \"./src/window.ts\"));\nconst APIVERSION = 8;\nconst logger = __webpack_require__(/*! ./util/logger */ \"./src/util/logger.ts\")('workspace');\nlet NAME_SPACE = 2000;\nconst methods = [\n    'showMessage',\n    'runTerminalCommand',\n    'openTerminal',\n    'showQuickpick',\n    'menuPick',\n    'openLocalConfig',\n    'showPrompt',\n    'createStatusBarItem',\n    'createOutputChannel',\n    'showOutputChannel',\n    'requestInput',\n    'echoLines',\n    'getCursorPosition',\n    'moveTo',\n    'getOffset'\n];\nclass Workspace {\n    constructor() {\n        this.keymaps = new Map();\n        this.resolver = new resolver_1.default();\n        this.rootPatterns = new Map();\n        this._workspaceFolders = [];\n        this._insertMode = false;\n        this._cwd = process.cwd();\n        this._initialized = false;\n        this._attached = false;\n        this.buffers = new Map();\n        this.autocmdMaxId = 0;\n        this.autocmds = new Map();\n        this.terminals = new Map();\n        this.creatingSources = new Map();\n        this.schemeProviderMap = new Map();\n        this.namespaceMap = new Map();\n        this.disposables = [];\n        this.watchedOptions = new Set();\n        this._dynAutocmd = false;\n        this._disposed = false;\n        this._onDidOpenDocument = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidCloseDocument = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidChangeDocument = new vscode_languageserver_protocol_1.Emitter();\n        this._onWillSaveDocument = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidSaveDocument = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidChangeConfiguration = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidWorkspaceInitialized = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidOpenTerminal = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidCloseTerminal = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidRuntimePathChange = new vscode_languageserver_protocol_1.Emitter();\n        this.onDidCloseTerminal = this._onDidCloseTerminal.event;\n        this.onDidOpenTerminal = this._onDidOpenTerminal.event;\n        this.onDidChangeWorkspaceFolders = this._onDidChangeWorkspaceFolders.event;\n        this.onDidOpenTextDocument = this._onDidOpenDocument.event;\n        this.onDidCloseTextDocument = this._onDidCloseDocument.event;\n        this.onDidChangeTextDocument = this._onDidChangeDocument.event;\n        this.onWillSaveTextDocument = this._onWillSaveDocument.event;\n        this.onDidSaveTextDocument = this._onDidSaveDocument.event;\n        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;\n        this.onDidWorkspaceInitialized = this._onDidWorkspaceInitialized.event;\n        this.onDidRuntimePathChange = this._onDidRuntimePathChange.event;\n        let json = __webpack_require__(/*! ../package.json */ \"./package.json\");\n        this.version = json.version;\n        this.configurations = this.createConfigurations();\n        let cwd = process.cwd();\n        if (cwd != os_1.default.homedir() && fs_1.inDirectory(cwd, ['.vim'])) {\n            this._workspaceFolders.push({\n                uri: vscode_uri_1.URI.file(cwd).toString(),\n                name: path_1.default.basename(cwd)\n            });\n        }\n    }\n    async init() {\n        let { nvim } = this;\n        for (let method of methods) {\n            Object.defineProperty(this, method, {\n                get: () => {\n                    return (...args) => {\n                        // logger.warn(`workspace.${method} is deprecated, please use window.${method} instead.`, Error().stack)\n                        return window_1.default[method].apply(window_1.default, args);\n                    };\n                }\n            });\n        }\n        this._env = await nvim.call('coc#util#vim_info');\n        if (this._env.apiversion != APIVERSION) {\n            console.error(`API version ${this._env.apiversion} is not ${APIVERSION}, please build coc.nvim by 'yarn install' after pull source code.`);\n            process.exit();\n        }\n        this._insertMode = this._env.mode.startsWith('insert');\n        let preferences = this.getConfiguration('coc.preferences');\n        let maxFileSize = preferences.get('maxFileSize', '10MB');\n        this.maxFileSize = bytes_1.default.parse(maxFileSize);\n        if (this._env.workspaceFolders) {\n            this._workspaceFolders = this._env.workspaceFolders.map(f => ({\n                uri: vscode_uri_1.URI.file(f).toString(),\n                name: path_1.default.dirname(f)\n            }));\n        }\n        this.configurations.updateUserConfig(this._env.config);\n        events_1.default.on(['InsertEnter', 'CursorMovedI'], () => {\n            this._insertMode = true;\n        }, null, this.disposables);\n        events_1.default.on(['InsertLeave', 'CursorMoved'], () => {\n            this._insertMode = false;\n        }, null, this.disposables);\n        let forceSync = async (bufnr) => {\n            let doc = this.getDocument(bufnr);\n            if (doc)\n                doc.forceSync();\n        };\n        events_1.default.on('InsertLeave', forceSync, null, this.disposables);\n        events_1.default.on('CursorHold', forceSync, null, this.disposables);\n        events_1.default.on('BufWinLeave', (_, winid) => {\n            if (winid == -1)\n                return;\n            this.nvim.call('coc#highlight#clear_match_group', [winid, '^Coc'], true);\n        }, null, this.disposables);\n        events_1.default.on('BufEnter', this.onBufEnter, this, this.disposables);\n        events_1.default.on('CursorMoved', this.checkCurrentBuffer, this, this.disposables);\n        events_1.default.on('CursorMovedI', this.checkCurrentBuffer, this, this.disposables);\n        events_1.default.on('DirChanged', this.onDirChanged, this, this.disposables);\n        events_1.default.on('BufCreate', this.onBufCreate, this, this.disposables);\n        events_1.default.on('BufUnload', this.onBufUnload, this, this.disposables);\n        events_1.default.on('TermOpen', this.onBufCreate, this, this.disposables);\n        events_1.default.on('TermClose', this.onBufUnload, this, this.disposables);\n        events_1.default.on('BufWritePost', this.onBufWritePost, this, this.disposables);\n        events_1.default.on('BufWritePre', this.onBufWritePre, this, this.disposables);\n        events_1.default.on('FileType', this.onFileTypeChange, this, this.disposables);\n        events_1.default.on('CursorHold', this.checkCurrentBuffer, this, this.disposables);\n        events_1.default.on('TextChanged', this.checkBuffer, this, this.disposables);\n        events_1.default.on('BufReadCmd', this.onBufReadCmd, this, this.disposables);\n        events_1.default.on('VimResized', (columns, lines) => {\n            Object.assign(this._env, { columns, lines });\n        }, null, this.disposables);\n        await this.attach();\n        this.attachChangedEvents();\n        this.configurations.onDidChange(e => {\n            this._onDidChangeConfiguration.fire(e);\n        }, null, this.disposables);\n        this.watchOption('runtimepath', (oldValue, newValue) => {\n            let result = fast_diff_1.default(oldValue, newValue);\n            for (let [changeType, value] of result) {\n                if (changeType == 1) {\n                    let paths = value.replace(/,$/, '').split(',');\n                    this._onDidRuntimePathChange.fire(paths);\n                }\n            }\n            this._env.runtimepath = newValue;\n        }, this.disposables);\n        this.watchOption('completeopt', async (_, newValue) => {\n            this.env.completeOpt = newValue;\n            if (!this._attached)\n                return;\n            if (this.insertMode) {\n                let suggest = this.getConfiguration('suggest');\n                if (suggest.get('autoTrigger') == 'always') {\n                    let content = await this.nvim.call('execute', ['verbose set completeopt']);\n                    let lines = content.split(/\\r?\\n/);\n                    console.error(`Some plugin change completeopt on insert mode: ${lines[lines.length - 1].trim()}!`);\n                }\n            }\n        }, this.disposables);\n        this.watchGlobal('coc_sources_disable_map', async (_, newValue) => {\n            this.env.disabledSources = newValue;\n        });\n        this.disposables.push(this.registerTextDocumentContentProvider('output', channels_1.default.getProvider(nvim)));\n    }\n    getConfigFile(target) {\n        return this.configurations.getConfigFile(target);\n    }\n    /**\n     * Register autocmd on vim.\n     */\n    registerAutocmd(autocmd) {\n        this.autocmdMaxId += 1;\n        let id = this.autocmdMaxId;\n        this.autocmds.set(id, autocmd);\n        this.setupDynamicAutocmd();\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.autocmds.delete(id);\n            this.setupDynamicAutocmd();\n        });\n    }\n    /**\n     * Watch for option change.\n     */\n    watchOption(key, callback, disposables) {\n        let watching = this.watchedOptions.has(key);\n        if (!watching) {\n            this.watchedOptions.add(key);\n            this.setupDynamicAutocmd();\n        }\n        let disposable = events_1.default.on('OptionSet', async (changed, oldValue, newValue) => {\n            if (changed == key && callback) {\n                await Promise.resolve(callback(oldValue, newValue));\n            }\n        });\n        if (disposables) {\n            disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {\n                disposable.dispose();\n                if (watching)\n                    return;\n                this.watchedOptions.delete(key);\n                this.setupDynamicAutocmd();\n            }));\n        }\n    }\n    /**\n     * Watch global variable, works on neovim only.\n     */\n    watchGlobal(key, callback, disposables) {\n        let { nvim } = this;\n        nvim.call('coc#_watch', key, true);\n        let disposable = events_1.default.on('GlobalChange', async (changed, oldValue, newValue) => {\n            if (changed == key && callback) {\n                await Promise.resolve(callback(oldValue, newValue));\n            }\n        });\n        if (disposables) {\n            disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {\n                disposable.dispose();\n                nvim.call('coc#_unwatch', key, true);\n            }));\n        }\n    }\n    get cwd() {\n        return this._cwd;\n    }\n    get env() {\n        return this._env;\n    }\n    get root() {\n        return this._root || this.cwd;\n    }\n    get rootPath() {\n        return this.root;\n    }\n    get workspaceFolders() {\n        return this._workspaceFolders;\n    }\n    /**\n     * uri of current file, could be null\n     *\n     * @deprecated this method is reliable, will be removed in the feature.\n     */\n    get uri() {\n        let { bufnr } = this;\n        if (bufnr) {\n            let document = this.getDocument(bufnr);\n            if (document && document.schema == 'file') {\n                return document.uri;\n            }\n        }\n        return null;\n    }\n    get workspaceFolder() {\n        let { rootPath } = this;\n        if (rootPath == os_1.default.homedir())\n            return null;\n        return {\n            uri: vscode_uri_1.URI.file(rootPath).toString(),\n            name: path_1.default.basename(rootPath)\n        };\n    }\n    get textDocuments() {\n        let docs = [];\n        for (let b of this.buffers.values()) {\n            docs.push(b.textDocument);\n        }\n        return docs;\n    }\n    get documents() {\n        return Array.from(this.buffers.values());\n    }\n    createNameSpace(name = '') {\n        if (this.namespaceMap.has(name))\n            return this.namespaceMap.get(name);\n        NAME_SPACE = NAME_SPACE + 1;\n        this.namespaceMap.set(name, NAME_SPACE);\n        return NAME_SPACE;\n    }\n    get channelNames() {\n        return channels_1.default.names;\n    }\n    get pluginRoot() {\n        return path_1.default.dirname(__dirname);\n    }\n    get isVim() {\n        return this._env.isVim;\n    }\n    get isNvim() {\n        return !this._env.isVim;\n    }\n    get completeOpt() {\n        return this._env.completeOpt;\n    }\n    get initialized() {\n        return this._initialized;\n    }\n    get ready() {\n        if (this._initialized)\n            return Promise.resolve();\n        return new Promise(resolve => {\n            let disposable = this.onDidWorkspaceInitialized(() => {\n                disposable.dispose();\n                resolve();\n            });\n        });\n    }\n    /**\n     * Current filetypes.\n     */\n    get filetypes() {\n        let res = new Set();\n        for (let doc of this.documents) {\n            res.add(doc.filetype);\n        }\n        return res;\n    }\n    /**\n     * Check if selector match document.\n     */\n    match(selector, document) {\n        return match_1.score(selector, document.uri, document.languageId);\n    }\n    /**\n     * Findup for filename or filenames from current filepath or root.\n     */\n    async findUp(filename) {\n        let { cwd } = this;\n        let filepath = await this.nvim.call('expand', '%:p');\n        filepath = path_1.default.normalize(filepath);\n        let isFile = filepath && path_1.default.isAbsolute(filepath);\n        if (isFile && !fs_1.isParentFolder(cwd, filepath, true)) {\n            // can't use cwd\n            return fs_1.findUp(filename, path_1.default.dirname(filepath));\n        }\n        let res = fs_1.findUp(filename, cwd);\n        if (res && res != os_1.default.homedir())\n            return res;\n        if (isFile)\n            return fs_1.findUp(filename, path_1.default.dirname(filepath));\n        return null;\n    }\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async resolveRootFolder(uri, patterns) {\n        let { cwd } = this;\n        if (uri.scheme != 'file')\n            return cwd;\n        let filepath = path_1.default.normalize(uri.fsPath);\n        let dir = path_1.default.dirname(filepath);\n        return fs_1.resolveRoot(dir, patterns) || dir;\n    }\n    /**\n     * Create a FileSystemWatcher instance,\n     * doesn't fail when watchman not found.\n     */\n    createFileSystemWatcher(globPattern, ignoreCreate, ignoreChange, ignoreDelete) {\n        let watchmanPath = global.hasOwnProperty('__TEST__') ? null : this.getWatchmanPath();\n        let channel = watchmanPath ? window_1.default.createOutputChannel('watchman') : null;\n        let promise = watchmanPath ? watchman_1.default.createClient(watchmanPath, this.root, channel) : Promise.resolve(null);\n        let watcher = new fileSystemWatcher_1.default(promise, globPattern, !!ignoreCreate, !!ignoreChange, !!ignoreDelete);\n        return watcher;\n    }\n    getWatchmanPath() {\n        const preferences = this.getConfiguration('coc.preferences');\n        let watchmanPath = preferences.get('watchmanPath', 'watchman');\n        try {\n            return which_1.default.sync(watchmanPath);\n        }\n        catch (e) {\n            return null;\n        }\n    }\n    /**\n     * Get configuration by section and optional resource uri.\n     */\n    getConfiguration(section, resource) {\n        return this.configurations.getConfiguration(section, resource);\n    }\n    /**\n     * Get created document by uri or bufnr.\n     */\n    getDocument(uri) {\n        if (typeof uri === 'number') {\n            return this.buffers.get(uri);\n        }\n        const caseInsensitive = index_1.platform.isWindows || index_1.platform.isMacintosh;\n        uri = vscode_uri_1.URI.parse(uri).toString();\n        for (let doc of this.buffers.values()) {\n            if (!doc)\n                continue;\n            if (doc.uri === uri)\n                return doc;\n            if (caseInsensitive && doc.uri.toLowerCase() === uri.toLowerCase())\n                return doc;\n        }\n        return null;\n    }\n    /**\n     * Apply WorkspaceEdit.\n     */\n    async applyEdit(edit) {\n        let { nvim } = this;\n        let { documentChanges, changes } = edit;\n        let [bufnr, cursor] = await nvim.eval('[bufnr(\"%\"),coc#util#cursor()]');\n        let document = this.getDocument(bufnr);\n        let uri = document ? document.uri : null;\n        let currEdits = null;\n        let locations = [];\n        let changeCount = 0;\n        const preferences = this.getConfiguration('coc.preferences');\n        let promptUser = !global.hasOwnProperty('__TEST__') && preferences.get('promptWorkspaceEdit', true);\n        let listTarget = preferences.get('listOfWorkspaceEdit', 'quickfix');\n        try {\n            if (documentChanges && documentChanges.length) {\n                let changedUris = this.getChangedUris(documentChanges);\n                changeCount = changedUris.length;\n                if (promptUser) {\n                    let diskCount = changedUris.reduce((p, c) => {\n                        return p + (this.getDocument(c) == null ? 1 : 0);\n                    }, 0);\n                    if (diskCount) {\n                        let res = await window_1.default.showPrompt(`${diskCount} documents on disk would be loaded for change, confirm?`);\n                        if (!res)\n                            return;\n                    }\n                }\n                let changedMap = new Map();\n                // let changes: Map<string, TextEdit[]> = new Map()\n                let textEdits = [];\n                for (let i = 0; i < documentChanges.length; i++) {\n                    let change = documentChanges[i];\n                    if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change)) {\n                        let { textDocument, edits } = change;\n                        let next = documentChanges[i + 1];\n                        textEdits.push(...edits);\n                        if (next && vscode_languageserver_protocol_1.TextDocumentEdit.is(next) && object_1.equals((next).textDocument, textDocument)) {\n                            continue;\n                        }\n                        let doc = await this.loadFile(textDocument.uri);\n                        if (textDocument.uri == uri)\n                            currEdits = textEdits;\n                        await doc.applyEdits(textEdits);\n                        for (let edit of textEdits) {\n                            locations.push({ uri: doc.uri, range: edit.range });\n                        }\n                        textEdits = [];\n                    }\n                    else if (vscode_languageserver_protocol_1.CreateFile.is(change)) {\n                        let file = vscode_uri_1.URI.parse(change.uri).fsPath;\n                        await this.createFile(file, change.options);\n                    }\n                    else if (vscode_languageserver_protocol_1.RenameFile.is(change)) {\n                        changedMap.set(change.oldUri, change.newUri);\n                        await this.renameFile(vscode_uri_1.URI.parse(change.oldUri).fsPath, vscode_uri_1.URI.parse(change.newUri).fsPath, change.options);\n                    }\n                    else if (vscode_languageserver_protocol_1.DeleteFile.is(change)) {\n                        await this.deleteFile(vscode_uri_1.URI.parse(change.uri).fsPath, change.options);\n                    }\n                }\n                // fix location uris on renameFile\n                if (changedMap.size) {\n                    locations.forEach(location => {\n                        let newUri = changedMap.get(location.uri);\n                        if (newUri)\n                            location.uri = newUri;\n                    });\n                }\n            }\n            else if (changes) {\n                let uris = Object.keys(changes);\n                let unloaded = uris.filter(uri => this.getDocument(uri) == null);\n                if (unloaded.length) {\n                    if (promptUser) {\n                        let res = await window_1.default.showPrompt(`${unloaded.length} documents on disk would be loaded for change, confirm?`);\n                        if (!res)\n                            return;\n                    }\n                    await this.loadFiles(unloaded);\n                }\n                for (let uri of Object.keys(changes)) {\n                    let document = this.getDocument(uri);\n                    if (vscode_uri_1.URI.parse(uri).toString() == uri)\n                        currEdits = changes[uri];\n                    let edits = changes[uri];\n                    for (let edit of edits) {\n                        locations.push({ uri: document.uri, range: edit.range });\n                    }\n                    await document.applyEdits(edits);\n                }\n                changeCount = uris.length;\n            }\n            if (currEdits) {\n                let changed = position_1.getChangedFromEdits({ line: cursor[0], character: cursor[1] }, currEdits);\n                if (changed)\n                    await window_1.default.moveTo({\n                        line: cursor[0] + changed.line,\n                        character: cursor[1] + changed.character\n                    });\n            }\n            if (locations.length) {\n                let items = await Promise.all(locations.map(loc => this.getQuickfixItem(loc)));\n                let silent = locations.every(l => l.uri == uri);\n                if (listTarget == 'quickfix') {\n                    await this.nvim.call('setqflist', [items]);\n                    if (!silent)\n                        window_1.default.showMessage(`changed ${changeCount} buffers, use :wa to save changes to disk and :copen to open quickfix list`, 'more');\n                }\n                else if (listTarget == 'location') {\n                    await nvim.setVar('coc_jump_locations', items);\n                    if (!silent)\n                        window_1.default.showMessage(`changed ${changeCount} buffers, use :wa to save changes to disk and :CocList location to manage changed locations`, 'more');\n                }\n            }\n        }\n        catch (e) {\n            logger.error(e);\n            window_1.default.showMessage(`Error on applyEdits: ${e.message}`, 'error');\n            return false;\n        }\n        await index_1.wait(50);\n        return true;\n    }\n    /**\n     * Convert location to quickfix item.\n     */\n    async getQuickfixItem(loc, text, type = '', module) {\n        if (vscode_languageserver_protocol_1.LocationLink.is(loc)) {\n            loc = vscode_languageserver_protocol_1.Location.create(loc.targetUri, loc.targetRange);\n        }\n        let doc = this.getDocument(loc.uri);\n        let { uri, range } = loc;\n        let { line, character } = range.start;\n        let u = vscode_uri_1.URI.parse(uri);\n        let bufnr = doc ? doc.bufnr : -1;\n        if (!text && u.scheme == 'file') {\n            text = await this.getLine(uri, line);\n            character = string_1.byteIndex(text, character);\n        }\n        let item = {\n            uri,\n            filename: u.scheme == 'file' ? u.fsPath : uri,\n            lnum: line + 1,\n            col: character + 1,\n            text: text || '',\n            range\n        };\n        if (module)\n            item.module = module;\n        if (type)\n            item.type = type;\n        if (bufnr != -1)\n            item.bufnr = bufnr;\n        return item;\n    }\n    /**\n     * Create persistence Mru instance.\n     */\n    createMru(name) {\n        return new mru_1.default(name);\n    }\n    /**\n     * Get selected range for current document\n     */\n    async getSelectedRange(mode, document) {\n        let { nvim } = this;\n        if (mode == 'n') {\n            let line = await nvim.call('line', ['.']);\n            let content = document.getline(line - 1);\n            if (!content.length)\n                return null;\n            return vscode_languageserver_protocol_1.Range.create(line - 1, 0, line - 1, content.length);\n        }\n        if (!['v', 'V', 'char', 'line', '\\x16'].includes(mode)) {\n            throw new Error(`Mode '${mode}' not supported`);\n        }\n        let isVisual = ['v', 'V', '\\x16'].includes(mode);\n        let [, sl, sc] = await nvim.call('getpos', isVisual ? `'<` : `'[`);\n        let [, el, ec] = await nvim.call('getpos', isVisual ? `'>` : `']`);\n        let range = vscode_languageserver_protocol_1.Range.create(document.getPosition(sl, sc), document.getPosition(el, ec));\n        if (mode == 'v' || mode == '\\x16') {\n            range.end.character = range.end.character + 1;\n        }\n        return range;\n    }\n    /**\n     * Visual select range of current document\n     */\n    async selectRange(range) {\n        let { nvim } = this;\n        let { start, end } = range;\n        let [bufnr, ve, selection] = await nvim.eval(`[bufnr('%'), &virtualedit, &selection, mode()]`);\n        let document = this.getDocument(bufnr);\n        if (!document)\n            return;\n        let line = document.getline(start.line);\n        let col = line ? string_1.byteLength(line.slice(0, start.character)) : 0;\n        let endLine = document.getline(end.line);\n        let endCol = endLine ? string_1.byteLength(endLine.slice(0, end.character)) : 0;\n        let move_cmd = '';\n        let resetVirtualEdit = false;\n        move_cmd += 'v';\n        endCol = await nvim.eval(`virtcol([${end.line + 1}, ${endCol}])`);\n        if (selection == 'inclusive') {\n            if (end.character == 0) {\n                move_cmd += `${end.line}G`;\n            }\n            else {\n                move_cmd += `${end.line + 1}G${endCol}|`;\n            }\n        }\n        else if (selection == 'old') {\n            move_cmd += `${end.line + 1}G${endCol}|`;\n        }\n        else {\n            move_cmd += `${end.line + 1}G${endCol + 1}|`;\n        }\n        col = await nvim.eval(`virtcol([${start.line + 1}, ${col}])`);\n        move_cmd += `o${start.line + 1}G${col + 1}|o`;\n        nvim.pauseNotification();\n        if (ve != 'onemore') {\n            resetVirtualEdit = true;\n            nvim.setOption('virtualedit', 'onemore', true);\n        }\n        nvim.command(`noa call cursor(${start.line + 1},${col + (move_cmd == 'a' ? 0 : 1)})`, true);\n        // nvim.call('eval', [`feedkeys(\"${move_cmd}\", 'in')`], true)\n        nvim.command(`normal! ${move_cmd}`, true);\n        if (resetVirtualEdit)\n            nvim.setOption('virtualedit', ve, true);\n        if (this.isVim)\n            nvim.command('redraw', true);\n        await nvim.resumeNotification();\n    }\n    /**\n     * Populate locations to UI.\n     */\n    async showLocations(locations) {\n        let items = await Promise.all(locations.map(loc => this.getQuickfixItem(loc)));\n        let { nvim } = this;\n        const preferences = this.getConfiguration('coc.preferences');\n        if (preferences.get('useQuickfixForLocations', false)) {\n            let openCommand = await nvim.getVar('coc_quickfix_open_command');\n            if (typeof openCommand != 'string') {\n                openCommand = items.length < 10 ? `copen ${items.length}` : 'copen';\n            }\n            nvim.pauseNotification();\n            nvim.call('setqflist', [items], true);\n            nvim.command(openCommand, true);\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            nvim.resumeNotification(false, true);\n        }\n        else {\n            await nvim.setVar('coc_jump_locations', items);\n            if (this.env.locationlist) {\n                nvim.command('CocList --normal --auto-preview location', true);\n            }\n            else {\n                nvim.call('coc#util#do_autocmd', ['CocLocationsChange'], true);\n            }\n        }\n    }\n    /**\n     * Get content of line by uri and line.\n     */\n    async getLine(uri, line) {\n        let document = this.getDocument(uri);\n        if (document)\n            return document.getline(line) || '';\n        if (!uri.startsWith('file:'))\n            return '';\n        let fsPath = vscode_uri_1.URI.parse(uri).fsPath;\n        if (!fs_extra_1.default.existsSync(fsPath))\n            return '';\n        return await fs_1.readFileLine(fsPath, line);\n    }\n    /**\n     * Get WorkspaceFolder of uri\n     */\n    getWorkspaceFolder(uri) {\n        this.workspaceFolders.sort((a, b) => b.uri.length - a.uri.length);\n        let filepath = vscode_uri_1.URI.parse(uri).fsPath;\n        return this.workspaceFolders.find(folder => fs_1.isParentFolder(vscode_uri_1.URI.parse(folder.uri).fsPath, filepath, true));\n    }\n    /**\n     * Get content from buffer of file by uri.\n     */\n    async readFile(uri) {\n        let document = this.getDocument(uri);\n        if (document) {\n            await document.patchChange();\n            return document.content;\n        }\n        let u = vscode_uri_1.URI.parse(uri);\n        if (u.scheme != 'file')\n            return '';\n        let lines = await this.nvim.call('readfile', [u.fsPath]);\n        return lines.join('\\n') + '\\n';\n    }\n    /**\n     * Current document.\n     */\n    get document() {\n        return new Promise((resolve, reject) => {\n            this.nvim.buffer.then(buf => {\n                let bufnr = buf.id;\n                this.bufnr = bufnr;\n                if (this.buffers.has(bufnr)) {\n                    resolve(this.buffers.get(bufnr));\n                    return;\n                }\n                this.onBufCreate(bufnr).catch(reject);\n                let disposable = this.onDidOpenTextDocument(doc => {\n                    disposable.dispose();\n                    resolve(this.getDocument(doc.uri));\n                });\n            }, reject);\n        });\n    }\n    /**\n     * Get current document and position.\n     */\n    async getCurrentState() {\n        let document = await this.document;\n        let position = await window_1.default.getCursorPosition();\n        return {\n            document: document.textDocument,\n            position\n        };\n    }\n    /**\n     * Get format options\n     */\n    async getFormatOptions(uri) {\n        let doc;\n        if (uri)\n            doc = this.getDocument(uri);\n        let bufnr = doc ? doc.bufnr : 0;\n        let [tabSize, insertSpaces] = await this.nvim.call('coc#util#get_format_opts', [bufnr]);\n        return {\n            tabSize,\n            insertSpaces: insertSpaces == 1\n        };\n    }\n    /**\n     * Jump to location.\n     */\n    async jumpTo(uri, position, openCommand) {\n        const preferences = this.getConfiguration('coc.preferences');\n        let jumpCommand = openCommand || preferences.get('jumpCommand', 'edit');\n        let { nvim } = this;\n        let doc = this.getDocument(uri);\n        let bufnr = doc ? doc.bufnr : -1;\n        if (bufnr != -1 && jumpCommand == 'edit') {\n            // use buffer command since edit command would reload the buffer\n            nvim.pauseNotification();\n            nvim.command(`silent! normal! m'`, true);\n            nvim.command(`buffer ${bufnr}`, true);\n            if (position) {\n                let line = doc.getline(position.line);\n                let col = string_1.byteLength(line.slice(0, position.character)) + 1;\n                nvim.call('cursor', [position.line + 1, col], true);\n            }\n            if (this.isVim)\n                nvim.command('redraw', true);\n            await nvim.resumeNotification();\n        }\n        else {\n            let { fsPath, scheme } = vscode_uri_1.URI.parse(uri);\n            let pos = position == null ? null : [position.line, position.character];\n            if (scheme == 'file') {\n                let bufname = fs_1.fixDriver(path_1.default.normalize(fsPath));\n                await this.nvim.call('coc#util#jump', [jumpCommand, bufname, pos]);\n            }\n            else {\n                if (os_1.default.platform() == 'win32') {\n                    uri = uri.replace(/\\/?/, '?');\n                }\n                await this.nvim.call('coc#util#jump', [jumpCommand, uri, pos]);\n            }\n        }\n    }\n    /**\n     * Create a file in vim and disk\n     */\n    async createFile(filepath, opts = {}) {\n        let stat = await fs_1.statAsync(filepath);\n        if (stat && !opts.overwrite && !opts.ignoreIfExists) {\n            window_1.default.showMessage(`${filepath} already exists!`, 'error');\n            return;\n        }\n        if (!stat || opts.overwrite) {\n            // directory\n            if (filepath.endsWith('/')) {\n                try {\n                    filepath = this.expand(filepath);\n                    await fs_extra_1.default.mkdirp(filepath);\n                }\n                catch (e) {\n                    window_1.default.showMessage(`Can't create ${filepath}: ${e.message}`, 'error');\n                }\n            }\n            else {\n                let uri = vscode_uri_1.URI.file(filepath).toString();\n                let doc = this.getDocument(uri);\n                if (doc)\n                    return;\n                if (!fs_extra_1.default.existsSync(path_1.default.dirname(filepath))) {\n                    fs_extra_1.default.mkdirpSync(path_1.default.dirname(filepath));\n                }\n                fs_extra_1.default.writeFileSync(filepath, '', 'utf8');\n                await this.loadFile(uri);\n            }\n        }\n    }\n    /**\n     * Load uri as document.\n     */\n    async loadFile(uri) {\n        let doc = this.getDocument(uri);\n        if (doc)\n            return doc;\n        let { nvim } = this;\n        let filepath = uri.startsWith('file') ? vscode_uri_1.URI.parse(uri).fsPath : uri;\n        nvim.call('coc#util#open_files', [[filepath]], true);\n        return await new Promise((resolve, reject) => {\n            let disposable = this.onDidOpenTextDocument(textDocument => {\n                let fsPath = vscode_uri_1.URI.parse(textDocument.uri).fsPath;\n                if (textDocument.uri == uri || fsPath == filepath) {\n                    clearTimeout(timer);\n                    disposable.dispose();\n                    resolve(this.getDocument(uri));\n                }\n            });\n            let timer = setTimeout(() => {\n                disposable.dispose();\n                reject(new Error(`Create document ${uri} timeout after 1s.`));\n            }, 1000);\n        });\n    }\n    /**\n     * Load the files that not loaded\n     */\n    async loadFiles(uris) {\n        uris = uris.filter(uri => this.getDocument(uri) == null);\n        if (!uris.length)\n            return;\n        let bufnrs = await this.nvim.call('coc#util#open_files', [uris.map(u => vscode_uri_1.URI.parse(u).fsPath)]);\n        let create = bufnrs.filter(bufnr => this.getDocument(bufnr) == null);\n        if (!create.length)\n            return;\n        return new Promise((resolve, reject) => {\n            let timer = setTimeout(() => {\n                disposable.dispose();\n                reject(new Error(`Create document timeout after 2s.`));\n            }, 2000);\n            let disposable = this.onDidOpenTextDocument(() => {\n                if (uris.every(uri => this.getDocument(uri) != null)) {\n                    clearTimeout(timer);\n                    disposable.dispose();\n                    resolve();\n                }\n            });\n        });\n    }\n    /**\n     * Rename file in vim and disk\n     */\n    async renameFile(oldPath, newPath, opts = {}) {\n        let { overwrite, ignoreIfExists } = opts;\n        let { nvim } = this;\n        try {\n            let stat = await fs_1.statAsync(newPath);\n            if (stat && !overwrite && !ignoreIfExists) {\n                throw new Error(`${newPath} already exists`);\n            }\n            if (!stat || overwrite) {\n                let uri = vscode_uri_1.URI.file(oldPath).toString();\n                let newUri = vscode_uri_1.URI.file(newPath).toString();\n                let doc = this.getDocument(uri);\n                let isCurrent = doc.bufnr == this.bufnr;\n                let newDoc = this.getDocument(newUri);\n                if (newDoc)\n                    await this.nvim.command(`silent ${newDoc.bufnr}bwipeout!`);\n                if (doc != null) {\n                    let content = doc.getDocumentContent();\n                    let encoding = await doc.buffer.getOption('fileencoding');\n                    await fs_extra_1.default.writeFile(newPath, content, { encoding });\n                    // open renamed file\n                    if (!isCurrent) {\n                        await nvim.call('coc#util#open_files', [[newPath]]);\n                        await nvim.command(`silent ${doc.bufnr}bwipeout!`);\n                    }\n                    else {\n                        let view = await nvim.call('winsaveview');\n                        nvim.pauseNotification();\n                        nvim.call('coc#util#open_file', ['keepalt edit', newPath], true);\n                        nvim.command(`silent ${doc.bufnr}bwipeout!`, true);\n                        nvim.call('winrestview', [view], true);\n                        await nvim.resumeNotification();\n                    }\n                    // avoid vim detect file unlink\n                    await fs_extra_1.default.unlink(oldPath);\n                }\n                else {\n                    await fs_1.renameAsync(oldPath, newPath);\n                }\n            }\n        }\n        catch (e) {\n            window_1.default.showMessage(`Rename error: ${e.message}`, 'error');\n        }\n    }\n    /**\n     * Delete file from vim and disk.\n     */\n    async deleteFile(filepath, opts = {}) {\n        let { ignoreIfNotExists, recursive } = opts;\n        let stat = await fs_1.statAsync(filepath.replace(/\\/$/, ''));\n        let isDir = stat && stat.isDirectory();\n        if (filepath.endsWith('/') && !isDir) {\n            window_1.default.showMessage(`${filepath} is not directory`, 'error');\n            return;\n        }\n        if (!stat && !ignoreIfNotExists) {\n            window_1.default.showMessage(`${filepath} not exists`, 'error');\n            return;\n        }\n        if (stat == null)\n            return;\n        if (isDir && !recursive) {\n            window_1.default.showMessage(`Can't remove directory, recursive not set`, 'error');\n            return;\n        }\n        try {\n            if (isDir && recursive) {\n                await fs_extra_1.default.remove(filepath);\n            }\n            else if (isDir) {\n                await fs_extra_1.default.rmdir(filepath);\n            }\n            else {\n                await fs_extra_1.default.unlink(filepath);\n            }\n            if (!isDir) {\n                let uri = vscode_uri_1.URI.file(filepath).toString();\n                let doc = this.getDocument(uri);\n                if (doc)\n                    await this.nvim.command(`silent! bwipeout! ${doc.bufnr}`);\n            }\n        }\n        catch (e) {\n            window_1.default.showMessage(`Error on delete ${filepath}: ${e.message}`, 'error');\n        }\n    }\n    /**\n     * Open resource by uri\n     */\n    async openResource(uri) {\n        let { nvim } = this;\n        // not supported\n        if (uri.startsWith('http')) {\n            await nvim.call('coc#util#open_url', uri);\n            return;\n        }\n        let wildignore = await nvim.getOption('wildignore');\n        await nvim.setOption('wildignore', '');\n        await this.jumpTo(uri);\n        await nvim.setOption('wildignore', wildignore);\n    }\n    /**\n     * Resovle module from yarn or npm.\n     */\n    async resolveModule(name) {\n        return await this.resolver.resolveModule(name);\n    }\n    /**\n     * Run nodejs command\n     */\n    async runCommand(cmd, cwd, timeout) {\n        cwd = cwd || this.cwd;\n        return index_1.runCommand(cmd, { cwd }, timeout);\n    }\n    /**\n     * Expand filepath with `~` and/or environment placeholders\n     */\n    expand(filepath) {\n        if (!filepath)\n            return filepath;\n        if (filepath.startsWith('~')) {\n            filepath = os_1.default.homedir() + filepath.slice(1);\n        }\n        if (filepath.includes('$')) {\n            let doc = this.getDocument(this.bufnr);\n            let fsPath = doc ? vscode_uri_1.URI.parse(doc.uri).fsPath : '';\n            filepath = filepath.replace(/\\$\\{(.*?)\\}/g, (match, name) => {\n                if (name.startsWith('env:')) {\n                    let key = name.split(':')[1];\n                    let val = key ? process.env[key] : '';\n                    return val;\n                }\n                switch (name) {\n                    case 'workspace':\n                    case 'workspaceRoot':\n                    case 'workspaceFolder':\n                        return this.root;\n                    case 'workspaceFolderBasename':\n                        return path_1.default.dirname(this.root);\n                    case 'cwd':\n                        return this.cwd;\n                    case 'file':\n                        return fsPath;\n                    case 'fileDirname':\n                        return fsPath ? path_1.default.dirname(fsPath) : '';\n                    case 'fileExtname':\n                        return fsPath ? path_1.default.extname(fsPath) : '';\n                    case 'fileBasename':\n                        return fsPath ? path_1.default.basename(fsPath) : '';\n                    case 'fileBasenameNoExtension': {\n                        let basename = fsPath ? path_1.default.basename(fsPath) : '';\n                        return basename ? basename.slice(0, basename.length - path_1.default.extname(basename).length) : '';\n                    }\n                    default:\n                        return match;\n                }\n            });\n            filepath = filepath.replace(/\\$[\\w]+/g, match => {\n                if (match == '$HOME')\n                    return os_1.default.homedir();\n                return process.env[match.slice(1)] || match;\n            });\n        }\n        return filepath;\n    }\n    async createTerminal(opts) {\n        let cmd = opts.shellPath;\n        let args = opts.shellArgs;\n        if (!cmd)\n            cmd = await this.nvim.getOption('shell');\n        let terminal = new terminal_1.default(cmd, args || [], this.nvim, opts.name);\n        await terminal.start(opts.cwd || this.cwd, opts.env);\n        this.terminals.set(terminal.bufnr, terminal);\n        this._onDidOpenTerminal.fire(terminal);\n        return terminal;\n    }\n    async callAsync(method, args) {\n        if (this.isNvim)\n            return await this.nvim.call(method, args);\n        return await this.nvim.callAsync('coc#util#with_callback', [method, args]);\n    }\n    /**\n     * registerTextDocumentContentProvider\n     */\n    registerTextDocumentContentProvider(scheme, provider) {\n        this.schemeProviderMap.set(scheme, provider);\n        this.setupDynamicAutocmd();\n        let disposables = [];\n        if (provider.onDidChange) {\n            provider.onDidChange(async (uri) => {\n                let doc = this.getDocument(uri.toString());\n                if (doc) {\n                    let { buffer } = doc;\n                    let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n                    let content = await Promise.resolve(provider.provideTextDocumentContent(uri, tokenSource.token));\n                    await buffer.setLines(content.split('\\n'), {\n                        start: 0,\n                        end: -1,\n                        strictIndexing: false\n                    });\n                }\n            }, null, disposables);\n        }\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.schemeProviderMap.delete(scheme);\n            index_1.disposeAll(disposables);\n            this.setupDynamicAutocmd();\n        });\n    }\n    /**\n     * Register unique keymap uses `<Plug>(coc-{key})` as lhs\n     * Throw error when {key} already exists.\n     *\n     * @param {MapMode[]} modes - array of 'n' | 'i' | 'v' | 'x' | 's' | 'o'\n     * @param {string} key - unique name\n     * @param {Function} fn - callback function\n     * @param {Partial} opts\n     * @returns {Disposable}\n     */\n    registerKeymap(modes, key, fn, opts = {}) {\n        if (!key)\n            throw new Error(`Invalid key ${key} of registerKeymap`);\n        if (this.keymaps.has(key))\n            throw new Error(`${key} already exists.`);\n        opts = Object.assign({ sync: true, cancel: true, silent: true, repeat: false }, opts);\n        let { nvim } = this;\n        this.keymaps.set(key, [fn, !!opts.repeat]);\n        let method = opts.sync ? 'request' : 'notify';\n        let silent = opts.silent ? '<silent>' : '';\n        for (let m of modes) {\n            if (m == 'i') {\n                nvim.command(`inoremap ${silent}<expr> <Plug>(coc-${key}) coc#_insert_key('${method}', '${key}', ${opts.cancel ? 1 : 0})`, true);\n            }\n            else {\n                let modify = index_1.getKeymapModifier(m);\n                nvim.command(`${m}noremap ${silent} <Plug>(coc-${key}) :${modify}call coc#rpc#${method}('doKeymap', ['${key}'])<cr>`, true);\n            }\n        }\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.keymaps.delete(key);\n            for (let m of modes) {\n                nvim.command(`${m}unmap <Plug>(coc-${key})`, true);\n            }\n        });\n    }\n    /**\n     * Register expr keymap.\n     */\n    registerExprKeymap(mode, key, fn, buffer = false) {\n        if (!key)\n            return;\n        let id = `${mode}${global.Buffer.from(key).toString('base64')}${buffer ? '1' : '0'}`;\n        let { nvim } = this;\n        this.keymaps.set(id, [fn, false]);\n        if (mode == 'i') {\n            nvim.command(`inoremap <silent><expr>${buffer ? '<nowait><buffer>' : ''} ${key} coc#_insert_key('request', '${id}')`, true);\n        }\n        else {\n            nvim.command(`${mode}noremap <silent><expr>${buffer ? '<nowait><buffer>' : ''} ${key} coc#rpc#request('doKeymap', ['${id}'])`, true);\n        }\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.keymaps.delete(id);\n            nvim.command(`${mode}unmap ${buffer ? '<buffer>' : ''} ${key}`, true);\n        });\n    }\n    registerLocalKeymap(mode, key, fn, notify = false) {\n        let id = uuid_1.v1();\n        let { nvim } = this;\n        this.keymaps.set(id, [fn, false]);\n        let buf = this.nvim.createBuffer(this.bufnr);\n        let method = notify ? 'notify' : 'request';\n        let modify = index_1.getKeymapModifier(mode);\n        // neoivm's bug '<' can't be used.\n        let escaped = key.startsWith('<') && key.endsWith('>') ? `{${key.slice(1, -1)}}` : key;\n        if (this.isNvim && !global.hasOwnProperty('__TEST__')) {\n            buf.notify('nvim_buf_set_keymap', [mode, key, `:${modify}call coc#rpc#${method}('doKeymap', ['${id}', '', '${escaped}'])<CR>`, {\n                    silent: true,\n                    nowait: true\n                }]);\n        }\n        else {\n            let cmd = `${mode}noremap <silent><nowait><buffer> ${key} :${modify}call coc#rpc#${method}('doKeymap', ['${id}', '', '${escaped}'])<CR>`;\n            nvim.command(cmd, true);\n        }\n        return vscode_languageserver_protocol_1.Disposable.create(() => {\n            this.keymaps.delete(id);\n            nvim.call('coc#compat#buf_del_keymap', [buf.id, mode, key], true);\n        });\n    }\n    /**\n     * Create DB instance at extension root.\n     */\n    createDatabase(name) {\n        let root;\n        if (global.hasOwnProperty('__TEST__')) {\n            root = path_1.default.join(os_1.default.tmpdir(), `coc-${process.pid}`);\n            fs_extra_1.default.mkdirpSync(root);\n        }\n        else {\n            root = path_1.default.dirname(this.env.extensionRoot);\n        }\n        let filepath = path_1.default.join(root, name + '.json');\n        return new db_1.default(filepath);\n    }\n    /**\n     * Create Task instance that runs in vim.\n     */\n    createTask(id) {\n        return new task_1.default(this.nvim, id);\n    }\n    registerBufferSync(create) {\n        return new bufferSync_1.default(create, this);\n    }\n    setupDynamicAutocmd(initialize = false) {\n        if (!initialize && !this._dynAutocmd)\n            return;\n        this._dynAutocmd = true;\n        let schemes = this.schemeProviderMap.keys();\n        let cmds = [];\n        for (let scheme of schemes) {\n            cmds.push(`autocmd BufReadCmd,FileReadCmd,SourceCmd ${scheme}://* call coc#rpc#request('CocAutocmd', ['BufReadCmd','${scheme}', expand('<amatch>')])`);\n        }\n        for (let [id, autocmd] of this.autocmds.entries()) {\n            let args = autocmd.arglist && autocmd.arglist.length ? ', ' + autocmd.arglist.join(', ') : '';\n            let event = Array.isArray(autocmd.event) ? autocmd.event.join(',') : autocmd.event;\n            let pattern = autocmd.pattern != null ? autocmd.pattern : '*';\n            if (/\\buser\\b/i.test(event)) {\n                pattern = '';\n            }\n            cmds.push(`autocmd ${event} ${pattern} call coc#rpc#${autocmd.request ? 'request' : 'notify'}('doAutocmd', [${id}${args}])`);\n        }\n        for (let key of this.watchedOptions) {\n            cmds.push(`autocmd OptionSet ${key} call coc#rpc#notify('OptionSet',[expand('<amatch>'), v:option_old, v:option_new])`);\n        }\n        let content = `\naugroup coc_dynamic_autocmd\n  autocmd!\n  ${cmds.join('\\n  ')}\naugroup end`;\n        try {\n            let dir = path_1.default.join(process.env.TMPDIR, `coc.nvim-${process.pid}`);\n            if (!fs_extra_1.default.existsSync(dir))\n                fs_extra_1.default.mkdirpSync(dir);\n            let filepath = path_1.default.join(dir, `coc-${process.pid}.vim`);\n            fs_extra_1.default.writeFileSync(filepath, content, 'utf8');\n            let cmd = `source ${filepath}`;\n            if (this.env.isCygwin && index_1.platform.isWindows) {\n                cmd = `execute \"source\" . substitute(system('cygpath ${filepath.replace(/\\\\/g, '/')}'), '\\\\n', '', 'g')`;\n            }\n            this.nvim.command(cmd).logError();\n        }\n        catch (e) {\n            window_1.default.showMessage(`Can't create tmp file: ${e.message}`, 'error');\n        }\n    }\n    async onBufReadCmd(scheme, uri) {\n        let provider = this.schemeProviderMap.get(scheme);\n        if (!provider) {\n            window_1.default.showMessage(`Provider for ${scheme} not found`, 'error');\n            return;\n        }\n        let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();\n        let content = await Promise.resolve(provider.provideTextDocumentContent(vscode_uri_1.URI.parse(uri), tokenSource.token));\n        let buf = await this.nvim.buffer;\n        await buf.setLines(content.split('\\n'), {\n            start: 0,\n            end: -1,\n            strictIndexing: false\n        });\n        setTimeout(async () => {\n            await events_1.default.fire('BufCreate', [buf.id]);\n        }, 30);\n    }\n    async attach() {\n        if (this._attached)\n            return;\n        this._attached = true;\n        let [bufs, bufnr, winid] = await this.nvim.eval(`[map(getbufinfo({'bufloaded': 1}),'v:val[\"bufnr\"]'),bufnr('%'),win_getid()]`);\n        this.bufnr = bufnr;\n        await Promise.all(bufs.map(buf => this.onBufCreate(buf)));\n        if (!this._initialized) {\n            this._onDidWorkspaceInitialized.fire(void 0);\n            this._initialized = true;\n        }\n        await events_1.default.fire('BufEnter', [bufnr]);\n        await events_1.default.fire('BufWinEnter', [bufnr, winid]);\n    }\n    // count of document need change\n    getChangedUris(documentChanges) {\n        let uris = new Set();\n        let createUris = new Set();\n        for (let change of documentChanges) {\n            if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change)) {\n                let { textDocument } = change;\n                let { uri, version } = textDocument;\n                uris.add(uri);\n                if (version != null && version > 0) {\n                    let doc = this.getDocument(uri);\n                    if (!doc) {\n                        throw new Error(`${uri} not loaded`);\n                    }\n                    if (doc.version != version) {\n                        throw new Error(`${uri} changed before apply edit`);\n                    }\n                }\n            }\n            else if (vscode_languageserver_protocol_1.CreateFile.is(change) || vscode_languageserver_protocol_1.DeleteFile.is(change)) {\n                if (!fs_1.isFile(change.uri)) {\n                    throw new Error(`change of scheme ${change.uri} not supported`);\n                }\n                createUris.add(change.uri);\n                uris.add(change.uri);\n            }\n            else if (vscode_languageserver_protocol_1.RenameFile.is(change)) {\n                if (!fs_1.isFile(change.oldUri) || !fs_1.isFile(change.newUri)) {\n                    throw new Error(`change of scheme ${change.oldUri} not supported`);\n                }\n                let newFile = vscode_uri_1.URI.parse(change.newUri).fsPath;\n                if (fs_extra_1.default.existsSync(newFile)) {\n                    throw new Error(`file \"${newFile}\" already exists for rename`);\n                }\n                uris.add(change.oldUri);\n            }\n            else {\n                throw new Error(`Invalid document change: ${JSON.stringify(change, null, 2)}`);\n            }\n        }\n        return Array.from(uris);\n    }\n    createConfigurations() {\n        let home = path_1.default.normalize(process.env.COC_VIMCONFIG) || path_1.default.join(os_1.default.homedir(), '.vim');\n        let userConfigFile = path_1.default.join(home, index_1.CONFIG_FILE_NAME);\n        return new configuration_1.default(userConfigFile, new shape_1.default(this));\n    }\n    // events for sync buffer of vim\n    attachChangedEvents() {\n        if (this.isVim) {\n            const onChange = (bufnr) => {\n                let doc = this.getDocument(bufnr);\n                if (doc && doc.attached)\n                    doc.fetchContent();\n            };\n            events_1.default.on('TextChangedI', onChange, null, this.disposables);\n            events_1.default.on('TextChanged', onChange, null, this.disposables);\n        }\n    }\n    async onBufCreate(buf) {\n        let buffer = typeof buf === 'number' ? this.nvim.createBuffer(buf) : buf;\n        let bufnr = buffer.id;\n        if (this.creatingSources.has(bufnr))\n            return;\n        let document = this.getDocument(bufnr);\n        let source = new vscode_languageserver_protocol_1.CancellationTokenSource();\n        try {\n            if (document)\n                this.onBufUnload(bufnr, true);\n            document = new document_1.default(buffer, this._env, this.maxFileSize);\n            let token = source.token;\n            this.creatingSources.set(bufnr, source);\n            let created = await document.init(this.nvim, token);\n            if (!created)\n                document = null;\n        }\n        catch (e) {\n            logger.error('Error on create buffer:', e);\n            document = null;\n        }\n        if (this.creatingSources.get(bufnr) == source) {\n            source.dispose();\n            this.creatingSources.delete(bufnr);\n        }\n        if (!document || !document.textDocument)\n            return;\n        this.buffers.set(bufnr, document);\n        if (document.attached) {\n            document.onDocumentDetach(bufnr => {\n                let doc = this.getDocument(bufnr);\n                if (doc)\n                    this.onBufUnload(doc.bufnr);\n            });\n        }\n        if (document.buftype == '' && document.schema == 'file') {\n            this.configurations.checkFolderConfiguration(document.uri);\n            let config = this.getConfiguration('workspace');\n            let filetypes = config.get('ignoredFiletypes', []);\n            if (!filetypes.includes(document.filetype)) {\n                let root = this.resolveRoot(document);\n                if (root) {\n                    this.addWorkspaceFolder(root);\n                    if (this.bufnr == buffer.id) {\n                        this._root = root;\n                    }\n                }\n            }\n        }\n        if (document.enabled) {\n            let textDocument = Object.assign(document.textDocument, { bufnr });\n            this._onDidOpenDocument.fire(textDocument);\n            document.onDocumentChange(e => this._onDidChangeDocument.fire(e));\n        }\n        logger.debug('buffer created', buffer.id);\n    }\n    onBufEnter(bufnr) {\n        this.bufnr = bufnr;\n        let doc = this.getDocument(bufnr);\n        if (doc) {\n            this.configurations.setFolderConfiguration(doc.uri);\n            let workspaceFolder = this.getWorkspaceFolder(doc.uri);\n            if (workspaceFolder)\n                this._root = vscode_uri_1.URI.parse(workspaceFolder.uri).fsPath;\n        }\n    }\n    async checkCurrentBuffer(bufnr) {\n        this.bufnr = bufnr;\n        await this.checkBuffer(bufnr);\n    }\n    onBufWritePost(bufnr) {\n        let doc = this.buffers.get(bufnr);\n        if (!doc)\n            return;\n        this._onDidSaveDocument.fire(doc.textDocument);\n    }\n    onBufUnload(bufnr, recreate = false) {\n        logger.debug('buffer unload', bufnr);\n        if (!recreate) {\n            let source = this.creatingSources.get(bufnr);\n            if (source) {\n                source.cancel();\n                this.creatingSources.delete(bufnr);\n            }\n        }\n        if (this.terminals.has(bufnr)) {\n            let terminal = this.terminals.get(bufnr);\n            this._onDidCloseTerminal.fire(terminal);\n            this.terminals.delete(bufnr);\n        }\n        let doc = this.buffers.get(bufnr);\n        if (doc) {\n            let textDocument = Object.assign(doc.textDocument, { bufnr });\n            this._onDidCloseDocument.fire(textDocument);\n            this.buffers.delete(bufnr);\n            doc.detach();\n        }\n    }\n    async onBufWritePre(bufnr) {\n        let doc = this.buffers.get(bufnr);\n        if (!doc || !doc.attached)\n            return;\n        await doc.checkDocument();\n        let firing = true;\n        let thenables = [];\n        let event = {\n            document: doc.textDocument,\n            reason: vscode_languageserver_protocol_1.TextDocumentSaveReason.Manual,\n            waitUntil: (thenable) => {\n                if (!firing) {\n                    logger.error(`Can't call waitUntil in async manner:`, Error().stack);\n                    window_1.default.showMessage(`waitUntil can't be used in async manner, check log for details`, 'error');\n                }\n                else {\n                    thenables.push(thenable);\n                }\n            }\n        };\n        this._onWillSaveDocument.fire(event);\n        firing = false;\n        let total = thenables.length;\n        if (total) {\n            let promise = new Promise(resolve => {\n                let timer = setTimeout(() => {\n                    window_1.default.showMessage('Will save handler timeout after 0.5s', 'warning');\n                    resolve(undefined);\n                }, 500);\n                let i = 0;\n                let called = false;\n                for (let p of thenables) {\n                    let cb = (res) => {\n                        if (called)\n                            return;\n                        called = true;\n                        clearTimeout(timer);\n                        resolve(res);\n                    };\n                    p.then(res => {\n                        if (Array.isArray(res) && res.length && vscode_languageserver_protocol_1.TextEdit.is(res[0])) {\n                            return cb(res);\n                        }\n                        i = i + 1;\n                        if (i == total)\n                            cb(undefined);\n                    }, () => {\n                        i = i + 1;\n                        if (i == total)\n                            cb(undefined);\n                    });\n                }\n            });\n            let edits = await promise;\n            if (edits)\n                await doc.applyEdits(edits);\n        }\n    }\n    onDirChanged(cwd) {\n        if (cwd == this._cwd)\n            return;\n        this._cwd = cwd;\n    }\n    onFileTypeChange(filetype, bufnr) {\n        let doc = this.getDocument(bufnr);\n        if (!doc)\n            return;\n        let converted = doc.convertFiletype(filetype);\n        if (converted == doc.filetype)\n            return;\n        let textDocument = Object.assign(doc.textDocument, { bufnr });\n        this._onDidCloseDocument.fire(textDocument);\n        doc.setFiletype(filetype);\n        this._onDidOpenDocument.fire(textDocument);\n    }\n    async checkBuffer(bufnr) {\n        if (this._disposed || !bufnr)\n            return;\n        let doc = this.getDocument(bufnr);\n        if (!doc && !this.creatingSources.has(bufnr))\n            await this.onBufCreate(bufnr);\n    }\n    resolveRoot(document) {\n        let types = [types_1.PatternType.Buffer, types_1.PatternType.LanguageServer, types_1.PatternType.Global];\n        let u = vscode_uri_1.URI.parse(document.uri);\n        let dir = path_1.default.dirname(u.fsPath);\n        let { cwd } = this;\n        for (let patternType of types) {\n            let patterns = this.getRootPatterns(document, patternType);\n            if (patterns && patterns.length) {\n                let root = fs_1.resolveRoot(dir, patterns, cwd);\n                if (root)\n                    return root;\n            }\n        }\n        if (this.cwd != os_1.default.homedir() && fs_1.isParentFolder(this.cwd, dir, true))\n            return this.cwd;\n        return null;\n    }\n    getRootPatterns(document, patternType) {\n        let { uri } = document;\n        if (patternType == types_1.PatternType.Buffer)\n            return document.getVar('root_patterns', []) || [];\n        if (patternType == types_1.PatternType.LanguageServer)\n            return this.getServerRootPatterns(document.filetype);\n        const preferences = this.getConfiguration('coc.preferences', uri);\n        return preferences.get('rootPatterns', ['.git', '.hg', '.projections.json']).slice();\n    }\n    async renameCurrent() {\n        let { nvim } = this;\n        let bufnr = await nvim.call('bufnr', '%');\n        let cwd = await nvim.call('getcwd');\n        let doc = this.getDocument(bufnr);\n        if (!doc || doc.buftype != '' || doc.schema != 'file') {\n            nvim.errWriteLine('current buffer is not file.');\n            return;\n        }\n        let oldPath = vscode_uri_1.URI.parse(doc.uri).fsPath;\n        // await nvim.callAsync()\n        let newPath = await nvim.callAsync('coc#util#with_callback', ['input', ['New path: ', oldPath, 'file']]);\n        newPath = newPath ? newPath.trim() : null;\n        if (newPath == oldPath || !newPath)\n            return;\n        let lines = await doc.buffer.lines;\n        let exists = fs_extra_1.default.existsSync(oldPath);\n        if (exists) {\n            let modified = await nvim.eval('&modified');\n            if (modified)\n                await nvim.command('noa w');\n            if (oldPath.toLowerCase() != newPath.toLowerCase() && fs_extra_1.default.existsSync(newPath)) {\n                let overwrite = await window_1.default.showPrompt(`${newPath} exists, overwrite?`);\n                if (!overwrite)\n                    return;\n                fs_extra_1.default.unlinkSync(newPath);\n            }\n            fs_extra_1.default.renameSync(oldPath, newPath);\n        }\n        let filepath = fs_1.isParentFolder(cwd, newPath) ? path_1.default.relative(cwd, newPath) : newPath;\n        let view = await nvim.call('winsaveview');\n        nvim.pauseNotification();\n        if (oldPath.toLowerCase() == newPath.toLowerCase()) {\n            nvim.command(`keepalt ${bufnr}bwipeout!`, true);\n            nvim.call('coc#util#open_file', ['keepalt edit', filepath], true);\n        }\n        else {\n            nvim.call('coc#util#open_file', ['keepalt edit', filepath], true);\n            nvim.command(`${bufnr}bwipeout!`, true);\n        }\n        if (!exists && lines.join('\\n') != '\\n') {\n            nvim.call('append', [0, lines], true);\n            nvim.command('normal! Gdd', true);\n        }\n        nvim.call('winrestview', [view], true);\n        await nvim.resumeNotification();\n    }\n    get folderPaths() {\n        return this.workspaceFolders.map(f => vscode_uri_1.URI.parse(f.uri).fsPath);\n    }\n    get floatSupported() {\n        let { env } = this;\n        return env.floating || env.textprop;\n    }\n    removeWorkspaceFolder(fsPath) {\n        let idx = this._workspaceFolders.findIndex(f => vscode_uri_1.URI.parse(f.uri).fsPath == fsPath);\n        if (idx != -1) {\n            let folder = this._workspaceFolders[idx];\n            this._workspaceFolders.splice(idx, 1);\n            this._onDidChangeWorkspaceFolders.fire({\n                removed: [folder],\n                added: []\n            });\n        }\n    }\n    renameWorkspaceFolder(oldPath, newPath) {\n        let idx = this._workspaceFolders.findIndex(f => vscode_uri_1.URI.parse(f.uri).fsPath == oldPath);\n        if (idx == -1)\n            return;\n        let removed = this._workspaceFolders[idx];\n        let added = {\n            uri: vscode_uri_1.URI.file(newPath).toString(),\n            name: path_1.default.dirname(newPath)\n        };\n        this._workspaceFolders.splice(idx, 1);\n        this._workspaceFolders.push(added);\n        this._onDidChangeWorkspaceFolders.fire({\n            removed: [removed],\n            added: [added]\n        });\n    }\n    addRootPattern(filetype, rootPatterns) {\n        let patterns = this.rootPatterns.get(filetype) || [];\n        for (let p of rootPatterns) {\n            if (!patterns.includes(p)) {\n                patterns.push(p);\n            }\n        }\n        this.rootPatterns.set(filetype, patterns);\n    }\n    get insertMode() {\n        return this._insertMode;\n    }\n    async detach() {\n        if (!this._attached)\n            return;\n        this._attached = false;\n        channels_1.default.dispose();\n        for (let bufnr of this.buffers.keys()) {\n            await events_1.default.fire('BufUnload', [bufnr]);\n        }\n    }\n    dispose() {\n        this._disposed = true;\n        for (let doc of this.documents) {\n            doc.detach();\n        }\n        index_1.disposeAll(this.disposables);\n        watchman_1.default.dispose();\n        this.configurations.dispose();\n        this.buffers.clear();\n    }\n    addWorkspaceFolder(rootPath) {\n        if (rootPath == os_1.default.homedir())\n            return;\n        let { _workspaceFolders } = this;\n        let uri = vscode_uri_1.URI.file(rootPath).toString();\n        let workspaceFolder = { uri, name: path_1.default.basename(rootPath) };\n        if (_workspaceFolders.findIndex(o => o.uri == uri) == -1) {\n            _workspaceFolders.push(workspaceFolder);\n            if (this._initialized) {\n                this._onDidChangeWorkspaceFolders.fire({\n                    added: [workspaceFolder],\n                    removed: []\n                });\n            }\n        }\n        return workspaceFolder;\n    }\n    getServerRootPatterns(filetype) {\n        let lspConfig = this.getConfiguration().get('languageserver', {});\n        let patterns = [];\n        for (let key of Object.keys(lspConfig)) {\n            let config = lspConfig[key];\n            let { filetypes, rootPatterns } = config;\n            if (filetypes && rootPatterns && filetypes.includes(filetype)) {\n                patterns.push(...rootPatterns);\n            }\n        }\n        patterns = patterns.concat(this.rootPatterns.get(filetype) || []);\n        return patterns.length ? array_1.distinct(patterns) : null;\n    }\n}\nexports.Workspace = Workspace;\nexports.default = new Workspace();\n\n\n//# sourceURL=webpack://coc.nvim/./src/workspace.ts?");

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__extends\": () => /* binding */ __extends,\n/* harmony export */   \"__assign\": () => /* binding */ __assign,\n/* harmony export */   \"__rest\": () => /* binding */ __rest,\n/* harmony export */   \"__decorate\": () => /* binding */ __decorate,\n/* harmony export */   \"__param\": () => /* binding */ __param,\n/* harmony export */   \"__metadata\": () => /* binding */ __metadata,\n/* harmony export */   \"__awaiter\": () => /* binding */ __awaiter,\n/* harmony export */   \"__generator\": () => /* binding */ __generator,\n/* harmony export */   \"__createBinding\": () => /* binding */ __createBinding,\n/* harmony export */   \"__exportStar\": () => /* binding */ __exportStar,\n/* harmony export */   \"__values\": () => /* binding */ __values,\n/* harmony export */   \"__read\": () => /* binding */ __read,\n/* harmony export */   \"__spread\": () => /* binding */ __spread,\n/* harmony export */   \"__spreadArrays\": () => /* binding */ __spreadArrays,\n/* harmony export */   \"__await\": () => /* binding */ __await,\n/* harmony export */   \"__asyncGenerator\": () => /* binding */ __asyncGenerator,\n/* harmony export */   \"__asyncDelegator\": () => /* binding */ __asyncDelegator,\n/* harmony export */   \"__asyncValues\": () => /* binding */ __asyncValues,\n/* harmony export */   \"__makeTemplateObject\": () => /* binding */ __makeTemplateObject,\n/* harmony export */   \"__importStar\": () => /* binding */ __importStar,\n/* harmony export */   \"__importDefault\": () => /* binding */ __importDefault,\n/* harmony export */   \"__classPrivateFieldGet\": () => /* binding */ __classPrivateFieldGet,\n/* harmony export */   \"__classPrivateFieldSet\": () => /* binding */ __classPrivateFieldSet\n/* harmony export */ });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/tslib/tslib.es6.js?");

/***/ }),

/***/ "./node_modules/universalify/index.js":
/*!********************************************!*\
  !*** ./node_modules/universalify/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.fromCallback = function (fn) {\n  return Object.defineProperty(function (...args) {\n    if (typeof args[args.length - 1] === 'function') fn.apply(this, args)\n    else {\n      return new Promise((resolve, reject) => {\n        fn.apply(\n          this,\n          args.concat([(err, res) => err ? reject(err) : resolve(res)])\n        )\n      })\n    }\n  }, 'name', { value: fn.name })\n}\n\nexports.fromPromise = function (fn) {\n  return Object.defineProperty(function (...args) {\n    const cb = args[args.length - 1]\n    if (typeof cb !== 'function') return fn.apply(this, args)\n    else fn.apply(this, args.slice(0, -1)).then(r => cb(null, r), cb)\n  }, 'name', { value: fn.name })\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/universalify/index.js?");

/***/ }),

/***/ "./node_modules/unzipper/lib/Buffer.js":
/*!*********************************************!*\
  !*** ./node_modules/unzipper/lib/Buffer.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Buffer = __webpack_require__(/*! buffer */ \"buffer\").Buffer;\n\n// Backwards compatibility for node versions < 8\nif (Buffer.from === undefined) {\n  Buffer.from = function (a, b, c) {\n    return new Buffer(a, b, c)\n  };\n\n  Buffer.alloc = Buffer.from;\n}\n\nmodule.exports = Buffer;\n\n//# sourceURL=webpack://coc.nvim/./node_modules/unzipper/lib/Buffer.js?");

/***/ }),

/***/ "./node_modules/unzipper/lib/BufferStream.js":
/*!***************************************************!*\
  !*** ./node_modules/unzipper/lib/BufferStream.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Promise = __webpack_require__(/*! bluebird */ \"./node_modules/bluebird/js/release/bluebird.js\");\nvar Stream = __webpack_require__(/*! stream */ \"stream\");\nvar Buffer = __webpack_require__(/*! ./Buffer */ \"./node_modules/unzipper/lib/Buffer.js\");\n\n// Backwards compatibility for node versions < 8\nif (!Stream.Writable || !Stream.Writable.prototype.destroy)\n  Stream = __webpack_require__(/*! readable-stream */ \"./node_modules/readable-stream/readable.js\");\n\nmodule.exports = function(entry) {\n  return new Promise(function(resolve,reject) {\n    var chunks = [];\n    var bufferStream = Stream.Transform()\n      .on('finish',function() {\n        resolve(Buffer.concat(chunks));\n      })\n      .on('error',reject);\n        \n    bufferStream._transform = function(d,e,cb) {\n      chunks.push(d);\n      cb();\n    };\n    entry.on('error',reject)\n      .pipe(bufferStream);\n  });\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/unzipper/lib/BufferStream.js?");

/***/ }),

/***/ "./node_modules/unzipper/lib/Decrypt.js":
/*!**********************************************!*\
  !*** ./node_modules/unzipper/lib/Decrypt.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var bigInt = __webpack_require__(/*! big-integer */ \"./node_modules/big-integer/BigInteger.js\");\nvar Stream = __webpack_require__(/*! stream */ \"stream\");\n\n// Backwards compatibility for node versions < 8\nif (!Stream.Writable || !Stream.Writable.prototype.destroy)\n  Stream = __webpack_require__(/*! readable-stream */ \"./node_modules/readable-stream/readable.js\");\n\nvar table;\n\nfunction generateTable() {\n  var poly = 0xEDB88320,c,n,k;\n  table = [];\n  for (n = 0; n < 256; n++) {\n    c = n;\n    for (k = 0; k < 8; k++)\n      c = (c & 1) ? poly ^ (c >>> 1) :  c = c >>> 1;\n    table[n] = c >>> 0;\n  }\n}\n\nfunction crc(ch,crc) {\n  if (!table)\n    generateTable();\n\n  if (ch.charCodeAt)\n    ch = ch.charCodeAt(0);        \n\n  return (bigInt(crc).shiftRight(8).and(0xffffff)).xor(table[bigInt(crc).xor(ch).and(0xff)]).value;\n}\n\nfunction Decrypt() {\n  if (!(this instanceof Decrypt))\n    return new Decrypt();\n\n  this.key0 = 305419896;\n  this.key1 = 591751049;\n  this.key2 = 878082192;\n}\n\nDecrypt.prototype.update = function(h) {            \n  this.key0 = crc(h,this.key0);\n  this.key1 = bigInt(this.key0).and(255).and(4294967295).add(this.key1)\n  this.key1 = bigInt(this.key1).multiply(134775813).add(1).and(4294967295).value;\n  this.key2 = crc(bigInt(this.key1).shiftRight(24).and(255), this.key2);\n}\n\n\nDecrypt.prototype.decryptByte = function(c) {\n  var k = bigInt(this.key2).or(2);\n  c = c ^ bigInt(k).multiply(bigInt(k^1)).shiftRight(8).and(255);\n  this.update(c);\n  return c;\n};\n\n Decrypt.prototype.stream = function() {\n  var stream = Stream.Transform(),\n      self = this;\n\n  stream._transform = function(d,e,cb) {\n    for (var i = 0; i<d.length;i++) {\n      d[i] = self.decryptByte(d[i]);\n    }\n    this.push(d);\n    cb();\n  };\n  return stream;\n};\n\n\n\n\nmodule.exports = Decrypt;\n\n//# sourceURL=webpack://coc.nvim/./node_modules/unzipper/lib/Decrypt.js?");

/***/ }),

/***/ "./node_modules/unzipper/lib/NoopStream.js":
/*!*************************************************!*\
  !*** ./node_modules/unzipper/lib/NoopStream.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Stream = __webpack_require__(/*! stream */ \"stream\");\nvar util = __webpack_require__(/*! util */ \"util\");\n\n// Backwards compatibility for node versions < 8\nif (!Stream.Writable || !Stream.Writable.prototype.destroy)\n  Stream = __webpack_require__(/*! readable-stream */ \"./node_modules/readable-stream/readable.js\");\n\nfunction NoopStream() {\n  if (!(this instanceof NoopStream)) {\n    return new NoopStream();\n  }\n  Stream.Transform.call(this);\n}\n\nutil.inherits(NoopStream,Stream.Transform);\n\nNoopStream.prototype._transform = function(d,e,cb) { cb() ;};\n  \nmodule.exports = NoopStream;\n\n//# sourceURL=webpack://coc.nvim/./node_modules/unzipper/lib/NoopStream.js?");

/***/ }),

/***/ "./node_modules/unzipper/lib/Open/directory.js":
/*!*****************************************************!*\
  !*** ./node_modules/unzipper/lib/Open/directory.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var binary = __webpack_require__(/*! binary */ \"./node_modules/binary/index.js\");\nvar PullStream = __webpack_require__(/*! ../PullStream */ \"./node_modules/unzipper/lib/PullStream.js\");\nvar unzip = __webpack_require__(/*! ./unzip */ \"./node_modules/unzipper/lib/Open/unzip.js\");\nvar Promise = __webpack_require__(/*! bluebird */ \"./node_modules/bluebird/js/release/bluebird.js\");\nvar BufferStream = __webpack_require__(/*! ../BufferStream */ \"./node_modules/unzipper/lib/BufferStream.js\");\nvar parseExtraField = __webpack_require__(/*! ../parseExtraField */ \"./node_modules/unzipper/lib/parseExtraField.js\");\nvar Buffer = __webpack_require__(/*! ../Buffer */ \"./node_modules/unzipper/lib/Buffer.js\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar Writer = __webpack_require__(/*! fstream */ \"./node_modules/fstream/fstream.js\").Writer;\nvar parseDateTime = __webpack_require__(/*! ../parseDateTime */ \"./node_modules/unzipper/lib/parseDateTime.js\");\n\nvar signature = Buffer.alloc(4);\nsignature.writeUInt32LE(0x06054b50,0);\n\nfunction getCrxHeader(source) {\n  var sourceStream = source.stream(0).pipe(PullStream());\n\n  return sourceStream.pull(4).then(function(data) {\n    var signature = data.readUInt32LE(0);\n    if (signature === 0x34327243) {\n      var crxHeader;\n      return sourceStream.pull(12).then(function(data) {\n        crxHeader = binary.parse(data)\n          .word32lu('version')\n          .word32lu('pubKeyLength')\n          .word32lu('signatureLength')\n          .vars;\n      }).then(function() {\n        return sourceStream.pull(crxHeader.pubKeyLength +crxHeader.signatureLength);\n      }).then(function(data) {\n        crxHeader.publicKey = data.slice(0,crxHeader.pubKeyLength);\n        crxHeader.signature = data.slice(crxHeader.pubKeyLength);\n        crxHeader.size = 16 + crxHeader.pubKeyLength +crxHeader.signatureLength;\n        return crxHeader;\n      });\n    }\n  });\n}\n\n// Zip64 File Format Notes: https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT\nfunction getZip64CentralDirectory(source, zip64CDL) {\n  var d64loc = binary.parse(zip64CDL)\n    .word32lu('signature')\n    .word32lu('diskNumber')\n    .word64lu('offsetToStartOfCentralDirectory')\n    .word32lu('numberOfDisks')\n    .vars;\n\n  if (d64loc.signature != 0x07064b50) {\n    throw new Error('invalid zip64 end of central dir locator signature (0x07064b50): 0x' + d64loc.signature.toString(16));\n  }\n\n  var dir64 = PullStream();\n  source.stream(d64loc.offsetToStartOfCentralDirectory).pipe(dir64);\n\n  return dir64.pull(56)\n}\n\n// Zip64 File Format Notes: https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT\nfunction parseZip64DirRecord (dir64record) {\n  var vars = binary.parse(dir64record)\n    .word32lu('signature')\n    .word64lu('sizeOfCentralDirectory')\n    .word16lu('version')\n    .word16lu('versionsNeededToExtract')\n    .word32lu('diskNumber')\n    .word32lu('diskStart')\n    .word64lu('numberOfRecordsOnDisk')\n    .word64lu('numberOfRecords')\n    .word64lu('sizeOfCentralDirectory')\n    .word64lu('offsetToStartOfCentralDirectory')\n    .vars;\n\n  if (vars.signature != 0x06064b50) {\n    throw new Error('invalid zip64 end of central dir locator signature (0x06064b50): 0x0' + vars.signature.toString(16));\n  }\n\n  return vars\n}\n\nmodule.exports = function centralDirectory(source, options) {\n  var endDir = PullStream(),\n      records = PullStream(),\n      tailSize = (options && options.tailSize) || 80,\n      sourceSize,\n      crxHeader,\n      startOffset,\n      vars;\n\n  if (options && options.crx)\n    crxHeader = getCrxHeader(source);\n\n  return source.size()\n    .then(function(size) {\n      sourceSize = size;\n\n      source.stream(Math.max(0,size-tailSize))\n        .on('error', function (error) { endDir.emit('error', error) })\n        .pipe(endDir);\n\n      return endDir.pull(signature);\n    })\n    .then(function() {\n      return Promise.props({directory: endDir.pull(22), crxHeader: crxHeader});\n    })\n    .then(function(d) {\n      var data = d.directory;\n      startOffset = d.crxHeader && d.crxHeader.size || 0;\n\n      vars = binary.parse(data)\n        .word32lu('signature')\n        .word16lu('diskNumber')\n        .word16lu('diskStart')\n        .word16lu('numberOfRecordsOnDisk')\n        .word16lu('numberOfRecords')\n        .word32lu('sizeOfCentralDirectory')\n        .word32lu('offsetToStartOfCentralDirectory')\n        .word16lu('commentLength')\n        .vars;\n\n      // Is this zip file using zip64 format? Use same check as Go:\n      // https://github.com/golang/go/blob/master/src/archive/zip/reader.go#L503\n      // For zip64 files, need to find zip64 central directory locator header to extract\n      // relative offset for zip64 central directory record.\n      if (vars.numberOfRecords == 0xffff|| vars.numberOfRecords == 0xffff ||\n        vars.offsetToStartOfCentralDirectory == 0xffffffff) {\n\n        // Offset to zip64 CDL is 20 bytes before normal CDR\n        const zip64CDLSize = 20\n        const zip64CDLOffset = sourceSize - (tailSize - endDir.match + zip64CDLSize)\n        const zip64CDLStream = PullStream();\n\n        source.stream(zip64CDLOffset).pipe(zip64CDLStream);\n\n        return zip64CDLStream.pull(zip64CDLSize)\n          .then(function (d) { return getZip64CentralDirectory(source, d) })\n          .then(function (dir64record) {\n            vars = parseZip64DirRecord(dir64record)\n          })\n      } else {\n        vars.offsetToStartOfCentralDirectory += startOffset;\n      }\n    })\n    .then(function() {\n      source.stream(vars.offsetToStartOfCentralDirectory).pipe(records);\n\n      vars.extract = function(opts) {\n        if (!opts || !opts.path) throw new Error('PATH_MISSING');\n        return vars.files.then(function(files) {\n          return Promise.map(files, function(entry) {\n            if (entry.type == 'Directory') return;\n\n            // to avoid zip slip (writing outside of the destination), we resolve\n            // the target path, and make sure it's nested in the intended\n            // destination, or not extract it otherwise.\n            var extractPath = path.join(opts.path, entry.path);\n            if (extractPath.indexOf(opts.path) != 0) {\n              return;\n            }\n            var writer = opts.getWriter ? opts.getWriter({path: extractPath}) :  Writer({ path: extractPath });\n\n            return new Promise(function(resolve, reject) {\n              entry.stream(opts.password)\n                .on('error',reject)\n                .pipe(writer)\n                .on('close',resolve)\n                .on('error',reject);\n            });\n          }, opts.concurrency > 1 ? {concurrency: opts.concurrency || undefined} : undefined);\n        });\n      };\n\n      vars.files = Promise.mapSeries(Array(vars.numberOfRecords),function() {\n        return records.pull(46).then(function(data) {    \n          var vars = binary.parse(data)\n            .word32lu('signature')\n            .word16lu('versionMadeBy')\n            .word16lu('versionsNeededToExtract')\n            .word16lu('flags')\n            .word16lu('compressionMethod')\n            .word16lu('lastModifiedTime')\n            .word16lu('lastModifiedDate')\n            .word32lu('crc32')\n            .word32lu('compressedSize')\n            .word32lu('uncompressedSize')\n            .word16lu('fileNameLength')\n            .word16lu('extraFieldLength')\n            .word16lu('fileCommentLength')\n            .word16lu('diskNumber')\n            .word16lu('internalFileAttributes')\n            .word32lu('externalFileAttributes')\n            .word32lu('offsetToLocalFileHeader')\n            .vars;\n\n        vars.offsetToLocalFileHeader += startOffset;\n        vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);\n\n        return records.pull(vars.fileNameLength).then(function(fileNameBuffer) {\n          vars.pathBuffer = fileNameBuffer;\n          vars.path = fileNameBuffer.toString('utf8');\n          vars.isUnicode = vars.flags & 0x11;\n          return records.pull(vars.extraFieldLength);\n        })\n        .then(function(extraField) {\n          vars.extra = parseExtraField(extraField, vars);\n          return records.pull(vars.fileCommentLength);\n        })\n        .then(function(comment) {\n          vars.comment = comment;\n          vars.type = (vars.uncompressedSize === 0 && /[\\/\\\\]$/.test(vars.path)) ? 'Directory' : 'File';\n          vars.stream = function(_password) {\n            return unzip(source, vars.offsetToLocalFileHeader,_password, vars);\n          };\n          vars.buffer = function(_password) {\n            return BufferStream(vars.stream(_password));\n          };\n          return vars;\n        });\n      });\n    });\n\n    return Promise.props(vars);\n  });\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/unzipper/lib/Open/directory.js?");

/***/ }),

/***/ "./node_modules/unzipper/lib/Open/index.js":
/*!*************************************************!*\
  !*** ./node_modules/unzipper/lib/Open/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var fs = __webpack_require__(/*! graceful-fs */ \"./node_modules/graceful-fs/graceful-fs.js\");\nvar Promise = __webpack_require__(/*! bluebird */ \"./node_modules/bluebird/js/release/bluebird.js\");\nvar directory = __webpack_require__(/*! ./directory */ \"./node_modules/unzipper/lib/Open/directory.js\");\nvar Stream = __webpack_require__(/*! stream */ \"stream\");\n\n// Backwards compatibility for node versions < 8\nif (!Stream.Writable || !Stream.Writable.prototype.destroy)\n  Stream = __webpack_require__(/*! readable-stream */ \"./node_modules/readable-stream/readable.js\");\n\nmodule.exports = {\n  buffer: function(buffer, options) {\n    var source = {\n      stream: function(offset, length) {\n        var stream = Stream.PassThrough();\n        stream.end(buffer.slice(offset, length));\n        return stream;\n      },\n      size: function() {\n        return Promise.resolve(buffer.length);\n      }\n    };\n    return directory(source, options);\n  },\n  file: function(filename, options) {\n    var source = {\n      stream: function(offset,length) {\n        return fs.createReadStream(filename,{start: offset, end: length && offset+length});\n      },\n      size: function() {\n        return new Promise(function(resolve,reject) {\n          fs.stat(filename,function(err,d) {\n            if (err)\n              reject(err);\n            else\n              resolve(d.size);\n          });\n        });\n      }\n    };\n    return directory(source, options);\n  },\n\n  url: function(request, params, options) {\n    if (typeof params === 'string')\n      params = {url: params};\n    if (!params.url)\n      throw 'URL missing';\n    params.headers = params.headers || {};\n\n    var source = {\n      stream : function(offset,length) {\n        var options = Object.create(params);\n        options.headers = Object.create(params.headers);\n        options.headers.range = 'bytes='+offset+'-' + (length ? length : '');\n        return request(options);\n      },\n      size: function() {\n        return new Promise(function(resolve,reject) {\n          var req = request(params);\n          req.on('response',function(d) {\n            req.abort();\n            if (!d.headers['content-length'])\n              reject(new Error('Missing content length header'));\n            else\n              resolve(d.headers['content-length']);\n          }).on('error',reject);\n        });\n      }\n    };\n\n    return directory(source, options);\n  },\n\n  s3 : function(client,params, options) {\n    var source = {\n      size: function() {\n        return new Promise(function(resolve,reject) {\n          client.headObject(params, function(err,d) {\n            if (err)\n              reject(err);\n            else\n              resolve(d.ContentLength);\n          });\n        });\n      },\n      stream: function(offset,length) {\n        var d = {};\n        for (var key in params)\n          d[key] = params[key];\n        d.Range = 'bytes='+offset+'-' + (length ? length : '');\n        return client.getObject(d).createReadStream();\n      }\n    };\n\n    return directory(source, options);\n  }\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/unzipper/lib/Open/index.js?");

/***/ }),

/***/ "./node_modules/unzipper/lib/Open/unzip.js":
/*!*************************************************!*\
  !*** ./node_modules/unzipper/lib/Open/unzip.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Promise = __webpack_require__(/*! bluebird */ \"./node_modules/bluebird/js/release/bluebird.js\");\nvar Decrypt = __webpack_require__(/*! ../Decrypt */ \"./node_modules/unzipper/lib/Decrypt.js\");\nvar PullStream = __webpack_require__(/*! ../PullStream */ \"./node_modules/unzipper/lib/PullStream.js\");\nvar Stream = __webpack_require__(/*! stream */ \"stream\");\nvar binary = __webpack_require__(/*! binary */ \"./node_modules/binary/index.js\");\nvar zlib = __webpack_require__(/*! zlib */ \"zlib\");\nvar parseExtraField = __webpack_require__(/*! ../parseExtraField */ \"./node_modules/unzipper/lib/parseExtraField.js\");\nvar Buffer = __webpack_require__(/*! ../Buffer */ \"./node_modules/unzipper/lib/Buffer.js\");\nvar parseDateTime = __webpack_require__(/*! ../parseDateTime */ \"./node_modules/unzipper/lib/parseDateTime.js\");\n\n// Backwards compatibility for node versions < 8\nif (!Stream.Writable || !Stream.Writable.prototype.destroy)\n  Stream = __webpack_require__(/*! readable-stream */ \"./node_modules/readable-stream/readable.js\");\n\nmodule.exports = function unzip(source,offset,_password, directoryVars) {\n  var file = PullStream(),\n      entry = Stream.PassThrough();\n\n  var req = source.stream(offset);\n  req.pipe(file).on('error', function(e) {\n    entry.emit('error', e);\n  });\n\n  entry.vars = file.pull(30)\n    .then(function(data) {\n      var vars = binary.parse(data)\n        .word32lu('signature')\n        .word16lu('versionsNeededToExtract')\n        .word16lu('flags')\n        .word16lu('compressionMethod')\n        .word16lu('lastModifiedTime')\n        .word16lu('lastModifiedDate')\n        .word32lu('crc32')\n        .word32lu('compressedSize')\n        .word32lu('uncompressedSize')\n        .word16lu('fileNameLength')\n        .word16lu('extraFieldLength')\n        .vars;\n\n      vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);\n\n      return file.pull(vars.fileNameLength)\n        .then(function(fileName) {\n          vars.fileName = fileName.toString('utf8');\n          return file.pull(vars.extraFieldLength);\n        })\n        .then(function(extraField) {\n          var checkEncryption;\n          vars.extra = parseExtraField(extraField, vars);\n          // Ignore logal file header vars if the directory vars are available\n          if (directoryVars && directoryVars.compressedSize) vars = directoryVars;\n\n          if (vars.flags & 0x01) checkEncryption = file.pull(12)\n            .then(function(header) {\n              if (!_password)\n                throw new Error('MISSING_PASSWORD');\n\n              var decrypt = Decrypt();\n\n              String(_password).split('').forEach(function(d) {\n                decrypt.update(d);\n              });\n\n              for (var i=0; i < header.length; i++)\n                header[i] = decrypt.decryptByte(header[i]);\n\n              vars.decrypt = decrypt;\n              vars.compressedSize -= 12;\n\n              var check = (vars.flags & 0x8) ? (vars.lastModifiedTime >> 8) & 0xff : (vars.crc32 >> 24) & 0xff;\n              if (header[11] !== check)\n                throw new Error('BAD_PASSWORD');\n\n              return vars;\n            });\n\n          return Promise.resolve(checkEncryption)\n            .then(function() {\n              entry.emit('vars',vars);\n              return vars;\n            });\n        });\n    });\n\n    entry.vars.then(function(vars) {\n      var fileSizeKnown = !(vars.flags & 0x08) || vars.compressedSize > 0,\n          eof;\n\n      var inflater = vars.compressionMethod ? zlib.createInflateRaw() : Stream.PassThrough();\n\n      if (fileSizeKnown) {\n        entry.size = vars.uncompressedSize;\n        eof = vars.compressedSize;\n      } else {\n        eof = Buffer.alloc(4);\n        eof.writeUInt32LE(0x08074b50, 0);\n      }\n\n      var stream = file.stream(eof);\n\n      if (vars.decrypt)\n        stream = stream.pipe(vars.decrypt.stream());\n\n      stream\n        .pipe(inflater)\n        .on('error',function(err) { entry.emit('error',err);})\n        .pipe(entry)\n        .on('finish', function() {\n          if (req.abort)\n            req.abort();\n          else if (req.close)\n            req.close();\n          else if (req.push)\n            req.push();\n          else\n            console.log('warning - unable to close stream');\n        });\n    })\n    .catch(function(e) {\n      entry.emit('error',e);\n    });\n\n  return entry;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/unzipper/lib/Open/unzip.js?");

/***/ }),

/***/ "./node_modules/unzipper/lib/PullStream.js":
/*!*************************************************!*\
  !*** ./node_modules/unzipper/lib/PullStream.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Stream = __webpack_require__(/*! stream */ \"stream\");\nvar Promise = __webpack_require__(/*! bluebird */ \"./node_modules/bluebird/js/release/bluebird.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar Buffer = __webpack_require__(/*! ./Buffer */ \"./node_modules/unzipper/lib/Buffer.js\");\nvar strFunction = 'function';\n\n// Backwards compatibility for node versions < 8\nif (!Stream.Writable || !Stream.Writable.prototype.destroy)\n  Stream = __webpack_require__(/*! readable-stream */ \"./node_modules/readable-stream/readable.js\");\n\nfunction PullStream() {\n  if (!(this instanceof PullStream))\n    return new PullStream();\n\n  Stream.Duplex.call(this,{decodeStrings:false, objectMode:true});\n  this.buffer = Buffer.from('');\n  var self = this;\n  self.on('finish',function() {\n    self.finished = true;\n    self.emit('chunk',false);\n  });\n}\n\nutil.inherits(PullStream,Stream.Duplex);\n\nPullStream.prototype._write = function(chunk,e,cb) {\n  this.buffer = Buffer.concat([this.buffer,chunk]);\n  this.cb = cb;\n  this.emit('chunk');\n};\n\n\n// The `eof` parameter is interpreted as `file_length` if the type is number\n// otherwise (i.e. buffer) it is interpreted as a pattern signaling end of stream\nPullStream.prototype.stream = function(eof,includeEof) {\n  var p = Stream.PassThrough();\n  var done,self= this;\n\n  function cb() {\n    if (typeof self.cb === strFunction) {\n      var callback = self.cb;\n      self.cb = undefined;\n      return callback();\n    }\n  }\n\n  function pull() {\n    var packet;\n    if (self.buffer && self.buffer.length) {\n      if (typeof eof === 'number') {\n        packet = self.buffer.slice(0,eof);\n        self.buffer = self.buffer.slice(eof);\n        eof -= packet.length;\n        done = !eof;\n      } else {\n        var match = self.buffer.indexOf(eof);\n        if (match !== -1) {\n          // store signature match byte offset to allow us to reference\n          // this for zip64 offset\n          self.match = match\n          if (includeEof) match = match + eof.length;\n          packet = self.buffer.slice(0,match);\n          self.buffer = self.buffer.slice(match);\n          done = true;\n        } else {\n          var len = self.buffer.length - eof.length;\n          if (len <= 0) {\n            cb();\n          } else {\n            packet = self.buffer.slice(0,len);\n            self.buffer = self.buffer.slice(len);\n          }\n        }\n      }\n      if (packet) p.write(packet,function() {\n        if (self.buffer.length === 0 || (eof.length && self.buffer.length <= eof.length)) cb();\n      });\n    }\n    \n    if (!done) {\n      if (self.finished && !this.__ended) {\n        self.removeListener('chunk',pull);\n        self.emit('error', new Error('FILE_ENDED'));\n        this.__ended = true;\n        return;\n      }\n      \n    } else {\n      self.removeListener('chunk',pull);\n      p.end();\n    }\n  }\n\n  self.on('chunk',pull);\n  pull();\n  return p;\n};\n\nPullStream.prototype.pull = function(eof,includeEof) {\n  if (eof === 0) return Promise.resolve('');\n\n  // If we already have the required data in buffer\n  // we can resolve the request immediately\n  if (!isNaN(eof) && this.buffer.length > eof) {\n    var data = this.buffer.slice(0,eof);\n    this.buffer = this.buffer.slice(eof);\n    return Promise.resolve(data);\n  }\n\n  // Otherwise we stream until we have it\n  var buffer = Buffer.from(''),\n      self = this;\n\n  var concatStream = Stream.Transform();\n  concatStream._transform = function(d,e,cb) {\n    buffer = Buffer.concat([buffer,d]);\n    cb();\n  };\n  \n  var rejectHandler;\n  var pullStreamRejectHandler;\n  return new Promise(function(resolve,reject) {\n    rejectHandler = reject;\n    pullStreamRejectHandler = function(e) {\n      self.__emittedError = e;\n      reject(e);\n    }\n    if (self.finished)\n      return reject(new Error('FILE_ENDED'));\n    self.once('error',pullStreamRejectHandler);  // reject any errors from pullstream itself\n    self.stream(eof,includeEof)\n      .on('error',reject)\n      .pipe(concatStream)\n      .on('finish',function() {resolve(buffer);})\n      .on('error',reject);\n  })\n  .finally(function() {\n    self.removeListener('error',rejectHandler);\n    self.removeListener('error',pullStreamRejectHandler);\n  });\n};\n\nPullStream.prototype._read = function(){};\n\nmodule.exports = PullStream;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/unzipper/lib/PullStream.js?");

/***/ }),

/***/ "./node_modules/unzipper/lib/extract.js":
/*!**********************************************!*\
  !*** ./node_modules/unzipper/lib/extract.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = Extract;\n\nvar Parse = __webpack_require__(/*! ./parse */ \"./node_modules/unzipper/lib/parse.js\");\nvar Writer = __webpack_require__(/*! fstream */ \"./node_modules/fstream/fstream.js\").Writer;\nvar path = __webpack_require__(/*! path */ \"path\");\nvar stream = __webpack_require__(/*! stream */ \"stream\");\nvar duplexer2 = __webpack_require__(/*! duplexer2 */ \"./node_modules/duplexer2/index.js\");\nvar Promise = __webpack_require__(/*! bluebird */ \"./node_modules/bluebird/js/release/bluebird.js\");\n\nfunction Extract (opts) {\n  // make sure path is normalized before using it\n  opts.path = path.resolve(path.normalize(opts.path));\n\n  var parser = new Parse(opts);\n\n  var outStream = new stream.Writable({objectMode: true});\n  outStream._write = function(entry, encoding, cb) {\n\n    if (entry.type == 'Directory') return cb();\n\n    // to avoid zip slip (writing outside of the destination), we resolve\n    // the target path, and make sure it's nested in the intended\n    // destination, or not extract it otherwise.\n    var extractPath = path.join(opts.path, entry.path);\n    if (extractPath.indexOf(opts.path) != 0) {\n      return cb();\n    }\n\n    const writer = opts.getWriter ? opts.getWriter({path: extractPath}) :  Writer({ path: extractPath });\n\n    entry.pipe(writer)\n      .on('error', cb)\n      .on('close', cb);\n  };\n\n  var extract = duplexer2(parser,outStream);\n  parser.once('crx-header', function(crxHeader) {\n    extract.crxHeader = crxHeader;\n  });\n\n  parser\n    .pipe(outStream)\n    .on('finish',function() {\n      extract.emit('close');\n    });\n  \n  extract.promise = function() {\n    return new Promise(function(resolve, reject) {\n      extract.on('close', resolve);\n      extract.on('error',reject);\n    });\n  };\n\n  return extract;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/unzipper/lib/extract.js?");

/***/ }),

/***/ "./node_modules/unzipper/lib/parse.js":
/*!********************************************!*\
  !*** ./node_modules/unzipper/lib/parse.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var util = __webpack_require__(/*! util */ \"util\");\nvar zlib = __webpack_require__(/*! zlib */ \"zlib\");\nvar Stream = __webpack_require__(/*! stream */ \"stream\");\nvar binary = __webpack_require__(/*! binary */ \"./node_modules/binary/index.js\");\nvar Promise = __webpack_require__(/*! bluebird */ \"./node_modules/bluebird/js/release/bluebird.js\");\nvar PullStream = __webpack_require__(/*! ./PullStream */ \"./node_modules/unzipper/lib/PullStream.js\");\nvar NoopStream = __webpack_require__(/*! ./NoopStream */ \"./node_modules/unzipper/lib/NoopStream.js\");\nvar BufferStream = __webpack_require__(/*! ./BufferStream */ \"./node_modules/unzipper/lib/BufferStream.js\");\nvar parseExtraField = __webpack_require__(/*! ./parseExtraField */ \"./node_modules/unzipper/lib/parseExtraField.js\");\nvar Buffer = __webpack_require__(/*! ./Buffer */ \"./node_modules/unzipper/lib/Buffer.js\");\nvar parseDateTime = __webpack_require__(/*! ./parseDateTime */ \"./node_modules/unzipper/lib/parseDateTime.js\");\n\n// Backwards compatibility for node versions < 8\nif (!Stream.Writable || !Stream.Writable.prototype.destroy)\n  Stream = __webpack_require__(/*! readable-stream */ \"./node_modules/readable-stream/readable.js\");\n\nvar endDirectorySignature = Buffer.alloc(4);\nendDirectorySignature.writeUInt32LE(0x06054b50, 0);\n\nfunction Parse(opts) {\n  if (!(this instanceof Parse)) {\n    return new Parse(opts);\n  }\n  var self = this;\n  self._opts = opts || { verbose: false };\n\n  PullStream.call(self, self._opts);\n  self.on('finish',function() {\n    self.emit('close');\n  });\n  self._readRecord().catch(function(e) {\n    if (!self.__emittedError || self.__emittedError !== e)\n      self.emit('error',e);\n  });\n}\n\nutil.inherits(Parse, PullStream);\n\nParse.prototype._readRecord = function () {\n  var self = this;\n  return self.pull(4).then(function(data) {\n    if (data.length === 0)\n      return;\n\n    var signature = data.readUInt32LE(0);\n\n    if (signature === 0x34327243) {\n      return self._readCrxHeader();\n    }\n    if (signature === 0x04034b50) {\n      return self._readFile();\n    }\n    else if (signature === 0x02014b50) {\n      self.__ended = true;\n      return self._readCentralDirectoryFileHeader();\n    }\n    else if (signature === 0x06054b50) {\n      return self._readEndOfCentralDirectoryRecord();\n    }\n    else if (self.__ended) {\n      return self.pull(endDirectorySignature).then(function() {\n          return self._readEndOfCentralDirectoryRecord();\n        });\n    }\n    else\n      self.emit('error', new Error('invalid signature: 0x' + signature.toString(16)));\n  });\n};\n\nParse.prototype._readCrxHeader = function() {\n  var self = this;\n  return self.pull(12).then(function(data) {\n    self.crxHeader = binary.parse(data)\n      .word32lu('version')\n      .word32lu('pubKeyLength')\n      .word32lu('signatureLength')\n      .vars;\n    return self.pull(self.crxHeader.pubKeyLength + self.crxHeader.signatureLength);\n  }).then(function(data) {\n    self.crxHeader.publicKey = data.slice(0,self.crxHeader.pubKeyLength);\n    self.crxHeader.signature = data.slice(self.crxHeader.pubKeyLength);\n    self.emit('crx-header',self.crxHeader);\n    return self._readRecord();\n  });\n};\n\nParse.prototype._readFile = function () {\n  var self = this;\n  return self.pull(26).then(function(data) {\n    var vars = binary.parse(data)\n      .word16lu('versionsNeededToExtract')\n      .word16lu('flags')\n      .word16lu('compressionMethod')\n      .word16lu('lastModifiedTime')\n      .word16lu('lastModifiedDate')\n      .word32lu('crc32')\n      .word32lu('compressedSize')\n      .word32lu('uncompressedSize')\n      .word16lu('fileNameLength')\n      .word16lu('extraFieldLength')\n      .vars;\n\n    vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);\n\n    if (self.crxHeader) vars.crxHeader = self.crxHeader;\n\n    return self.pull(vars.fileNameLength).then(function(fileNameBuffer) {\n      var fileName = fileNameBuffer.toString('utf8');\n      var entry = Stream.PassThrough();\n      var __autodraining = false;\n\n      entry.autodrain = function() {\n        __autodraining = true;\n        var draining = entry.pipe(NoopStream());\n        draining.promise = function() {\n          return new Promise(function(resolve, reject) {\n            draining.on('finish',resolve);\n            draining.on('error',reject);\n          });\n        };\n        return draining;\n      };\n\n      entry.buffer = function() {\n        return BufferStream(entry);\n      };\n\n      entry.path = fileName;\n      entry.props = {};\n      entry.props.path = fileName;\n      entry.props.pathBuffer = fileNameBuffer;\n      entry.props.flags = {\n        \"isUnicode\": vars.flags & 0x11\n      };\n      entry.type = (vars.uncompressedSize === 0 && /[\\/\\\\]$/.test(fileName)) ? 'Directory' : 'File';\n\n      if (self._opts.verbose) {\n        if (entry.type === 'Directory') {\n          console.log('   creating:', fileName);\n        } else if (entry.type === 'File') {\n          if (vars.compressionMethod === 0) {\n            console.log(' extracting:', fileName);\n          } else {\n            console.log('  inflating:', fileName);\n          }\n        }\n      }\n\n      return self.pull(vars.extraFieldLength).then(function(extraField) {\n        var extra = parseExtraField(extraField, vars);\n\n        entry.vars = vars;\n        entry.extra = extra;\n\n        if (self._opts.forceStream) {\n          self.push(entry);\n        } else {\n          self.emit('entry', entry);\n\n          if (self._readableState.pipesCount || (self._readableState.pipes && self._readableState.pipes.length))\n            self.push(entry);\n        }\n\n        if (self._opts.verbose)\n          console.log({\n            filename:fileName,\n            vars: vars,\n            extra: extra\n          });\n\n        var fileSizeKnown = !(vars.flags & 0x08) || vars.compressedSize > 0,\n            eof;\n\n        entry.__autodraining = __autodraining;  // expose __autodraining for test purposes\n        var inflater = (vars.compressionMethod && !__autodraining) ? zlib.createInflateRaw() : Stream.PassThrough();\n\n        if (fileSizeKnown) {\n          entry.size = vars.uncompressedSize;\n          eof = vars.compressedSize;\n        } else {\n          eof = Buffer.alloc(4);\n          eof.writeUInt32LE(0x08074b50, 0);\n        }\n\n        return new Promise(function(resolve, reject) {\n          self.stream(eof)\n            .pipe(inflater)\n            .on('error',function(err) { self.emit('error',err);})\n            .pipe(entry)\n            .on('finish', function() {\n              return fileSizeKnown ?\n                self._readRecord().then(resolve).catch(reject) :\n                self._processDataDescriptor(entry).then(resolve).catch(reject);\n            });\n        });\n      });\n    });\n  });\n};\n\nParse.prototype._processDataDescriptor = function (entry) {\n  var self = this;\n  return self.pull(16).then(function(data) {\n    var vars = binary.parse(data)\n      .word32lu('dataDescriptorSignature')\n      .word32lu('crc32')\n      .word32lu('compressedSize')\n      .word32lu('uncompressedSize')\n      .vars;\n\n    entry.size = vars.uncompressedSize;\n    return self._readRecord();\n  });\n};\n\nParse.prototype._readCentralDirectoryFileHeader = function () {\n  var self = this;\n  return self.pull(42).then(function(data) {\n\n    var vars = binary.parse(data)\n      .word16lu('versionMadeBy')\n      .word16lu('versionsNeededToExtract')\n      .word16lu('flags')\n      .word16lu('compressionMethod')\n      .word16lu('lastModifiedTime')\n      .word16lu('lastModifiedDate')\n      .word32lu('crc32')\n      .word32lu('compressedSize')\n      .word32lu('uncompressedSize')\n      .word16lu('fileNameLength')\n      .word16lu('extraFieldLength')\n      .word16lu('fileCommentLength')\n      .word16lu('diskNumber')\n      .word16lu('internalFileAttributes')\n      .word32lu('externalFileAttributes')\n      .word32lu('offsetToLocalFileHeader')\n      .vars;\n\n    return self.pull(vars.fileNameLength).then(function(fileName) {\n      vars.fileName = fileName.toString('utf8');\n      return self.pull(vars.extraFieldLength);\n    })\n    .then(function(extraField) {\n      return self.pull(vars.fileCommentLength);\n    })\n    .then(function(fileComment) {\n      return self._readRecord();\n    });\n  });\n};\n\nParse.prototype._readEndOfCentralDirectoryRecord = function() {\n  var self = this;\n  return self.pull(18).then(function(data) {\n\n    var vars = binary.parse(data)\n      .word16lu('diskNumber')\n      .word16lu('diskStart')\n      .word16lu('numberOfRecordsOnDisk')\n      .word16lu('numberOfRecords')\n      .word32lu('sizeOfCentralDirectory')\n      .word32lu('offsetToStartOfCentralDirectory')\n      .word16lu('commentLength')\n      .vars;\n\n    return self.pull(vars.commentLength).then(function(comment) {\n      comment = comment.toString('utf8');\n      self.end();\n      self.push(null);\n    });\n\n  });\n};\n\nParse.prototype.promise = function() {\n  var self = this;\n  return new Promise(function(resolve,reject) {\n    self.on('finish',resolve);\n    self.on('error',reject);\n  });\n};\n\nmodule.exports = Parse;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/unzipper/lib/parse.js?");

/***/ }),

/***/ "./node_modules/unzipper/lib/parseDateTime.js":
/*!****************************************************!*\
  !*** ./node_modules/unzipper/lib/parseDateTime.js ***!
  \****************************************************/
/***/ ((module) => {

eval("// Dates in zip file entries are stored as DosDateTime\n// Spec is here: https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-dosdatetimetofiletime\n\nmodule.exports = function parseDateTime(date, time) {\n  const day = date & 0x1F;\n  const month = date >> 5 & 0x0F;\n  const year = (date >> 9 & 0x7F) + 1980;\n  const seconds = time ? (time & 0x1F) * 2 : 0;\n  const minutes = time ? (time >> 5) & 0x3F : 0;\n  const hours = time ? (time >> 11): 0;\n\n  return new Date(Date.UTC(year, month-1, day, hours, minutes, seconds));\n};\n\n//# sourceURL=webpack://coc.nvim/./node_modules/unzipper/lib/parseDateTime.js?");

/***/ }),

/***/ "./node_modules/unzipper/lib/parseExtraField.js":
/*!******************************************************!*\
  !*** ./node_modules/unzipper/lib/parseExtraField.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var binary = __webpack_require__(/*! binary */ \"./node_modules/binary/index.js\");\n\nmodule.exports = function(extraField, vars) {\n  var extra;\n  // Find the ZIP64 header, if present.\n  while(!extra && extraField && extraField.length) {\n    var candidateExtra = binary.parse(extraField)\n      .word16lu('signature')\n      .word16lu('partsize')\n      .word64lu('uncompressedSize')\n      .word64lu('compressedSize')\n      .word64lu('offset')\n      .word64lu('disknum')\n      .vars;\n\n    if(candidateExtra.signature === 0x0001) {\n      extra = candidateExtra;\n    } else {\n      // Advance the buffer to the next part.\n      // The total size of this part is the 4 byte header + partsize.\n      extraField = extraField.slice(candidateExtra.partsize + 4);\n    }\n  }\n\n  extra = extra || {};\n\n  if (vars.compressedSize === 0xffffffff)\n    vars.compressedSize = extra.compressedSize;\n\n  if (vars.uncompressedSize  === 0xffffffff)\n    vars.uncompressedSize= extra.uncompressedSize;\n\n  if (vars.offsetToLocalFileHeader === 0xffffffff)\n    vars.offsetToLocalFileHeader= extra.offset;\n\n  return extra;\n};\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/unzipper/lib/parseExtraField.js?");

/***/ }),

/***/ "./node_modules/unzipper/lib/parseOne.js":
/*!***********************************************!*\
  !*** ./node_modules/unzipper/lib/parseOne.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Stream = __webpack_require__(/*! stream */ \"stream\");\nvar Parse = __webpack_require__(/*! ./parse */ \"./node_modules/unzipper/lib/parse.js\");\nvar duplexer2 = __webpack_require__(/*! duplexer2 */ \"./node_modules/duplexer2/index.js\");\nvar BufferStream = __webpack_require__(/*! ./BufferStream */ \"./node_modules/unzipper/lib/BufferStream.js\");\n\n// Backwards compatibility for node versions < 8\nif (!Stream.Writable || !Stream.Writable.prototype.destroy)\n  Stream = __webpack_require__(/*! readable-stream */ \"./node_modules/readable-stream/readable.js\");\n\nfunction parseOne(match,opts) {\n  var inStream = Stream.PassThrough({objectMode:true});\n  var outStream = Stream.PassThrough();\n  var transform = Stream.Transform({objectMode:true});\n  var re = match instanceof RegExp ? match : (match && new RegExp(match));\n  var found;\n\n  transform._transform = function(entry,e,cb) {\n    if (found || (re && !re.exec(entry.path))) {\n      entry.autodrain();\n      return cb();\n    } else {\n      found = true;\n      out.emit('entry',entry);\n      entry.on('error',function(e) {\n        outStream.emit('error',e);\n      });\n      entry.pipe(outStream)\n        .on('error',function(err) {\n          cb(err);\n        })\n        .on('finish',function(d) {\n          cb(null,d);\n        });\n    }\n  };\n\n  inStream.pipe(Parse(opts))\n    .on('error',function(err) {\n      outStream.emit('error',err);\n    })\n    .pipe(transform)\n    .on('error',Object)  // Silence error as its already addressed in transform\n    .on('finish',function() {\n      if (!found)\n        outStream.emit('error',new Error('PATTERN_NOT_FOUND'));\n      else\n        outStream.end();\n    });\n\n  var out = duplexer2(inStream,outStream);\n  out.buffer = function() {\n    return BufferStream(outStream);\n  };\n\n  return out;\n}\n\nmodule.exports = parseOne;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/unzipper/lib/parseOne.js?");

/***/ }),

/***/ "./node_modules/unzipper/unzip.js":
/*!****************************************!*\
  !*** ./node_modules/unzipper/unzip.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Polyfills for node 0.8\n__webpack_require__(/*! listenercount */ \"./node_modules/listenercount/index.js\");\n__webpack_require__(/*! buffer-indexof-polyfill */ \"./node_modules/buffer-indexof-polyfill/index.js\");\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n\n\nexports.Parse = __webpack_require__(/*! ./lib/parse */ \"./node_modules/unzipper/lib/parse.js\");\nexports.ParseOne = __webpack_require__(/*! ./lib/parseOne */ \"./node_modules/unzipper/lib/parseOne.js\");\nexports.Extract = __webpack_require__(/*! ./lib/extract */ \"./node_modules/unzipper/lib/extract.js\");\nexports.Open = __webpack_require__(/*! ./lib/Open */ \"./node_modules/unzipper/lib/Open/index.js\");\n\n//# sourceURL=webpack://coc.nvim/./node_modules/unzipper/unzip.js?");

/***/ }),

/***/ "./node_modules/util-deprecate/node.js":
/*!*********************************************!*\
  !*** ./node_modules/util-deprecate/node.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * For Node.js, simply re-export the core `util.deprecate` function.\n */\n\nmodule.exports = __webpack_require__(/*! util */ \"util\").deprecate;\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/util-deprecate/node.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-node/bytesToUuid.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-node/bytesToUuid.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\n  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bytesToUuid);\n\n//# sourceURL=webpack://coc.nvim/./node_modules/uuid/dist/esm-node/bytesToUuid.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-node/index.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-node/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"v1\": () => /* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__.default,\n/* harmony export */   \"v3\": () => /* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__.default,\n/* harmony export */   \"v4\": () => /* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__.default,\n/* harmony export */   \"v5\": () => /* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__.default\n/* harmony export */ });\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"./node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ \"./node_modules/uuid/dist/esm-node/v3.js\");\n/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ \"./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ \"./node_modules/uuid/dist/esm-node/v5.js\");\n\n\n\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/uuid/dist/esm-node/index.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-node/md5.js":
/*!************************************************!*\
  !*** ./node_modules/uuid/dist/esm-node/md5.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('md5').update(bytes).digest();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);\n\n//# sourceURL=webpack://coc.nvim/./node_modules/uuid/dist/esm-node/md5.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-node/rng.js":
/*!************************************************!*\
  !*** ./node_modules/uuid/dist/esm-node/rng.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ rng\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction rng() {\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default().randomBytes(16);\n}\n\n//# sourceURL=webpack://coc.nvim/./node_modules/uuid/dist/esm-node/rng.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-node/sha1.js":
/*!*************************************************!*\
  !*** ./node_modules/uuid/dist/esm-node/sha1.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha1').update(bytes).digest();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);\n\n//# sourceURL=webpack://coc.nvim/./node_modules/uuid/dist/esm-node/sha1.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-node/v1.js":
/*!***********************************************!*\
  !*** ./node_modules/uuid/dist/esm-node/v1.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _bytesToUuid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bytesToUuid.js */ \"./node_modules/uuid/dist/esm-node/bytesToUuid.js\");\n\n // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\n\nvar _clockseq; // Previous uuid creation time\n\n\nvar _lastMSecs = 0;\nvar _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    var seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__.default)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : (0,_bytesToUuid_js__WEBPACK_IMPORTED_MODULE_1__.default)(b);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);\n\n//# sourceURL=webpack://coc.nvim/./node_modules/uuid/dist/esm-node/v1.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-node/v3.js":
/*!***********************************************!*\
  !*** ./node_modules/uuid/dist/esm-node/v3.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"./node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"./node_modules/uuid/dist/esm-node/md5.js\");\n\n\nconst v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__.default)('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__.default);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);\n\n//# sourceURL=webpack://coc.nvim/./node_modules/uuid/dist/esm-node/v3.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-node/v35.js":
/*!************************************************!*\
  !*** ./node_modules/uuid/dist/esm-node/v35.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DNS\": () => /* binding */ DNS,\n/* harmony export */   \"URL\": () => /* binding */ URL,\n/* harmony export */   \"default\": () => /* export default binding */ __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _bytesToUuid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytesToUuid.js */ \"./node_modules/uuid/dist/esm-node/bytesToUuid.js\");\n\n\nfunction uuidToBytes(uuid) {\n  // Note: We assume we're being passed a valid uuid string\n  var bytes = [];\n  uuid.replace(/[a-fA-F0-9]{2}/g, function (hex) {\n    bytes.push(parseInt(hex, 16));\n  });\n  return bytes;\n}\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  var bytes = new Array(str.length);\n\n  for (var i = 0; i < str.length; i++) {\n    bytes[i] = str.charCodeAt(i);\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {\n  var generateUUID = function (value, namespace, buf, offset) {\n    var off = buf && offset || 0;\n    if (typeof value == 'string') value = stringToBytes(value);\n    if (typeof namespace == 'string') namespace = uuidToBytes(namespace);\n    if (!Array.isArray(value)) throw TypeError('value must be an array of bytes');\n    if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError('namespace must be uuid string or an Array of 16 byte values'); // Per 4.3\n\n    var bytes = hashfunc(namespace.concat(value));\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      for (var idx = 0; idx < 16; ++idx) {\n        buf[off + idx] = bytes[idx];\n      }\n    }\n\n    return buf || (0,_bytesToUuid_js__WEBPACK_IMPORTED_MODULE_0__.default)(bytes);\n  }; // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name;\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}\n\n//# sourceURL=webpack://coc.nvim/./node_modules/uuid/dist/esm-node/v35.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-node/v4.js":
/*!***********************************************!*\
  !*** ./node_modules/uuid/dist/esm-node/v4.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _bytesToUuid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bytesToUuid.js */ \"./node_modules/uuid/dist/esm-node/bytesToUuid.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof options == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n\n  options = options || {};\n  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || (0,_bytesToUuid_js__WEBPACK_IMPORTED_MODULE_1__.default)(rnds);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);\n\n//# sourceURL=webpack://coc.nvim/./node_modules/uuid/dist/esm-node/v4.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-node/v5.js":
/*!***********************************************!*\
  !*** ./node_modules/uuid/dist/esm-node/v5.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"./node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"./node_modules/uuid/dist/esm-node/sha1.js\");\n\n\nconst v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__.default)('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__.default);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);\n\n//# sourceURL=webpack://coc.nvim/./node_modules/uuid/dist/esm-node/v5.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/cancellation.js":
/*!*********************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/cancellation.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst events_1 = __webpack_require__(/*! ./events */ \"./node_modules/vscode-jsonrpc/lib/events.js\");\r\nconst Is = __webpack_require__(/*! ./is */ \"./node_modules/vscode-jsonrpc/lib/is.js\");\r\nvar CancellationToken;\r\n(function (CancellationToken) {\r\n    CancellationToken.None = Object.freeze({\r\n        isCancellationRequested: false,\r\n        onCancellationRequested: events_1.Event.None\r\n    });\r\n    CancellationToken.Cancelled = Object.freeze({\r\n        isCancellationRequested: true,\r\n        onCancellationRequested: events_1.Event.None\r\n    });\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && (candidate === CancellationToken.None\r\n            || candidate === CancellationToken.Cancelled\r\n            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));\r\n    }\r\n    CancellationToken.is = is;\r\n})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));\r\nconst shortcutEvent = Object.freeze(function (callback, context) {\r\n    let handle = setTimeout(callback.bind(context), 0);\r\n    return { dispose() { clearTimeout(handle); } };\r\n});\r\nclass MutableToken {\r\n    constructor() {\r\n        this._isCancelled = false;\r\n    }\r\n    cancel() {\r\n        if (!this._isCancelled) {\r\n            this._isCancelled = true;\r\n            if (this._emitter) {\r\n                this._emitter.fire(undefined);\r\n                this.dispose();\r\n            }\r\n        }\r\n    }\r\n    get isCancellationRequested() {\r\n        return this._isCancelled;\r\n    }\r\n    get onCancellationRequested() {\r\n        if (this._isCancelled) {\r\n            return shortcutEvent;\r\n        }\r\n        if (!this._emitter) {\r\n            this._emitter = new events_1.Emitter();\r\n        }\r\n        return this._emitter.event;\r\n    }\r\n    dispose() {\r\n        if (this._emitter) {\r\n            this._emitter.dispose();\r\n            this._emitter = undefined;\r\n        }\r\n    }\r\n}\r\nclass CancellationTokenSource {\r\n    get token() {\r\n        if (!this._token) {\r\n            // be lazy and create the token only when\r\n            // actually needed\r\n            this._token = new MutableToken();\r\n        }\r\n        return this._token;\r\n    }\r\n    cancel() {\r\n        if (!this._token) {\r\n            // save an object by returning the default\r\n            // cancelled token when cancellation happens\r\n            // before someone asks for the token\r\n            this._token = CancellationToken.Cancelled;\r\n        }\r\n        else {\r\n            this._token.cancel();\r\n        }\r\n    }\r\n    dispose() {\r\n        if (!this._token) {\r\n            // ensure to initialize with an empty token if we had none\r\n            this._token = CancellationToken.None;\r\n        }\r\n        else if (this._token instanceof MutableToken) {\r\n            // actually dispose\r\n            this._token.dispose();\r\n        }\r\n    }\r\n}\r\nexports.CancellationTokenSource = CancellationTokenSource;\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-jsonrpc/lib/cancellation.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/events.js":
/*!***************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/events.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar Disposable;\r\n(function (Disposable) {\r\n    function create(func) {\r\n        return {\r\n            dispose: func\r\n        };\r\n    }\r\n    Disposable.create = create;\r\n})(Disposable = exports.Disposable || (exports.Disposable = {}));\r\nvar Event;\r\n(function (Event) {\r\n    const _disposable = { dispose() { } };\r\n    Event.None = function () { return _disposable; };\r\n})(Event = exports.Event || (exports.Event = {}));\r\nclass CallbackList {\r\n    add(callback, context = null, bucket) {\r\n        if (!this._callbacks) {\r\n            this._callbacks = [];\r\n            this._contexts = [];\r\n        }\r\n        this._callbacks.push(callback);\r\n        this._contexts.push(context);\r\n        if (Array.isArray(bucket)) {\r\n            bucket.push({ dispose: () => this.remove(callback, context) });\r\n        }\r\n    }\r\n    remove(callback, context = null) {\r\n        if (!this._callbacks) {\r\n            return;\r\n        }\r\n        var foundCallbackWithDifferentContext = false;\r\n        for (var i = 0, len = this._callbacks.length; i < len; i++) {\r\n            if (this._callbacks[i] === callback) {\r\n                if (this._contexts[i] === context) {\r\n                    // callback & context match => remove it\r\n                    this._callbacks.splice(i, 1);\r\n                    this._contexts.splice(i, 1);\r\n                    return;\r\n                }\r\n                else {\r\n                    foundCallbackWithDifferentContext = true;\r\n                }\r\n            }\r\n        }\r\n        if (foundCallbackWithDifferentContext) {\r\n            throw new Error('When adding a listener with a context, you should remove it with the same context');\r\n        }\r\n    }\r\n    invoke(...args) {\r\n        if (!this._callbacks) {\r\n            return [];\r\n        }\r\n        var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);\r\n        for (var i = 0, len = callbacks.length; i < len; i++) {\r\n            try {\r\n                ret.push(callbacks[i].apply(contexts[i], args));\r\n            }\r\n            catch (e) {\r\n                // eslint-disable-next-line no-console\r\n                console.error(e);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    isEmpty() {\r\n        return !this._callbacks || this._callbacks.length === 0;\r\n    }\r\n    dispose() {\r\n        this._callbacks = undefined;\r\n        this._contexts = undefined;\r\n    }\r\n}\r\nclass Emitter {\r\n    constructor(_options) {\r\n        this._options = _options;\r\n    }\r\n    /**\r\n     * For the public to allow to subscribe\r\n     * to events from this Emitter\r\n     */\r\n    get event() {\r\n        if (!this._event) {\r\n            this._event = (listener, thisArgs, disposables) => {\r\n                if (!this._callbacks) {\r\n                    this._callbacks = new CallbackList();\r\n                }\r\n                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {\r\n                    this._options.onFirstListenerAdd(this);\r\n                }\r\n                this._callbacks.add(listener, thisArgs);\r\n                let result;\r\n                result = {\r\n                    dispose: () => {\r\n                        this._callbacks.remove(listener, thisArgs);\r\n                        result.dispose = Emitter._noop;\r\n                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {\r\n                            this._options.onLastListenerRemove(this);\r\n                        }\r\n                    }\r\n                };\r\n                if (Array.isArray(disposables)) {\r\n                    disposables.push(result);\r\n                }\r\n                return result;\r\n            };\r\n        }\r\n        return this._event;\r\n    }\r\n    /**\r\n     * To be kept private to fire an event to\r\n     * subscribers\r\n     */\r\n    fire(event) {\r\n        if (this._callbacks) {\r\n            this._callbacks.invoke.call(this._callbacks, event);\r\n        }\r\n    }\r\n    dispose() {\r\n        if (this._callbacks) {\r\n            this._callbacks.dispose();\r\n            this._callbacks = undefined;\r\n        }\r\n    }\r\n}\r\nexports.Emitter = Emitter;\r\nEmitter._noop = function () { };\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-jsonrpc/lib/events.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/is.js":
/*!***********************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/is.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nfunction boolean(value) {\r\n    return value === true || value === false;\r\n}\r\nexports.boolean = boolean;\r\nfunction string(value) {\r\n    return typeof value === 'string' || value instanceof String;\r\n}\r\nexports.string = string;\r\nfunction number(value) {\r\n    return typeof value === 'number' || value instanceof Number;\r\n}\r\nexports.number = number;\r\nfunction error(value) {\r\n    return value instanceof Error;\r\n}\r\nexports.error = error;\r\nfunction func(value) {\r\n    return typeof value === 'function';\r\n}\r\nexports.func = func;\r\nfunction array(value) {\r\n    return Array.isArray(value);\r\n}\r\nexports.array = array;\r\nfunction stringArray(value) {\r\n    return array(value) && value.every(elem => string(elem));\r\n}\r\nexports.stringArray = stringArray;\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-jsonrpc/lib/is.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/linkedMap.js":
/*!******************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/linkedMap.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar Touch;\r\n(function (Touch) {\r\n    Touch.None = 0;\r\n    Touch.First = 1;\r\n    Touch.Last = 2;\r\n})(Touch = exports.Touch || (exports.Touch = {}));\r\nclass LinkedMap {\r\n    constructor() {\r\n        this._map = new Map();\r\n        this._head = undefined;\r\n        this._tail = undefined;\r\n        this._size = 0;\r\n    }\r\n    clear() {\r\n        this._map.clear();\r\n        this._head = undefined;\r\n        this._tail = undefined;\r\n        this._size = 0;\r\n    }\r\n    isEmpty() {\r\n        return !this._head && !this._tail;\r\n    }\r\n    get size() {\r\n        return this._size;\r\n    }\r\n    has(key) {\r\n        return this._map.has(key);\r\n    }\r\n    get(key) {\r\n        const item = this._map.get(key);\r\n        if (!item) {\r\n            return undefined;\r\n        }\r\n        return item.value;\r\n    }\r\n    set(key, value, touch = Touch.None) {\r\n        let item = this._map.get(key);\r\n        if (item) {\r\n            item.value = value;\r\n            if (touch !== Touch.None) {\r\n                this.touch(item, touch);\r\n            }\r\n        }\r\n        else {\r\n            item = { key, value, next: undefined, previous: undefined };\r\n            switch (touch) {\r\n                case Touch.None:\r\n                    this.addItemLast(item);\r\n                    break;\r\n                case Touch.First:\r\n                    this.addItemFirst(item);\r\n                    break;\r\n                case Touch.Last:\r\n                    this.addItemLast(item);\r\n                    break;\r\n                default:\r\n                    this.addItemLast(item);\r\n                    break;\r\n            }\r\n            this._map.set(key, item);\r\n            this._size++;\r\n        }\r\n    }\r\n    delete(key) {\r\n        const item = this._map.get(key);\r\n        if (!item) {\r\n            return false;\r\n        }\r\n        this._map.delete(key);\r\n        this.removeItem(item);\r\n        this._size--;\r\n        return true;\r\n    }\r\n    shift() {\r\n        if (!this._head && !this._tail) {\r\n            return undefined;\r\n        }\r\n        if (!this._head || !this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        const item = this._head;\r\n        this._map.delete(item.key);\r\n        this.removeItem(item);\r\n        this._size--;\r\n        return item.value;\r\n    }\r\n    forEach(callbackfn, thisArg) {\r\n        let current = this._head;\r\n        while (current) {\r\n            if (thisArg) {\r\n                callbackfn.bind(thisArg)(current.value, current.key, this);\r\n            }\r\n            else {\r\n                callbackfn(current.value, current.key, this);\r\n            }\r\n            current = current.next;\r\n        }\r\n    }\r\n    forEachReverse(callbackfn, thisArg) {\r\n        let current = this._tail;\r\n        while (current) {\r\n            if (thisArg) {\r\n                callbackfn.bind(thisArg)(current.value, current.key, this);\r\n            }\r\n            else {\r\n                callbackfn(current.value, current.key, this);\r\n            }\r\n            current = current.previous;\r\n        }\r\n    }\r\n    values() {\r\n        let result = [];\r\n        let current = this._head;\r\n        while (current) {\r\n            result.push(current.value);\r\n            current = current.next;\r\n        }\r\n        return result;\r\n    }\r\n    keys() {\r\n        let result = [];\r\n        let current = this._head;\r\n        while (current) {\r\n            result.push(current.key);\r\n            current = current.next;\r\n        }\r\n        return result;\r\n    }\r\n    /* JSON RPC run on es5 which has no Symbol.iterator\r\n    public keys(): IterableIterator<K> {\r\n        let current = this._head;\r\n        let iterator: IterableIterator<K> = {\r\n            [Symbol.iterator]() {\r\n                return iterator;\r\n            },\r\n            next():IteratorResult<K> {\r\n                if (current) {\r\n                    let result = { value: current.key, done: false };\r\n                    current = current.next;\r\n                    return result;\r\n                } else {\r\n                    return { value: undefined, done: true };\r\n                }\r\n            }\r\n        };\r\n        return iterator;\r\n    }\r\n\r\n    public values(): IterableIterator<V> {\r\n        let current = this._head;\r\n        let iterator: IterableIterator<V> = {\r\n            [Symbol.iterator]() {\r\n                return iterator;\r\n            },\r\n            next():IteratorResult<V> {\r\n                if (current) {\r\n                    let result = { value: current.value, done: false };\r\n                    current = current.next;\r\n                    return result;\r\n                } else {\r\n                    return { value: undefined, done: true };\r\n                }\r\n            }\r\n        };\r\n        return iterator;\r\n    }\r\n    */\r\n    addItemFirst(item) {\r\n        // First time Insert\r\n        if (!this._head && !this._tail) {\r\n            this._tail = item;\r\n        }\r\n        else if (!this._head) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        else {\r\n            item.next = this._head;\r\n            this._head.previous = item;\r\n        }\r\n        this._head = item;\r\n    }\r\n    addItemLast(item) {\r\n        // First time Insert\r\n        if (!this._head && !this._tail) {\r\n            this._head = item;\r\n        }\r\n        else if (!this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        else {\r\n            item.previous = this._tail;\r\n            this._tail.next = item;\r\n        }\r\n        this._tail = item;\r\n    }\r\n    removeItem(item) {\r\n        if (item === this._head && item === this._tail) {\r\n            this._head = undefined;\r\n            this._tail = undefined;\r\n        }\r\n        else if (item === this._head) {\r\n            this._head = item.next;\r\n        }\r\n        else if (item === this._tail) {\r\n            this._tail = item.previous;\r\n        }\r\n        else {\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            if (!next || !previous) {\r\n                throw new Error('Invalid list');\r\n            }\r\n            next.previous = previous;\r\n            previous.next = next;\r\n        }\r\n    }\r\n    touch(item, touch) {\r\n        if (!this._head || !this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        if ((touch !== Touch.First && touch !== Touch.Last)) {\r\n            return;\r\n        }\r\n        if (touch === Touch.First) {\r\n            if (item === this._head) {\r\n                return;\r\n            }\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            // Unlink the item\r\n            if (item === this._tail) {\r\n                // previous must be defined since item was not head but is tail\r\n                // So there are more than on item in the map\r\n                previous.next = undefined;\r\n                this._tail = previous;\r\n            }\r\n            else {\r\n                // Both next and previous are not undefined since item was neither head nor tail.\r\n                next.previous = previous;\r\n                previous.next = next;\r\n            }\r\n            // Insert the node at head\r\n            item.previous = undefined;\r\n            item.next = this._head;\r\n            this._head.previous = item;\r\n            this._head = item;\r\n        }\r\n        else if (touch === Touch.Last) {\r\n            if (item === this._tail) {\r\n                return;\r\n            }\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            // Unlink the item.\r\n            if (item === this._head) {\r\n                // next must be defined since item was not tail but is head\r\n                // So there are more than on item in the map\r\n                next.previous = undefined;\r\n                this._head = next;\r\n            }\r\n            else {\r\n                // Both next and previous are not undefined since item was neither head nor tail.\r\n                next.previous = previous;\r\n                previous.next = next;\r\n            }\r\n            item.next = undefined;\r\n            item.previous = this._tail;\r\n            this._tail.next = item;\r\n            this._tail = item;\r\n        }\r\n    }\r\n}\r\nexports.LinkedMap = LinkedMap;\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-jsonrpc/lib/linkedMap.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/main.js":
/*!*************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/main.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n/// <reference path=\"../typings/thenable.d.ts\" />\r\n\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst Is = __webpack_require__(/*! ./is */ \"./node_modules/vscode-jsonrpc/lib/is.js\");\r\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-jsonrpc/lib/messages.js\");\r\nexports.RequestType = messages_1.RequestType;\r\nexports.RequestType0 = messages_1.RequestType0;\r\nexports.RequestType1 = messages_1.RequestType1;\r\nexports.RequestType2 = messages_1.RequestType2;\r\nexports.RequestType3 = messages_1.RequestType3;\r\nexports.RequestType4 = messages_1.RequestType4;\r\nexports.RequestType5 = messages_1.RequestType5;\r\nexports.RequestType6 = messages_1.RequestType6;\r\nexports.RequestType7 = messages_1.RequestType7;\r\nexports.RequestType8 = messages_1.RequestType8;\r\nexports.RequestType9 = messages_1.RequestType9;\r\nexports.ResponseError = messages_1.ResponseError;\r\nexports.ErrorCodes = messages_1.ErrorCodes;\r\nexports.NotificationType = messages_1.NotificationType;\r\nexports.NotificationType0 = messages_1.NotificationType0;\r\nexports.NotificationType1 = messages_1.NotificationType1;\r\nexports.NotificationType2 = messages_1.NotificationType2;\r\nexports.NotificationType3 = messages_1.NotificationType3;\r\nexports.NotificationType4 = messages_1.NotificationType4;\r\nexports.NotificationType5 = messages_1.NotificationType5;\r\nexports.NotificationType6 = messages_1.NotificationType6;\r\nexports.NotificationType7 = messages_1.NotificationType7;\r\nexports.NotificationType8 = messages_1.NotificationType8;\r\nexports.NotificationType9 = messages_1.NotificationType9;\r\nconst messageReader_1 = __webpack_require__(/*! ./messageReader */ \"./node_modules/vscode-jsonrpc/lib/messageReader.js\");\r\nexports.MessageReader = messageReader_1.MessageReader;\r\nexports.StreamMessageReader = messageReader_1.StreamMessageReader;\r\nexports.IPCMessageReader = messageReader_1.IPCMessageReader;\r\nexports.SocketMessageReader = messageReader_1.SocketMessageReader;\r\nconst messageWriter_1 = __webpack_require__(/*! ./messageWriter */ \"./node_modules/vscode-jsonrpc/lib/messageWriter.js\");\r\nexports.MessageWriter = messageWriter_1.MessageWriter;\r\nexports.StreamMessageWriter = messageWriter_1.StreamMessageWriter;\r\nexports.IPCMessageWriter = messageWriter_1.IPCMessageWriter;\r\nexports.SocketMessageWriter = messageWriter_1.SocketMessageWriter;\r\nconst events_1 = __webpack_require__(/*! ./events */ \"./node_modules/vscode-jsonrpc/lib/events.js\");\r\nexports.Disposable = events_1.Disposable;\r\nexports.Event = events_1.Event;\r\nexports.Emitter = events_1.Emitter;\r\nconst cancellation_1 = __webpack_require__(/*! ./cancellation */ \"./node_modules/vscode-jsonrpc/lib/cancellation.js\");\r\nexports.CancellationTokenSource = cancellation_1.CancellationTokenSource;\r\nexports.CancellationToken = cancellation_1.CancellationToken;\r\nconst linkedMap_1 = __webpack_require__(/*! ./linkedMap */ \"./node_modules/vscode-jsonrpc/lib/linkedMap.js\");\r\n__export(__webpack_require__(/*! ./pipeSupport */ \"./node_modules/vscode-jsonrpc/lib/pipeSupport.js\"));\r\n__export(__webpack_require__(/*! ./socketSupport */ \"./node_modules/vscode-jsonrpc/lib/socketSupport.js\"));\r\nvar CancelNotification;\r\n(function (CancelNotification) {\r\n    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');\r\n})(CancelNotification || (CancelNotification = {}));\r\nvar ProgressNotification;\r\n(function (ProgressNotification) {\r\n    ProgressNotification.type = new messages_1.NotificationType('$/progress');\r\n})(ProgressNotification || (ProgressNotification = {}));\r\nclass ProgressType {\r\n    constructor() {\r\n    }\r\n}\r\nexports.ProgressType = ProgressType;\r\nexports.NullLogger = Object.freeze({\r\n    error: () => { },\r\n    warn: () => { },\r\n    info: () => { },\r\n    log: () => { }\r\n});\r\nvar Trace;\r\n(function (Trace) {\r\n    Trace[Trace[\"Off\"] = 0] = \"Off\";\r\n    Trace[Trace[\"Messages\"] = 1] = \"Messages\";\r\n    Trace[Trace[\"Verbose\"] = 2] = \"Verbose\";\r\n})(Trace = exports.Trace || (exports.Trace = {}));\r\n(function (Trace) {\r\n    function fromString(value) {\r\n        if (!Is.string(value)) {\r\n            return Trace.Off;\r\n        }\r\n        value = value.toLowerCase();\r\n        switch (value) {\r\n            case 'off':\r\n                return Trace.Off;\r\n            case 'messages':\r\n                return Trace.Messages;\r\n            case 'verbose':\r\n                return Trace.Verbose;\r\n            default:\r\n                return Trace.Off;\r\n        }\r\n    }\r\n    Trace.fromString = fromString;\r\n    function toString(value) {\r\n        switch (value) {\r\n            case Trace.Off:\r\n                return 'off';\r\n            case Trace.Messages:\r\n                return 'messages';\r\n            case Trace.Verbose:\r\n                return 'verbose';\r\n            default:\r\n                return 'off';\r\n        }\r\n    }\r\n    Trace.toString = toString;\r\n})(Trace = exports.Trace || (exports.Trace = {}));\r\nvar TraceFormat;\r\n(function (TraceFormat) {\r\n    TraceFormat[\"Text\"] = \"text\";\r\n    TraceFormat[\"JSON\"] = \"json\";\r\n})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));\r\n(function (TraceFormat) {\r\n    function fromString(value) {\r\n        value = value.toLowerCase();\r\n        if (value === 'json') {\r\n            return TraceFormat.JSON;\r\n        }\r\n        else {\r\n            return TraceFormat.Text;\r\n        }\r\n    }\r\n    TraceFormat.fromString = fromString;\r\n})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));\r\nvar SetTraceNotification;\r\n(function (SetTraceNotification) {\r\n    SetTraceNotification.type = new messages_1.NotificationType('$/setTraceNotification');\r\n})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));\r\nvar LogTraceNotification;\r\n(function (LogTraceNotification) {\r\n    LogTraceNotification.type = new messages_1.NotificationType('$/logTraceNotification');\r\n})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));\r\nvar ConnectionErrors;\r\n(function (ConnectionErrors) {\r\n    /**\r\n     * The connection is closed.\r\n     */\r\n    ConnectionErrors[ConnectionErrors[\"Closed\"] = 1] = \"Closed\";\r\n    /**\r\n     * The connection got disposed.\r\n     */\r\n    ConnectionErrors[ConnectionErrors[\"Disposed\"] = 2] = \"Disposed\";\r\n    /**\r\n     * The connection is already in listening mode.\r\n     */\r\n    ConnectionErrors[ConnectionErrors[\"AlreadyListening\"] = 3] = \"AlreadyListening\";\r\n})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));\r\nclass ConnectionError extends Error {\r\n    constructor(code, message) {\r\n        super(message);\r\n        this.code = code;\r\n        Object.setPrototypeOf(this, ConnectionError.prototype);\r\n    }\r\n}\r\nexports.ConnectionError = ConnectionError;\r\nvar ConnectionStrategy;\r\n(function (ConnectionStrategy) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && Is.func(candidate.cancelUndispatched);\r\n    }\r\n    ConnectionStrategy.is = is;\r\n})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));\r\nvar ConnectionState;\r\n(function (ConnectionState) {\r\n    ConnectionState[ConnectionState[\"New\"] = 1] = \"New\";\r\n    ConnectionState[ConnectionState[\"Listening\"] = 2] = \"Listening\";\r\n    ConnectionState[ConnectionState[\"Closed\"] = 3] = \"Closed\";\r\n    ConnectionState[ConnectionState[\"Disposed\"] = 4] = \"Disposed\";\r\n})(ConnectionState || (ConnectionState = {}));\r\nfunction _createMessageConnection(messageReader, messageWriter, logger, strategy) {\r\n    let sequenceNumber = 0;\r\n    let notificationSquenceNumber = 0;\r\n    let unknownResponseSquenceNumber = 0;\r\n    const version = '2.0';\r\n    let starRequestHandler = undefined;\r\n    let requestHandlers = Object.create(null);\r\n    let starNotificationHandler = undefined;\r\n    let notificationHandlers = Object.create(null);\r\n    let progressHandlers = new Map();\r\n    let timer;\r\n    let messageQueue = new linkedMap_1.LinkedMap();\r\n    let responsePromises = Object.create(null);\r\n    let requestTokens = Object.create(null);\r\n    let trace = Trace.Off;\r\n    let traceFormat = TraceFormat.Text;\r\n    let tracer;\r\n    let state = ConnectionState.New;\r\n    let errorEmitter = new events_1.Emitter();\r\n    let closeEmitter = new events_1.Emitter();\r\n    let unhandledNotificationEmitter = new events_1.Emitter();\r\n    let unhandledProgressEmitter = new events_1.Emitter();\r\n    let disposeEmitter = new events_1.Emitter();\r\n    function createRequestQueueKey(id) {\r\n        return 'req-' + id.toString();\r\n    }\r\n    function createResponseQueueKey(id) {\r\n        if (id === null) {\r\n            return 'res-unknown-' + (++unknownResponseSquenceNumber).toString();\r\n        }\r\n        else {\r\n            return 'res-' + id.toString();\r\n        }\r\n    }\r\n    function createNotificationQueueKey() {\r\n        return 'not-' + (++notificationSquenceNumber).toString();\r\n    }\r\n    function addMessageToQueue(queue, message) {\r\n        if (messages_1.isRequestMessage(message)) {\r\n            queue.set(createRequestQueueKey(message.id), message);\r\n        }\r\n        else if (messages_1.isResponseMessage(message)) {\r\n            queue.set(createResponseQueueKey(message.id), message);\r\n        }\r\n        else {\r\n            queue.set(createNotificationQueueKey(), message);\r\n        }\r\n    }\r\n    function cancelUndispatched(_message) {\r\n        return undefined;\r\n    }\r\n    function isListening() {\r\n        return state === ConnectionState.Listening;\r\n    }\r\n    function isClosed() {\r\n        return state === ConnectionState.Closed;\r\n    }\r\n    function isDisposed() {\r\n        return state === ConnectionState.Disposed;\r\n    }\r\n    function closeHandler() {\r\n        if (state === ConnectionState.New || state === ConnectionState.Listening) {\r\n            state = ConnectionState.Closed;\r\n            closeEmitter.fire(undefined);\r\n        }\r\n        // If the connection is disposed don't sent close events.\r\n    }\r\n    function readErrorHandler(error) {\r\n        errorEmitter.fire([error, undefined, undefined]);\r\n    }\r\n    function writeErrorHandler(data) {\r\n        errorEmitter.fire(data);\r\n    }\r\n    messageReader.onClose(closeHandler);\r\n    messageReader.onError(readErrorHandler);\r\n    messageWriter.onClose(closeHandler);\r\n    messageWriter.onError(writeErrorHandler);\r\n    function triggerMessageQueue() {\r\n        if (timer || messageQueue.size === 0) {\r\n            return;\r\n        }\r\n        timer = setImmediate(() => {\r\n            timer = undefined;\r\n            processMessageQueue();\r\n        });\r\n    }\r\n    function processMessageQueue() {\r\n        if (messageQueue.size === 0) {\r\n            return;\r\n        }\r\n        let message = messageQueue.shift();\r\n        try {\r\n            if (messages_1.isRequestMessage(message)) {\r\n                handleRequest(message);\r\n            }\r\n            else if (messages_1.isNotificationMessage(message)) {\r\n                handleNotification(message);\r\n            }\r\n            else if (messages_1.isResponseMessage(message)) {\r\n                handleResponse(message);\r\n            }\r\n            else {\r\n                handleInvalidMessage(message);\r\n            }\r\n        }\r\n        finally {\r\n            triggerMessageQueue();\r\n        }\r\n    }\r\n    let callback = (message) => {\r\n        try {\r\n            // We have received a cancellation message. Check if the message is still in the queue\r\n            // and cancel it if allowed to do so.\r\n            if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {\r\n                let key = createRequestQueueKey(message.params.id);\r\n                let toCancel = messageQueue.get(key);\r\n                if (messages_1.isRequestMessage(toCancel)) {\r\n                    let response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);\r\n                    if (response && (response.error !== void 0 || response.result !== void 0)) {\r\n                        messageQueue.delete(key);\r\n                        response.id = toCancel.id;\r\n                        traceSendingResponse(response, message.method, Date.now());\r\n                        messageWriter.write(response);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            addMessageToQueue(messageQueue, message);\r\n        }\r\n        finally {\r\n            triggerMessageQueue();\r\n        }\r\n    };\r\n    function handleRequest(requestMessage) {\r\n        if (isDisposed()) {\r\n            // we return here silently since we fired an event when the\r\n            // connection got disposed.\r\n            return;\r\n        }\r\n        function reply(resultOrError, method, startTime) {\r\n            let message = {\r\n                jsonrpc: version,\r\n                id: requestMessage.id\r\n            };\r\n            if (resultOrError instanceof messages_1.ResponseError) {\r\n                message.error = resultOrError.toJson();\r\n            }\r\n            else {\r\n                message.result = resultOrError === void 0 ? null : resultOrError;\r\n            }\r\n            traceSendingResponse(message, method, startTime);\r\n            messageWriter.write(message);\r\n        }\r\n        function replyError(error, method, startTime) {\r\n            let message = {\r\n                jsonrpc: version,\r\n                id: requestMessage.id,\r\n                error: error.toJson()\r\n            };\r\n            traceSendingResponse(message, method, startTime);\r\n            messageWriter.write(message);\r\n        }\r\n        function replySuccess(result, method, startTime) {\r\n            // The JSON RPC defines that a response must either have a result or an error\r\n            // So we can't treat undefined as a valid response result.\r\n            if (result === void 0) {\r\n                result = null;\r\n            }\r\n            let message = {\r\n                jsonrpc: version,\r\n                id: requestMessage.id,\r\n                result: result\r\n            };\r\n            traceSendingResponse(message, method, startTime);\r\n            messageWriter.write(message);\r\n        }\r\n        traceReceivedRequest(requestMessage);\r\n        let element = requestHandlers[requestMessage.method];\r\n        let type;\r\n        let requestHandler;\r\n        if (element) {\r\n            type = element.type;\r\n            requestHandler = element.handler;\r\n        }\r\n        let startTime = Date.now();\r\n        if (requestHandler || starRequestHandler) {\r\n            let cancellationSource = new cancellation_1.CancellationTokenSource();\r\n            let tokenKey = String(requestMessage.id);\r\n            requestTokens[tokenKey] = cancellationSource;\r\n            try {\r\n                let handlerResult;\r\n                if (requestMessage.params === void 0 || (type !== void 0 && type.numberOfParams === 0)) {\r\n                    handlerResult = requestHandler\r\n                        ? requestHandler(cancellationSource.token)\r\n                        : starRequestHandler(requestMessage.method, cancellationSource.token);\r\n                }\r\n                else if (Is.array(requestMessage.params) && (type === void 0 || type.numberOfParams > 1)) {\r\n                    handlerResult = requestHandler\r\n                        ? requestHandler(...requestMessage.params, cancellationSource.token)\r\n                        : starRequestHandler(requestMessage.method, ...requestMessage.params, cancellationSource.token);\r\n                }\r\n                else {\r\n                    handlerResult = requestHandler\r\n                        ? requestHandler(requestMessage.params, cancellationSource.token)\r\n                        : starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);\r\n                }\r\n                let promise = handlerResult;\r\n                if (!handlerResult) {\r\n                    delete requestTokens[tokenKey];\r\n                    replySuccess(handlerResult, requestMessage.method, startTime);\r\n                }\r\n                else if (promise.then) {\r\n                    promise.then((resultOrError) => {\r\n                        delete requestTokens[tokenKey];\r\n                        reply(resultOrError, requestMessage.method, startTime);\r\n                    }, error => {\r\n                        delete requestTokens[tokenKey];\r\n                        if (error instanceof messages_1.ResponseError) {\r\n                            replyError(error, requestMessage.method, startTime);\r\n                        }\r\n                        else if (error && Is.string(error.message)) {\r\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\r\n                        }\r\n                        else {\r\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    delete requestTokens[tokenKey];\r\n                    reply(handlerResult, requestMessage.method, startTime);\r\n                }\r\n            }\r\n            catch (error) {\r\n                delete requestTokens[tokenKey];\r\n                if (error instanceof messages_1.ResponseError) {\r\n                    reply(error, requestMessage.method, startTime);\r\n                }\r\n                else if (error && Is.string(error.message)) {\r\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\r\n                }\r\n                else {\r\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);\r\n        }\r\n    }\r\n    function handleResponse(responseMessage) {\r\n        if (isDisposed()) {\r\n            // See handle request.\r\n            return;\r\n        }\r\n        if (responseMessage.id === null) {\r\n            if (responseMessage.error) {\r\n                logger.error(`Received response message without id: Error is: \\n${JSON.stringify(responseMessage.error, undefined, 4)}`);\r\n            }\r\n            else {\r\n                logger.error(`Received response message without id. No further error information provided.`);\r\n            }\r\n        }\r\n        else {\r\n            let key = String(responseMessage.id);\r\n            let responsePromise = responsePromises[key];\r\n            traceReceivedResponse(responseMessage, responsePromise);\r\n            if (responsePromise) {\r\n                delete responsePromises[key];\r\n                try {\r\n                    if (responseMessage.error) {\r\n                        let error = responseMessage.error;\r\n                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));\r\n                    }\r\n                    else if (responseMessage.result !== void 0) {\r\n                        responsePromise.resolve(responseMessage.result);\r\n                    }\r\n                    else {\r\n                        throw new Error('Should never happen.');\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    if (error.message) {\r\n                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);\r\n                    }\r\n                    else {\r\n                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function handleNotification(message) {\r\n        if (isDisposed()) {\r\n            // See handle request.\r\n            return;\r\n        }\r\n        let type = undefined;\r\n        let notificationHandler;\r\n        if (message.method === CancelNotification.type.method) {\r\n            notificationHandler = (params) => {\r\n                let id = params.id;\r\n                let source = requestTokens[String(id)];\r\n                if (source) {\r\n                    source.cancel();\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            let element = notificationHandlers[message.method];\r\n            if (element) {\r\n                notificationHandler = element.handler;\r\n                type = element.type;\r\n            }\r\n        }\r\n        if (notificationHandler || starNotificationHandler) {\r\n            try {\r\n                traceReceivedNotification(message);\r\n                if (message.params === void 0 || (type !== void 0 && type.numberOfParams === 0)) {\r\n                    notificationHandler ? notificationHandler() : starNotificationHandler(message.method);\r\n                }\r\n                else if (Is.array(message.params) && (type === void 0 || type.numberOfParams > 1)) {\r\n                    notificationHandler ? notificationHandler(...message.params) : starNotificationHandler(message.method, ...message.params);\r\n                }\r\n                else {\r\n                    notificationHandler ? notificationHandler(message.params) : starNotificationHandler(message.method, message.params);\r\n                }\r\n            }\r\n            catch (error) {\r\n                if (error.message) {\r\n                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);\r\n                }\r\n                else {\r\n                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            unhandledNotificationEmitter.fire(message);\r\n        }\r\n    }\r\n    function handleInvalidMessage(message) {\r\n        if (!message) {\r\n            logger.error('Received empty message.');\r\n            return;\r\n        }\r\n        logger.error(`Received message which is neither a response nor a notification message:\\n${JSON.stringify(message, null, 4)}`);\r\n        // Test whether we find an id to reject the promise\r\n        let responseMessage = message;\r\n        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {\r\n            let key = String(responseMessage.id);\r\n            let responseHandler = responsePromises[key];\r\n            if (responseHandler) {\r\n                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));\r\n            }\r\n        }\r\n    }\r\n    function traceSendingRequest(message) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose && message.params) {\r\n                data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\r\n            }\r\n            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('send-request', message);\r\n        }\r\n    }\r\n    function traceSendingNotification(message) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose) {\r\n                if (message.params) {\r\n                    data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\r\n                }\r\n                else {\r\n                    data = 'No parameters provided.\\n\\n';\r\n                }\r\n            }\r\n            tracer.log(`Sending notification '${message.method}'.`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('send-notification', message);\r\n        }\r\n    }\r\n    function traceSendingResponse(message, method, startTime) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose) {\r\n                if (message.error && message.error.data) {\r\n                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\\n\\n`;\r\n                }\r\n                else {\r\n                    if (message.result) {\r\n                        data = `Result: ${JSON.stringify(message.result, null, 4)}\\n\\n`;\r\n                    }\r\n                    else if (message.error === void 0) {\r\n                        data = 'No result returned.\\n\\n';\r\n                    }\r\n                }\r\n            }\r\n            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('send-response', message);\r\n        }\r\n    }\r\n    function traceReceivedRequest(message) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose && message.params) {\r\n                data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\r\n            }\r\n            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('receive-request', message);\r\n        }\r\n    }\r\n    function traceReceivedNotification(message) {\r\n        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose) {\r\n                if (message.params) {\r\n                    data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\r\n                }\r\n                else {\r\n                    data = 'No parameters provided.\\n\\n';\r\n                }\r\n            }\r\n            tracer.log(`Received notification '${message.method}'.`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('receive-notification', message);\r\n        }\r\n    }\r\n    function traceReceivedResponse(message, responsePromise) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose) {\r\n                if (message.error && message.error.data) {\r\n                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\\n\\n`;\r\n                }\r\n                else {\r\n                    if (message.result) {\r\n                        data = `Result: ${JSON.stringify(message.result, null, 4)}\\n\\n`;\r\n                    }\r\n                    else if (message.error === void 0) {\r\n                        data = 'No result returned.\\n\\n';\r\n                    }\r\n                }\r\n            }\r\n            if (responsePromise) {\r\n                let error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';\r\n                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);\r\n            }\r\n            else {\r\n                tracer.log(`Received response ${message.id} without active response promise.`, data);\r\n            }\r\n        }\r\n        else {\r\n            logLSPMessage('receive-response', message);\r\n        }\r\n    }\r\n    function logLSPMessage(type, message) {\r\n        if (!tracer || trace === Trace.Off) {\r\n            return;\r\n        }\r\n        const lspMessage = {\r\n            isLSPMessage: true,\r\n            type,\r\n            message,\r\n            timestamp: Date.now()\r\n        };\r\n        tracer.log(lspMessage);\r\n    }\r\n    function throwIfClosedOrDisposed() {\r\n        if (isClosed()) {\r\n            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');\r\n        }\r\n        if (isDisposed()) {\r\n            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');\r\n        }\r\n    }\r\n    function throwIfListening() {\r\n        if (isListening()) {\r\n            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');\r\n        }\r\n    }\r\n    function throwIfNotListening() {\r\n        if (!isListening()) {\r\n            throw new Error('Call listen() first.');\r\n        }\r\n    }\r\n    function undefinedToNull(param) {\r\n        if (param === void 0) {\r\n            return null;\r\n        }\r\n        else {\r\n            return param;\r\n        }\r\n    }\r\n    function computeMessageParams(type, params) {\r\n        let result;\r\n        let numberOfParams = type.numberOfParams;\r\n        switch (numberOfParams) {\r\n            case 0:\r\n                result = null;\r\n                break;\r\n            case 1:\r\n                result = undefinedToNull(params[0]);\r\n                break;\r\n            default:\r\n                result = [];\r\n                for (let i = 0; i < params.length && i < numberOfParams; i++) {\r\n                    result.push(undefinedToNull(params[i]));\r\n                }\r\n                if (params.length < numberOfParams) {\r\n                    for (let i = params.length; i < numberOfParams; i++) {\r\n                        result.push(null);\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n        return result;\r\n    }\r\n    let connection = {\r\n        sendNotification: (type, ...params) => {\r\n            throwIfClosedOrDisposed();\r\n            let method;\r\n            let messageParams;\r\n            if (Is.string(type)) {\r\n                method = type;\r\n                switch (params.length) {\r\n                    case 0:\r\n                        messageParams = null;\r\n                        break;\r\n                    case 1:\r\n                        messageParams = params[0];\r\n                        break;\r\n                    default:\r\n                        messageParams = params;\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                method = type.method;\r\n                messageParams = computeMessageParams(type, params);\r\n            }\r\n            let notificationMessage = {\r\n                jsonrpc: version,\r\n                method: method,\r\n                params: messageParams\r\n            };\r\n            traceSendingNotification(notificationMessage);\r\n            messageWriter.write(notificationMessage);\r\n        },\r\n        onNotification: (type, handler) => {\r\n            throwIfClosedOrDisposed();\r\n            if (Is.func(type)) {\r\n                starNotificationHandler = type;\r\n            }\r\n            else if (handler) {\r\n                if (Is.string(type)) {\r\n                    notificationHandlers[type] = { type: undefined, handler };\r\n                }\r\n                else {\r\n                    notificationHandlers[type.method] = { type, handler };\r\n                }\r\n            }\r\n        },\r\n        onProgress: (_type, token, handler) => {\r\n            if (progressHandlers.has(token)) {\r\n                throw new Error(`Progress handler for token ${token} already registered`);\r\n            }\r\n            progressHandlers.set(token, handler);\r\n            return {\r\n                dispose: () => {\r\n                    progressHandlers.delete(token);\r\n                }\r\n            };\r\n        },\r\n        sendProgress: (_type, token, value) => {\r\n            connection.sendNotification(ProgressNotification.type, { token, value });\r\n        },\r\n        onUnhandledProgress: unhandledProgressEmitter.event,\r\n        sendRequest: (type, ...params) => {\r\n            throwIfClosedOrDisposed();\r\n            throwIfNotListening();\r\n            let method;\r\n            let messageParams;\r\n            let token = undefined;\r\n            if (Is.string(type)) {\r\n                method = type;\r\n                switch (params.length) {\r\n                    case 0:\r\n                        messageParams = null;\r\n                        break;\r\n                    case 1:\r\n                        // The cancellation token is optional so it can also be undefined.\r\n                        if (cancellation_1.CancellationToken.is(params[0])) {\r\n                            messageParams = null;\r\n                            token = params[0];\r\n                        }\r\n                        else {\r\n                            messageParams = undefinedToNull(params[0]);\r\n                        }\r\n                        break;\r\n                    default:\r\n                        const last = params.length - 1;\r\n                        if (cancellation_1.CancellationToken.is(params[last])) {\r\n                            token = params[last];\r\n                            if (params.length === 2) {\r\n                                messageParams = undefinedToNull(params[0]);\r\n                            }\r\n                            else {\r\n                                messageParams = params.slice(0, last).map(value => undefinedToNull(value));\r\n                            }\r\n                        }\r\n                        else {\r\n                            messageParams = params.map(value => undefinedToNull(value));\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                method = type.method;\r\n                messageParams = computeMessageParams(type, params);\r\n                let numberOfParams = type.numberOfParams;\r\n                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;\r\n            }\r\n            let id = sequenceNumber++;\r\n            let result = new Promise((resolve, reject) => {\r\n                let requestMessage = {\r\n                    jsonrpc: version,\r\n                    id: id,\r\n                    method: method,\r\n                    params: messageParams\r\n                };\r\n                let responsePromise = { method: method, timerStart: Date.now(), resolve, reject };\r\n                traceSendingRequest(requestMessage);\r\n                try {\r\n                    messageWriter.write(requestMessage);\r\n                }\r\n                catch (e) {\r\n                    // Writing the message failed. So we need to reject the promise.\r\n                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));\r\n                    responsePromise = null;\r\n                }\r\n                if (responsePromise) {\r\n                    responsePromises[String(id)] = responsePromise;\r\n                }\r\n            });\r\n            if (token) {\r\n                token.onCancellationRequested(() => {\r\n                    connection.sendNotification(CancelNotification.type, { id });\r\n                });\r\n            }\r\n            return result;\r\n        },\r\n        onRequest: (type, handler) => {\r\n            throwIfClosedOrDisposed();\r\n            if (Is.func(type)) {\r\n                starRequestHandler = type;\r\n            }\r\n            else if (handler) {\r\n                if (Is.string(type)) {\r\n                    requestHandlers[type] = { type: undefined, handler };\r\n                }\r\n                else {\r\n                    requestHandlers[type.method] = { type, handler };\r\n                }\r\n            }\r\n        },\r\n        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {\r\n            let _sendNotification = false;\r\n            let _traceFormat = TraceFormat.Text;\r\n            if (sendNotificationOrTraceOptions !== void 0) {\r\n                if (Is.boolean(sendNotificationOrTraceOptions)) {\r\n                    _sendNotification = sendNotificationOrTraceOptions;\r\n                }\r\n                else {\r\n                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;\r\n                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;\r\n                }\r\n            }\r\n            trace = _value;\r\n            traceFormat = _traceFormat;\r\n            if (trace === Trace.Off) {\r\n                tracer = undefined;\r\n            }\r\n            else {\r\n                tracer = _tracer;\r\n            }\r\n            if (_sendNotification && !isClosed() && !isDisposed()) {\r\n                connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });\r\n            }\r\n        },\r\n        onError: errorEmitter.event,\r\n        onClose: closeEmitter.event,\r\n        onUnhandledNotification: unhandledNotificationEmitter.event,\r\n        onDispose: disposeEmitter.event,\r\n        dispose: () => {\r\n            if (isDisposed()) {\r\n                return;\r\n            }\r\n            state = ConnectionState.Disposed;\r\n            disposeEmitter.fire(undefined);\r\n            let error = new Error('Connection got disposed.');\r\n            Object.keys(responsePromises).forEach((key) => {\r\n                responsePromises[key].reject(error);\r\n            });\r\n            responsePromises = Object.create(null);\r\n            requestTokens = Object.create(null);\r\n            messageQueue = new linkedMap_1.LinkedMap();\r\n            // Test for backwards compatibility\r\n            if (Is.func(messageWriter.dispose)) {\r\n                messageWriter.dispose();\r\n            }\r\n            if (Is.func(messageReader.dispose)) {\r\n                messageReader.dispose();\r\n            }\r\n        },\r\n        listen: () => {\r\n            throwIfClosedOrDisposed();\r\n            throwIfListening();\r\n            state = ConnectionState.Listening;\r\n            messageReader.listen(callback);\r\n        },\r\n        inspect: () => {\r\n            // eslint-disable-next-line no-console\r\n            console.log('inspect');\r\n        }\r\n    };\r\n    connection.onNotification(LogTraceNotification.type, (params) => {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);\r\n    });\r\n    connection.onNotification(ProgressNotification.type, (params) => {\r\n        const handler = progressHandlers.get(params.token);\r\n        if (handler) {\r\n            handler(params.value);\r\n        }\r\n        else {\r\n            unhandledProgressEmitter.fire(params);\r\n        }\r\n    });\r\n    return connection;\r\n}\r\nfunction isMessageReader(value) {\r\n    return value.listen !== void 0 && value.read === void 0;\r\n}\r\nfunction isMessageWriter(value) {\r\n    return value.write !== void 0 && value.end === void 0;\r\n}\r\nfunction createMessageConnection(input, output, logger, strategy) {\r\n    if (!logger) {\r\n        logger = exports.NullLogger;\r\n    }\r\n    let reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);\r\n    let writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);\r\n    return _createMessageConnection(reader, writer, logger, strategy);\r\n}\r\nexports.createMessageConnection = createMessageConnection;\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-jsonrpc/lib/main.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/messageReader.js":
/*!**********************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/messageReader.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst events_1 = __webpack_require__(/*! ./events */ \"./node_modules/vscode-jsonrpc/lib/events.js\");\r\nconst Is = __webpack_require__(/*! ./is */ \"./node_modules/vscode-jsonrpc/lib/is.js\");\r\nlet DefaultSize = 8192;\r\nlet CR = Buffer.from('\\r', 'ascii')[0];\r\nlet LF = Buffer.from('\\n', 'ascii')[0];\r\nlet CRLF = '\\r\\n';\r\nclass MessageBuffer {\r\n    constructor(encoding = 'utf8') {\r\n        this.encoding = encoding;\r\n        this.index = 0;\r\n        this.buffer = Buffer.allocUnsafe(DefaultSize);\r\n    }\r\n    append(chunk) {\r\n        var toAppend = chunk;\r\n        if (typeof (chunk) === 'string') {\r\n            var str = chunk;\r\n            var bufferLen = Buffer.byteLength(str, this.encoding);\r\n            toAppend = Buffer.allocUnsafe(bufferLen);\r\n            toAppend.write(str, 0, bufferLen, this.encoding);\r\n        }\r\n        if (this.buffer.length - this.index >= toAppend.length) {\r\n            toAppend.copy(this.buffer, this.index, 0, toAppend.length);\r\n        }\r\n        else {\r\n            var newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;\r\n            if (this.index === 0) {\r\n                this.buffer = Buffer.allocUnsafe(newSize);\r\n                toAppend.copy(this.buffer, 0, 0, toAppend.length);\r\n            }\r\n            else {\r\n                this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);\r\n            }\r\n        }\r\n        this.index += toAppend.length;\r\n    }\r\n    tryReadHeaders() {\r\n        let result = undefined;\r\n        let current = 0;\r\n        while (current + 3 < this.index && (this.buffer[current] !== CR || this.buffer[current + 1] !== LF || this.buffer[current + 2] !== CR || this.buffer[current + 3] !== LF)) {\r\n            current++;\r\n        }\r\n        // No header / body separator found (e.g CRLFCRLF)\r\n        if (current + 3 >= this.index) {\r\n            return result;\r\n        }\r\n        result = Object.create(null);\r\n        let headers = this.buffer.toString('ascii', 0, current).split(CRLF);\r\n        headers.forEach((header) => {\r\n            let index = header.indexOf(':');\r\n            if (index === -1) {\r\n                throw new Error('Message header must separate key and value using :');\r\n            }\r\n            let key = header.substr(0, index);\r\n            let value = header.substr(index + 1).trim();\r\n            result[key] = value;\r\n        });\r\n        let nextStart = current + 4;\r\n        this.buffer = this.buffer.slice(nextStart);\r\n        this.index = this.index - nextStart;\r\n        return result;\r\n    }\r\n    tryReadContent(length) {\r\n        if (this.index < length) {\r\n            return null;\r\n        }\r\n        let result = this.buffer.toString(this.encoding, 0, length);\r\n        let nextStart = length;\r\n        this.buffer.copy(this.buffer, 0, nextStart);\r\n        this.index = this.index - nextStart;\r\n        return result;\r\n    }\r\n    get numberOfBytes() {\r\n        return this.index;\r\n    }\r\n}\r\nvar MessageReader;\r\n(function (MessageReader) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&\r\n            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);\r\n    }\r\n    MessageReader.is = is;\r\n})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));\r\nclass AbstractMessageReader {\r\n    constructor() {\r\n        this.errorEmitter = new events_1.Emitter();\r\n        this.closeEmitter = new events_1.Emitter();\r\n        this.partialMessageEmitter = new events_1.Emitter();\r\n    }\r\n    dispose() {\r\n        this.errorEmitter.dispose();\r\n        this.closeEmitter.dispose();\r\n    }\r\n    get onError() {\r\n        return this.errorEmitter.event;\r\n    }\r\n    fireError(error) {\r\n        this.errorEmitter.fire(this.asError(error));\r\n    }\r\n    get onClose() {\r\n        return this.closeEmitter.event;\r\n    }\r\n    fireClose() {\r\n        this.closeEmitter.fire(undefined);\r\n    }\r\n    get onPartialMessage() {\r\n        return this.partialMessageEmitter.event;\r\n    }\r\n    firePartialMessage(info) {\r\n        this.partialMessageEmitter.fire(info);\r\n    }\r\n    asError(error) {\r\n        if (error instanceof Error) {\r\n            return error;\r\n        }\r\n        else {\r\n            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\r\n        }\r\n    }\r\n}\r\nexports.AbstractMessageReader = AbstractMessageReader;\r\nclass StreamMessageReader extends AbstractMessageReader {\r\n    constructor(readable, encoding = 'utf8') {\r\n        super();\r\n        this.readable = readable;\r\n        this.buffer = new MessageBuffer(encoding);\r\n        this._partialMessageTimeout = 10000;\r\n    }\r\n    set partialMessageTimeout(timeout) {\r\n        this._partialMessageTimeout = timeout;\r\n    }\r\n    get partialMessageTimeout() {\r\n        return this._partialMessageTimeout;\r\n    }\r\n    listen(callback) {\r\n        this.nextMessageLength = -1;\r\n        this.messageToken = 0;\r\n        this.partialMessageTimer = undefined;\r\n        this.callback = callback;\r\n        this.readable.on('data', (data) => {\r\n            this.onData(data);\r\n        });\r\n        this.readable.on('error', (error) => this.fireError(error));\r\n        this.readable.on('close', () => this.fireClose());\r\n    }\r\n    onData(data) {\r\n        this.buffer.append(data);\r\n        while (true) {\r\n            if (this.nextMessageLength === -1) {\r\n                let headers = this.buffer.tryReadHeaders();\r\n                if (!headers) {\r\n                    return;\r\n                }\r\n                let contentLength = headers['Content-Length'];\r\n                if (!contentLength) {\r\n                    throw new Error('Header must provide a Content-Length property.');\r\n                }\r\n                let length = parseInt(contentLength);\r\n                if (isNaN(length)) {\r\n                    throw new Error('Content-Length value must be a number.');\r\n                }\r\n                this.nextMessageLength = length;\r\n                // Take the encoding form the header. For compatibility\r\n                // treat both utf-8 and utf8 as node utf8\r\n            }\r\n            var msg = this.buffer.tryReadContent(this.nextMessageLength);\r\n            if (msg === null) {\r\n                /** We haven't received the full message yet. */\r\n                this.setPartialMessageTimer();\r\n                return;\r\n            }\r\n            this.clearPartialMessageTimer();\r\n            this.nextMessageLength = -1;\r\n            this.messageToken++;\r\n            var json = JSON.parse(msg);\r\n            this.callback(json);\r\n        }\r\n    }\r\n    clearPartialMessageTimer() {\r\n        if (this.partialMessageTimer) {\r\n            clearTimeout(this.partialMessageTimer);\r\n            this.partialMessageTimer = undefined;\r\n        }\r\n    }\r\n    setPartialMessageTimer() {\r\n        this.clearPartialMessageTimer();\r\n        if (this._partialMessageTimeout <= 0) {\r\n            return;\r\n        }\r\n        this.partialMessageTimer = setTimeout((token, timeout) => {\r\n            this.partialMessageTimer = undefined;\r\n            if (token === this.messageToken) {\r\n                this.firePartialMessage({ messageToken: token, waitingTime: timeout });\r\n                this.setPartialMessageTimer();\r\n            }\r\n        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);\r\n    }\r\n}\r\nexports.StreamMessageReader = StreamMessageReader;\r\nclass IPCMessageReader extends AbstractMessageReader {\r\n    constructor(process) {\r\n        super();\r\n        this.process = process;\r\n        let eventEmitter = this.process;\r\n        eventEmitter.on('error', (error) => this.fireError(error));\r\n        eventEmitter.on('close', () => this.fireClose());\r\n    }\r\n    listen(callback) {\r\n        this.process.on('message', callback);\r\n    }\r\n}\r\nexports.IPCMessageReader = IPCMessageReader;\r\nclass SocketMessageReader extends StreamMessageReader {\r\n    constructor(socket, encoding = 'utf-8') {\r\n        super(socket, encoding);\r\n    }\r\n}\r\nexports.SocketMessageReader = SocketMessageReader;\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-jsonrpc/lib/messageReader.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/messageWriter.js":
/*!**********************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/messageWriter.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst events_1 = __webpack_require__(/*! ./events */ \"./node_modules/vscode-jsonrpc/lib/events.js\");\r\nconst Is = __webpack_require__(/*! ./is */ \"./node_modules/vscode-jsonrpc/lib/is.js\");\r\nlet ContentLength = 'Content-Length: ';\r\nlet CRLF = '\\r\\n';\r\nvar MessageWriter;\r\n(function (MessageWriter) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&\r\n            Is.func(candidate.onError) && Is.func(candidate.write);\r\n    }\r\n    MessageWriter.is = is;\r\n})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));\r\nclass AbstractMessageWriter {\r\n    constructor() {\r\n        this.errorEmitter = new events_1.Emitter();\r\n        this.closeEmitter = new events_1.Emitter();\r\n    }\r\n    dispose() {\r\n        this.errorEmitter.dispose();\r\n        this.closeEmitter.dispose();\r\n    }\r\n    get onError() {\r\n        return this.errorEmitter.event;\r\n    }\r\n    fireError(error, message, count) {\r\n        this.errorEmitter.fire([this.asError(error), message, count]);\r\n    }\r\n    get onClose() {\r\n        return this.closeEmitter.event;\r\n    }\r\n    fireClose() {\r\n        this.closeEmitter.fire(undefined);\r\n    }\r\n    asError(error) {\r\n        if (error instanceof Error) {\r\n            return error;\r\n        }\r\n        else {\r\n            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\r\n        }\r\n    }\r\n}\r\nexports.AbstractMessageWriter = AbstractMessageWriter;\r\nclass StreamMessageWriter extends AbstractMessageWriter {\r\n    constructor(writable, encoding = 'utf8') {\r\n        super();\r\n        this.writable = writable;\r\n        this.encoding = encoding;\r\n        this.errorCount = 0;\r\n        this.writable.on('error', (error) => this.fireError(error));\r\n        this.writable.on('close', () => this.fireClose());\r\n    }\r\n    write(msg) {\r\n        let json = JSON.stringify(msg);\r\n        let contentLength = Buffer.byteLength(json, this.encoding);\r\n        let headers = [\r\n            ContentLength, contentLength.toString(), CRLF,\r\n            CRLF\r\n        ];\r\n        try {\r\n            // Header must be written in ASCII encoding\r\n            this.writable.write(headers.join(''), 'ascii');\r\n            // Now write the content. This can be written in any encoding\r\n            this.writable.write(json, this.encoding);\r\n            this.errorCount = 0;\r\n        }\r\n        catch (error) {\r\n            this.errorCount++;\r\n            this.fireError(error, msg, this.errorCount);\r\n        }\r\n    }\r\n}\r\nexports.StreamMessageWriter = StreamMessageWriter;\r\nclass IPCMessageWriter extends AbstractMessageWriter {\r\n    constructor(process) {\r\n        super();\r\n        this.process = process;\r\n        this.errorCount = 0;\r\n        this.queue = [];\r\n        this.sending = false;\r\n        let eventEmitter = this.process;\r\n        eventEmitter.on('error', (error) => this.fireError(error));\r\n        eventEmitter.on('close', () => this.fireClose);\r\n    }\r\n    write(msg) {\r\n        if (!this.sending && this.queue.length === 0) {\r\n            // See https://github.com/nodejs/node/issues/7657\r\n            this.doWriteMessage(msg);\r\n        }\r\n        else {\r\n            this.queue.push(msg);\r\n        }\r\n    }\r\n    doWriteMessage(msg) {\r\n        try {\r\n            if (this.process.send) {\r\n                this.sending = true;\r\n                this.process.send(msg, undefined, undefined, (error) => {\r\n                    this.sending = false;\r\n                    if (error) {\r\n                        this.errorCount++;\r\n                        this.fireError(error, msg, this.errorCount);\r\n                    }\r\n                    else {\r\n                        this.errorCount = 0;\r\n                    }\r\n                    if (this.queue.length > 0) {\r\n                        this.doWriteMessage(this.queue.shift());\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        catch (error) {\r\n            this.errorCount++;\r\n            this.fireError(error, msg, this.errorCount);\r\n        }\r\n    }\r\n}\r\nexports.IPCMessageWriter = IPCMessageWriter;\r\nclass SocketMessageWriter extends AbstractMessageWriter {\r\n    constructor(socket, encoding = 'utf8') {\r\n        super();\r\n        this.socket = socket;\r\n        this.queue = [];\r\n        this.sending = false;\r\n        this.encoding = encoding;\r\n        this.errorCount = 0;\r\n        this.socket.on('error', (error) => this.fireError(error));\r\n        this.socket.on('close', () => this.fireClose());\r\n    }\r\n    dispose() {\r\n        super.dispose();\r\n        this.socket.destroy();\r\n    }\r\n    write(msg) {\r\n        if (!this.sending && this.queue.length === 0) {\r\n            // See https://github.com/nodejs/node/issues/7657\r\n            this.doWriteMessage(msg);\r\n        }\r\n        else {\r\n            this.queue.push(msg);\r\n        }\r\n    }\r\n    doWriteMessage(msg) {\r\n        let json = JSON.stringify(msg);\r\n        let contentLength = Buffer.byteLength(json, this.encoding);\r\n        let headers = [\r\n            ContentLength, contentLength.toString(), CRLF,\r\n            CRLF\r\n        ];\r\n        try {\r\n            // Header must be written in ASCII encoding\r\n            this.sending = true;\r\n            this.socket.write(headers.join(''), 'ascii', (error) => {\r\n                if (error) {\r\n                    this.handleError(error, msg);\r\n                }\r\n                try {\r\n                    // Now write the content. This can be written in any encoding\r\n                    this.socket.write(json, this.encoding, (error) => {\r\n                        this.sending = false;\r\n                        if (error) {\r\n                            this.handleError(error, msg);\r\n                        }\r\n                        else {\r\n                            this.errorCount = 0;\r\n                        }\r\n                        if (this.queue.length > 0) {\r\n                            this.doWriteMessage(this.queue.shift());\r\n                        }\r\n                    });\r\n                }\r\n                catch (error) {\r\n                    this.handleError(error, msg);\r\n                }\r\n            });\r\n        }\r\n        catch (error) {\r\n            this.handleError(error, msg);\r\n        }\r\n    }\r\n    handleError(error, msg) {\r\n        this.errorCount++;\r\n        this.fireError(error, msg, this.errorCount);\r\n    }\r\n}\r\nexports.SocketMessageWriter = SocketMessageWriter;\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-jsonrpc/lib/messageWriter.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/messages.js":
/*!*****************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/messages.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst is = __webpack_require__(/*! ./is */ \"./node_modules/vscode-jsonrpc/lib/is.js\");\r\n/**\r\n * Predefined error codes.\r\n */\r\nvar ErrorCodes;\r\n(function (ErrorCodes) {\r\n    // Defined by JSON RPC\r\n    ErrorCodes.ParseError = -32700;\r\n    ErrorCodes.InvalidRequest = -32600;\r\n    ErrorCodes.MethodNotFound = -32601;\r\n    ErrorCodes.InvalidParams = -32602;\r\n    ErrorCodes.InternalError = -32603;\r\n    ErrorCodes.serverErrorStart = -32099;\r\n    ErrorCodes.serverErrorEnd = -32000;\r\n    ErrorCodes.ServerNotInitialized = -32002;\r\n    ErrorCodes.UnknownErrorCode = -32001;\r\n    // Defined by the protocol.\r\n    ErrorCodes.RequestCancelled = -32800;\r\n    ErrorCodes.ContentModified = -32801;\r\n    // Defined by VSCode library.\r\n    ErrorCodes.MessageWriteError = 1;\r\n    ErrorCodes.MessageReadError = 2;\r\n})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));\r\n/**\r\n * An error object return in a response in case a request\r\n * has failed.\r\n */\r\nclass ResponseError extends Error {\r\n    constructor(code, message, data) {\r\n        super(message);\r\n        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;\r\n        this.data = data;\r\n        Object.setPrototypeOf(this, ResponseError.prototype);\r\n    }\r\n    toJson() {\r\n        return {\r\n            code: this.code,\r\n            message: this.message,\r\n            data: this.data,\r\n        };\r\n    }\r\n}\r\nexports.ResponseError = ResponseError;\r\n/**\r\n * An abstract implementation of a MessageType.\r\n */\r\nclass AbstractMessageType {\r\n    constructor(_method, _numberOfParams) {\r\n        this._method = _method;\r\n        this._numberOfParams = _numberOfParams;\r\n    }\r\n    get method() {\r\n        return this._method;\r\n    }\r\n    get numberOfParams() {\r\n        return this._numberOfParams;\r\n    }\r\n}\r\nexports.AbstractMessageType = AbstractMessageType;\r\n/**\r\n * Classes to type request response pairs\r\n *\r\n * The type parameter RO will be removed in the next major version\r\n * of the JSON RPC library since it is a LSP concept and doesn't\r\n * belong here. For now it is tagged as default never.\r\n */\r\nclass RequestType0 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 0);\r\n    }\r\n}\r\nexports.RequestType0 = RequestType0;\r\nclass RequestType extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 1);\r\n    }\r\n}\r\nexports.RequestType = RequestType;\r\nclass RequestType1 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 1);\r\n    }\r\n}\r\nexports.RequestType1 = RequestType1;\r\nclass RequestType2 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 2);\r\n    }\r\n}\r\nexports.RequestType2 = RequestType2;\r\nclass RequestType3 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 3);\r\n    }\r\n}\r\nexports.RequestType3 = RequestType3;\r\nclass RequestType4 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 4);\r\n    }\r\n}\r\nexports.RequestType4 = RequestType4;\r\nclass RequestType5 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 5);\r\n    }\r\n}\r\nexports.RequestType5 = RequestType5;\r\nclass RequestType6 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 6);\r\n    }\r\n}\r\nexports.RequestType6 = RequestType6;\r\nclass RequestType7 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 7);\r\n    }\r\n}\r\nexports.RequestType7 = RequestType7;\r\nclass RequestType8 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 8);\r\n    }\r\n}\r\nexports.RequestType8 = RequestType8;\r\nclass RequestType9 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 9);\r\n    }\r\n}\r\nexports.RequestType9 = RequestType9;\r\n/**\r\n * The type parameter RO will be removed in the next major version\r\n * of the JSON RPC library since it is a LSP concept and doesn't\r\n * belong here. For now it is tagged as default never.\r\n */\r\nclass NotificationType extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 1);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType = NotificationType;\r\nclass NotificationType0 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 0);\r\n    }\r\n}\r\nexports.NotificationType0 = NotificationType0;\r\nclass NotificationType1 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 1);\r\n    }\r\n}\r\nexports.NotificationType1 = NotificationType1;\r\nclass NotificationType2 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 2);\r\n    }\r\n}\r\nexports.NotificationType2 = NotificationType2;\r\nclass NotificationType3 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 3);\r\n    }\r\n}\r\nexports.NotificationType3 = NotificationType3;\r\nclass NotificationType4 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 4);\r\n    }\r\n}\r\nexports.NotificationType4 = NotificationType4;\r\nclass NotificationType5 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 5);\r\n    }\r\n}\r\nexports.NotificationType5 = NotificationType5;\r\nclass NotificationType6 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 6);\r\n    }\r\n}\r\nexports.NotificationType6 = NotificationType6;\r\nclass NotificationType7 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 7);\r\n    }\r\n}\r\nexports.NotificationType7 = NotificationType7;\r\nclass NotificationType8 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 8);\r\n    }\r\n}\r\nexports.NotificationType8 = NotificationType8;\r\nclass NotificationType9 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 9);\r\n    }\r\n}\r\nexports.NotificationType9 = NotificationType9;\r\n/**\r\n * Tests if the given message is a request message\r\n */\r\nfunction isRequestMessage(message) {\r\n    let candidate = message;\r\n    return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));\r\n}\r\nexports.isRequestMessage = isRequestMessage;\r\n/**\r\n * Tests if the given message is a notification message\r\n */\r\nfunction isNotificationMessage(message) {\r\n    let candidate = message;\r\n    return candidate && is.string(candidate.method) && message.id === void 0;\r\n}\r\nexports.isNotificationMessage = isNotificationMessage;\r\n/**\r\n * Tests if the given message is a response message\r\n */\r\nfunction isResponseMessage(message) {\r\n    let candidate = message;\r\n    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);\r\n}\r\nexports.isResponseMessage = isResponseMessage;\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-jsonrpc/lib/messages.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/pipeSupport.js":
/*!********************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/pipeSupport.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst path_1 = __webpack_require__(/*! path */ \"path\");\r\nconst os_1 = __webpack_require__(/*! os */ \"os\");\r\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\r\nconst net_1 = __webpack_require__(/*! net */ \"net\");\r\nconst messageReader_1 = __webpack_require__(/*! ./messageReader */ \"./node_modules/vscode-jsonrpc/lib/messageReader.js\");\r\nconst messageWriter_1 = __webpack_require__(/*! ./messageWriter */ \"./node_modules/vscode-jsonrpc/lib/messageWriter.js\");\r\nfunction generateRandomPipeName() {\r\n    const randomSuffix = crypto_1.randomBytes(21).toString('hex');\r\n    if (process.platform === 'win32') {\r\n        return `\\\\\\\\.\\\\pipe\\\\vscode-jsonrpc-${randomSuffix}-sock`;\r\n    }\r\n    else {\r\n        // Mac/Unix: use socket file\r\n        return path_1.join(os_1.tmpdir(), `vscode-${randomSuffix}.sock`);\r\n    }\r\n}\r\nexports.generateRandomPipeName = generateRandomPipeName;\r\nfunction createClientPipeTransport(pipeName, encoding = 'utf-8') {\r\n    let connectResolve;\r\n    let connected = new Promise((resolve, _reject) => {\r\n        connectResolve = resolve;\r\n    });\r\n    return new Promise((resolve, reject) => {\r\n        let server = net_1.createServer((socket) => {\r\n            server.close();\r\n            connectResolve([\r\n                new messageReader_1.SocketMessageReader(socket, encoding),\r\n                new messageWriter_1.SocketMessageWriter(socket, encoding)\r\n            ]);\r\n        });\r\n        server.on('error', reject);\r\n        server.listen(pipeName, () => {\r\n            server.removeListener('error', reject);\r\n            resolve({\r\n                onConnected: () => { return connected; }\r\n            });\r\n        });\r\n    });\r\n}\r\nexports.createClientPipeTransport = createClientPipeTransport;\r\nfunction createServerPipeTransport(pipeName, encoding = 'utf-8') {\r\n    const socket = net_1.createConnection(pipeName);\r\n    return [\r\n        new messageReader_1.SocketMessageReader(socket, encoding),\r\n        new messageWriter_1.SocketMessageWriter(socket, encoding)\r\n    ];\r\n}\r\nexports.createServerPipeTransport = createServerPipeTransport;\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-jsonrpc/lib/pipeSupport.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/socketSupport.js":
/*!**********************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/socketSupport.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst net_1 = __webpack_require__(/*! net */ \"net\");\r\nconst messageReader_1 = __webpack_require__(/*! ./messageReader */ \"./node_modules/vscode-jsonrpc/lib/messageReader.js\");\r\nconst messageWriter_1 = __webpack_require__(/*! ./messageWriter */ \"./node_modules/vscode-jsonrpc/lib/messageWriter.js\");\r\nfunction createClientSocketTransport(port, encoding = 'utf-8') {\r\n    let connectResolve;\r\n    let connected = new Promise((resolve, _reject) => {\r\n        connectResolve = resolve;\r\n    });\r\n    return new Promise((resolve, reject) => {\r\n        let server = net_1.createServer((socket) => {\r\n            server.close();\r\n            connectResolve([\r\n                new messageReader_1.SocketMessageReader(socket, encoding),\r\n                new messageWriter_1.SocketMessageWriter(socket, encoding)\r\n            ]);\r\n        });\r\n        server.on('error', reject);\r\n        server.listen(port, '127.0.0.1', () => {\r\n            server.removeListener('error', reject);\r\n            resolve({\r\n                onConnected: () => { return connected; }\r\n            });\r\n        });\r\n    });\r\n}\r\nexports.createClientSocketTransport = createClientSocketTransport;\r\nfunction createServerSocketTransport(port, encoding = 'utf-8') {\r\n    const socket = net_1.createConnection(port, '127.0.0.1');\r\n    return [\r\n        new messageReader_1.SocketMessageReader(socket, encoding),\r\n        new messageWriter_1.SocketMessageWriter(socket, encoding)\r\n    ];\r\n}\r\nexports.createServerSocketTransport = createServerSocketTransport;\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-jsonrpc/lib/socketSupport.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/main.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/main.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/main.js\");\r\nexports.ErrorCodes = vscode_jsonrpc_1.ErrorCodes;\r\nexports.ResponseError = vscode_jsonrpc_1.ResponseError;\r\nexports.CancellationToken = vscode_jsonrpc_1.CancellationToken;\r\nexports.CancellationTokenSource = vscode_jsonrpc_1.CancellationTokenSource;\r\nexports.Disposable = vscode_jsonrpc_1.Disposable;\r\nexports.Event = vscode_jsonrpc_1.Event;\r\nexports.Emitter = vscode_jsonrpc_1.Emitter;\r\nexports.Trace = vscode_jsonrpc_1.Trace;\r\nexports.TraceFormat = vscode_jsonrpc_1.TraceFormat;\r\nexports.SetTraceNotification = vscode_jsonrpc_1.SetTraceNotification;\r\nexports.LogTraceNotification = vscode_jsonrpc_1.LogTraceNotification;\r\nexports.RequestType = vscode_jsonrpc_1.RequestType;\r\nexports.RequestType0 = vscode_jsonrpc_1.RequestType0;\r\nexports.NotificationType = vscode_jsonrpc_1.NotificationType;\r\nexports.NotificationType0 = vscode_jsonrpc_1.NotificationType0;\r\nexports.MessageReader = vscode_jsonrpc_1.MessageReader;\r\nexports.MessageWriter = vscode_jsonrpc_1.MessageWriter;\r\nexports.ConnectionStrategy = vscode_jsonrpc_1.ConnectionStrategy;\r\nexports.StreamMessageReader = vscode_jsonrpc_1.StreamMessageReader;\r\nexports.StreamMessageWriter = vscode_jsonrpc_1.StreamMessageWriter;\r\nexports.IPCMessageReader = vscode_jsonrpc_1.IPCMessageReader;\r\nexports.IPCMessageWriter = vscode_jsonrpc_1.IPCMessageWriter;\r\nexports.createClientPipeTransport = vscode_jsonrpc_1.createClientPipeTransport;\r\nexports.createServerPipeTransport = vscode_jsonrpc_1.createServerPipeTransport;\r\nexports.generateRandomPipeName = vscode_jsonrpc_1.generateRandomPipeName;\r\nexports.createClientSocketTransport = vscode_jsonrpc_1.createClientSocketTransport;\r\nexports.createServerSocketTransport = vscode_jsonrpc_1.createServerSocketTransport;\r\nexports.ProgressType = vscode_jsonrpc_1.ProgressType;\r\n__export(__webpack_require__(/*! vscode-languageserver-types */ \"./node_modules/vscode-languageserver-types/lib/esm/main.js\"));\r\n__export(__webpack_require__(/*! ./protocol */ \"./node_modules/vscode-languageserver-protocol/lib/protocol.js\"));\r\nconst callHierarchy = __webpack_require__(/*! ./protocol.callHierarchy.proposed */ \"./node_modules/vscode-languageserver-protocol/lib/protocol.callHierarchy.proposed.js\");\r\nconst st = __webpack_require__(/*! ./protocol.sematicTokens.proposed */ \"./node_modules/vscode-languageserver-protocol/lib/protocol.sematicTokens.proposed.js\");\r\nvar Proposed;\r\n(function (Proposed) {\r\n    let CallHierarchyPrepareRequest;\r\n    (function (CallHierarchyPrepareRequest) {\r\n        CallHierarchyPrepareRequest.method = callHierarchy.CallHierarchyPrepareRequest.method;\r\n        CallHierarchyPrepareRequest.type = callHierarchy.CallHierarchyPrepareRequest.type;\r\n    })(CallHierarchyPrepareRequest = Proposed.CallHierarchyPrepareRequest || (Proposed.CallHierarchyPrepareRequest = {}));\r\n    let CallHierarchyIncomingCallsRequest;\r\n    (function (CallHierarchyIncomingCallsRequest) {\r\n        CallHierarchyIncomingCallsRequest.method = callHierarchy.CallHierarchyIncomingCallsRequest.method;\r\n        CallHierarchyIncomingCallsRequest.type = callHierarchy.CallHierarchyIncomingCallsRequest.type;\r\n    })(CallHierarchyIncomingCallsRequest = Proposed.CallHierarchyIncomingCallsRequest || (Proposed.CallHierarchyIncomingCallsRequest = {}));\r\n    let CallHierarchyOutgoingCallsRequest;\r\n    (function (CallHierarchyOutgoingCallsRequest) {\r\n        CallHierarchyOutgoingCallsRequest.method = callHierarchy.CallHierarchyOutgoingCallsRequest.method;\r\n        CallHierarchyOutgoingCallsRequest.type = callHierarchy.CallHierarchyOutgoingCallsRequest.type;\r\n    })(CallHierarchyOutgoingCallsRequest = Proposed.CallHierarchyOutgoingCallsRequest || (Proposed.CallHierarchyOutgoingCallsRequest = {}));\r\n    Proposed.SemanticTokenTypes = st.SemanticTokenTypes;\r\n    Proposed.SemanticTokenModifiers = st.SemanticTokenModifiers;\r\n    Proposed.SemanticTokens = st.SemanticTokens;\r\n    let SemanticTokensRequest;\r\n    (function (SemanticTokensRequest) {\r\n        SemanticTokensRequest.method = st.SemanticTokensRequest.method;\r\n        SemanticTokensRequest.type = st.SemanticTokensRequest.type;\r\n    })(SemanticTokensRequest = Proposed.SemanticTokensRequest || (Proposed.SemanticTokensRequest = {}));\r\n    let SemanticTokensEditsRequest;\r\n    (function (SemanticTokensEditsRequest) {\r\n        SemanticTokensEditsRequest.method = st.SemanticTokensEditsRequest.method;\r\n        SemanticTokensEditsRequest.type = st.SemanticTokensEditsRequest.type;\r\n    })(SemanticTokensEditsRequest = Proposed.SemanticTokensEditsRequest || (Proposed.SemanticTokensEditsRequest = {}));\r\n    let SemanticTokensRangeRequest;\r\n    (function (SemanticTokensRangeRequest) {\r\n        SemanticTokensRangeRequest.method = st.SemanticTokensRangeRequest.method;\r\n        SemanticTokensRangeRequest.type = st.SemanticTokensRangeRequest.type;\r\n    })(SemanticTokensRangeRequest = Proposed.SemanticTokensRangeRequest || (Proposed.SemanticTokensRangeRequest = {}));\r\n})(Proposed = exports.Proposed || (exports.Proposed = {}));\r\nfunction createProtocolConnection(reader, writer, logger, strategy) {\r\n    return vscode_jsonrpc_1.createMessageConnection(reader, writer, logger, strategy);\r\n}\r\nexports.createProtocolConnection = createProtocolConnection;\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-languageserver-protocol/lib/main.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/messages.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/messages.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/main.js\");\r\nclass ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {\r\n    constructor(method) {\r\n        super(method);\r\n    }\r\n}\r\nexports.ProtocolRequestType0 = ProtocolRequestType0;\r\nclass ProtocolRequestType extends vscode_jsonrpc_1.RequestType {\r\n    constructor(method) {\r\n        super(method);\r\n    }\r\n}\r\nexports.ProtocolRequestType = ProtocolRequestType;\r\nclass ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {\r\n    constructor(method) {\r\n        super(method);\r\n    }\r\n}\r\nexports.ProtocolNotificationType = ProtocolNotificationType;\r\nclass ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {\r\n    constructor(method) {\r\n        super(method);\r\n    }\r\n}\r\nexports.ProtocolNotificationType0 = ProtocolNotificationType0;\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-languageserver-protocol/lib/messages.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/protocol.callHierarchy.proposed.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/protocol.callHierarchy.proposed.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) TypeFox and others. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/messages.js\");\r\n/**\r\n * A request to result a `CallHierarchyItem` in a document at a given position.\r\n * Can be used as an input to a incoming or outgoing call hierarchy.\r\n *\r\n * @since 3.16.0 - Proposed state\r\n */\r\nvar CallHierarchyPrepareRequest;\r\n(function (CallHierarchyPrepareRequest) {\r\n    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';\r\n    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);\r\n})(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));\r\n/**\r\n * A request to resolve the incoming calls for a given `CallHierarchyItem`.\r\n *\r\n * @since 3.16.0 - Proposed state\r\n */\r\nvar CallHierarchyIncomingCallsRequest;\r\n(function (CallHierarchyIncomingCallsRequest) {\r\n    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';\r\n    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);\r\n})(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));\r\n/**\r\n * A request to resolve the outgoing calls for a given `CallHierarchyItem`.\r\n *\r\n * @since 3.16.0 - Proposed state\r\n */\r\nvar CallHierarchyOutgoingCallsRequest;\r\n(function (CallHierarchyOutgoingCallsRequest) {\r\n    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';\r\n    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);\r\n})(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-languageserver-protocol/lib/protocol.callHierarchy.proposed.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/main.js\");\r\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/messages.js\");\r\n/**\r\n * A request to list all color symbols found in a given text document. The request's\r\n * parameter is of type [DocumentColorParams](#DocumentColorParams) the\r\n * response is of type [ColorInformation[]](#ColorInformation) or a Thenable\r\n * that resolves to such.\r\n */\r\nvar DocumentColorRequest;\r\n(function (DocumentColorRequest) {\r\n    DocumentColorRequest.method = 'textDocument/documentColor';\r\n    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);\r\n    /** @deprecated Use DocumentColorRequest.type */\r\n    DocumentColorRequest.resultType = new vscode_jsonrpc_1.ProgressType();\r\n})(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));\r\n/**\r\n * A request to list all presentation for a color. The request's\r\n * parameter is of type [ColorPresentationParams](#ColorPresentationParams) the\r\n * response is of type [ColorInformation[]](#ColorInformation) or a Thenable\r\n * that resolves to such.\r\n */\r\nvar ColorPresentationRequest;\r\n(function (ColorPresentationRequest) {\r\n    ColorPresentationRequest.type = new messages_1.ProtocolRequestType('textDocument/colorPresentation');\r\n})(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/protocol.configuration.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/protocol.configuration.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/messages.js\");\r\n/**\r\n * The 'workspace/configuration' request is sent from the server to the client to fetch a certain\r\n * configuration setting.\r\n *\r\n * This pull model replaces the old push model were the client signaled configuration change via an\r\n * event. If the server still needs to react to configuration changes (since the server caches the\r\n * result of `workspace/configuration` requests) the server should register for an empty configuration\r\n * change event and empty the cache if such an event is received.\r\n */\r\nvar ConfigurationRequest;\r\n(function (ConfigurationRequest) {\r\n    ConfigurationRequest.type = new messages_1.ProtocolRequestType('workspace/configuration');\r\n})(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-languageserver-protocol/lib/protocol.configuration.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/protocol.declaration.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/protocol.declaration.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/main.js\");\r\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/messages.js\");\r\n// @ts-ignore: to avoid inlining LocatioLink as dynamic import\r\nlet __noDynamicImport;\r\n/**\r\n * A request to resolve the type definition locations of a symbol at a given text\r\n * document position. The request's parameter is of type [TextDocumentPositioParams]\r\n * (#TextDocumentPositionParams) the response is of type [Declaration](#Declaration)\r\n * or a typed array of [DeclarationLink](#DeclarationLink) or a Thenable that resolves\r\n * to such.\r\n */\r\nvar DeclarationRequest;\r\n(function (DeclarationRequest) {\r\n    DeclarationRequest.method = 'textDocument/declaration';\r\n    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);\r\n    /** @deprecated Use DeclarationRequest.type */\r\n    DeclarationRequest.resultType = new vscode_jsonrpc_1.ProgressType();\r\n})(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-languageserver-protocol/lib/protocol.declaration.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/protocol.foldingRange.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/protocol.foldingRange.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/main.js\");\r\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/messages.js\");\r\n/**\r\n * Enum of known range kinds\r\n */\r\nvar FoldingRangeKind;\r\n(function (FoldingRangeKind) {\r\n    /**\r\n     * Folding range for a comment\r\n     */\r\n    FoldingRangeKind[\"Comment\"] = \"comment\";\r\n    /**\r\n     * Folding range for a imports or includes\r\n     */\r\n    FoldingRangeKind[\"Imports\"] = \"imports\";\r\n    /**\r\n     * Folding range for a region (e.g. `#region`)\r\n     */\r\n    FoldingRangeKind[\"Region\"] = \"region\";\r\n})(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));\r\n/**\r\n * A request to provide folding ranges in a document. The request's\r\n * parameter is of type [FoldingRangeParams](#FoldingRangeParams), the\r\n * response is of type [FoldingRangeList](#FoldingRangeList) or a Thenable\r\n * that resolves to such.\r\n */\r\nvar FoldingRangeRequest;\r\n(function (FoldingRangeRequest) {\r\n    FoldingRangeRequest.method = 'textDocument/foldingRange';\r\n    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);\r\n    /** @deprecated Use FoldingRangeRequest.type */\r\n    FoldingRangeRequest.resultType = new vscode_jsonrpc_1.ProgressType();\r\n})(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-languageserver-protocol/lib/protocol.foldingRange.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/protocol.implementation.js":
/*!************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/protocol.implementation.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/main.js\");\r\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/messages.js\");\r\n// @ts-ignore: to avoid inlining LocatioLink as dynamic import\r\nlet __noDynamicImport;\r\n/**\r\n * A request to resolve the implementation locations of a symbol at a given text\r\n * document position. The request's parameter is of type [TextDocumentPositioParams]\r\n * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a\r\n * Thenable that resolves to such.\r\n */\r\nvar ImplementationRequest;\r\n(function (ImplementationRequest) {\r\n    ImplementationRequest.method = 'textDocument/implementation';\r\n    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);\r\n    /** @deprecated Use ImplementationRequest.type */\r\n    ImplementationRequest.resultType = new vscode_jsonrpc_1.ProgressType();\r\n})(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-languageserver-protocol/lib/protocol.implementation.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/protocol.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/protocol.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst Is = __webpack_require__(/*! ./utils/is */ \"./node_modules/vscode-languageserver-protocol/lib/utils/is.js\");\r\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/main.js\");\r\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/messages.js\");\r\nconst protocol_implementation_1 = __webpack_require__(/*! ./protocol.implementation */ \"./node_modules/vscode-languageserver-protocol/lib/protocol.implementation.js\");\r\nexports.ImplementationRequest = protocol_implementation_1.ImplementationRequest;\r\nconst protocol_typeDefinition_1 = __webpack_require__(/*! ./protocol.typeDefinition */ \"./node_modules/vscode-languageserver-protocol/lib/protocol.typeDefinition.js\");\r\nexports.TypeDefinitionRequest = protocol_typeDefinition_1.TypeDefinitionRequest;\r\nconst protocol_workspaceFolders_1 = __webpack_require__(/*! ./protocol.workspaceFolders */ \"./node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.js\");\r\nexports.WorkspaceFoldersRequest = protocol_workspaceFolders_1.WorkspaceFoldersRequest;\r\nexports.DidChangeWorkspaceFoldersNotification = protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification;\r\nconst protocol_configuration_1 = __webpack_require__(/*! ./protocol.configuration */ \"./node_modules/vscode-languageserver-protocol/lib/protocol.configuration.js\");\r\nexports.ConfigurationRequest = protocol_configuration_1.ConfigurationRequest;\r\nconst protocol_colorProvider_1 = __webpack_require__(/*! ./protocol.colorProvider */ \"./node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.js\");\r\nexports.DocumentColorRequest = protocol_colorProvider_1.DocumentColorRequest;\r\nexports.ColorPresentationRequest = protocol_colorProvider_1.ColorPresentationRequest;\r\nconst protocol_foldingRange_1 = __webpack_require__(/*! ./protocol.foldingRange */ \"./node_modules/vscode-languageserver-protocol/lib/protocol.foldingRange.js\");\r\nexports.FoldingRangeRequest = protocol_foldingRange_1.FoldingRangeRequest;\r\nconst protocol_declaration_1 = __webpack_require__(/*! ./protocol.declaration */ \"./node_modules/vscode-languageserver-protocol/lib/protocol.declaration.js\");\r\nexports.DeclarationRequest = protocol_declaration_1.DeclarationRequest;\r\nconst protocol_selectionRange_1 = __webpack_require__(/*! ./protocol.selectionRange */ \"./node_modules/vscode-languageserver-protocol/lib/protocol.selectionRange.js\");\r\nexports.SelectionRangeRequest = protocol_selectionRange_1.SelectionRangeRequest;\r\nconst protocol_progress_1 = __webpack_require__(/*! ./protocol.progress */ \"./node_modules/vscode-languageserver-protocol/lib/protocol.progress.js\");\r\nexports.WorkDoneProgress = protocol_progress_1.WorkDoneProgress;\r\nexports.WorkDoneProgressCreateRequest = protocol_progress_1.WorkDoneProgressCreateRequest;\r\nexports.WorkDoneProgressCancelNotification = protocol_progress_1.WorkDoneProgressCancelNotification;\r\n// @ts-ignore: to avoid inlining LocatioLink as dynamic import\r\nlet __noDynamicImport;\r\n/**\r\n * The DocumentFilter namespace provides helper functions to work with\r\n * [DocumentFilter](#DocumentFilter) literals.\r\n */\r\nvar DocumentFilter;\r\n(function (DocumentFilter) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);\r\n    }\r\n    DocumentFilter.is = is;\r\n})(DocumentFilter = exports.DocumentFilter || (exports.DocumentFilter = {}));\r\n/**\r\n * The DocumentSelector namespace provides helper functions to work with\r\n * [DocumentSelector](#DocumentSelector)s.\r\n */\r\nvar DocumentSelector;\r\n(function (DocumentSelector) {\r\n    function is(value) {\r\n        if (!Array.isArray(value)) {\r\n            return false;\r\n        }\r\n        for (let elem of value) {\r\n            if (!Is.string(elem) && !DocumentFilter.is(elem)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    DocumentSelector.is = is;\r\n})(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));\r\n/**\r\n * The `client/registerCapability` request is sent from the server to the client to register a new capability\r\n * handler on the client side.\r\n */\r\nvar RegistrationRequest;\r\n(function (RegistrationRequest) {\r\n    RegistrationRequest.type = new messages_1.ProtocolRequestType('client/registerCapability');\r\n})(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));\r\n/**\r\n * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability\r\n * handler on the client side.\r\n */\r\nvar UnregistrationRequest;\r\n(function (UnregistrationRequest) {\r\n    UnregistrationRequest.type = new messages_1.ProtocolRequestType('client/unregisterCapability');\r\n})(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));\r\nvar ResourceOperationKind;\r\n(function (ResourceOperationKind) {\r\n    /**\r\n     * Supports creating new files and folders.\r\n     */\r\n    ResourceOperationKind.Create = 'create';\r\n    /**\r\n     * Supports renaming existing files and folders.\r\n     */\r\n    ResourceOperationKind.Rename = 'rename';\r\n    /**\r\n     * Supports deleting existing files and folders.\r\n     */\r\n    ResourceOperationKind.Delete = 'delete';\r\n})(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));\r\nvar FailureHandlingKind;\r\n(function (FailureHandlingKind) {\r\n    /**\r\n     * Applying the workspace change is simply aborted if one of the changes provided\r\n     * fails. All operations executed before the failing operation stay executed.\r\n     */\r\n    FailureHandlingKind.Abort = 'abort';\r\n    /**\r\n     * All operations are executed transactional. That means they either all\r\n     * succeed or no changes at all are applied to the workspace.\r\n     */\r\n    FailureHandlingKind.Transactional = 'transactional';\r\n    /**\r\n     * If the workspace edit contains only textual file changes they are executed transactional.\r\n     * If resource changes (create, rename or delete file) are part of the change the failure\r\n     * handling startegy is abort.\r\n     */\r\n    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';\r\n    /**\r\n     * The client tries to undo the operations already executed. But there is no\r\n     * guarantee that this is succeeding.\r\n     */\r\n    FailureHandlingKind.Undo = 'undo';\r\n})(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));\r\n/**\r\n * The StaticRegistrationOptions namespace provides helper functions to work with\r\n * [StaticRegistrationOptions](#StaticRegistrationOptions) literals.\r\n */\r\nvar StaticRegistrationOptions;\r\n(function (StaticRegistrationOptions) {\r\n    function hasId(value) {\r\n        const candidate = value;\r\n        return candidate && Is.string(candidate.id) && candidate.id.length > 0;\r\n    }\r\n    StaticRegistrationOptions.hasId = hasId;\r\n})(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));\r\n/**\r\n * The TextDocumentRegistrationOptions namespace provides helper functions to work with\r\n * [TextDocumentRegistrationOptions](#TextDocumentRegistrationOptions) literals.\r\n */\r\nvar TextDocumentRegistrationOptions;\r\n(function (TextDocumentRegistrationOptions) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));\r\n    }\r\n    TextDocumentRegistrationOptions.is = is;\r\n})(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));\r\n/**\r\n * The WorkDoneProgressOptions namespace provides helper functions to work with\r\n * [WorkDoneProgressOptions](#WorkDoneProgressOptions) literals.\r\n */\r\nvar WorkDoneProgressOptions;\r\n(function (WorkDoneProgressOptions) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));\r\n    }\r\n    WorkDoneProgressOptions.is = is;\r\n    function hasWorkDoneProgress(value) {\r\n        const candidate = value;\r\n        return candidate && Is.boolean(candidate.workDoneProgress);\r\n    }\r\n    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;\r\n})(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));\r\n/**\r\n * The initialize request is sent from the client to the server.\r\n * It is sent once as the request after starting up the server.\r\n * The requests parameter is of type [InitializeParams](#InitializeParams)\r\n * the response if of type [InitializeResult](#InitializeResult) of a Thenable that\r\n * resolves to such.\r\n */\r\nvar InitializeRequest;\r\n(function (InitializeRequest) {\r\n    InitializeRequest.type = new messages_1.ProtocolRequestType('initialize');\r\n})(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));\r\n/**\r\n * Known error codes for an `InitializeError`;\r\n */\r\nvar InitializeError;\r\n(function (InitializeError) {\r\n    /**\r\n     * If the protocol version provided by the client can't be handled by the server.\r\n     * @deprecated This initialize error got replaced by client capabilities. There is\r\n     * no version handshake in version 3.0x\r\n     */\r\n    InitializeError.unknownProtocolVersion = 1;\r\n})(InitializeError = exports.InitializeError || (exports.InitializeError = {}));\r\n/**\r\n * The intialized notification is sent from the client to the\r\n * server after the client is fully initialized and the server\r\n * is allowed to send requests from the server to the client.\r\n */\r\nvar InitializedNotification;\r\n(function (InitializedNotification) {\r\n    InitializedNotification.type = new messages_1.ProtocolNotificationType('initialized');\r\n})(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));\r\n//---- Shutdown Method ----\r\n/**\r\n * A shutdown request is sent from the client to the server.\r\n * It is sent once when the client decides to shutdown the\r\n * server. The only notification that is sent after a shutdown request\r\n * is the exit event.\r\n */\r\nvar ShutdownRequest;\r\n(function (ShutdownRequest) {\r\n    ShutdownRequest.type = new messages_1.ProtocolRequestType0('shutdown');\r\n})(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));\r\n//---- Exit Notification ----\r\n/**\r\n * The exit event is sent from the client to the server to\r\n * ask the server to exit its process.\r\n */\r\nvar ExitNotification;\r\n(function (ExitNotification) {\r\n    ExitNotification.type = new messages_1.ProtocolNotificationType0('exit');\r\n})(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));\r\n/**\r\n * The configuration change notification is sent from the client to the server\r\n * when the client's configuration has changed. The notification contains\r\n * the changed configuration as defined by the language client.\r\n */\r\nvar DidChangeConfigurationNotification;\r\n(function (DidChangeConfigurationNotification) {\r\n    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeConfiguration');\r\n})(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));\r\n//---- Message show and log notifications ----\r\n/**\r\n * The message type\r\n */\r\nvar MessageType;\r\n(function (MessageType) {\r\n    /**\r\n     * An error message.\r\n     */\r\n    MessageType.Error = 1;\r\n    /**\r\n     * A warning message.\r\n     */\r\n    MessageType.Warning = 2;\r\n    /**\r\n     * An information message.\r\n     */\r\n    MessageType.Info = 3;\r\n    /**\r\n     * A log message.\r\n     */\r\n    MessageType.Log = 4;\r\n})(MessageType = exports.MessageType || (exports.MessageType = {}));\r\n/**\r\n * The show message notification is sent from a server to a client to ask\r\n * the client to display a particular message in the user interface.\r\n */\r\nvar ShowMessageNotification;\r\n(function (ShowMessageNotification) {\r\n    ShowMessageNotification.type = new messages_1.ProtocolNotificationType('window/showMessage');\r\n})(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));\r\n/**\r\n * The show message request is sent from the server to the client to show a message\r\n * and a set of options actions to the user.\r\n */\r\nvar ShowMessageRequest;\r\n(function (ShowMessageRequest) {\r\n    ShowMessageRequest.type = new messages_1.ProtocolRequestType('window/showMessageRequest');\r\n})(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));\r\n/**\r\n * The log message notification is sent from the server to the client to ask\r\n * the client to log a particular message.\r\n */\r\nvar LogMessageNotification;\r\n(function (LogMessageNotification) {\r\n    LogMessageNotification.type = new messages_1.ProtocolNotificationType('window/logMessage');\r\n})(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));\r\n//---- Telemetry notification\r\n/**\r\n * The telemetry event notification is sent from the server to the client to ask\r\n * the client to log telemetry data.\r\n */\r\nvar TelemetryEventNotification;\r\n(function (TelemetryEventNotification) {\r\n    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType('telemetry/event');\r\n})(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));\r\n/**\r\n * Defines how the host (editor) should sync\r\n * document changes to the language server.\r\n */\r\nvar TextDocumentSyncKind;\r\n(function (TextDocumentSyncKind) {\r\n    /**\r\n     * Documents should not be synced at all.\r\n     */\r\n    TextDocumentSyncKind.None = 0;\r\n    /**\r\n     * Documents are synced by always sending the full content\r\n     * of the document.\r\n     */\r\n    TextDocumentSyncKind.Full = 1;\r\n    /**\r\n     * Documents are synced by sending the full content on open.\r\n     * After that only incremental updates to the document are\r\n     * send.\r\n     */\r\n    TextDocumentSyncKind.Incremental = 2;\r\n})(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));\r\n/**\r\n * The document open notification is sent from the client to the server to signal\r\n * newly opened text documents. The document's truth is now managed by the client\r\n * and the server must not try to read the document's truth using the document's\r\n * uri. Open in this sense means it is managed by the client. It doesn't necessarily\r\n * mean that its content is presented in an editor. An open notification must not\r\n * be sent more than once without a corresponding close notification send before.\r\n * This means open and close notification must be balanced and the max open count\r\n * is one.\r\n */\r\nvar DidOpenTextDocumentNotification;\r\n(function (DidOpenTextDocumentNotification) {\r\n    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';\r\n    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);\r\n})(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));\r\n/**\r\n * The document change notification is sent from the client to the server to signal\r\n * changes to a text document.\r\n */\r\nvar DidChangeTextDocumentNotification;\r\n(function (DidChangeTextDocumentNotification) {\r\n    DidChangeTextDocumentNotification.method = 'textDocument/didChange';\r\n    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);\r\n})(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));\r\n/**\r\n * The document close notification is sent from the client to the server when\r\n * the document got closed in the client. The document's truth now exists where\r\n * the document's uri points to (e.g. if the document's uri is a file uri the\r\n * truth now exists on disk). As with the open notification the close notification\r\n * is about managing the document's content. Receiving a close notification\r\n * doesn't mean that the document was open in an editor before. A close\r\n * notification requires a previous open notification to be sent.\r\n */\r\nvar DidCloseTextDocumentNotification;\r\n(function (DidCloseTextDocumentNotification) {\r\n    DidCloseTextDocumentNotification.method = 'textDocument/didClose';\r\n    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);\r\n})(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));\r\n/**\r\n * The document save notification is sent from the client to the server when\r\n * the document got saved in the client.\r\n */\r\nvar DidSaveTextDocumentNotification;\r\n(function (DidSaveTextDocumentNotification) {\r\n    DidSaveTextDocumentNotification.method = 'textDocument/didSave';\r\n    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);\r\n})(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));\r\n/**\r\n * Represents reasons why a text document is saved.\r\n */\r\nvar TextDocumentSaveReason;\r\n(function (TextDocumentSaveReason) {\r\n    /**\r\n     * Manually triggered, e.g. by the user pressing save, by starting debugging,\r\n     * or by an API call.\r\n     */\r\n    TextDocumentSaveReason.Manual = 1;\r\n    /**\r\n     * Automatic after a delay.\r\n     */\r\n    TextDocumentSaveReason.AfterDelay = 2;\r\n    /**\r\n     * When the editor lost focus.\r\n     */\r\n    TextDocumentSaveReason.FocusOut = 3;\r\n})(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));\r\n/**\r\n * A document will save notification is sent from the client to the server before\r\n * the document is actually saved.\r\n */\r\nvar WillSaveTextDocumentNotification;\r\n(function (WillSaveTextDocumentNotification) {\r\n    WillSaveTextDocumentNotification.method = 'textDocument/willSave';\r\n    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);\r\n})(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));\r\n/**\r\n * A document will save request is sent from the client to the server before\r\n * the document is actually saved. The request can return an array of TextEdits\r\n * which will be applied to the text document before it is saved. Please note that\r\n * clients might drop results if computing the text edits took too long or if a\r\n * server constantly fails on this request. This is done to keep the save fast and\r\n * reliable.\r\n */\r\nvar WillSaveTextDocumentWaitUntilRequest;\r\n(function (WillSaveTextDocumentWaitUntilRequest) {\r\n    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';\r\n    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);\r\n})(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));\r\n/**\r\n * The watched files notification is sent from the client to the server when\r\n * the client detects changes to file watched by the language client.\r\n */\r\nvar DidChangeWatchedFilesNotification;\r\n(function (DidChangeWatchedFilesNotification) {\r\n    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWatchedFiles');\r\n})(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));\r\n/**\r\n * The file event type\r\n */\r\nvar FileChangeType;\r\n(function (FileChangeType) {\r\n    /**\r\n     * The file got created.\r\n     */\r\n    FileChangeType.Created = 1;\r\n    /**\r\n     * The file got changed.\r\n     */\r\n    FileChangeType.Changed = 2;\r\n    /**\r\n     * The file got deleted.\r\n     */\r\n    FileChangeType.Deleted = 3;\r\n})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));\r\nvar WatchKind;\r\n(function (WatchKind) {\r\n    /**\r\n     * Interested in create events.\r\n     */\r\n    WatchKind.Create = 1;\r\n    /**\r\n     * Interested in change events\r\n     */\r\n    WatchKind.Change = 2;\r\n    /**\r\n     * Interested in delete events\r\n     */\r\n    WatchKind.Delete = 4;\r\n})(WatchKind = exports.WatchKind || (exports.WatchKind = {}));\r\n/**\r\n * Diagnostics notification are sent from the server to the client to signal\r\n * results of validation runs.\r\n */\r\nvar PublishDiagnosticsNotification;\r\n(function (PublishDiagnosticsNotification) {\r\n    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType('textDocument/publishDiagnostics');\r\n})(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));\r\n/**\r\n * How a completion was triggered\r\n */\r\nvar CompletionTriggerKind;\r\n(function (CompletionTriggerKind) {\r\n    /**\r\n     * Completion was triggered by typing an identifier (24x7 code\r\n     * complete), manual invocation (e.g Ctrl+Space) or via API.\r\n     */\r\n    CompletionTriggerKind.Invoked = 1;\r\n    /**\r\n     * Completion was triggered by a trigger character specified by\r\n     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.\r\n     */\r\n    CompletionTriggerKind.TriggerCharacter = 2;\r\n    /**\r\n     * Completion was re-triggered as current completion list is incomplete\r\n     */\r\n    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;\r\n})(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));\r\n/**\r\n * Request to request completion at a given text document position. The request's\r\n * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response\r\n * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)\r\n * or a Thenable that resolves to such.\r\n *\r\n * The request can delay the computation of the [`detail`](#CompletionItem.detail)\r\n * and [`documentation`](#CompletionItem.documentation) properties to the `completionItem/resolve`\r\n * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,\r\n * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.\r\n */\r\nvar CompletionRequest;\r\n(function (CompletionRequest) {\r\n    CompletionRequest.method = 'textDocument/completion';\r\n    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);\r\n    /** @deprecated Use CompletionRequest.type */\r\n    CompletionRequest.resultType = new vscode_jsonrpc_1.ProgressType();\r\n})(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));\r\n/**\r\n * Request to resolve additional information for a given completion item.The request's\r\n * parameter is of type [CompletionItem](#CompletionItem) the response\r\n * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.\r\n */\r\nvar CompletionResolveRequest;\r\n(function (CompletionResolveRequest) {\r\n    CompletionResolveRequest.method = 'completionItem/resolve';\r\n    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);\r\n})(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));\r\n/**\r\n * Request to request hover information at a given text document position. The request's\r\n * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of\r\n * type [Hover](#Hover) or a Thenable that resolves to such.\r\n */\r\nvar HoverRequest;\r\n(function (HoverRequest) {\r\n    HoverRequest.method = 'textDocument/hover';\r\n    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);\r\n})(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));\r\n/**\r\n * How a signature help was triggered.\r\n *\r\n * @since 3.15.0\r\n */\r\nvar SignatureHelpTriggerKind;\r\n(function (SignatureHelpTriggerKind) {\r\n    /**\r\n     * Signature help was invoked manually by the user or by a command.\r\n     */\r\n    SignatureHelpTriggerKind.Invoked = 1;\r\n    /**\r\n     * Signature help was triggered by a trigger character.\r\n     */\r\n    SignatureHelpTriggerKind.TriggerCharacter = 2;\r\n    /**\r\n     * Signature help was triggered by the cursor moving or by the document content changing.\r\n     */\r\n    SignatureHelpTriggerKind.ContentChange = 3;\r\n})(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));\r\nvar SignatureHelpRequest;\r\n(function (SignatureHelpRequest) {\r\n    SignatureHelpRequest.method = 'textDocument/signatureHelp';\r\n    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);\r\n})(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));\r\n/**\r\n * A request to resolve the definition location of a symbol at a given text\r\n * document position. The request's parameter is of type [TextDocumentPosition]\r\n * (#TextDocumentPosition) the response is of either type [Definition](#Definition)\r\n * or a typed array of [DefinitionLink](#DefinitionLink) or a Thenable that resolves\r\n * to such.\r\n */\r\nvar DefinitionRequest;\r\n(function (DefinitionRequest) {\r\n    DefinitionRequest.method = 'textDocument/definition';\r\n    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);\r\n    /** @deprecated Use DefinitionRequest.type */\r\n    DefinitionRequest.resultType = new vscode_jsonrpc_1.ProgressType();\r\n})(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));\r\n/**\r\n * A request to resolve project-wide references for the symbol denoted\r\n * by the given text document position. The request's parameter is of\r\n * type [ReferenceParams](#ReferenceParams) the response is of type\r\n * [Location[]](#Location) or a Thenable that resolves to such.\r\n */\r\nvar ReferencesRequest;\r\n(function (ReferencesRequest) {\r\n    ReferencesRequest.method = 'textDocument/references';\r\n    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);\r\n    /** @deprecated Use ReferencesRequest.type */\r\n    ReferencesRequest.resultType = new vscode_jsonrpc_1.ProgressType();\r\n})(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));\r\n/**\r\n * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given\r\n * text document position. The request's parameter is of type [TextDocumentPosition]\r\n * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]\r\n * (#DocumentHighlight) or a Thenable that resolves to such.\r\n */\r\nvar DocumentHighlightRequest;\r\n(function (DocumentHighlightRequest) {\r\n    DocumentHighlightRequest.method = 'textDocument/documentHighlight';\r\n    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);\r\n    /** @deprecated Use DocumentHighlightRequest.type */\r\n    DocumentHighlightRequest.resultType = new vscode_jsonrpc_1.ProgressType();\r\n})(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));\r\n/**\r\n * A request to list all symbols found in a given text document. The request's\r\n * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the\r\n * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable\r\n * that resolves to such.\r\n */\r\nvar DocumentSymbolRequest;\r\n(function (DocumentSymbolRequest) {\r\n    DocumentSymbolRequest.method = 'textDocument/documentSymbol';\r\n    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);\r\n    /** @deprecated Use DocumentSymbolRequest.type */\r\n    DocumentSymbolRequest.resultType = new vscode_jsonrpc_1.ProgressType();\r\n})(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));\r\n/**\r\n * A request to provide commands for the given text document and range.\r\n */\r\nvar CodeActionRequest;\r\n(function (CodeActionRequest) {\r\n    CodeActionRequest.method = 'textDocument/codeAction';\r\n    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);\r\n    /** @deprecated Use CodeActionRequest.type */\r\n    CodeActionRequest.resultType = new vscode_jsonrpc_1.ProgressType();\r\n})(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));\r\n/**\r\n * A request to list project-wide symbols matching the query string given\r\n * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is\r\n * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that\r\n * resolves to such.\r\n */\r\nvar WorkspaceSymbolRequest;\r\n(function (WorkspaceSymbolRequest) {\r\n    WorkspaceSymbolRequest.method = 'workspace/symbol';\r\n    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);\r\n    /** @deprecated Use WorkspaceSymbolRequest.type */\r\n    WorkspaceSymbolRequest.resultType = new vscode_jsonrpc_1.ProgressType();\r\n})(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));\r\n/**\r\n * A request to provide code lens for the given text document.\r\n */\r\nvar CodeLensRequest;\r\n(function (CodeLensRequest) {\r\n    CodeLensRequest.type = new messages_1.ProtocolRequestType('textDocument/codeLens');\r\n    /** @deprecated Use CodeLensRequest.type */\r\n    CodeLensRequest.resultType = new vscode_jsonrpc_1.ProgressType();\r\n})(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));\r\n/**\r\n * A request to resolve a command for a given code lens.\r\n */\r\nvar CodeLensResolveRequest;\r\n(function (CodeLensResolveRequest) {\r\n    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType('codeLens/resolve');\r\n})(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));\r\n/**\r\n * A request to provide document links\r\n */\r\nvar DocumentLinkRequest;\r\n(function (DocumentLinkRequest) {\r\n    DocumentLinkRequest.method = 'textDocument/documentLink';\r\n    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);\r\n    /** @deprecated Use DocumentLinkRequest.type */\r\n    DocumentLinkRequest.resultType = new vscode_jsonrpc_1.ProgressType();\r\n})(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));\r\n/**\r\n * Request to resolve additional information for a given document link. The request's\r\n * parameter is of type [DocumentLink](#DocumentLink) the response\r\n * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.\r\n */\r\nvar DocumentLinkResolveRequest;\r\n(function (DocumentLinkResolveRequest) {\r\n    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType('documentLink/resolve');\r\n})(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));\r\n/**\r\n * A request to to format a whole document.\r\n */\r\nvar DocumentFormattingRequest;\r\n(function (DocumentFormattingRequest) {\r\n    DocumentFormattingRequest.method = 'textDocument/formatting';\r\n    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);\r\n})(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));\r\n/**\r\n * A request to to format a range in a document.\r\n */\r\nvar DocumentRangeFormattingRequest;\r\n(function (DocumentRangeFormattingRequest) {\r\n    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';\r\n    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);\r\n})(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));\r\n/**\r\n * A request to format a document on type.\r\n */\r\nvar DocumentOnTypeFormattingRequest;\r\n(function (DocumentOnTypeFormattingRequest) {\r\n    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';\r\n    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);\r\n})(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));\r\n/**\r\n * A request to rename a symbol.\r\n */\r\nvar RenameRequest;\r\n(function (RenameRequest) {\r\n    RenameRequest.method = 'textDocument/rename';\r\n    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);\r\n})(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));\r\n/**\r\n * A request to test and perform the setup necessary for a rename.\r\n */\r\nvar PrepareRenameRequest;\r\n(function (PrepareRenameRequest) {\r\n    PrepareRenameRequest.method = 'textDocument/prepareRename';\r\n    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);\r\n})(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));\r\n/**\r\n * A request send from the client to the server to execute a command. The request might return\r\n * a workspace edit which the client will apply to the workspace.\r\n */\r\nvar ExecuteCommandRequest;\r\n(function (ExecuteCommandRequest) {\r\n    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType('workspace/executeCommand');\r\n})(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));\r\n/**\r\n * A request sent from the server to the client to modified certain resources.\r\n */\r\nvar ApplyWorkspaceEditRequest;\r\n(function (ApplyWorkspaceEditRequest) {\r\n    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');\r\n})(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-languageserver-protocol/lib/protocol.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/protocol.progress.js":
/*!******************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/protocol.progress.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/main.js\");\r\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/messages.js\");\r\nvar WorkDoneProgress;\r\n(function (WorkDoneProgress) {\r\n    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();\r\n})(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));\r\n/**\r\n * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress\r\n * reporting from the server.\r\n */\r\nvar WorkDoneProgressCreateRequest;\r\n(function (WorkDoneProgressCreateRequest) {\r\n    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType('window/workDoneProgress/create');\r\n})(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));\r\n/**\r\n * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress\r\n * initiated on the server side.\r\n */\r\nvar WorkDoneProgressCancelNotification;\r\n(function (WorkDoneProgressCancelNotification) {\r\n    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType('window/workDoneProgress/cancel');\r\n})(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-languageserver-protocol/lib/protocol.progress.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/protocol.selectionRange.js":
/*!************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/protocol.selectionRange.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/main.js\");\r\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/messages.js\");\r\n/**\r\n * A request to provide selection ranges in a document. The request's\r\n * parameter is of type [SelectionRangeParams](#SelectionRangeParams), the\r\n * response is of type [SelectionRange[]](#SelectionRange[]) or a Thenable\r\n * that resolves to such.\r\n */\r\nvar SelectionRangeRequest;\r\n(function (SelectionRangeRequest) {\r\n    SelectionRangeRequest.method = 'textDocument/selectionRange';\r\n    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);\r\n    /** @deprecated  Use SelectionRangeRequest.type */\r\n    SelectionRangeRequest.resultType = new vscode_jsonrpc_1.ProgressType();\r\n})(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-languageserver-protocol/lib/protocol.selectionRange.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/protocol.sematicTokens.proposed.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/protocol.sematicTokens.proposed.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/messages.js\");\r\n/**\r\n * A set of predefined token types. This set is not fixed\r\n * an clients can specify additional token types via the\r\n * corresponding client capabilities.\r\n *\r\n * @since 3.16.0 - Proposed state\r\n */\r\nvar SemanticTokenTypes;\r\n(function (SemanticTokenTypes) {\r\n    SemanticTokenTypes[\"comment\"] = \"comment\";\r\n    SemanticTokenTypes[\"keyword\"] = \"keyword\";\r\n    SemanticTokenTypes[\"string\"] = \"string\";\r\n    SemanticTokenTypes[\"number\"] = \"number\";\r\n    SemanticTokenTypes[\"regexp\"] = \"regexp\";\r\n    SemanticTokenTypes[\"operator\"] = \"operator\";\r\n    SemanticTokenTypes[\"namespace\"] = \"namespace\";\r\n    SemanticTokenTypes[\"type\"] = \"type\";\r\n    SemanticTokenTypes[\"struct\"] = \"struct\";\r\n    SemanticTokenTypes[\"class\"] = \"class\";\r\n    SemanticTokenTypes[\"interface\"] = \"interface\";\r\n    SemanticTokenTypes[\"enum\"] = \"enum\";\r\n    SemanticTokenTypes[\"typeParameter\"] = \"typeParameter\";\r\n    SemanticTokenTypes[\"function\"] = \"function\";\r\n    SemanticTokenTypes[\"member\"] = \"member\";\r\n    SemanticTokenTypes[\"property\"] = \"property\";\r\n    SemanticTokenTypes[\"macro\"] = \"macro\";\r\n    SemanticTokenTypes[\"variable\"] = \"variable\";\r\n    SemanticTokenTypes[\"parameter\"] = \"parameter\";\r\n    SemanticTokenTypes[\"label\"] = \"label\";\r\n})(SemanticTokenTypes = exports.SemanticTokenTypes || (exports.SemanticTokenTypes = {}));\r\n/**\r\n * A set of predefined token modifiers. This set is not fixed\r\n * an clients can specify additional token types via the\r\n * corresponding client capabilities.\r\n *\r\n * @since 3.16.0 - Proposed state\r\n */\r\nvar SemanticTokenModifiers;\r\n(function (SemanticTokenModifiers) {\r\n    SemanticTokenModifiers[\"documentation\"] = \"documentation\";\r\n    SemanticTokenModifiers[\"declaration\"] = \"declaration\";\r\n    SemanticTokenModifiers[\"definition\"] = \"definition\";\r\n    SemanticTokenModifiers[\"reference\"] = \"reference\";\r\n    SemanticTokenModifiers[\"static\"] = \"static\";\r\n    SemanticTokenModifiers[\"abstract\"] = \"abstract\";\r\n    SemanticTokenModifiers[\"deprecated\"] = \"deprecated\";\r\n    SemanticTokenModifiers[\"async\"] = \"async\";\r\n    SemanticTokenModifiers[\"volatile\"] = \"volatile\";\r\n    SemanticTokenModifiers[\"readonly\"] = \"readonly\";\r\n})(SemanticTokenModifiers = exports.SemanticTokenModifiers || (exports.SemanticTokenModifiers = {}));\r\n/**\r\n * @since 3.16.0 - Proposed state\r\n */\r\nvar SemanticTokens;\r\n(function (SemanticTokens) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return candidate !== undefined && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&\r\n            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');\r\n    }\r\n    SemanticTokens.is = is;\r\n})(SemanticTokens = exports.SemanticTokens || (exports.SemanticTokens = {}));\r\n/**\r\n * @since 3.16.0 - Proposed state\r\n */\r\nvar SemanticTokensRequest;\r\n(function (SemanticTokensRequest) {\r\n    SemanticTokensRequest.method = 'textDocument/semanticTokens';\r\n    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);\r\n})(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));\r\n/**\r\n * @since 3.16.0 - Proposed state\r\n */\r\nvar SemanticTokensEditsRequest;\r\n(function (SemanticTokensEditsRequest) {\r\n    SemanticTokensEditsRequest.method = 'textDocument/semanticTokens/edits';\r\n    SemanticTokensEditsRequest.type = new messages_1.ProtocolRequestType(SemanticTokensEditsRequest.method);\r\n})(SemanticTokensEditsRequest = exports.SemanticTokensEditsRequest || (exports.SemanticTokensEditsRequest = {}));\r\n/**\r\n * @since 3.16.0 - Proposed state\r\n */\r\nvar SemanticTokensRangeRequest;\r\n(function (SemanticTokensRangeRequest) {\r\n    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';\r\n    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);\r\n})(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-languageserver-protocol/lib/protocol.sematicTokens.proposed.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/protocol.typeDefinition.js":
/*!************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/protocol.typeDefinition.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/main.js\");\r\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/messages.js\");\r\n// @ts-ignore: to avoid inlining LocatioLink as dynamic import\r\nlet __noDynamicImport;\r\n/**\r\n * A request to resolve the type definition locations of a symbol at a given text\r\n * document position. The request's parameter is of type [TextDocumentPositioParams]\r\n * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a\r\n * Thenable that resolves to such.\r\n */\r\nvar TypeDefinitionRequest;\r\n(function (TypeDefinitionRequest) {\r\n    TypeDefinitionRequest.method = 'textDocument/typeDefinition';\r\n    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);\r\n    /** @deprecated Use TypeDefinitionRequest.type */\r\n    TypeDefinitionRequest.resultType = new vscode_jsonrpc_1.ProgressType();\r\n})(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-languageserver-protocol/lib/protocol.typeDefinition.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/messages.js\");\r\n/**\r\n * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.\r\n */\r\nvar WorkspaceFoldersRequest;\r\n(function (WorkspaceFoldersRequest) {\r\n    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0('workspace/workspaceFolders');\r\n})(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));\r\n/**\r\n * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace\r\n * folder configuration changes.\r\n */\r\nvar DidChangeWorkspaceFoldersNotification;\r\n(function (DidChangeWorkspaceFoldersNotification) {\r\n    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWorkspaceFolders');\r\n})(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/utils/is.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/utils/is.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nfunction boolean(value) {\r\n    return value === true || value === false;\r\n}\r\nexports.boolean = boolean;\r\nfunction string(value) {\r\n    return typeof value === 'string' || value instanceof String;\r\n}\r\nexports.string = string;\r\nfunction number(value) {\r\n    return typeof value === 'number' || value instanceof Number;\r\n}\r\nexports.number = number;\r\nfunction error(value) {\r\n    return value instanceof Error;\r\n}\r\nexports.error = error;\r\nfunction func(value) {\r\n    return typeof value === 'function';\r\n}\r\nexports.func = func;\r\nfunction array(value) {\r\n    return Array.isArray(value);\r\n}\r\nexports.array = array;\r\nfunction stringArray(value) {\r\n    return array(value) && value.every(elem => string(elem));\r\n}\r\nexports.stringArray = stringArray;\r\nfunction typedArray(value, check) {\r\n    return Array.isArray(value) && value.every(check);\r\n}\r\nexports.typedArray = typedArray;\r\nfunction objectLiteral(value) {\r\n    // Strictly speaking class instances pass this check as well. Since the LSP\r\n    // doesn't use classes we ignore this for now. If we do we need to add something\r\n    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\r\n    return value !== null && typeof value === 'object';\r\n}\r\nexports.objectLiteral = objectLiteral;\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-languageserver-protocol/lib/utils/is.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-textdocument/lib/esm/main.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-textdocument/lib/esm/main.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TextDocument\": () => /* binding */ TextDocument\n/* harmony export */ });\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\nvar FullTextDocument = /** @class */ (function () {\n    function FullTextDocument(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n        get: function () {\n            return this._uri;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n        get: function () {\n            return this._languageId;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"version\", {\n        get: function () {\n            return this._version;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    FullTextDocument.prototype.getText = function (range) {\n        if (range) {\n            var start = this.offsetAt(range.start);\n            var end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    };\n    FullTextDocument.prototype.update = function (changes, version) {\n        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {\n            var change = changes_1[_i];\n            if (FullTextDocument.isIncremental(change)) {\n                // makes sure start is before end\n                var range = getWellformedRange(change.range);\n                // update content\n                var startOffset = this.offsetAt(range.start);\n                var endOffset = this.offsetAt(range.end);\n                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n                // update the offsets\n                var startLine = Math.max(range.start.line, 0);\n                var endLine = Math.max(range.end.line, 0);\n                var lineOffsets = this._lineOffsets;\n                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n                if (endLine - startLine === addedLineOffsets.length) {\n                    for (var i = 0, len = addedLineOffsets.length; i < len; i++) {\n                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n                    }\n                }\n                else {\n                    if (addedLineOffsets.length < 10000) {\n                        lineOffsets.splice.apply(lineOffsets, [startLine + 1, endLine - startLine].concat(addedLineOffsets));\n                    }\n                    else { // avoid too many arguments for splice\n                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n                    }\n                }\n                var diff = change.text.length - (endOffset - startOffset);\n                if (diff !== 0) {\n                    for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\n                        lineOffsets[i] = lineOffsets[i] + diff;\n                    }\n                }\n            }\n            else if (FullTextDocument.isFull(change)) {\n                this._content = change.text;\n                this._lineOffsets = undefined;\n            }\n            else {\n                throw new Error('Unknown change event received');\n            }\n        }\n        this._version = version;\n    };\n    FullTextDocument.prototype.getLineOffsets = function () {\n        if (this._lineOffsets === undefined) {\n            this._lineOffsets = computeLineOffsets(this._content, true);\n        }\n        return this._lineOffsets;\n    };\n    FullTextDocument.prototype.positionAt = function (offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        var lineOffsets = this.getLineOffsets();\n        var low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return { line: 0, character: offset };\n        }\n        while (low < high) {\n            var mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        var line = low - 1;\n        return { line: line, character: offset - lineOffsets[line] };\n    };\n    FullTextDocument.prototype.offsetAt = function (position) {\n        var lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        var lineOffset = lineOffsets[position.line];\n        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    };\n    Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n        get: function () {\n            return this.getLineOffsets().length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    FullTextDocument.isIncremental = function (event) {\n        var candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range !== undefined &&\n            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\n    };\n    FullTextDocument.isFull = function (event) {\n        var candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\n    };\n    return FullTextDocument;\n}());\nvar TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new text document.\n     *\n     * @param uri The document's uri.\n     * @param languageId  The document's language Id.\n     * @param version The document's initial version number.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Updates a TextDocument by modifing its content.\n     *\n     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\n     * @param changes the changes to apply to the document.\n     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\n     *\n     */\n    function update(document, changes, version) {\n        if (document instanceof FullTextDocument) {\n            document.update(changes, version);\n            return document;\n        }\n        else {\n            throw new Error('TextDocument.update: document must be created by TextDocument.create');\n        }\n    }\n    TextDocument.update = update;\n    function applyEdits(document, edits) {\n        var text = document.getText();\n        var sortedEdits = mergeSort(edits.map(getWellformedEdit), function (a, b) {\n            var diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        var lastModifiedOffset = 0;\n        var spans = [];\n        for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {\n            var e = sortedEdits_1[_i];\n            var startOffset = document.offsetAt(e.range.start);\n            if (startOffset < lastModifiedOffset) {\n                throw new Error('Overlapping edit');\n            }\n            else if (startOffset > lastModifiedOffset) {\n                spans.push(text.substring(lastModifiedOffset, startOffset));\n            }\n            if (e.newText.length) {\n                spans.push(e.newText);\n            }\n            lastModifiedOffset = document.offsetAt(e.range.end);\n        }\n        spans.push(text.substr(lastModifiedOffset));\n        return spans.join('');\n    }\n    TextDocument.applyEdits = applyEdits;\n})(TextDocument || (TextDocument = {}));\nfunction mergeSort(data, compare) {\n    if (data.length <= 1) {\n        // sorted\n        return data;\n    }\n    var p = (data.length / 2) | 0;\n    var left = data.slice(0, p);\n    var right = data.slice(p);\n    mergeSort(left, compare);\n    mergeSort(right, compare);\n    var leftIdx = 0;\n    var rightIdx = 0;\n    var i = 0;\n    while (leftIdx < left.length && rightIdx < right.length) {\n        var ret = compare(left[leftIdx], right[rightIdx]);\n        if (ret <= 0) {\n            // smaller_equal -> take left to preserve order\n            data[i++] = left[leftIdx++];\n        }\n        else {\n            // greater -> take right\n            data[i++] = right[rightIdx++];\n        }\n    }\n    while (leftIdx < left.length) {\n        data[i++] = left[leftIdx++];\n    }\n    while (rightIdx < right.length) {\n        data[i++] = right[rightIdx++];\n    }\n    return data;\n}\nfunction computeLineOffsets(text, isAtLineStart, textOffset) {\n    if (textOffset === void 0) { textOffset = 0; }\n    var result = isAtLineStart ? [textOffset] : [];\n    for (var i = 0; i < text.length; i++) {\n        var ch = text.charCodeAt(i);\n        if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {\n            if (ch === 13 /* CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* LineFeed */) {\n                i++;\n            }\n            result.push(textOffset + i + 1);\n        }\n    }\n    return result;\n}\nfunction getWellformedRange(range) {\n    var start = range.start;\n    var end = range.end;\n    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {\n        return { start: end, end: start };\n    }\n    return range;\n}\nfunction getWellformedEdit(textEdit) {\n    var range = getWellformedRange(textEdit.range);\n    if (range !== textEdit.range) {\n        return { newText: textEdit.newText, range: range };\n    }\n    return textEdit;\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-languageserver-textdocument/lib/esm/main.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-types/lib/esm/main.js":
/*!******************************************************************!*\
  !*** ./node_modules/vscode-languageserver-types/lib/esm/main.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Position\": () => /* binding */ Position,\n/* harmony export */   \"Range\": () => /* binding */ Range,\n/* harmony export */   \"Location\": () => /* binding */ Location,\n/* harmony export */   \"LocationLink\": () => /* binding */ LocationLink,\n/* harmony export */   \"Color\": () => /* binding */ Color,\n/* harmony export */   \"ColorInformation\": () => /* binding */ ColorInformation,\n/* harmony export */   \"ColorPresentation\": () => /* binding */ ColorPresentation,\n/* harmony export */   \"FoldingRangeKind\": () => /* binding */ FoldingRangeKind,\n/* harmony export */   \"FoldingRange\": () => /* binding */ FoldingRange,\n/* harmony export */   \"DiagnosticRelatedInformation\": () => /* binding */ DiagnosticRelatedInformation,\n/* harmony export */   \"DiagnosticSeverity\": () => /* binding */ DiagnosticSeverity,\n/* harmony export */   \"DiagnosticTag\": () => /* binding */ DiagnosticTag,\n/* harmony export */   \"Diagnostic\": () => /* binding */ Diagnostic,\n/* harmony export */   \"Command\": () => /* binding */ Command,\n/* harmony export */   \"TextEdit\": () => /* binding */ TextEdit,\n/* harmony export */   \"TextDocumentEdit\": () => /* binding */ TextDocumentEdit,\n/* harmony export */   \"CreateFile\": () => /* binding */ CreateFile,\n/* harmony export */   \"RenameFile\": () => /* binding */ RenameFile,\n/* harmony export */   \"DeleteFile\": () => /* binding */ DeleteFile,\n/* harmony export */   \"WorkspaceEdit\": () => /* binding */ WorkspaceEdit,\n/* harmony export */   \"WorkspaceChange\": () => /* binding */ WorkspaceChange,\n/* harmony export */   \"TextDocumentIdentifier\": () => /* binding */ TextDocumentIdentifier,\n/* harmony export */   \"VersionedTextDocumentIdentifier\": () => /* binding */ VersionedTextDocumentIdentifier,\n/* harmony export */   \"TextDocumentItem\": () => /* binding */ TextDocumentItem,\n/* harmony export */   \"MarkupKind\": () => /* binding */ MarkupKind,\n/* harmony export */   \"MarkupContent\": () => /* binding */ MarkupContent,\n/* harmony export */   \"CompletionItemKind\": () => /* binding */ CompletionItemKind,\n/* harmony export */   \"InsertTextFormat\": () => /* binding */ InsertTextFormat,\n/* harmony export */   \"CompletionItemTag\": () => /* binding */ CompletionItemTag,\n/* harmony export */   \"CompletionItem\": () => /* binding */ CompletionItem,\n/* harmony export */   \"CompletionList\": () => /* binding */ CompletionList,\n/* harmony export */   \"MarkedString\": () => /* binding */ MarkedString,\n/* harmony export */   \"Hover\": () => /* binding */ Hover,\n/* harmony export */   \"ParameterInformation\": () => /* binding */ ParameterInformation,\n/* harmony export */   \"SignatureInformation\": () => /* binding */ SignatureInformation,\n/* harmony export */   \"DocumentHighlightKind\": () => /* binding */ DocumentHighlightKind,\n/* harmony export */   \"DocumentHighlight\": () => /* binding */ DocumentHighlight,\n/* harmony export */   \"SymbolKind\": () => /* binding */ SymbolKind,\n/* harmony export */   \"SymbolTag\": () => /* binding */ SymbolTag,\n/* harmony export */   \"SymbolInformation\": () => /* binding */ SymbolInformation,\n/* harmony export */   \"DocumentSymbol\": () => /* binding */ DocumentSymbol,\n/* harmony export */   \"CodeActionKind\": () => /* binding */ CodeActionKind,\n/* harmony export */   \"CodeActionContext\": () => /* binding */ CodeActionContext,\n/* harmony export */   \"CodeAction\": () => /* binding */ CodeAction,\n/* harmony export */   \"CodeLens\": () => /* binding */ CodeLens,\n/* harmony export */   \"FormattingOptions\": () => /* binding */ FormattingOptions,\n/* harmony export */   \"DocumentLink\": () => /* binding */ DocumentLink,\n/* harmony export */   \"SelectionRange\": () => /* binding */ SelectionRange,\n/* harmony export */   \"EOL\": () => /* binding */ EOL,\n/* harmony export */   \"TextDocument\": () => /* binding */ TextDocument\n/* harmony export */ });\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\n/**\r\n * The Position namespace provides helper functions to work with\r\n * [Position](#Position) literals.\r\n */\r\nvar Position;\r\n(function (Position) {\r\n    /**\r\n     * Creates a new Position literal from the given line and character.\r\n     * @param line The position's line.\r\n     * @param character The position's character.\r\n     */\r\n    function create(line, character) {\r\n        return { line: line, character: character };\r\n    }\r\n    Position.create = create;\r\n    /**\r\n     * Checks whether the given liternal conforms to the [Position](#Position) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.objectLiteral(candidate) && Is.number(candidate.line) && Is.number(candidate.character);\r\n    }\r\n    Position.is = is;\r\n})(Position || (Position = {}));\r\n/**\r\n * The Range namespace provides helper functions to work with\r\n * [Range](#Range) literals.\r\n */\r\nvar Range;\r\n(function (Range) {\r\n    function create(one, two, three, four) {\r\n        if (Is.number(one) && Is.number(two) && Is.number(three) && Is.number(four)) {\r\n            return { start: Position.create(one, two), end: Position.create(three, four) };\r\n        }\r\n        else if (Position.is(one) && Position.is(two)) {\r\n            return { start: one, end: two };\r\n        }\r\n        else {\r\n            throw new Error(\"Range#create called with invalid arguments[\" + one + \", \" + two + \", \" + three + \", \" + four + \"]\");\r\n        }\r\n    }\r\n    Range.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [Range](#Range) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\r\n    }\r\n    Range.is = is;\r\n})(Range || (Range = {}));\r\n/**\r\n * The Location namespace provides helper functions to work with\r\n * [Location](#Location) literals.\r\n */\r\nvar Location;\r\n(function (Location) {\r\n    /**\r\n     * Creates a Location literal.\r\n     * @param uri The location's uri.\r\n     * @param range The location's range.\r\n     */\r\n    function create(uri, range) {\r\n        return { uri: uri, range: range };\r\n    }\r\n    Location.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [Location](#Location) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\r\n    }\r\n    Location.is = is;\r\n})(Location || (Location = {}));\r\n/**\r\n * The LocationLink namespace provides helper functions to work with\r\n * [LocationLink](#LocationLink) literals.\r\n */\r\nvar LocationLink;\r\n(function (LocationLink) {\r\n    /**\r\n     * Creates a LocationLink literal.\r\n     * @param targetUri The definition's uri.\r\n     * @param targetRange The full range of the definition.\r\n     * @param targetSelectionRange The span of the symbol definition at the target.\r\n     * @param originSelectionRange The span of the symbol being defined in the originating source file.\r\n     */\r\n    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\r\n        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };\r\n    }\r\n    LocationLink.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)\r\n            && (Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange))\r\n            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\r\n    }\r\n    LocationLink.is = is;\r\n})(LocationLink || (LocationLink = {}));\r\n/**\r\n * The Color namespace provides helper functions to work with\r\n * [Color](#Color) literals.\r\n */\r\nvar Color;\r\n(function (Color) {\r\n    /**\r\n     * Creates a new Color literal.\r\n     */\r\n    function create(red, green, blue, alpha) {\r\n        return {\r\n            red: red,\r\n            green: green,\r\n            blue: blue,\r\n            alpha: alpha,\r\n        };\r\n    }\r\n    Color.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [Color](#Color) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.number(candidate.red)\r\n            && Is.number(candidate.green)\r\n            && Is.number(candidate.blue)\r\n            && Is.number(candidate.alpha);\r\n    }\r\n    Color.is = is;\r\n})(Color || (Color = {}));\r\n/**\r\n * The ColorInformation namespace provides helper functions to work with\r\n * [ColorInformation](#ColorInformation) literals.\r\n */\r\nvar ColorInformation;\r\n(function (ColorInformation) {\r\n    /**\r\n     * Creates a new ColorInformation literal.\r\n     */\r\n    function create(range, color) {\r\n        return {\r\n            range: range,\r\n            color: color,\r\n        };\r\n    }\r\n    ColorInformation.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Range.is(candidate.range) && Color.is(candidate.color);\r\n    }\r\n    ColorInformation.is = is;\r\n})(ColorInformation || (ColorInformation = {}));\r\n/**\r\n * The Color namespace provides helper functions to work with\r\n * [ColorPresentation](#ColorPresentation) literals.\r\n */\r\nvar ColorPresentation;\r\n(function (ColorPresentation) {\r\n    /**\r\n     * Creates a new ColorInformation literal.\r\n     */\r\n    function create(label, textEdit, additionalTextEdits) {\r\n        return {\r\n            label: label,\r\n            textEdit: textEdit,\r\n            additionalTextEdits: additionalTextEdits,\r\n        };\r\n    }\r\n    ColorPresentation.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.string(candidate.label)\r\n            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))\r\n            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\r\n    }\r\n    ColorPresentation.is = is;\r\n})(ColorPresentation || (ColorPresentation = {}));\r\n/**\r\n * Enum of known range kinds\r\n */\r\nvar FoldingRangeKind;\r\n(function (FoldingRangeKind) {\r\n    /**\r\n     * Folding range for a comment\r\n     */\r\n    FoldingRangeKind[\"Comment\"] = \"comment\";\r\n    /**\r\n     * Folding range for a imports or includes\r\n     */\r\n    FoldingRangeKind[\"Imports\"] = \"imports\";\r\n    /**\r\n     * Folding range for a region (e.g. `#region`)\r\n     */\r\n    FoldingRangeKind[\"Region\"] = \"region\";\r\n})(FoldingRangeKind || (FoldingRangeKind = {}));\r\n/**\r\n * The folding range namespace provides helper functions to work with\r\n * [FoldingRange](#FoldingRange) literals.\r\n */\r\nvar FoldingRange;\r\n(function (FoldingRange) {\r\n    /**\r\n     * Creates a new FoldingRange literal.\r\n     */\r\n    function create(startLine, endLine, startCharacter, endCharacter, kind) {\r\n        var result = {\r\n            startLine: startLine,\r\n            endLine: endLine\r\n        };\r\n        if (Is.defined(startCharacter)) {\r\n            result.startCharacter = startCharacter;\r\n        }\r\n        if (Is.defined(endCharacter)) {\r\n            result.endCharacter = endCharacter;\r\n        }\r\n        if (Is.defined(kind)) {\r\n            result.kind = kind;\r\n        }\r\n        return result;\r\n    }\r\n    FoldingRange.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.number(candidate.startLine) && Is.number(candidate.startLine)\r\n            && (Is.undefined(candidate.startCharacter) || Is.number(candidate.startCharacter))\r\n            && (Is.undefined(candidate.endCharacter) || Is.number(candidate.endCharacter))\r\n            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\r\n    }\r\n    FoldingRange.is = is;\r\n})(FoldingRange || (FoldingRange = {}));\r\n/**\r\n * The DiagnosticRelatedInformation namespace provides helper functions to work with\r\n * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.\r\n */\r\nvar DiagnosticRelatedInformation;\r\n(function (DiagnosticRelatedInformation) {\r\n    /**\r\n     * Creates a new DiagnosticRelatedInformation literal.\r\n     */\r\n    function create(location, message) {\r\n        return {\r\n            location: location,\r\n            message: message\r\n        };\r\n    }\r\n    DiagnosticRelatedInformation.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\r\n    }\r\n    DiagnosticRelatedInformation.is = is;\r\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\r\n/**\r\n * The diagnostic's severity.\r\n */\r\nvar DiagnosticSeverity;\r\n(function (DiagnosticSeverity) {\r\n    /**\r\n     * Reports an error.\r\n     */\r\n    DiagnosticSeverity.Error = 1;\r\n    /**\r\n     * Reports a warning.\r\n     */\r\n    DiagnosticSeverity.Warning = 2;\r\n    /**\r\n     * Reports an information.\r\n     */\r\n    DiagnosticSeverity.Information = 3;\r\n    /**\r\n     * Reports a hint.\r\n     */\r\n    DiagnosticSeverity.Hint = 4;\r\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\r\n/**\r\n * The diagnostic tags.\r\n *\r\n * @since 3.15.0\r\n */\r\nvar DiagnosticTag;\r\n(function (DiagnosticTag) {\r\n    /**\r\n     * Unused or unnecessary code.\r\n     *\r\n     * Clients are allowed to render diagnostics with this tag faded out instead of having\r\n     * an error squiggle.\r\n     */\r\n    DiagnosticTag.Unnecessary = 1;\r\n    /**\r\n     * Deprecated or obsolete code.\r\n     *\r\n     * Clients are allowed to rendered diagnostics with this tag strike through.\r\n     */\r\n    DiagnosticTag.Deprecated = 2;\r\n})(DiagnosticTag || (DiagnosticTag = {}));\r\n/**\r\n * The Diagnostic namespace provides helper functions to work with\r\n * [Diagnostic](#Diagnostic) literals.\r\n */\r\nvar Diagnostic;\r\n(function (Diagnostic) {\r\n    /**\r\n     * Creates a new Diagnostic literal.\r\n     */\r\n    function create(range, message, severity, code, source, relatedInformation) {\r\n        var result = { range: range, message: message };\r\n        if (Is.defined(severity)) {\r\n            result.severity = severity;\r\n        }\r\n        if (Is.defined(code)) {\r\n            result.code = code;\r\n        }\r\n        if (Is.defined(source)) {\r\n            result.source = source;\r\n        }\r\n        if (Is.defined(relatedInformation)) {\r\n            result.relatedInformation = relatedInformation;\r\n        }\r\n        return result;\r\n    }\r\n    Diagnostic.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate)\r\n            && Range.is(candidate.range)\r\n            && Is.string(candidate.message)\r\n            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\r\n            && (Is.number(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\r\n            && (Is.string(candidate.source) || Is.undefined(candidate.source))\r\n            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\r\n    }\r\n    Diagnostic.is = is;\r\n})(Diagnostic || (Diagnostic = {}));\r\n/**\r\n * The Command namespace provides helper functions to work with\r\n * [Command](#Command) literals.\r\n */\r\nvar Command;\r\n(function (Command) {\r\n    /**\r\n     * Creates a new Command literal.\r\n     */\r\n    function create(title, command) {\r\n        var args = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            args[_i - 2] = arguments[_i];\r\n        }\r\n        var result = { title: title, command: command };\r\n        if (Is.defined(args) && args.length > 0) {\r\n            result.arguments = args;\r\n        }\r\n        return result;\r\n    }\r\n    Command.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [Command](#Command) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\r\n    }\r\n    Command.is = is;\r\n})(Command || (Command = {}));\r\n/**\r\n * The TextEdit namespace provides helper function to create replace,\r\n * insert and delete edits more easily.\r\n */\r\nvar TextEdit;\r\n(function (TextEdit) {\r\n    /**\r\n     * Creates a replace text edit.\r\n     * @param range The range of text to be replaced.\r\n     * @param newText The new text.\r\n     */\r\n    function replace(range, newText) {\r\n        return { range: range, newText: newText };\r\n    }\r\n    TextEdit.replace = replace;\r\n    /**\r\n     * Creates a insert text edit.\r\n     * @param position The position to insert the text at.\r\n     * @param newText The text to be inserted.\r\n     */\r\n    function insert(position, newText) {\r\n        return { range: { start: position, end: position }, newText: newText };\r\n    }\r\n    TextEdit.insert = insert;\r\n    /**\r\n     * Creates a delete text edit.\r\n     * @param range The range of text to be deleted.\r\n     */\r\n    function del(range) {\r\n        return { range: range, newText: '' };\r\n    }\r\n    TextEdit.del = del;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.objectLiteral(candidate)\r\n            && Is.string(candidate.newText)\r\n            && Range.is(candidate.range);\r\n    }\r\n    TextEdit.is = is;\r\n})(TextEdit || (TextEdit = {}));\r\n/**\r\n * The TextDocumentEdit namespace provides helper function to create\r\n * an edit that manipulates a text document.\r\n */\r\nvar TextDocumentEdit;\r\n(function (TextDocumentEdit) {\r\n    /**\r\n     * Creates a new `TextDocumentEdit`\r\n     */\r\n    function create(textDocument, edits) {\r\n        return { textDocument: textDocument, edits: edits };\r\n    }\r\n    TextDocumentEdit.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate)\r\n            && VersionedTextDocumentIdentifier.is(candidate.textDocument)\r\n            && Array.isArray(candidate.edits);\r\n    }\r\n    TextDocumentEdit.is = is;\r\n})(TextDocumentEdit || (TextDocumentEdit = {}));\r\nvar CreateFile;\r\n(function (CreateFile) {\r\n    function create(uri, options) {\r\n        var result = {\r\n            kind: 'create',\r\n            uri: uri\r\n        };\r\n        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\r\n            result.options = options;\r\n        }\r\n        return result;\r\n    }\r\n    CreateFile.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) &&\r\n            (candidate.options === void 0 ||\r\n                ((candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))));\r\n    }\r\n    CreateFile.is = is;\r\n})(CreateFile || (CreateFile = {}));\r\nvar RenameFile;\r\n(function (RenameFile) {\r\n    function create(oldUri, newUri, options) {\r\n        var result = {\r\n            kind: 'rename',\r\n            oldUri: oldUri,\r\n            newUri: newUri\r\n        };\r\n        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\r\n            result.options = options;\r\n        }\r\n        return result;\r\n    }\r\n    RenameFile.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) &&\r\n            (candidate.options === void 0 ||\r\n                ((candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))));\r\n    }\r\n    RenameFile.is = is;\r\n})(RenameFile || (RenameFile = {}));\r\nvar DeleteFile;\r\n(function (DeleteFile) {\r\n    function create(uri, options) {\r\n        var result = {\r\n            kind: 'delete',\r\n            uri: uri\r\n        };\r\n        if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {\r\n            result.options = options;\r\n        }\r\n        return result;\r\n    }\r\n    DeleteFile.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) &&\r\n            (candidate.options === void 0 ||\r\n                ((candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))));\r\n    }\r\n    DeleteFile.is = is;\r\n})(DeleteFile || (DeleteFile = {}));\r\nvar WorkspaceEdit;\r\n(function (WorkspaceEdit) {\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate &&\r\n            (candidate.changes !== void 0 || candidate.documentChanges !== void 0) &&\r\n            (candidate.documentChanges === void 0 || candidate.documentChanges.every(function (change) {\r\n                if (Is.string(change.kind)) {\r\n                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\r\n                }\r\n                else {\r\n                    return TextDocumentEdit.is(change);\r\n                }\r\n            }));\r\n    }\r\n    WorkspaceEdit.is = is;\r\n})(WorkspaceEdit || (WorkspaceEdit = {}));\r\nvar TextEditChangeImpl = /** @class */ (function () {\r\n    function TextEditChangeImpl(edits) {\r\n        this.edits = edits;\r\n    }\r\n    TextEditChangeImpl.prototype.insert = function (position, newText) {\r\n        this.edits.push(TextEdit.insert(position, newText));\r\n    };\r\n    TextEditChangeImpl.prototype.replace = function (range, newText) {\r\n        this.edits.push(TextEdit.replace(range, newText));\r\n    };\r\n    TextEditChangeImpl.prototype.delete = function (range) {\r\n        this.edits.push(TextEdit.del(range));\r\n    };\r\n    TextEditChangeImpl.prototype.add = function (edit) {\r\n        this.edits.push(edit);\r\n    };\r\n    TextEditChangeImpl.prototype.all = function () {\r\n        return this.edits;\r\n    };\r\n    TextEditChangeImpl.prototype.clear = function () {\r\n        this.edits.splice(0, this.edits.length);\r\n    };\r\n    return TextEditChangeImpl;\r\n}());\r\n/**\r\n * A workspace change helps constructing changes to a workspace.\r\n */\r\nvar WorkspaceChange = /** @class */ (function () {\r\n    function WorkspaceChange(workspaceEdit) {\r\n        var _this = this;\r\n        this._textEditChanges = Object.create(null);\r\n        if (workspaceEdit) {\r\n            this._workspaceEdit = workspaceEdit;\r\n            if (workspaceEdit.documentChanges) {\r\n                workspaceEdit.documentChanges.forEach(function (change) {\r\n                    if (TextDocumentEdit.is(change)) {\r\n                        var textEditChange = new TextEditChangeImpl(change.edits);\r\n                        _this._textEditChanges[change.textDocument.uri] = textEditChange;\r\n                    }\r\n                });\r\n            }\r\n            else if (workspaceEdit.changes) {\r\n                Object.keys(workspaceEdit.changes).forEach(function (key) {\r\n                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\r\n                    _this._textEditChanges[key] = textEditChange;\r\n                });\r\n            }\r\n        }\r\n    }\r\n    Object.defineProperty(WorkspaceChange.prototype, \"edit\", {\r\n        /**\r\n         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal\r\n         * use to be returned from a workspace edit operation like rename.\r\n         */\r\n        get: function () {\r\n            return this._workspaceEdit;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    WorkspaceChange.prototype.getTextEditChange = function (key) {\r\n        if (VersionedTextDocumentIdentifier.is(key)) {\r\n            if (!this._workspaceEdit) {\r\n                this._workspaceEdit = {\r\n                    documentChanges: []\r\n                };\r\n            }\r\n            if (!this._workspaceEdit.documentChanges) {\r\n                throw new Error('Workspace edit is not configured for document changes.');\r\n            }\r\n            var textDocument = key;\r\n            var result = this._textEditChanges[textDocument.uri];\r\n            if (!result) {\r\n                var edits = [];\r\n                var textDocumentEdit = {\r\n                    textDocument: textDocument,\r\n                    edits: edits\r\n                };\r\n                this._workspaceEdit.documentChanges.push(textDocumentEdit);\r\n                result = new TextEditChangeImpl(edits);\r\n                this._textEditChanges[textDocument.uri] = result;\r\n            }\r\n            return result;\r\n        }\r\n        else {\r\n            if (!this._workspaceEdit) {\r\n                this._workspaceEdit = {\r\n                    changes: Object.create(null)\r\n                };\r\n            }\r\n            if (!this._workspaceEdit.changes) {\r\n                throw new Error('Workspace edit is not configured for normal text edit changes.');\r\n            }\r\n            var result = this._textEditChanges[key];\r\n            if (!result) {\r\n                var edits = [];\r\n                this._workspaceEdit.changes[key] = edits;\r\n                result = new TextEditChangeImpl(edits);\r\n                this._textEditChanges[key] = result;\r\n            }\r\n            return result;\r\n        }\r\n    };\r\n    WorkspaceChange.prototype.createFile = function (uri, options) {\r\n        this.checkDocumentChanges();\r\n        this._workspaceEdit.documentChanges.push(CreateFile.create(uri, options));\r\n    };\r\n    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, options) {\r\n        this.checkDocumentChanges();\r\n        this._workspaceEdit.documentChanges.push(RenameFile.create(oldUri, newUri, options));\r\n    };\r\n    WorkspaceChange.prototype.deleteFile = function (uri, options) {\r\n        this.checkDocumentChanges();\r\n        this._workspaceEdit.documentChanges.push(DeleteFile.create(uri, options));\r\n    };\r\n    WorkspaceChange.prototype.checkDocumentChanges = function () {\r\n        if (!this._workspaceEdit || !this._workspaceEdit.documentChanges) {\r\n            throw new Error('Workspace edit is not configured for document changes.');\r\n        }\r\n    };\r\n    return WorkspaceChange;\r\n}());\r\n\r\n/**\r\n * The TextDocumentIdentifier namespace provides helper functions to work with\r\n * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.\r\n */\r\nvar TextDocumentIdentifier;\r\n(function (TextDocumentIdentifier) {\r\n    /**\r\n     * Creates a new TextDocumentIdentifier literal.\r\n     * @param uri The document's uri.\r\n     */\r\n    function create(uri) {\r\n        return { uri: uri };\r\n    }\r\n    TextDocumentIdentifier.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri);\r\n    }\r\n    TextDocumentIdentifier.is = is;\r\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\r\n/**\r\n * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\r\n * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.\r\n */\r\nvar VersionedTextDocumentIdentifier;\r\n(function (VersionedTextDocumentIdentifier) {\r\n    /**\r\n     * Creates a new VersionedTextDocumentIdentifier literal.\r\n     * @param uri The document's uri.\r\n     * @param uri The document's text.\r\n     */\r\n    function create(uri, version) {\r\n        return { uri: uri, version: version };\r\n    }\r\n    VersionedTextDocumentIdentifier.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.number(candidate.version));\r\n    }\r\n    VersionedTextDocumentIdentifier.is = is;\r\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\r\n/**\r\n * The TextDocumentItem namespace provides helper functions to work with\r\n * [TextDocumentItem](#TextDocumentItem) literals.\r\n */\r\nvar TextDocumentItem;\r\n(function (TextDocumentItem) {\r\n    /**\r\n     * Creates a new TextDocumentItem literal.\r\n     * @param uri The document's uri.\r\n     * @param languageId The document's language identifier.\r\n     * @param version The document's version number.\r\n     * @param text The document's text.\r\n     */\r\n    function create(uri, languageId, version, text) {\r\n        return { uri: uri, languageId: languageId, version: version, text: text };\r\n    }\r\n    TextDocumentItem.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.number(candidate.version) && Is.string(candidate.text);\r\n    }\r\n    TextDocumentItem.is = is;\r\n})(TextDocumentItem || (TextDocumentItem = {}));\r\n/**\r\n * Describes the content type that a client supports in various\r\n * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\r\n *\r\n * Please note that `MarkupKinds` must not start with a `$`. This kinds\r\n * are reserved for internal usage.\r\n */\r\nvar MarkupKind;\r\n(function (MarkupKind) {\r\n    /**\r\n     * Plain text is supported as a content format\r\n     */\r\n    MarkupKind.PlainText = 'plaintext';\r\n    /**\r\n     * Markdown is supported as a content format\r\n     */\r\n    MarkupKind.Markdown = 'markdown';\r\n})(MarkupKind || (MarkupKind = {}));\r\n(function (MarkupKind) {\r\n    /**\r\n     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\r\n    }\r\n    MarkupKind.is = is;\r\n})(MarkupKind || (MarkupKind = {}));\r\nvar MarkupContent;\r\n(function (MarkupContent) {\r\n    /**\r\n     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\r\n    }\r\n    MarkupContent.is = is;\r\n})(MarkupContent || (MarkupContent = {}));\r\n/**\r\n * The kind of a completion entry.\r\n */\r\nvar CompletionItemKind;\r\n(function (CompletionItemKind) {\r\n    CompletionItemKind.Text = 1;\r\n    CompletionItemKind.Method = 2;\r\n    CompletionItemKind.Function = 3;\r\n    CompletionItemKind.Constructor = 4;\r\n    CompletionItemKind.Field = 5;\r\n    CompletionItemKind.Variable = 6;\r\n    CompletionItemKind.Class = 7;\r\n    CompletionItemKind.Interface = 8;\r\n    CompletionItemKind.Module = 9;\r\n    CompletionItemKind.Property = 10;\r\n    CompletionItemKind.Unit = 11;\r\n    CompletionItemKind.Value = 12;\r\n    CompletionItemKind.Enum = 13;\r\n    CompletionItemKind.Keyword = 14;\r\n    CompletionItemKind.Snippet = 15;\r\n    CompletionItemKind.Color = 16;\r\n    CompletionItemKind.File = 17;\r\n    CompletionItemKind.Reference = 18;\r\n    CompletionItemKind.Folder = 19;\r\n    CompletionItemKind.EnumMember = 20;\r\n    CompletionItemKind.Constant = 21;\r\n    CompletionItemKind.Struct = 22;\r\n    CompletionItemKind.Event = 23;\r\n    CompletionItemKind.Operator = 24;\r\n    CompletionItemKind.TypeParameter = 25;\r\n})(CompletionItemKind || (CompletionItemKind = {}));\r\n/**\r\n * Defines whether the insert text in a completion item should be interpreted as\r\n * plain text or a snippet.\r\n */\r\nvar InsertTextFormat;\r\n(function (InsertTextFormat) {\r\n    /**\r\n     * The primary text to be inserted is treated as a plain string.\r\n     */\r\n    InsertTextFormat.PlainText = 1;\r\n    /**\r\n     * The primary text to be inserted is treated as a snippet.\r\n     *\r\n     * A snippet can define tab stops and placeholders with `$1`, `$2`\r\n     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\r\n     * the end of the snippet. Placeholders with equal identifiers are linked,\r\n     * that is typing in one will update others too.\r\n     *\r\n     * See also: https://github.com/Microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/common/snippet.md\r\n     */\r\n    InsertTextFormat.Snippet = 2;\r\n})(InsertTextFormat || (InsertTextFormat = {}));\r\n/**\r\n * Completion item tags are extra annotations that tweak the rendering of a completion\r\n * item.\r\n *\r\n * @since 3.15.0\r\n */\r\nvar CompletionItemTag;\r\n(function (CompletionItemTag) {\r\n    /**\r\n     * Render a completion as obsolete, usually using a strike-out.\r\n     */\r\n    CompletionItemTag.Deprecated = 1;\r\n})(CompletionItemTag || (CompletionItemTag = {}));\r\n/**\r\n * The CompletionItem namespace provides functions to deal with\r\n * completion items.\r\n */\r\nvar CompletionItem;\r\n(function (CompletionItem) {\r\n    /**\r\n     * Create a completion item and seed it with a label.\r\n     * @param label The completion item's label\r\n     */\r\n    function create(label) {\r\n        return { label: label };\r\n    }\r\n    CompletionItem.create = create;\r\n})(CompletionItem || (CompletionItem = {}));\r\n/**\r\n * The CompletionList namespace provides functions to deal with\r\n * completion lists.\r\n */\r\nvar CompletionList;\r\n(function (CompletionList) {\r\n    /**\r\n     * Creates a new completion list.\r\n     *\r\n     * @param items The completion items.\r\n     * @param isIncomplete The list is not complete.\r\n     */\r\n    function create(items, isIncomplete) {\r\n        return { items: items ? items : [], isIncomplete: !!isIncomplete };\r\n    }\r\n    CompletionList.create = create;\r\n})(CompletionList || (CompletionList = {}));\r\nvar MarkedString;\r\n(function (MarkedString) {\r\n    /**\r\n     * Creates a marked string from plain text.\r\n     *\r\n     * @param plainText The plain text.\r\n     */\r\n    function fromPlainText(plainText) {\r\n        return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\r\n    }\r\n    MarkedString.fromPlainText = fromPlainText;\r\n    /**\r\n     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\r\n    }\r\n    MarkedString.is = is;\r\n})(MarkedString || (MarkedString = {}));\r\nvar Hover;\r\n(function (Hover) {\r\n    /**\r\n     * Checks whether the given value conforms to the [Hover](#Hover) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\r\n            MarkedString.is(candidate.contents) ||\r\n            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));\r\n    }\r\n    Hover.is = is;\r\n})(Hover || (Hover = {}));\r\n/**\r\n * The ParameterInformation namespace provides helper functions to work with\r\n * [ParameterInformation](#ParameterInformation) literals.\r\n */\r\nvar ParameterInformation;\r\n(function (ParameterInformation) {\r\n    /**\r\n     * Creates a new parameter information literal.\r\n     *\r\n     * @param label A label string.\r\n     * @param documentation A doc string.\r\n     */\r\n    function create(label, documentation) {\r\n        return documentation ? { label: label, documentation: documentation } : { label: label };\r\n    }\r\n    ParameterInformation.create = create;\r\n})(ParameterInformation || (ParameterInformation = {}));\r\n/**\r\n * The SignatureInformation namespace provides helper functions to work with\r\n * [SignatureInformation](#SignatureInformation) literals.\r\n */\r\nvar SignatureInformation;\r\n(function (SignatureInformation) {\r\n    function create(label, documentation) {\r\n        var parameters = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            parameters[_i - 2] = arguments[_i];\r\n        }\r\n        var result = { label: label };\r\n        if (Is.defined(documentation)) {\r\n            result.documentation = documentation;\r\n        }\r\n        if (Is.defined(parameters)) {\r\n            result.parameters = parameters;\r\n        }\r\n        else {\r\n            result.parameters = [];\r\n        }\r\n        return result;\r\n    }\r\n    SignatureInformation.create = create;\r\n})(SignatureInformation || (SignatureInformation = {}));\r\n/**\r\n * A document highlight kind.\r\n */\r\nvar DocumentHighlightKind;\r\n(function (DocumentHighlightKind) {\r\n    /**\r\n     * A textual occurrence.\r\n     */\r\n    DocumentHighlightKind.Text = 1;\r\n    /**\r\n     * Read-access of a symbol, like reading a variable.\r\n     */\r\n    DocumentHighlightKind.Read = 2;\r\n    /**\r\n     * Write-access of a symbol, like writing to a variable.\r\n     */\r\n    DocumentHighlightKind.Write = 3;\r\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\r\n/**\r\n * DocumentHighlight namespace to provide helper functions to work with\r\n * [DocumentHighlight](#DocumentHighlight) literals.\r\n */\r\nvar DocumentHighlight;\r\n(function (DocumentHighlight) {\r\n    /**\r\n     * Create a DocumentHighlight object.\r\n     * @param range The range the highlight applies to.\r\n     */\r\n    function create(range, kind) {\r\n        var result = { range: range };\r\n        if (Is.number(kind)) {\r\n            result.kind = kind;\r\n        }\r\n        return result;\r\n    }\r\n    DocumentHighlight.create = create;\r\n})(DocumentHighlight || (DocumentHighlight = {}));\r\n/**\r\n * A symbol kind.\r\n */\r\nvar SymbolKind;\r\n(function (SymbolKind) {\r\n    SymbolKind.File = 1;\r\n    SymbolKind.Module = 2;\r\n    SymbolKind.Namespace = 3;\r\n    SymbolKind.Package = 4;\r\n    SymbolKind.Class = 5;\r\n    SymbolKind.Method = 6;\r\n    SymbolKind.Property = 7;\r\n    SymbolKind.Field = 8;\r\n    SymbolKind.Constructor = 9;\r\n    SymbolKind.Enum = 10;\r\n    SymbolKind.Interface = 11;\r\n    SymbolKind.Function = 12;\r\n    SymbolKind.Variable = 13;\r\n    SymbolKind.Constant = 14;\r\n    SymbolKind.String = 15;\r\n    SymbolKind.Number = 16;\r\n    SymbolKind.Boolean = 17;\r\n    SymbolKind.Array = 18;\r\n    SymbolKind.Object = 19;\r\n    SymbolKind.Key = 20;\r\n    SymbolKind.Null = 21;\r\n    SymbolKind.EnumMember = 22;\r\n    SymbolKind.Struct = 23;\r\n    SymbolKind.Event = 24;\r\n    SymbolKind.Operator = 25;\r\n    SymbolKind.TypeParameter = 26;\r\n})(SymbolKind || (SymbolKind = {}));\r\n/**\r\n * Symbol tags are extra annotations that tweak the rendering of a symbol.\r\n * @since 3.15\r\n */\r\nvar SymbolTag;\r\n(function (SymbolTag) {\r\n    /**\r\n     * Render a symbol as obsolete, usually using a strike-out.\r\n     */\r\n    SymbolTag.Deprecated = 1;\r\n})(SymbolTag || (SymbolTag = {}));\r\nvar SymbolInformation;\r\n(function (SymbolInformation) {\r\n    /**\r\n     * Creates a new symbol information literal.\r\n     *\r\n     * @param name The name of the symbol.\r\n     * @param kind The kind of the symbol.\r\n     * @param range The range of the location of the symbol.\r\n     * @param uri The resource of the location of symbol, defaults to the current document.\r\n     * @param containerName The name of the symbol containing the symbol.\r\n     */\r\n    function create(name, kind, range, uri, containerName) {\r\n        var result = {\r\n            name: name,\r\n            kind: kind,\r\n            location: { uri: uri, range: range }\r\n        };\r\n        if (containerName) {\r\n            result.containerName = containerName;\r\n        }\r\n        return result;\r\n    }\r\n    SymbolInformation.create = create;\r\n})(SymbolInformation || (SymbolInformation = {}));\r\nvar DocumentSymbol;\r\n(function (DocumentSymbol) {\r\n    /**\r\n     * Creates a new symbol information literal.\r\n     *\r\n     * @param name The name of the symbol.\r\n     * @param detail The detail of the symbol.\r\n     * @param kind The kind of the symbol.\r\n     * @param range The range of the symbol.\r\n     * @param selectionRange The selectionRange of the symbol.\r\n     * @param children Children of the symbol.\r\n     */\r\n    function create(name, detail, kind, range, selectionRange, children) {\r\n        var result = {\r\n            name: name,\r\n            detail: detail,\r\n            kind: kind,\r\n            range: range,\r\n            selectionRange: selectionRange\r\n        };\r\n        if (children !== void 0) {\r\n            result.children = children;\r\n        }\r\n        return result;\r\n    }\r\n    DocumentSymbol.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate &&\r\n            Is.string(candidate.name) && Is.number(candidate.kind) &&\r\n            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&\r\n            (candidate.detail === void 0 || Is.string(candidate.detail)) &&\r\n            (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) &&\r\n            (candidate.children === void 0 || Array.isArray(candidate.children));\r\n    }\r\n    DocumentSymbol.is = is;\r\n})(DocumentSymbol || (DocumentSymbol = {}));\r\n/**\r\n * A set of predefined code action kinds\r\n */\r\nvar CodeActionKind;\r\n(function (CodeActionKind) {\r\n    /**\r\n     * Empty kind.\r\n     */\r\n    CodeActionKind.Empty = '';\r\n    /**\r\n     * Base kind for quickfix actions: 'quickfix'\r\n     */\r\n    CodeActionKind.QuickFix = 'quickfix';\r\n    /**\r\n     * Base kind for refactoring actions: 'refactor'\r\n     */\r\n    CodeActionKind.Refactor = 'refactor';\r\n    /**\r\n     * Base kind for refactoring extraction actions: 'refactor.extract'\r\n     *\r\n     * Example extract actions:\r\n     *\r\n     * - Extract method\r\n     * - Extract function\r\n     * - Extract variable\r\n     * - Extract interface from class\r\n     * - ...\r\n     */\r\n    CodeActionKind.RefactorExtract = 'refactor.extract';\r\n    /**\r\n     * Base kind for refactoring inline actions: 'refactor.inline'\r\n     *\r\n     * Example inline actions:\r\n     *\r\n     * - Inline function\r\n     * - Inline variable\r\n     * - Inline constant\r\n     * - ...\r\n     */\r\n    CodeActionKind.RefactorInline = 'refactor.inline';\r\n    /**\r\n     * Base kind for refactoring rewrite actions: 'refactor.rewrite'\r\n     *\r\n     * Example rewrite actions:\r\n     *\r\n     * - Convert JavaScript function to class\r\n     * - Add or remove parameter\r\n     * - Encapsulate field\r\n     * - Make method static\r\n     * - Move method to base class\r\n     * - ...\r\n     */\r\n    CodeActionKind.RefactorRewrite = 'refactor.rewrite';\r\n    /**\r\n     * Base kind for source actions: `source`\r\n     *\r\n     * Source code actions apply to the entire file.\r\n     */\r\n    CodeActionKind.Source = 'source';\r\n    /**\r\n     * Base kind for an organize imports source action: `source.organizeImports`\r\n     */\r\n    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\r\n    /**\r\n     * Base kind for auto-fix source actions: `source.fixAll`.\r\n     *\r\n     * Fix all actions automatically fix errors that have a clear fix that do not require user input.\r\n     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\r\n     *\r\n     * @since 3.15.0\r\n     */\r\n    CodeActionKind.SourceFixAll = 'source.fixAll';\r\n})(CodeActionKind || (CodeActionKind = {}));\r\n/**\r\n * The CodeActionContext namespace provides helper functions to work with\r\n * [CodeActionContext](#CodeActionContext) literals.\r\n */\r\nvar CodeActionContext;\r\n(function (CodeActionContext) {\r\n    /**\r\n     * Creates a new CodeActionContext literal.\r\n     */\r\n    function create(diagnostics, only) {\r\n        var result = { diagnostics: diagnostics };\r\n        if (only !== void 0 && only !== null) {\r\n            result.only = only;\r\n        }\r\n        return result;\r\n    }\r\n    CodeActionContext.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));\r\n    }\r\n    CodeActionContext.is = is;\r\n})(CodeActionContext || (CodeActionContext = {}));\r\nvar CodeAction;\r\n(function (CodeAction) {\r\n    function create(title, commandOrEdit, kind) {\r\n        var result = { title: title };\r\n        if (Command.is(commandOrEdit)) {\r\n            result.command = commandOrEdit;\r\n        }\r\n        else {\r\n            result.edit = commandOrEdit;\r\n        }\r\n        if (kind !== void 0) {\r\n            result.kind = kind;\r\n        }\r\n        return result;\r\n    }\r\n    CodeAction.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate && Is.string(candidate.title) &&\r\n            (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&\r\n            (candidate.kind === void 0 || Is.string(candidate.kind)) &&\r\n            (candidate.edit !== void 0 || candidate.command !== void 0) &&\r\n            (candidate.command === void 0 || Command.is(candidate.command)) &&\r\n            (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) &&\r\n            (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));\r\n    }\r\n    CodeAction.is = is;\r\n})(CodeAction || (CodeAction = {}));\r\n/**\r\n * The CodeLens namespace provides helper functions to work with\r\n * [CodeLens](#CodeLens) literals.\r\n */\r\nvar CodeLens;\r\n(function (CodeLens) {\r\n    /**\r\n     * Creates a new CodeLens literal.\r\n     */\r\n    function create(range, data) {\r\n        var result = { range: range };\r\n        if (Is.defined(data)) {\r\n            result.data = data;\r\n        }\r\n        return result;\r\n    }\r\n    CodeLens.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\r\n    }\r\n    CodeLens.is = is;\r\n})(CodeLens || (CodeLens = {}));\r\n/**\r\n * The FormattingOptions namespace provides helper functions to work with\r\n * [FormattingOptions](#FormattingOptions) literals.\r\n */\r\nvar FormattingOptions;\r\n(function (FormattingOptions) {\r\n    /**\r\n     * Creates a new FormattingOptions literal.\r\n     */\r\n    function create(tabSize, insertSpaces) {\r\n        return { tabSize: tabSize, insertSpaces: insertSpaces };\r\n    }\r\n    FormattingOptions.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.number(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\r\n    }\r\n    FormattingOptions.is = is;\r\n})(FormattingOptions || (FormattingOptions = {}));\r\n/**\r\n * The DocumentLink namespace provides helper functions to work with\r\n * [DocumentLink](#DocumentLink) literals.\r\n */\r\nvar DocumentLink;\r\n(function (DocumentLink) {\r\n    /**\r\n     * Creates a new DocumentLink literal.\r\n     */\r\n    function create(range, target, data) {\r\n        return { range: range, target: target, data: data };\r\n    }\r\n    DocumentLink.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\r\n    }\r\n    DocumentLink.is = is;\r\n})(DocumentLink || (DocumentLink = {}));\r\n/**\r\n * The SelectionRange namespace provides helper function to work with\r\n * SelectionRange literals.\r\n */\r\nvar SelectionRange;\r\n(function (SelectionRange) {\r\n    /**\r\n     * Creates a new SelectionRange\r\n     * @param range the range.\r\n     * @param parent an optional parent.\r\n     */\r\n    function create(range, parent) {\r\n        return { range: range, parent: parent };\r\n    }\r\n    SelectionRange.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate !== undefined && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\r\n    }\r\n    SelectionRange.is = is;\r\n})(SelectionRange || (SelectionRange = {}));\r\nvar EOL = ['\\n', '\\r\\n', '\\r'];\r\n/**\r\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\r\n */\r\nvar TextDocument;\r\n(function (TextDocument) {\r\n    /**\r\n     * Creates a new ITextDocument literal from the given uri and content.\r\n     * @param uri The document's uri.\r\n     * @param languageId  The document's language Id.\r\n     * @param content The document's content.\r\n     */\r\n    function create(uri, languageId, version, content) {\r\n        return new FullTextDocument(uri, languageId, version, content);\r\n    }\r\n    TextDocument.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.number(candidate.lineCount)\r\n            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\r\n    }\r\n    TextDocument.is = is;\r\n    function applyEdits(document, edits) {\r\n        var text = document.getText();\r\n        var sortedEdits = mergeSort(edits, function (a, b) {\r\n            var diff = a.range.start.line - b.range.start.line;\r\n            if (diff === 0) {\r\n                return a.range.start.character - b.range.start.character;\r\n            }\r\n            return diff;\r\n        });\r\n        var lastModifiedOffset = text.length;\r\n        for (var i = sortedEdits.length - 1; i >= 0; i--) {\r\n            var e = sortedEdits[i];\r\n            var startOffset = document.offsetAt(e.range.start);\r\n            var endOffset = document.offsetAt(e.range.end);\r\n            if (endOffset <= lastModifiedOffset) {\r\n                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\r\n            }\r\n            else {\r\n                throw new Error('Overlapping edit');\r\n            }\r\n            lastModifiedOffset = startOffset;\r\n        }\r\n        return text;\r\n    }\r\n    TextDocument.applyEdits = applyEdits;\r\n    function mergeSort(data, compare) {\r\n        if (data.length <= 1) {\r\n            // sorted\r\n            return data;\r\n        }\r\n        var p = (data.length / 2) | 0;\r\n        var left = data.slice(0, p);\r\n        var right = data.slice(p);\r\n        mergeSort(left, compare);\r\n        mergeSort(right, compare);\r\n        var leftIdx = 0;\r\n        var rightIdx = 0;\r\n        var i = 0;\r\n        while (leftIdx < left.length && rightIdx < right.length) {\r\n            var ret = compare(left[leftIdx], right[rightIdx]);\r\n            if (ret <= 0) {\r\n                // smaller_equal -> take left to preserve order\r\n                data[i++] = left[leftIdx++];\r\n            }\r\n            else {\r\n                // greater -> take right\r\n                data[i++] = right[rightIdx++];\r\n            }\r\n        }\r\n        while (leftIdx < left.length) {\r\n            data[i++] = left[leftIdx++];\r\n        }\r\n        while (rightIdx < right.length) {\r\n            data[i++] = right[rightIdx++];\r\n        }\r\n        return data;\r\n    }\r\n})(TextDocument || (TextDocument = {}));\r\nvar FullTextDocument = /** @class */ (function () {\r\n    function FullTextDocument(uri, languageId, version, content) {\r\n        this._uri = uri;\r\n        this._languageId = languageId;\r\n        this._version = version;\r\n        this._content = content;\r\n        this._lineOffsets = undefined;\r\n    }\r\n    Object.defineProperty(FullTextDocument.prototype, \"uri\", {\r\n        get: function () {\r\n            return this._uri;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\r\n        get: function () {\r\n            return this._languageId;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FullTextDocument.prototype, \"version\", {\r\n        get: function () {\r\n            return this._version;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FullTextDocument.prototype.getText = function (range) {\r\n        if (range) {\r\n            var start = this.offsetAt(range.start);\r\n            var end = this.offsetAt(range.end);\r\n            return this._content.substring(start, end);\r\n        }\r\n        return this._content;\r\n    };\r\n    FullTextDocument.prototype.update = function (event, version) {\r\n        this._content = event.text;\r\n        this._version = version;\r\n        this._lineOffsets = undefined;\r\n    };\r\n    FullTextDocument.prototype.getLineOffsets = function () {\r\n        if (this._lineOffsets === undefined) {\r\n            var lineOffsets = [];\r\n            var text = this._content;\r\n            var isLineStart = true;\r\n            for (var i = 0; i < text.length; i++) {\r\n                if (isLineStart) {\r\n                    lineOffsets.push(i);\r\n                    isLineStart = false;\r\n                }\r\n                var ch = text.charAt(i);\r\n                isLineStart = (ch === '\\r' || ch === '\\n');\r\n                if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\r\n                    i++;\r\n                }\r\n            }\r\n            if (isLineStart && text.length > 0) {\r\n                lineOffsets.push(text.length);\r\n            }\r\n            this._lineOffsets = lineOffsets;\r\n        }\r\n        return this._lineOffsets;\r\n    };\r\n    FullTextDocument.prototype.positionAt = function (offset) {\r\n        offset = Math.max(Math.min(offset, this._content.length), 0);\r\n        var lineOffsets = this.getLineOffsets();\r\n        var low = 0, high = lineOffsets.length;\r\n        if (high === 0) {\r\n            return Position.create(0, offset);\r\n        }\r\n        while (low < high) {\r\n            var mid = Math.floor((low + high) / 2);\r\n            if (lineOffsets[mid] > offset) {\r\n                high = mid;\r\n            }\r\n            else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n        // low is the least x for which the line offset is larger than the current offset\r\n        // or array.length if no line offset is larger than the current offset\r\n        var line = low - 1;\r\n        return Position.create(line, offset - lineOffsets[line]);\r\n    };\r\n    FullTextDocument.prototype.offsetAt = function (position) {\r\n        var lineOffsets = this.getLineOffsets();\r\n        if (position.line >= lineOffsets.length) {\r\n            return this._content.length;\r\n        }\r\n        else if (position.line < 0) {\r\n            return 0;\r\n        }\r\n        var lineOffset = lineOffsets[position.line];\r\n        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\r\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\r\n    };\r\n    Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\r\n        get: function () {\r\n            return this.getLineOffsets().length;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return FullTextDocument;\r\n}());\r\nvar Is;\r\n(function (Is) {\r\n    var toString = Object.prototype.toString;\r\n    function defined(value) {\r\n        return typeof value !== 'undefined';\r\n    }\r\n    Is.defined = defined;\r\n    function undefined(value) {\r\n        return typeof value === 'undefined';\r\n    }\r\n    Is.undefined = undefined;\r\n    function boolean(value) {\r\n        return value === true || value === false;\r\n    }\r\n    Is.boolean = boolean;\r\n    function string(value) {\r\n        return toString.call(value) === '[object String]';\r\n    }\r\n    Is.string = string;\r\n    function number(value) {\r\n        return toString.call(value) === '[object Number]';\r\n    }\r\n    Is.number = number;\r\n    function func(value) {\r\n        return toString.call(value) === '[object Function]';\r\n    }\r\n    Is.func = func;\r\n    function objectLiteral(value) {\r\n        // Strictly speaking class instances pass this check as well. Since the LSP\r\n        // doesn't use classes we ignore this for now. If we do we need to add something\r\n        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\r\n        return value !== null && typeof value === 'object';\r\n    }\r\n    Is.objectLiteral = objectLiteral;\r\n    function typedArray(value, check) {\r\n        return Array.isArray(value) && value.every(check);\r\n    }\r\n    Is.typedArray = typedArray;\r\n})(Is || (Is = {}));\r\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-languageserver-types/lib/esm/main.js?");

/***/ }),

/***/ "./node_modules/vscode-uri/lib/esm/index.js":
/*!**************************************************!*\
  !*** ./node_modules/vscode-uri/lib/esm/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"URI\": () => /* binding */ URI,\n/* harmony export */   \"uriToFsPath\": () => /* binding */ uriToFsPath\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar _a;\nvar isWindows;\nif (typeof process === 'object') {\n    isWindows = process.platform === 'win32';\n}\nelse if (typeof navigator === 'object') {\n    var userAgent = navigator.userAgent;\n    isWindows = userAgent.indexOf('Windows') >= 0;\n}\nfunction isHighSurrogate(charCode) {\n    return (0xD800 <= charCode && charCode <= 0xDBFF);\n}\nfunction isLowSurrogate(charCode) {\n    return (0xDC00 <= charCode && charCode <= 0xDFFF);\n}\nfunction isLowerAsciiHex(code) {\n    return code >= 97 /* a */ && code <= 102 /* f */;\n}\nfunction isLowerAsciiLetter(code) {\n    return code >= 97 /* a */ && code <= 122 /* z */;\n}\nfunction isUpperAsciiLetter(code) {\n    return code >= 65 /* A */ && code <= 90 /* Z */;\n}\nfunction isAsciiLetter(code) {\n    return isLowerAsciiLetter(code) || isUpperAsciiLetter(code);\n}\n//#endregion\nvar _schemePattern = /^\\w[\\w\\d+.-]*$/;\nvar _singleSlashStart = /^\\//;\nvar _doubleSlashStart = /^\\/\\//;\nfunction _validateUri(ret, _strict) {\n    // scheme, must be set\n    if (!ret.scheme && _strict) {\n        throw new Error(\"[UriError]: Scheme is missing: {scheme: \\\"\\\", authority: \\\"\" + ret.authority + \"\\\", path: \\\"\" + ret.path + \"\\\", query: \\\"\" + ret.query + \"\\\", fragment: \\\"\" + ret.fragment + \"\\\"}\");\n    }\n    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n    // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n    if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n        throw new Error('[UriError]: Scheme contains illegal characters.');\n    }\n    // path, http://tools.ietf.org/html/rfc3986#section-3.3\n    // If a URI contains an authority component, then the path component\n    // must either be empty or begin with a slash (\"/\") character.  If a URI\n    // does not contain an authority component, then the path cannot begin\n    // with two slash characters (\"//\").\n    if (ret.path) {\n        if (ret.authority) {\n            if (!_singleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n            }\n        }\n        else {\n            if (_doubleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n            }\n        }\n    }\n}\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme, _strict) {\n    if (!scheme && !_strict) {\n        return 'file';\n    }\n    return scheme;\n}\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme, path) {\n    // the slash-character is our 'default base' as we don't\n    // support constructing URIs relative to other URIs. This\n    // also means that we alter and potentially break paths.\n    // see https://tools.ietf.org/html/rfc3986#section-5.1.4\n    switch (scheme) {\n        case 'https':\n        case 'http':\n        case 'file':\n            if (!path) {\n                path = _slash;\n            }\n            else if (path[0] !== _slash) {\n                path = _slash + path;\n            }\n            break;\n    }\n    return path;\n}\nvar _empty = '';\nvar _slash = '/';\nvar _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nvar URI = /** @class */ (function () {\n    /**\n     * @internal\n     */\n    function URI(schemeOrData, authority, path, query, fragment, _strict) {\n        if (_strict === void 0) { _strict = false; }\n        if (typeof schemeOrData === 'object') {\n            this.scheme = schemeOrData.scheme || _empty;\n            this.authority = schemeOrData.authority || _empty;\n            this.path = schemeOrData.path || _empty;\n            this.query = schemeOrData.query || _empty;\n            this.fragment = schemeOrData.fragment || _empty;\n            // no validation because it's this URI\n            // that creates uri components.\n            // _validateUri(this);\n        }\n        else {\n            this.scheme = _schemeFix(schemeOrData, _strict);\n            this.authority = authority || _empty;\n            this.path = _referenceResolution(this.scheme, path || _empty);\n            this.query = query || _empty;\n            this.fragment = fragment || _empty;\n            _validateUri(this, _strict);\n        }\n    }\n    URI.isUri = function (thing) {\n        if (thing instanceof URI) {\n            return true;\n        }\n        if (!thing) {\n            return false;\n        }\n        return typeof thing.authority === 'string'\n            && typeof thing.fragment === 'string'\n            && typeof thing.path === 'string'\n            && typeof thing.query === 'string'\n            && typeof thing.scheme === 'string'\n            && typeof thing.fsPath === 'function'\n            && typeof thing.with === 'function'\n            && typeof thing.toString === 'function';\n    };\n    Object.defineProperty(URI.prototype, \"fsPath\", {\n        // ---- filesystem path -----------------------\n        /**\n         * Returns a string representing the corresponding file system path of this URI.\n         * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n         * platform specific path separator.\n         *\n         * * Will *not* validate the path for invalid characters and semantics.\n         * * Will *not* look at the scheme of this URI.\n         * * The result shall *not* be used for display purposes but for accessing a file on disk.\n         *\n         *\n         * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n         * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n         *\n         * ```ts\n            const u = URI.parse('file://server/c$/folder/file.txt')\n            u.authority === 'server'\n            u.path === '/shares/c$/file.txt'\n            u.fsPath === '\\\\server\\c$\\folder\\file.txt'\n        ```\n         *\n         * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n         * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n         * with URIs that represent files on disk (`file` scheme).\n         */\n        get: function () {\n            // if (this.scheme !== 'file') {\n            // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n            // }\n            return uriToFsPath(this, false);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // ---- modify to new -------------------------\n    URI.prototype.with = function (change) {\n        if (!change) {\n            return this;\n        }\n        var scheme = change.scheme, authority = change.authority, path = change.path, query = change.query, fragment = change.fragment;\n        if (scheme === undefined) {\n            scheme = this.scheme;\n        }\n        else if (scheme === null) {\n            scheme = _empty;\n        }\n        if (authority === undefined) {\n            authority = this.authority;\n        }\n        else if (authority === null) {\n            authority = _empty;\n        }\n        if (path === undefined) {\n            path = this.path;\n        }\n        else if (path === null) {\n            path = _empty;\n        }\n        if (query === undefined) {\n            query = this.query;\n        }\n        else if (query === null) {\n            query = _empty;\n        }\n        if (fragment === undefined) {\n            fragment = this.fragment;\n        }\n        else if (fragment === null) {\n            fragment = _empty;\n        }\n        if (scheme === this.scheme\n            && authority === this.authority\n            && path === this.path\n            && query === this.query\n            && fragment === this.fragment) {\n            return this;\n        }\n        return new _URI(scheme, authority, path, query, fragment);\n    };\n    // ---- parse & validate ------------------------\n    /**\n     * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\n     * `file:///usr/home`, or `scheme:with/path`.\n     *\n     * @param value A string which represents an URI (see `URI#toString`).\n     */\n    URI.parse = function (value, _strict) {\n        if (_strict === void 0) { _strict = false; }\n        var match = _regexp.exec(value);\n        if (!match) {\n            return new _URI(_empty, _empty, _empty, _empty, _empty);\n        }\n        return new _URI(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);\n    };\n    /**\n     * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n     * `/usr/home`, or `\\\\server\\share\\some\\path`.\n     *\n     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n     * `URI.parse('file://' + path)` because the path might contain characters that are\n     * interpreted (# and ?). See the following sample:\n     * ```ts\n    const good = URI.file('/coding/c#/project1');\n    good.scheme === 'file';\n    good.path === '/coding/c#/project1';\n    good.fragment === '';\n    const bad = URI.parse('file://' + '/coding/c#/project1');\n    bad.scheme === 'file';\n    bad.path === '/coding/c'; // path is now broken\n    bad.fragment === '/project1';\n    ```\n     *\n     * @param path A file system path (see `URI#fsPath`)\n     */\n    URI.file = function (path) {\n        var authority = _empty;\n        // normalize to fwd-slashes on windows,\n        // on other systems bwd-slashes are valid\n        // filename character, eg /f\\oo/ba\\r.txt\n        if (isWindows) {\n            path = path.replace(/\\\\/g, _slash);\n        }\n        // check for authority as used in UNC shares\n        // or use the path as given\n        if (path[0] === _slash && path[1] === _slash) {\n            var idx = path.indexOf(_slash, 2);\n            if (idx === -1) {\n                authority = path.substring(2);\n                path = _slash;\n            }\n            else {\n                authority = path.substring(2, idx);\n                path = path.substring(idx) || _slash;\n            }\n        }\n        return new _URI('file', authority, path, _empty, _empty);\n    };\n    URI.from = function (components) {\n        return new _URI(components.scheme, components.authority, components.path, components.query, components.fragment);\n    };\n    // /**\n    //  * Join a URI path with path fragments and normalizes the resulting path.\n    //  *\n    //  * @param uri The input URI.\n    //  * @param pathFragment The path fragment to add to the URI path.\n    //  * @returns The resulting URI.\n    //  */\n    // static joinPath(uri: URI, ...pathFragment: string[]): URI {\n    // \tif (!uri.path) {\n    // \t\tthrow new Error(`[UriError]: cannot call joinPaths on URI without path`);\n    // \t}\n    // \tlet newPath: string;\n    // \tif (isWindows && uri.scheme === 'file') {\n    // \t\tnewPath = URI.file(paths.win32.join(uriToFsPath(uri, true), ...pathFragment)).path;\n    // \t} else {\n    // \t\tnewPath = paths.posix.join(uri.path, ...pathFragment);\n    // \t}\n    // \treturn uri.with({ path: newPath });\n    // }\n    // ---- printing/externalize ---------------------------\n    /**\n     * Creates a string representation for this URI. It's guaranteed that calling\n     * `URI.parse` with the result of this function creates an URI which is equal\n     * to this URI.\n     *\n     * * The result shall *not* be used for display purposes but for externalization or transport.\n     * * The result will be encoded using the percentage encoding and encoding happens mostly\n     * ignore the scheme-specific encoding rules.\n     *\n     * @param skipEncoding Do not encode the result, default is `false`\n     */\n    URI.prototype.toString = function (skipEncoding) {\n        if (skipEncoding === void 0) { skipEncoding = false; }\n        return _asFormatted(this, skipEncoding);\n    };\n    URI.prototype.toJSON = function () {\n        return this;\n    };\n    URI.revive = function (data) {\n        if (!data) {\n            return data;\n        }\n        else if (data instanceof URI) {\n            return data;\n        }\n        else {\n            var result = new _URI(data);\n            result._formatted = data.external;\n            result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;\n            return result;\n        }\n    };\n    return URI;\n}());\n\nvar _pathSepMarker = isWindows ? 1 : undefined;\n// eslint-disable-next-line @typescript-eslint/class-name-casing\nvar _URI = /** @class */ (function (_super) {\n    __extends(_URI, _super);\n    function _URI() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._formatted = null;\n        _this._fsPath = null;\n        return _this;\n    }\n    Object.defineProperty(_URI.prototype, \"fsPath\", {\n        get: function () {\n            if (!this._fsPath) {\n                this._fsPath = uriToFsPath(this, false);\n            }\n            return this._fsPath;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    _URI.prototype.toString = function (skipEncoding) {\n        if (skipEncoding === void 0) { skipEncoding = false; }\n        if (!skipEncoding) {\n            if (!this._formatted) {\n                this._formatted = _asFormatted(this, false);\n            }\n            return this._formatted;\n        }\n        else {\n            // we don't cache that\n            return _asFormatted(this, true);\n        }\n    };\n    _URI.prototype.toJSON = function () {\n        var res = {\n            $mid: 1\n        };\n        // cached state\n        if (this._fsPath) {\n            res.fsPath = this._fsPath;\n            res._sep = _pathSepMarker;\n        }\n        if (this._formatted) {\n            res.external = this._formatted;\n        }\n        // uri components\n        if (this.path) {\n            res.path = this.path;\n        }\n        if (this.scheme) {\n            res.scheme = this.scheme;\n        }\n        if (this.authority) {\n            res.authority = this.authority;\n        }\n        if (this.query) {\n            res.query = this.query;\n        }\n        if (this.fragment) {\n            res.fragment = this.fragment;\n        }\n        return res;\n    };\n    return _URI;\n}(URI));\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nvar encodeTable = (_a = {},\n    _a[58 /* Colon */] = '%3A',\n    _a[47 /* Slash */] = '%2F',\n    _a[63 /* QuestionMark */] = '%3F',\n    _a[35 /* Hash */] = '%23',\n    _a[91 /* OpenSquareBracket */] = '%5B',\n    _a[93 /* CloseSquareBracket */] = '%5D',\n    _a[64 /* AtSign */] = '%40',\n    _a[33 /* ExclamationMark */] = '%21',\n    _a[36 /* DollarSign */] = '%24',\n    _a[38 /* Ampersand */] = '%26',\n    _a[39 /* SingleQuote */] = '%27',\n    _a[40 /* OpenParen */] = '%28',\n    _a[41 /* CloseParen */] = '%29',\n    _a[42 /* Asterisk */] = '%2A',\n    _a[43 /* Plus */] = '%2B',\n    _a[44 /* Comma */] = '%2C',\n    _a[59 /* Semicolon */] = '%3B',\n    _a[61 /* Equals */] = '%3D',\n    _a[32 /* Space */] = '%20',\n    _a);\nfunction encodeURIComponentFast(uriComponent, allowSlash) {\n    var res = undefined;\n    var nativeEncodePos = -1;\n    for (var pos = 0; pos < uriComponent.length; pos++) {\n        var code = uriComponent.charCodeAt(pos);\n        // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n        if ((code >= 97 /* a */ && code <= 122 /* z */)\n            || (code >= 65 /* A */ && code <= 90 /* Z */)\n            || (code >= 48 /* Digit0 */ && code <= 57 /* Digit9 */)\n            || code === 45 /* Dash */\n            || code === 46 /* Period */\n            || code === 95 /* Underline */\n            || code === 126 /* Tilde */\n            || (allowSlash && code === 47 /* Slash */)) {\n            // check if we are delaying native encode\n            if (nativeEncodePos !== -1) {\n                res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n                nativeEncodePos = -1;\n            }\n            // check if we write into a new string (by default we try to return the param)\n            if (res !== undefined) {\n                res += uriComponent.charAt(pos);\n            }\n        }\n        else {\n            // encoding needed, we need to allocate a new string\n            if (res === undefined) {\n                res = uriComponent.substr(0, pos);\n            }\n            // check with default table first\n            var escaped = encodeTable[code];\n            if (escaped !== undefined) {\n                // check if we are delaying native encode\n                if (nativeEncodePos !== -1) {\n                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n                    nativeEncodePos = -1;\n                }\n                // append escaped variant to result\n                res += escaped;\n            }\n            else if (nativeEncodePos === -1) {\n                // use native encode only when needed\n                nativeEncodePos = pos;\n            }\n        }\n    }\n    if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n    }\n    return res !== undefined ? res : uriComponent;\n}\nfunction encodeURIComponentMinimal(path) {\n    var res = undefined;\n    for (var pos = 0; pos < path.length; pos++) {\n        var code = path.charCodeAt(pos);\n        if (code === 35 /* Hash */ || code === 63 /* QuestionMark */) {\n            if (res === undefined) {\n                res = path.substr(0, pos);\n            }\n            res += encodeTable[code];\n        }\n        else {\n            if (res !== undefined) {\n                res += path[pos];\n            }\n        }\n    }\n    return res !== undefined ? res : path;\n}\n/**\n * Compute `fsPath` for the given uri\n */\nfunction uriToFsPath(uri, keepDriveLetterCasing) {\n    var value;\n    if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n        // unc path: file://shares/c$/far/boo\n        value = \"//\" + uri.authority + uri.path;\n    }\n    else if (uri.path.charCodeAt(0) === 47 /* Slash */\n        && (uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */ || uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)\n        && uri.path.charCodeAt(2) === 58 /* Colon */) {\n        if (!keepDriveLetterCasing) {\n            // windows drive letter: file:///c:/far/boo\n            value = uri.path[1].toLowerCase() + uri.path.substr(2);\n        }\n        else {\n            value = uri.path.substr(1);\n        }\n    }\n    else {\n        // other path\n        value = uri.path;\n    }\n    if (isWindows) {\n        value = value.replace(/\\//g, '\\\\');\n    }\n    return value;\n}\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri, skipEncoding) {\n    var encoder = !skipEncoding\n        ? encodeURIComponentFast\n        : encodeURIComponentMinimal;\n    var res = '';\n    var scheme = uri.scheme, authority = uri.authority, path = uri.path, query = uri.query, fragment = uri.fragment;\n    if (scheme) {\n        res += scheme;\n        res += ':';\n    }\n    if (authority || scheme === 'file') {\n        res += _slash;\n        res += _slash;\n    }\n    if (authority) {\n        var idx = authority.indexOf('@');\n        if (idx !== -1) {\n            // <user>@<auth>\n            var userinfo = authority.substr(0, idx);\n            authority = authority.substr(idx + 1);\n            idx = userinfo.indexOf(':');\n            if (idx === -1) {\n                res += encoder(userinfo, false);\n            }\n            else {\n                // <user>:<pass>@<auth>\n                res += encoder(userinfo.substr(0, idx), false);\n                res += ':';\n                res += encoder(userinfo.substr(idx + 1), false);\n            }\n            res += '@';\n        }\n        authority = authority.toLowerCase();\n        idx = authority.indexOf(':');\n        if (idx === -1) {\n            res += encoder(authority, false);\n        }\n        else {\n            // <auth>:<port>\n            res += encoder(authority.substr(0, idx), false);\n            res += authority.substr(idx);\n        }\n    }\n    if (path) {\n        // lower-case windows drive letters in /C:/fff or C:/fff\n        if (path.length >= 3 && path.charCodeAt(0) === 47 /* Slash */ && path.charCodeAt(2) === 58 /* Colon */) {\n            var code = path.charCodeAt(1);\n            if (code >= 65 /* A */ && code <= 90 /* Z */) {\n                path = \"/\" + String.fromCharCode(code + 32) + \":\" + path.substr(3); // \"/c:\".length === 3\n            }\n        }\n        else if (path.length >= 2 && path.charCodeAt(1) === 58 /* Colon */) {\n            var code = path.charCodeAt(0);\n            if (code >= 65 /* A */ && code <= 90 /* Z */) {\n                path = String.fromCharCode(code + 32) + \":\" + path.substr(2); // \"/c:\".length === 3\n            }\n        }\n        // encode the rest of the path\n        res += encoder(path, true);\n    }\n    if (query) {\n        res += '?';\n        res += encoder(query, false);\n    }\n    if (fragment) {\n        res += '#';\n        res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n    }\n    return res;\n}\n// --- decode\nfunction decodeURIComponentGraceful(str) {\n    try {\n        return decodeURIComponent(str);\n    }\n    catch (_a) {\n        if (str.length > 3) {\n            return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n        }\n        else {\n            return str;\n        }\n    }\n}\nvar _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\nfunction percentDecode(str) {\n    if (!str.match(_rEncodedAsHex)) {\n        return str;\n    }\n    return str.replace(_rEncodedAsHex, function (match) { return decodeURIComponentGraceful(match); });\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/vscode-uri/lib/esm/index.js?");

/***/ }),

/***/ "./node_modules/which/which.js":
/*!*************************************!*\
  !*** ./node_modules/which/which.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const isWindows = process.platform === 'win32' ||\n    process.env.OSTYPE === 'cygwin' ||\n    process.env.OSTYPE === 'msys'\n\nconst path = __webpack_require__(/*! path */ \"path\")\nconst COLON = isWindows ? ';' : ':'\nconst isexe = __webpack_require__(/*! isexe */ \"./node_modules/isexe/index.js\")\n\nconst getNotFoundError = (cmd) =>\n  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })\n\nconst getPathInfo = (cmd, opt) => {\n  const colon = opt.colon || COLON\n\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  const pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? ['']\n    : (\n      [\n        // windows always checks the cwd first\n        ...(isWindows ? [process.cwd()] : []),\n        ...(opt.path || process.env.PATH ||\n          /* istanbul ignore next: very unusual */ '').split(colon),\n      ]\n    )\n  const pathExtExe = isWindows\n    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'\n    : ''\n  const pathExt = isWindows ? pathExtExe.split(colon) : ['']\n\n  if (isWindows) {\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')\n      pathExt.unshift('')\n  }\n\n  return {\n    pathEnv,\n    pathExt,\n    pathExtExe,\n  }\n}\n\nconst which = (cmd, opt, cb) => {\n  if (typeof opt === 'function') {\n    cb = opt\n    opt = {}\n  }\n  if (!opt)\n    opt = {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  const step = i => new Promise((resolve, reject) => {\n    if (i === pathEnv.length)\n      return opt.all && found.length ? resolve(found)\n        : reject(getNotFoundError(cmd))\n\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    resolve(subStep(p, i, 0))\n  })\n\n  const subStep = (p, i, ii) => new Promise((resolve, reject) => {\n    if (ii === pathExt.length)\n      return resolve(step(i + 1))\n    const ext = pathExt[ii]\n    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {\n      if (!er && is) {\n        if (opt.all)\n          found.push(p + ext)\n        else\n          return resolve(p + ext)\n      }\n      return resolve(subStep(p, i, ii + 1))\n    })\n  })\n\n  return cb ? step(0).then(res => cb(null, res), cb) : step(0)\n}\n\nconst whichSync = (cmd, opt) => {\n  opt = opt || {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  for (let i = 0; i < pathEnv.length; i ++) {\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    for (let j = 0; j < pathExt.length; j ++) {\n      const cur = p + pathExt[j]\n      try {\n        const is = isexe.sync(cur, { pathExt: pathExtExe })\n        if (is) {\n          if (opt.all)\n            found.push(cur)\n          else\n            return cur\n        }\n      } catch (ex) {}\n    }\n  }\n\n  if (opt.all && found.length)\n    return found\n\n  if (opt.nothrow)\n    return null\n\n  throw getNotFoundError(cmd)\n}\n\nmodule.exports = which\nwhich.sync = whichSync\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/which/which.js?");

/***/ }),

/***/ "./node_modules/wrappy/wrappy.js":
/*!***************************************!*\
  !*** ./node_modules/wrappy/wrappy.js ***!
  \***************************************/
/***/ ((module) => {

eval("// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/wrappy/wrappy.js?");

/***/ }),

/***/ "./node_modules/yallist/iterator.js":
/*!******************************************!*\
  !*** ./node_modules/yallist/iterator.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/yallist/iterator.js?");

/***/ }),

/***/ "./node_modules/yallist/yallist.js":
/*!*****************************************!*\
  !*** ./node_modules/yallist/yallist.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n\n  return next\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.splice = function (start, deleteCount, ...nodes) {\n  if (start > this.length) {\n    start = this.length - 1\n  }\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next\n  }\n\n  var ret = []\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value)\n    walker = this.removeNode(walker)\n  }\n  if (walker === null) {\n    walker = this.tail\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    walker = insert(this, walker, nodes[i])\n  }\n  return ret;\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction insert (self, node, value) {\n  var inserted = node === self.head ?\n    new Node(value, null, node, self) :\n    new Node(value, node, node.next, self)\n\n  if (inserted.next === null) {\n    self.tail = inserted\n  }\n  if (inserted.prev === null) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  __webpack_require__(/*! ./iterator.js */ \"./node_modules/yallist/iterator.js\")(Yallist)\n} catch (er) {}\n\n\n//# sourceURL=webpack://coc.nvim/./node_modules/yallist/yallist.js?");

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse(\"{\\\"name\\\":\\\"coc.nvim\\\",\\\"version\\\":\\\"0.0.80\\\",\\\"description\\\":\\\"LSP based intellisense engine for neovim & vim8.\\\",\\\"main\\\":\\\"./lib/index.js\\\",\\\"engines\\\":{\\\"node\\\":\\\">=8.10.0\\\"},\\\"scripts\\\":{\\\"clean\\\":\\\"rimraf lib build\\\",\\\"lint\\\":\\\"eslint . --ext .ts --quiet\\\",\\\"build\\\":\\\"webpack\\\",\\\"watch\\\":\\\"webpack -w\\\",\\\"test\\\":\\\"node --trace-warnings node_modules/jest/bin/jest.js --runInBand --forceExit\\\",\\\"test-build\\\":\\\"node --trace-warnings node_modules/jest/bin/jest.js --runInBand --coverage --forceExit\\\",\\\"prepare\\\":\\\"webpack\\\"},\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/neoclide/coc.nvim.git\\\"},\\\"keywords\\\":[\\\"complete\\\",\\\"neovim\\\"],\\\"author\\\":\\\"Qiming Zhao <chemzqm@gmail.com>\\\",\\\"license\\\":\\\"MIT\\\",\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/neoclide/coc.nvim/issues\\\"},\\\"homepage\\\":\\\"https://github.com/neoclide/coc.nvim#readme\\\",\\\"jest\\\":{\\\"globals\\\":{\\\"__TEST__\\\":true},\\\"projects\\\":[\\\"<rootDir>\\\"],\\\"watchman\\\":false,\\\"clearMocks\\\":true,\\\"globalSetup\\\":\\\"./jest.js\\\",\\\"testEnvironment\\\":\\\"node\\\",\\\"moduleFileExtensions\\\":[\\\"ts\\\",\\\"tsx\\\",\\\"json\\\",\\\"js\\\"],\\\"transform\\\":{\\\"^.+\\\\\\\\.tsx?$\\\":\\\"ts-jest\\\"},\\\"testRegex\\\":\\\"src/__tests__/.*\\\\\\\\.(test|spec)\\\\\\\\.ts$\\\",\\\"coverageDirectory\\\":\\\"./coverage/\\\"},\\\"devDependencies\\\":{\\\"@types/cli-table\\\":\\\"^0.3.0\\\",\\\"@types/debounce\\\":\\\"^3.0.0\\\",\\\"@types/fb-watchman\\\":\\\"^2.0.0\\\",\\\"@types/glob\\\":\\\"^7.1.3\\\",\\\"@types/jest\\\":\\\"^26.0.18\\\",\\\"@types/marked\\\":\\\"^1.2.1\\\",\\\"@types/minimatch\\\":\\\"^3.0.3\\\",\\\"@types/mkdirp\\\":\\\"^1.0.1\\\",\\\"@types/node\\\":\\\"^10.12.0\\\",\\\"@types/semver\\\":\\\"^7.3.4\\\",\\\"@types/tar\\\":\\\"^4.0.4\\\",\\\"@types/uuid\\\":\\\"^8.3.0\\\",\\\"@types/which\\\":\\\"^1.3.2\\\",\\\"@typescript-eslint/eslint-plugin\\\":\\\"^4.9.1\\\",\\\"@typescript-eslint/parser\\\":\\\"^4.9.1\\\",\\\"colors\\\":\\\"^1.4.0\\\",\\\"eslint\\\":\\\"^7.15.0\\\",\\\"eslint-plugin-jest\\\":\\\"^24.1.3\\\",\\\"eslint-plugin-jsdoc\\\":\\\"^30.7.8\\\",\\\"jest\\\":\\\"26.6.3\\\",\\\"ts-jest\\\":\\\"^26.4.4\\\",\\\"ts-loader\\\":\\\"^8.0.11\\\",\\\"typescript\\\":\\\"^4.1.2\\\",\\\"vscode-languageserver\\\":\\\"next\\\",\\\"webpack\\\":\\\"^5.11.0\\\",\\\"webpack-cli\\\":\\\"^4.2.0\\\"},\\\"dependencies\\\":{\\\"@chemzqm/neovim\\\":\\\"^5.2.12\\\",\\\"ansi-styles\\\":\\\"^5.0.0\\\",\\\"bser\\\":\\\"^2.1.1\\\",\\\"bytes\\\":\\\"^3.1.0\\\",\\\"cli-table\\\":\\\"^0.3.4\\\",\\\"clipboardy\\\":\\\"^2.3.0\\\",\\\"content-disposition\\\":\\\"^0.5.3\\\",\\\"debounce\\\":\\\"^1.2.0\\\",\\\"esbuild\\\":\\\"^0.8.26\\\",\\\"fast-diff\\\":\\\"^1.2.0\\\",\\\"fb-watchman\\\":\\\"^2.0.1\\\",\\\"follow-redirects\\\":\\\"^1.13.0\\\",\\\"fs-extra\\\":\\\"^9.0.1\\\",\\\"glob\\\":\\\"^7.1.6\\\",\\\"http-proxy-agent\\\":\\\"^4.0.1\\\",\\\"https-proxy-agent\\\":\\\"^5.0.0\\\",\\\"isuri\\\":\\\"^2.0.3\\\",\\\"jsonc-parser\\\":\\\"^2.3.1\\\",\\\"log4js\\\":\\\"^6.3.0\\\",\\\"marked\\\":\\\"^1.2.5\\\",\\\"minimatch\\\":\\\"^3.0.4\\\",\\\"promise.prototype.finally\\\":\\\"^3.1.2\\\",\\\"rc\\\":\\\"^1.2.8\\\",\\\"semver\\\":\\\"^7.3.2\\\",\\\"tar\\\":\\\"^6.0.5\\\",\\\"tslib\\\":\\\"^2.0.3\\\",\\\"unzipper\\\":\\\"^0.10.11\\\",\\\"uuid\\\":\\\"^7.0.3\\\",\\\"vscode-jsonrpc\\\":\\\"^5.0.1\\\",\\\"vscode-languageserver-protocol\\\":\\\"^3.15.3\\\",\\\"vscode-languageserver-textdocument\\\":\\\"^1.0.1\\\",\\\"vscode-languageserver-types\\\":\\\"^3.15.1\\\",\\\"vscode-uri\\\":\\\"^2.1.2\\\",\\\"which\\\":\\\"^2.0.2\\\"}}\");\n\n//# sourceURL=webpack://coc.nvim/./package.json?");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"assert\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22assert%22?");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"buffer\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22buffer%22?");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"child_process\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22child_process%22?");

/***/ }),

/***/ "cluster":
/*!**************************!*\
  !*** external "cluster" ***!
  \**************************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"cluster\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22cluster%22?");

/***/ }),

/***/ "constants":
/*!****************************!*\
  !*** external "constants" ***!
  \****************************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"constants\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22constants%22?");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"crypto\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22crypto%22?");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"events\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22events%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"fs\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22fs%22?");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"http\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22http%22?");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"https\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22https%22?");

/***/ }),

/***/ "module":
/*!*************************!*\
  !*** external "module" ***!
  \*************************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"module\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22module%22?");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"net\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22net%22?");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"os\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22os%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"path\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22path%22?");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"querystring\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22querystring%22?");

/***/ }),

/***/ "readline":
/*!***************************!*\
  !*** external "readline" ***!
  \***************************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"readline\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22readline%22?");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"stream\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22stream%22?");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"string_decoder\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22string_decoder%22?");

/***/ }),

/***/ "timers":
/*!*************************!*\
  !*** external "timers" ***!
  \*************************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"timers\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22timers%22?");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"tls\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22tls%22?");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"tty\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22tty%22?");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"url\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22url%22?");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"util\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22util%22?");

/***/ }),

/***/ "vm":
/*!*********************!*\
  !*** external "vm" ***!
  \*********************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"vm\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22vm%22?");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"zlib\");;\n\n//# sourceURL=webpack://coc.nvim/external_%22zlib%22?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__(__webpack_require__.s = "./src/main.ts");
/******/ })()
;